package mlscript

import scala.util.Random
import mlscript.utils._, shorthands._

object EnumeratePrograms {
  private var className: Str = ""
  className = implicitly[sourcecode.Enclosing].value
  
  def main(args: Array[Str]): Unit = {
    
    val seed = 42
    val rand = new Random(seed)
    
    
    val StartP = 15
    val MultP = 0.14
    val fieldNames = "u" :: "v" :: Nil
    val varNames = "x" :: "y" :: "z" :: Nil
    // Number of expressions generated: 499
    
    
    // TODO add bigger tests in separate test suite (to avoid slowing it all down)
    
    /*
    val StartP = 20
    val MultP = 0.14705
    val fieldNames = "u" :: "v" :: Nil
    val varNames = "x" :: "y" :: "z" :: Nil
    // Number of expressions generated: 1032
    // Program sizes:
    //   1: 2
    //   2: 8
    //   3: 30
    //   4: 97
    //   5: 182
    //   6: 186
    //   7: 185
    //   8: 179
    //   9: 110
    //   10: 49
    //   11: 4
    
    val StartP = 50
    val MultP = 0.11
    val fieldNames = "u" :: "v" :: Nil
    val varNames = "x" :: "y" :: "z" :: Nil
    // Number of expressions generated: 4545
    // Program sizes:
    //   1: 2
    //   2: 8
    //   3: 36
    //   4: 143
    //   5: 429
    //   6: 785
    //   7: 1300
    //   8: 957
    //   9: 529
    //   10: 255
    //   11: 91
    //   12: 10
    */
    
    // val StartP = 200
    // val MultP = 0.11
    // val fieldNames = "u" :: "v" :: "w" :: Nil
    // val varNames = "x" :: "y" :: "z" :: "s" :: "t" :: Nil
    
    
    // Enumerate expressions based on StartP and MultP
    def enumerate(emit: Term => Unit): Unit = {
      def rec(curP: Double)(emit: Term => Unit)(implicit ctx: (List[String], List[String])): Unit =
      if (rand.nextFloat() <= curP) {
        val newP = curP * MultP
        emit(IntLit(0))
        emit(Var("add"))
        ctx._1.foreach(n => emit(Var(n)))
        rec(newP)(f => rec(newP)(a => emit(App(f, a))))
        if (ctx._2.nonEmpty) {
          val vn = ctx._2.head
          val lctx = vn :: ctx._1
          val rctx = ctx._2.tail
          rec(newP) { b =>
            emit(Lam(Var(vn), b))
            rec(newP) { v =>
              emit(Let(v.freeVars(vn), vn, v, b))
            }(lctx, rctx)
          }(lctx, rctx)
        }
        for (fn0 <- fieldNames) {
          rec(newP)(r => emit(Sel(r, fn0)))
          rec(newP) { v0 =>
            emit(Rcd((fn0, v0) :: Nil))
            for (fn1 <- fieldNames.tail) if (fn1 =/= fn0) {
              rec(newP)(v1 => emit(Rcd((fn0, v0) :: (fn1, v1) :: Nil)))
            }
          }
        }
      }
      rec(StartP)(emit)((Nil, varNames))
    }
    
    val sizes = scala.collection.mutable.Buffer.empty[Int]
    
    new java.io.PrintWriter(s"shared/src/test/diff/gen/genTests_v1-${MultP}-${StartP}-x${fieldNames.size}.fun") {
      println(s"// Automatically generated by $className â€” DO NOT EDIT")
      println
      println(s":AllowTypeErrors")
      println(s":ShowRelativeLineNums")
      println
      println
      
      enumerate(t => {
        sizes += t.size
        println(t.toString)
        println
      })
      
      println
      println(s"// Number of expressions generated: ${sizes.size}")
      println
      println(s"// Program sizes:")
      private val grouped = sizes.groupMapReduce(identity)(_ => 1)(_ + _).toList.sortBy(_._1)
      grouped.foreach { case (sz, num) =>
        println(s"//   $sz: $num")
      }
      println
      
      close
    }
    println(s"Done generating ${sizes.size} expressions.")
    
    
    ()
  }
  
}
