:NewParser
:NewDefs


// * Adapted example from Code reuse through polymorphic variants (FOSE 2000)


class Cons[out A](head: A, tail: Cons[A] | Nil)
module Nil
//│ class Cons[A](head: A, tail: Cons[A] | Nil)
//│ module Nil()

let l = Cons(1, Nil)
//│ let l: Cons[1]
//│ l
//│   = Cons {}

class NotFound
class Success[A](result: A)
//│ class NotFound()
//│ class Success[A](result: A)

fun list_assoc(s, l) =
  if l is
    Cons(h, t) then
      if s === h._1 then Success(h._2)
      else list_assoc(s, t)
    Nil then NotFound()
//│ fun list_assoc: forall 'a 'A. (Eql['a], Cons[{_1: 'a, _2: 'A}] | Nil,) -> (NotFound | Success['A])

// fun list_assoc(s: string, l: Cons[{ _1: string, _2: 'b }] | Nil): NotFound | Success['b]

class Var(s: string)
//│ class Var(s: string)

mixin EvalVar {
  fun eval(sub, v) =
    if v is Var(s) then
      if list_assoc(s, sub) is
        NotFound then v
        Success(r) then r
}
//│ mixin EvalVar() {
//│   fun eval: (Cons[{_1: string, _2: 'result}] | Nil, Var,) -> (Var | 'result)
//│ }

class Abs[A](x: string, t: A)
class App[A](s: A, t: A)
//│ class Abs[A](x: string, t: A)
//│ class App[A](s: A, t: A)

fun gensym(): string = "fun"
//│ fun gensym: () -> string

fun int_to_string(x: int): string = "0"
//│ fun int_to_string: (x: int,) -> string

mixin EvalLambda {
  fun eval(sub, v) =
    if v is
      App(t1, t2) then
        let l1 = this.eval(sub, t1)
        let l2 = this.eval(sub, t2)
        if t1 is
          Abs(x, t) then this.eval(Cons((x, l2), Nil), t)
        else
          App(l1, l2)
      Abs(x, t) then
        let s = gensym()
        Abs(s, this.eval(Cons((x, Var(s)), sub), t))
    else
      super.eval(sub, v)
}
//│ mixin EvalLambda() {
//│   super: {eval: ('a, 'b,) -> 'c}
//│   this: {eval: ('a, 's,) -> ('A & 'd) & (Cons[(string, 'd,)], 't,) -> 'c & (Cons[(string, Var,) | 'A0], 't0,) -> 'A1}
//│   fun eval: ('a & (Cons['A0] | Nil), Abs['t0] | App['s & (Abs['t] | ~#Abs)] | 'b & ~#Abs & ~#App,) -> (Abs['A1] | App['A] | 'c)
//│ }

// FIXME type simplification
:ns
module Test1 extends EvalVar, EvalLambda
//│ module Test1() {
//│   fun eval: forall 'A 'A0 'a 'b 'c. ('d, 'a,) -> ('e | 'c | 'b | 'f)
//│ }
//│ where
//│   'b :> #Abs & {Abs#A = 'A1}
//│   'c :> #App & {App#A = 'A2}
//│   'a <: #App & {App#A <: 'A0} | (#Abs & {Abs#A <: 'A} | 'g & ~#Abs) & ~#App
//│   'A <: 't
//│   'A0 <: 't0 & 's
//│   't0 <: 'h
//│   'h <: #App & {App#A <: 'A3} | (#Abs & {Abs#A <: 'A4} | 'g & ~#Abs) & ~#App
//│   'A4 <: 't
//│   'A3 <: 't0 & 's
//│   's <: 'i & (#Abs & {Abs#A <: 'A5} | 'j & ~#Abs)
//│   'A5 <: 't1
//│   't1 <: 'k
//│   'k <: #App & {App#A <: 'A6} | (#Abs & {Abs#A <: 'A7} | 'g & ~#Abs) & ~#App
//│   'A7 <: 't
//│   'A6 <: 't0 & 's
//│   'i <: #App & {App#A <: 'A8} | (#Abs & {Abs#A <: 'A9} | 'g & ~#Abs) & ~#App
//│   'A9 <: 't
//│   't <: 'l
//│   'l <: #App & {App#A <: 'A10} | (#Abs & {Abs#A <: 'A11} | 'g & ~#Abs) & ~#App
//│   'g <: 'm
//│   'm <: #Var
//│   'A11 <: 't
//│   'A10 <: 't0 & 's
//│   'A8 <: 't0 & 's
//│   'd :> #Cons & {Cons#A = 'A12} | #Cons & {Cons#A = 'A13}
//│      <: 'n & (Cons['A13] | Nil)
//│   'n :> #Cons & {Cons#A = 'A12} | #Cons & {Cons#A = 'A13}
//│      <: 'o
//│   'o :> #Cons & {Cons#A = 'A12} | #Cons & {Cons#A = 'A13} | Cons['A14] | Nil
//│      <: #Cons & {Cons#A <: 'A15} | #Nil & ~#Cons
//│   'A14 := out 'A15
//│   'A12 :> ('x, 'p,) | ('x0, 'q,)
//│        <: 'A13 & 'A15
//│   'A13 :> ('x, 'p,) | ('x0, 'q,)
//│        <: 'A12 & 'A15
//│   'A15 :> ('x0, 'q,) | ('x, 'p,)
//│        <: 'head
//│   'head :> ('x0, 'q,) | ('x, 'p,)
//│         <: {_2: 'r} & {_1: 'u}
//│   'q :> forall 'v 'w. 'e | 'v | 'w | 'f
//│      <: 'r & 'A2
//│   'x0 :> string
//│       <: 'u
//│   'p :> #Var
//│      <: 'r
//│   'r :> (forall 'v 'w. 'e | 'v | 'w | 'f) | #Var
//│      <: 'A16
//│   'A16 :> (forall 'v 'w. 'e | 'v | 'w | 'f) | #Var
//│        <: 'A17
//│   'A17 :> (forall 'v 'w. 'e | 'v | 'w | 'f) | #Var
//│        <: 'result
//│   'e :> forall 'y 'z. 'e | 'y | 'z | 'f
//│   'z :> #Abs & {Abs#A = 'A1}
//│   'y :> #App & {App#A = 'A2}
//│   'A2 :> (forall 'a1 'b1. 'e | 'a1 | 'b1 | 'f) | (forall 'v 'w. 'e | 'v | 'w | 'f)
//│   'b1 :> #Abs & {Abs#A = 'A1}
//│   'A1 :> forall 'c1 'd1. 'e | 'c1 | 'd1 | 'f
//│   'f :> #Var | 'result
//│   'result :> (forall 'v 'w. 'e | 'v | 'w | 'f) | #Var
//│   'w :> #Abs & {Abs#A = 'A1}
//│   'v :> #App & {App#A = 'A2}
//│   'd1 :> #Abs & {Abs#A = 'A1}
//│   'c1 :> #App & {App#A = 'A2}
//│   'a1 :> #App & {App#A = 'A2}
//│   'x :> string
//│      <: 'u
//│   'u :> string
//│      <: 'e1
//│   'e1 := string

Test1.eval(Nil, Var("a"))
//│ forall 'a. 'b | 'a | 'c
//│   where
//│     'b :> forall 'a. 'a | 'c
//│     'a :> App[forall 'a. 'b | 'a | 'c] | Abs[forall 'a. 'b | 'a | 'c]
//│     'c :> forall 'a. Var | 'b | 'a
//│ res
//│     = Var {}

Test1.eval(Nil, Abs("b", Var("a")))
//│ forall 'a. 'b | 'a | 'c
//│   where
//│     'b :> forall 'a. 'a | 'c
//│     'a :> App[forall 'a. 'b | 'a | 'c] | Abs[forall 'a. 'b | 'a | 'c]
//│     'c :> forall 'a. Var | 'b | 'a
//│ res
//│     = Abs {}

Test1.eval(Cons(("c", Var("d")), Nil), App(Abs("b", Var("b")), Var("c")))
//│ forall 'a. 'b | 'a | 'c
//│   where
//│     'b :> forall 'a. 'a | 'c
//│     'a :> App[forall 'a. 'b | 'a | 'c] | Abs[forall 'a. 'b | 'a | 'c]
//│     'c :> forall 'a. Var | 'b | 'a
//│ res
//│     = Var {}

Test1.eval(Cons(("c", Abs("d", Var("d"))), Nil), App(Abs("b", Var("b")), Var("c")))
//│ forall 'a. 'b | 'a | 'c
//│   where
//│     'b :> forall 'a. 'a | 'c
//│     'a :> App[forall 'a. 'b | 'a | 'c] | Abs[forall 'a. 'b | 'a | 'c]
//│     'c :> forall 'a. Abs[Var] | Var | 'b | 'a
//│ res
//│     = Var {}

class Num(n: int)
class Add[A](l: A, r: A)
class Mul[A](l: A, r: A)
//│ class Num(n: int)
//│ class Add[A](l: A, r: A)
//│ class Mul[A](l: A, r: A)

fun map_expr(f, v) =
  if v is
    Var then v
    Num then v
    Add(l, r) then Add(f(l), f(r))
    Mul(l, r) then Mul(f(l), f(r))
//│ fun map_expr: forall 'l 'A 'l0 'A0. ('l -> 'A & 'l0 -> 'A0, Add['l] | Mul['l0] | Num | Var,) -> (Add['A] | Mul['A0] | Num | Var)

mixin EvalExpr {
  fun eval(sub, v) =
    fun eta(e) = this.eval(sub, e)
    let vv = map_expr(eta, v)
    if vv is
      Var then super.eval(sub, vv)
      Add(Num(l), Num(r)) then Num(l + r)
      Mul(Num(l), Num(r)) then Num(l * r)
    else v
}
//│ mixin EvalExpr() {
//│   super: {eval: ('a, Var,) -> 'b}
//│   this: {eval: ('a, 'c,) -> anything}
//│   fun eval: ('a, 'b & (Add['c] | Mul['c] | Num | Var),) -> (Num | 'b)
//│ }

module Test2 extends EvalVar, EvalExpr
//│ module Test2() {
//│   fun eval: forall 'a. (Cons[{_1: string, _2: 'result}] | Nil, 'a & (Add['b] | Mul['b] | Num | Var),) -> (Num | Var | 'result | 'a)
//│ }
//│ where
//│   'b <: Add['b] | Mul['b] | Num | Var

Test2.eval(Nil, Var("a"))
//│ Num | Var
//│ res
//│     = Var {}

Test2.eval(Cons(("c", Abs("d", Var("d"))), Nil), Var("a"))
//│ Abs[Var] | Num | Var
//│ res
//│     = Var {}

Test2.eval(Cons(("a", Num(1)), Nil), Var("a"))
//│ Num | Var
//│ res
//│     = Var {}

// * This expected error shows that Test2 does not handle Abs expression inputs
:e
Test2.eval(Cons(("c", Abs("d", Var("d"))), Nil), Abs("a", Var("a")))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.248: 	Test2.eval(Cons(("c", Abs("d", Var("d"))), Nil), Abs("a", Var("a")))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Abs[?A]` does not match type `Add[?A0] | Mul[?A1] | Num | Var`
//│ ║  l.248: 	Test2.eval(Cons(("c", Abs("d", Var("d"))), Nil), Abs("a", Var("a")))
//│ ║         	                                                 ^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.201: 	  if v is
//│ ║         	     ^
//│ ╟── from reference:
//│ ║  l.211: 	    let vv = map_expr(eta, v)
//│ ╙──       	                           ^
//│ Abs[Var] | Num | Var | error
//│ res
//│ Runtime error:
//│   Error: non-exhaustive case expression

Test2.eval(Cons(("a", Abs("d", Var("d"))), Nil), Add(Num(1), Var("a")))
//│ Abs[Var] | Add[Num | Var] | Num | Var
//│ res
//│     = Add {}

// FIXME type simplification
:ns
module Test3 extends EvalVar, EvalExpr, EvalLambda
//│ module Test3() {
//│   fun eval: forall 'a 'b 'A 'A0 'c. ('d, 'a,) -> ('e | 'c | 'b | 'f)
//│ }
//│ where
//│   'b :> #Abs & {Abs#A = 'A1}
//│   'c :> #App & {App#A = 'A2}
//│   'a <: #App & {App#A <: 'A} | (#Abs & {Abs#A <: 'A0} | 'g & ~#Abs) & ~#App
//│   'A0 <: 't
//│   'A <: 't0 & 's
//│   'd :> #Cons & {Cons#A = 'A3} | #Cons & {Cons#A = 'A4}
//│      <: 'h & (Cons['A4] | Nil)
//│   'h :> #Cons & {Cons#A = 'A3} | #Cons & {Cons#A = 'A4}
//│      <: 'd & 'i
//│   'i :> #Cons & {Cons#A = 'A3} | #Cons & {Cons#A = 'A4}
//│      <: 'j
//│   'j :> #Cons & {Cons#A = 'A3} | #Cons & {Cons#A = 'A4} | Cons['A5] | Nil
//│      <: #Cons & {Cons#A <: 'A6} | #Nil & ~#Cons
//│   'A5 := out 'A6
//│   'A3 :> ('x, 'k,) | ('x0, 'm,)
//│       <: 'A4 & 'A6
//│   'A4 :> ('x, 'k,) | ('x0, 'm,)
//│       <: 'A3 & 'A6
//│   'A6 :> ('x0, 'm,) | ('x, 'k,)
//│       <: 'head
//│   'head :> ('x0, 'm,) | ('x, 'k,)
//│         <: {_2: 'n} & {_1: 'o}
//│   'm :> forall 'p 'q. 'e | 'p | 'q | 'f
//│      <: 'n & 'A2
//│   'x0 :> string
//│       <: 'o
//│   'k :> #Var
//│      <: 'n
//│   'n :> (forall 'p 'q. 'e | 'p | 'q | 'f) | #Var
//│      <: 'A7
//│   'A7 :> (forall 'p 'q. 'e | 'p | 'q | 'f) | #Var
//│       <: 'A8
//│   'A8 :> (forall 'p 'q. 'e | 'p | 'q | 'f) | #Var
//│       <: 'result
//│   'e :> forall 'u 'v. 'e | 'u | 'v | 'f
//│      <: (#Num | 'w & ~#Num) & (#Num | 'y & ~#Num) & (#Num | 'z & ~#Num) & (#Num | 'a1 & ~#Num)
//│   'v :> #Abs & {Abs#A = 'A1}
//│   'u :> #App & {App#A = 'A2}
//│   'A2 :> (forall 'b1 'c1. 'e | 'b1 | 'c1 | 'f) | (forall 'p 'q. 'e | 'p | 'q | 'f)
//│   'c1 :> #Abs & {Abs#A = 'A1}
//│   'A1 :> forall 'd1 'e1. 'e | 'd1 | 'e1 | 'f
//│   'f :> forall 'f1 'g1. 'h1 | 'f1 | 'i1 | 'g1
//│      <: (#Num | 'w & ~#Num) & (#Num | 'y & ~#Num) & (#Num | 'z & ~#Num) & (#Num | 'a1 & ~#Num)
//│   'g1 :> #Num
//│   'i1 <: (#Num | 'w & ~#Num) & (#Num | 'y & ~#Num) & (#Num | 'z & ~#Num) & (#Num | 'a1 & ~#Num) & 'j1
//│   'j1 <: #Var | (#Num | (#Add & {Add#A <: 'A9} | #Mul & {Mul#A <: 'A10} & ~#Add) & ~#Num) & ~#Var
//│   'A10 <: 'r & 'l
//│   'l <: 'k1
//│   'r <: 'k1
//│   'A9 <: 'r0 & 'l0
//│   'l0 <: 'k1
//│   'r0 <: 'k1
//│   'k1 <: 'l1
//│   'l1 <: #App & {App#A <: 'A11} | (#Abs & {Abs#A <: 'A12} | 'g & ~#Abs) & ~#App
//│   'A12 <: 't
//│   'A11 <: 't0 & 's
//│   't0 <: 'm1
//│   'm1 <: #App & {App#A <: 'A13} | (#Abs & {Abs#A <: 'A14} | 'g & ~#Abs) & ~#App
//│   'A14 <: 't
//│   'A13 <: 't0 & 's
//│   's <: 'n1 & (#Abs & {Abs#A <: 'A15} | 'o1 & ~#Abs)
//│   'A15 <: 't1
//│   't1 <: 'p1
//│   'p1 <: #App & {App#A <: 'A16} | (#Abs & {Abs#A <: 'A17} | 'g & ~#Abs) & ~#App
//│   'A17 <: 't
//│   'A16 <: 't0 & 's
//│   'n1 <: #App & {App#A <: 'A18} | (#Abs & {Abs#A <: 'A19} | 'g & ~#Abs) & ~#App
//│   'A19 <: 't
//│   't <: 'q1
//│   'q1 <: #App & {App#A <: 'A20} | (#Abs & {Abs#A <: 'A21} | 'g & ~#Abs) & ~#App
//│   'g <: 'i1
//│   'A21 <: 't
//│   'A20 <: 't0 & 's
//│   'A18 <: 't0 & 's
//│   'f1 :> #Num
//│   'h1 :> #Var | 'result
//│       <: (#Num | 'w & ~#Num) & (#Num | 'y & ~#Num) & (#Num | 'z & ~#Num) & (#Num | 'a1 & ~#Num)
//│   'result :> (forall 'p 'q. 'e | 'p | 'q | 'f) | #Var
//│           <: (#Num | 'w & ~#Num) & (#Num | 'y & ~#Num) & (#Num | 'z & ~#Num) & (#Num | 'a1 & ~#Num)
//│   'a1 :> #Var | #Abs & {Abs#A = 'A1} | #App & {App#A = 'A2}
//│   'z :> #Var | #Abs & {Abs#A = 'A1} | #App & {App#A = 'A2}
//│   'y :> #Var | #Abs & {Abs#A = 'A1} | #App & {App#A = 'A2}
//│   'w :> #Var | #Abs & {Abs#A = 'A1} | #App & {App#A = 'A2}
//│   'q :> #Abs & {Abs#A = 'A1}
//│   'p :> #App & {App#A = 'A2}
//│   'e1 :> #Abs & {Abs#A = 'A1}
//│   'd1 :> #App & {App#A = 'A2}
//│   'b1 :> #App & {App#A = 'A2}
//│   'x :> string
//│      <: 'o
//│   'o :> string
//│      <: 'r1
//│   'r1 := string

Test3.eval(Cons(("c", Abs("d", Var("d"))), Nil), Abs("a", Var("a")))
//│ forall 'a. 'b | 'a | 'c
//│   where
//│     'b :> forall 'a. 'a | 'c
//│     'a :> App[forall 'a. 'b | 'a | 'c] | Abs[forall 'a. 'b | 'a | 'c]
//│     'c :> Abs[Var] | Num | Var | 'b
//│ res
//│     = Abs {}

Test3.eval(Cons(("c", Abs("d", Var("d"))), Nil), App(Abs("a", Var("a")), Add(Num(1), Var("c"))))
//│ forall 'a. 'b | 'a | 'c
//│   where
//│     'b :> forall 'a. 'a | 'c
//│     'a :> App[forall 'a. 'b | 'a | 'c] | Abs[forall 'a. 'b | 'a | 'c]
//│     'c :> Abs[Var] | Add[Num | Var] | Num | Var | 'b
//│ res
//│     = Var {}

// FIXME type simplification
:ns
// * Incorrect version, for regression testing – EvalLambda should be mixed in after EvalExpr
module Test3 extends EvalVar, EvalLambda, EvalExpr
//│ module Test3() {
//│   fun eval: forall 'r 'r0 'a 'A 'b 'c 'l 'd 'A0 'l0. ('e, 'a,) -> ('f | 'd | 'a | 'b)
//│ }
//│ where
//│   'b :> #Num
//│   'd :> #Num
//│   'a <: 'c
//│   'c <: #Var | (#Num | (#Add & {Add#A <: 'A0} | #Mul & {Mul#A <: 'A} & ~#Add) & ~#Num) & ~#Var
//│   'A <: 'r0 & 'l0
//│   'l0 <: 'g
//│   'r0 <: 'g
//│   'A0 <: 'r & 'l
//│   'l <: 'g
//│   'r <: 'g
//│   'e :> #Cons & {Cons#A = 'A1} | #Cons & {Cons#A = 'A2}
//│      <: 'h
//│   'h :> #Cons & {Cons#A = 'A1} | #Cons & {Cons#A = 'A2}
//│      <: 'e & 'i & (Cons['A2] | Nil)
//│   'i :> #Cons & {Cons#A = 'A1} | #Cons & {Cons#A = 'A2}
//│      <: 'j
//│   'j :> #Cons & {Cons#A = 'A1} | #Cons & {Cons#A = 'A2} | Cons['A3] | Nil
//│      <: #Cons & {Cons#A <: 'A4} | #Nil & ~#Cons
//│   'A3 := out 'A4
//│   'A1 :> ('x, 'k,) | ('x0, 'm,)
//│       <: 'A2 & 'A4
//│   'A2 :> ('x, 'k,) | ('x0, 'm,)
//│       <: 'A1 & 'A4
//│   'A4 :> ('x0, 'm,) | ('x, 'k,)
//│       <: 'head
//│   'head :> ('x0, 'm,) | ('x, 'k,)
//│         <: {_2: 'n} & {_1: 'o}
//│   'm :> forall 'p 'q. 'f | 'p | 's | 'q
//│      <: 'n & 'A5
//│   'x0 :> string
//│       <: 'o
//│   'k :> #Var
//│      <: 'n
//│   'n :> (forall 'p 'q. 'f | 'p | 's | 'q) | #Var
//│      <: 'A6
//│   'A6 :> (forall 'p 'q. 'f | 'p | 's | 'q) | #Var
//│       <: 'A7
//│   'A7 :> (forall 'p 'q. 'f | 'p | 's | 'q) | #Var
//│       <: 'result
//│   'f :> forall 't 'u. 'v | 't | 'u | 'w
//│      <: (#Num | 'y & ~#Num) & (#Num | 'z & ~#Num) & (#Num | 'a1 & ~#Num) & (#Num | 'b1 & ~#Num)
//│   'w :> #Var | 'result
//│      <: (#Num | 'y & ~#Num) & (#Num | 'z & ~#Num) & (#Num | 'a1 & ~#Num) & (#Num | 'b1 & ~#Num)
//│   'result :> (forall 'p 'q. 'f | 'p | 's | 'q) | #Var
//│           <: (#Num | 'y & ~#Num) & (#Num | 'z & ~#Num) & (#Num | 'a1 & ~#Num) & (#Num | 'b1 & ~#Num)
//│   'u :> #Abs & {Abs#A = 'A8}
//│   't :> #App & {App#A = 'A5}
//│   'v :> forall 'c1 'd1. 'f | 'c1 | 'e1 | 'd1
//│      <: (#Num | 'y & ~#Num) & (#Num | 'z & ~#Num) & (#Num | 'a1 & ~#Num) & (#Num | 'b1 & ~#Num)
//│   'd1 :> #Num
//│   'e1 <: (#Num | 'b1 & ~#Num) & (#Num | 'a1 & ~#Num) & (#Num | 'z & ~#Num) & (#Num | 'y & ~#Num) & 'f1
//│   'f1 <: #Var | (#Num | (#Add & {Add#A <: 'A9} | #Mul & {Mul#A <: 'A10} & ~#Add) & ~#Num) & ~#Var
//│   'A10 <: 'r1 & 'l1
//│   'l1 <: 'g
//│   'r1 <: 'g
//│   'A9 <: 'r2 & 'l2
//│   'l2 <: 'g
//│   'r2 <: 'g
//│   'b1 :> #Var | #Abs & {Abs#A = 'A8} | #App & {App#A = 'A5}
//│   'A8 :> forall 'g1 'h1. 'f | 'g1 | 'i1 | 'h1
//│   'h1 :> #Num
//│   'i1 <: 'j1
//│   'j1 <: #Var | (#Num | (#Add & {Add#A <: 'A11} | #Mul & {Mul#A <: 'A12} & ~#Add) & ~#Num) & ~#Var
//│   'A12 <: 'r3 & 'l3
//│   'l3 <: 'g
//│   'r3 <: 'g
//│   'A11 <: 'r4 & 'l4
//│   'l4 <: 'g
//│   'r4 <: 'g
//│   'g <: 'k1
//│   'k1 <: (#Num | 'y & ~#Num) & (#Num | 'z & ~#Num) & (#Num | 'a1 & ~#Num) & (#Num | 'b1 & ~#Num) & 'l1
//│   'l1 <: #Var | (#Num | (#Add & {Add#A <: 'A13} | #Mul & {Mul#A <: 'A14} & ~#Add) & ~#Num) & ~#Var
//│   'A14 <: 'r5 & 'l5
//│   'l5 <: 'g
//│   'r5 <: 'g
//│   'A13 <: 'r6 & 'l6
//│   'l6 <: 'g
//│   'r6 <: 'g
//│   'y :> #Var | #Abs & {Abs#A = 'A8} | #App & {App#A = 'A5}
//│   'A5 :> (forall 'm1 'n1. 'f | 'm1 | 'o1 | 'n1) | (forall 'p 'q. 'f | 'p | 's | 'q)
//│   'q :> #Num
//│   's <: (#Num | 'b1 & ~#Num) & (#Num | 'a1 & ~#Num) & (#Num | 'z & ~#Num) & (#Num | 'y & ~#Num) & 'p1
//│   'p1 <: #Var | (#Num | (#Add & {Add#A <: 'A15} | #Mul & {Mul#A <: 'A16} & ~#Add) & ~#Num) & ~#Var
//│   'A16 <: 'r7 & 'l7
//│   'l7 <: 'g
//│   'r7 <: 'g
//│   'A15 <: 'r8 & 'l8
//│   'l8 <: 'g
//│   'r8 <: 'g
//│   'z :> #Var | #Abs & {Abs#A = 'A8} | #App & {App#A = 'A5}
//│   'a1 :> #Var | #Abs & {Abs#A = 'A8} | #App & {App#A = 'A5}
//│   'p :> #Num
//│   'n1 :> #Num
//│   'o1 <: 'q1
//│   'q1 <: #Var | (#Num | (#Add & {Add#A <: 'A17} | #Mul & {Mul#A <: 'A18} & ~#Add) & ~#Num) & ~#Var
//│   'A18 <: 'r9 & 'l9
//│   'l9 <: 'g
//│   'r9 <: 'g
//│   'A17 <: 'r10 & 'l10
//│   'l10 <: 'g
//│   'r10 <: 'g
//│   'm1 :> #Num
//│   'g1 :> #Num
//│   'c1 :> #Num
//│   'x :> string
//│      <: 'o
//│   'o :> string
//│      <: 'r1
//│   'r1 := string

// * Because EvalExpr does not dispatch lambdas to super and map_expr only
// * handles exprs
:e
Test3.eval(Cons(("c", Abs("d", Var("d"))), Nil), Abs("a", Var("a")))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.511: 	Test3.eval(Cons(("c", Abs("d", Var("d"))), Nil), Abs("a", Var("a")))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Abs[?A]` does not match type `Add[?A0] | Mul[?A1] | Num | Var`
//│ ║  l.511: 	Test3.eval(Cons(("c", Abs("d", Var("d"))), Nil), Abs("a", Var("a")))
//│ ║         	                                                 ^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.201: 	  if v is
//│ ║         	     ^
//│ ╟── from reference:
//│ ║  l.211: 	    let vv = map_expr(eta, v)
//│ ╙──       	                           ^
//│ Abs[Var] | error | 'a
//│   where
//│     'a :> Abs[Num | 'a] | App[Num | 'a] | Num | Var
//│ res
//│ Runtime error:
//│   Error: non-exhaustive case expression
