:NoRecursiveTypes
:GeneralizeCurriedFunctions

// ============ Dummy classes to represent the types in the examples ============

class List[a]
  method Head: a
  method Tail: List[a]
//│ Defined class List[+a]
//│ Declared List.Head: List['a] -> 'a
//│ Declared List.Tail: List['a] -> List['a]

class Cons[a]: List[a] & { head: a; tail: List[a] }
  method Head = this.head
  method Tail = this.tail
def cons[a]: a -> List[a] -> List[a]
def cons head tail = Cons { head; tail }
//│ Defined class Cons[+a]
//│ Defined Cons.Head: Cons['a] -> 'a
//│ Defined Cons.Tail: Cons['a] -> List['a]
//│ cons: 'a -> List['a] -> List['a]
//│     = <missing implementation>
//│ 'b -> (forall 'b, 'head, 'a, 'c, 'tail, 'd. ('c -> 'd
//│   where
//│     'b <: 'head & 'a
//│     'c <: List['a] & 'tail
//│     'd :> Cons['a] with {head: 'head, tail: 'tail}))
//│   where
//│     'e :> Cons['a0] with {head: 'head0, tail: 'tail0}
//│     'b <: 'head0 & 'a0
//│     'f <: List['a0] & 'tail0
//│   <:  cons:
//│ 'a -> List['a] -> List['a]
//│     = [Function: cons]

class Nil[a]: List[a]
  method Head = error
  method Tail = this
def nil: List['a]
def nil = Nil {}
//│ Defined class Nil[+a]
//│ Defined Nil.Head: Nil[?] -> nothing
//│ Defined Nil.Tail: (Nil['a] & 'this) -> (Nil['a] & 'this)
//│ nil: List[nothing]
//│    = <missing implementation>
//│ Nil[nothing]
//│   <:  nil:
//│ List[nothing]
//│    = Nil {}

// ============ Type signatures for functions used in the examples ============

def head: forall 'a. List['a] -> 'a
def head l = l.Head
//│ head: List['a] -> 'a
//│     = <missing implementation>
//│ 'b -> 'c
//│   where
//│     'a <: 'c
//│     'b <: List['a]
//│   <:  head:
//│ List['a] -> 'a
//│     = [Function: head]

def tail: forall 'a. List['a] -> List['a]
def tail l = l.Tail
//│ tail: List['a] -> List['a]
//│     = <missing implementation>
//│ 'b -> 'c
//│   where
//│     'b <: List['a]
//│     'c :> List['a]
//│   <:  tail:
//│ List['a] -> List['a]
//│     = [Function: tail]

def is_empty: forall 'a. List['a] -> bool
def is_empty l = eq l nil
//│ is_empty: List[?] -> bool
//│         = <missing implementation>
//│ 'a -> 'b
//│   where
//│     'a <: 'a
//│     'c :> 'a -> bool
//│        <: List[nothing] -> 'b
//│   <:  is_empty:
//│ List[?] -> bool
//│         = [Function: is_empty]

def concat: forall 'a. List['a] -> List['a] -> List['a]
rec def concat l1 l2 =
  if is_empty l1 then l2
  else cons (head l1) (concat (tail l1) l2)
//│ concat: List['a] -> List['a] -> List['a]
//│       = <missing implementation>
//│ List[?] -> List['a] -> List['a]
//│   <:  concat:
//│ List['a] -> List['a] -> List['a]
//│       = [Function: concat1]

def print_bool: bool -> unit
def print_bool b = log b
//│ print_bool: bool -> unit
//│           = <missing implementation>
//│ 'a -> 'b
//│   where
//│     'a <: 'a
//│     'b :> unit
//│   <:  print_bool:
//│ bool -> unit
//│           = [Function: print_bool]

def print_int: int -> unit
def print_int i = log i
//│ print_int: int -> unit
//│          = <missing implementation>
//│ 'a -> 'b
//│   where
//│     'a <: 'a
//│     'b :> unit
//│   <:  print_int:
//│ int -> unit
//│          = [Function: print_int]

def print_string: string -> unit
def print_string s = log s
//│ print_string: string -> unit
//│             = <missing implementation>
//│ 'a -> 'b
//│   where
//│     'a <: 'a
//│     'b :> unit
//│   <:  print_string:
//│ string -> unit
//│             = [Function: print_string]

def print x = log x
//│ print: 'a -> 'b
//│   where
//│     'a <: 'a
//│     'b :> unit
//│      = [Function: print]



// (* Ces exemples permettent de tester durement le syst�me de types. *)

// type id = ['a] 'a -> 'a
type Id = forall 'a. 'a -> 'a
//│ Defined type alias Id

// let choose x y = if true then x else y
// let succ n = n + 1
// let z = (succ : int -> int)
def choose x y = if true then x else y
def succ n = n + 1
def z = succ : int -> int
//│ choose: 'a -> (forall 'a, 'b, 'c, 'd, 'e, 'f. ('e -> 'f
//│   where
//│     'c :> 'd -> 'd -> 'd
//│        <: 'a -> 'b
//│     'b <: 'e -> 'f))
//│   where
//│     'g :> 'h -> 'h -> 'h
//│        <: 'a -> 'i
//│     'i <: nothing -> 'b
//│       = [Function: choose]
//│ succ: 'a -> 'b
//│   where
//│     'a <: int
//│     'c :> int -> int
//│        <: 1 -> 'b
//│     = [Function: succ]
//│ z: int -> int
//│  = [Function: succ]

// let id x = x
// let z = choose (id:id) id
// let z = (choose id succ) 10
// let z = (choose succ id) 10
def id x = x
def z = choose (id : Id) id
def z = (choose id succ) 10
def z = (choose succ id) 10
//│ id: 'a -> 'a
//│   = [Function: id]
//│ z: 'a -> 'a | Id
//│  = [Function: id]
//│ z: int
//│  = 10
//│ z: int
//│  = 11

// untype fun x -> x x
fun x -> x x
//│ res: 'a -> 'b
//│   where
//│     'a <: 'a -> 'b
//│    = [Function: res]

// let delta (x:id) = x x
def delta (x: Id) = x x
def delta_ x = x x
//│ delta: Id -> 'a
//│   where
//│     'b :> Id
//│        <: Id & 'b -> 'a
//│      = [Function: delta]
//│ delta_: 'a -> 'b
//│   where
//│     'a <: 'a -> 'b
//│       = [Function: delta_]

// let z = delta (delta id)

// :e // FIXME? failed with genLamBodies but works with quantif extrus
def z = delta (delta id)
//│ z: Id
//│  = [Function: id]

def z_ = delta_ (delta_ id)
//│ z_: 'a -> 'a
//│   = [Function: id]

// untype delta succ
:e
delta succ
delta_ succ
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.227: 	delta succ
//│ ║         	^^^^^^^^^^
//│ ╟── type `‘a` is not an instance of type `int`
//│ ║  l.149: 	type Id = forall 'a. 'a -> 'a
//│ ╙──       	                 ^^
//│ res: error | Id
//│    = 'function succ(n) {  return n + 1;}1'
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.228: 	delta_ succ
//│ ║         	^^^^^^^^^^^
//│ ╟── function of type `?a -> ?b` is not an instance of type `int`
//│ ║  l.156: 	def succ n = n + 1
//│ ║         	         ^^^^^^^^^
//│ ╟── but it flows into reference with expected type `int`
//│ ║  l.228: 	delta_ succ
//│ ╙──       	       ^^^^
//│ res: error | int
//│    = 'function succ(n) {  return n + 1;}1'

// let z = delta (choose id id)

// :e // FIXME? failed with genLamBodies but works with quantif extrus
def z = delta (choose id id)
//│ z: Id
//│  = [Function: id]

def z_ = delta_ (choose id id)
//│ z_: 'a -> 'a
//│   = [Function: id]

// let step g = (g 1) - (g 0)
// let apply_to_id f = f id
// let test1 = apply_to_id step
// let test2 = apply_to_id delta
def step g = (g 1) - (g 0)
def apply_to_id f = f id
def test1 = apply_to_id step
def test2 = apply_to_id delta
def test2_ = apply_to_id delta_
//│ step: 'a -> 'b
//│   where
//│     'c :> int -> int
//│        <: 'd -> 'b
//│     'a <: 1 -> 'e & 0 -> 'd
//│     'e <: int
//│     = [Function: step]
//│ apply_to_id: 'a -> 'b
//│   where
//│     'a <: (forall 'c. 'c -> 'c) -> 'b
//│            = [Function: apply_to_id]
//│ test1: int
//│      = 1
//│ test2: Id
//│      = [Function: id]
//│ test2_: 'a -> 'a
//│       = [Function: id]

// type s  = ['a] list ('a) -> bool
// let annote_s (x:id) = (x : s -> s)
type S = forall 'a. List['a] -> bool
def annote_s (x: Id) = x : S -> S
def annote_s_ x = x : S -> S
//│ Defined type alias S
//│ annote_s: Id -> S -> S
//│   where
//│     'a :> Id
//│        <: Id & S -> S
//│         = [Function: annote_s]
//│ annote_s_: 'a -> S -> S
//│   where
//│     'a <: S -> S
//│          = [Function: annote_s_]

// let isnil l = l = []
def isnil l = eq l nil
//│ isnil: 'a -> 'b
//│   where
//│     'a <: 'a
//│     'c :> 'a -> bool
//│        <: List[nothing] -> 'b
//│      = [Function: isnil]

// passif value_restriction
// let t = fun x y ->
//   let isnil = (annote_s x) y in
//   (isnil [ 1 ; 2 ; 3] , isnil [] , isnil ["ok"] , isnil [true])
// in t id isnil
let t = fun x -> fun y ->
  let isnil = (annote_s x) y in
    (isnil (cons 1 (cons 2 (cons 3 nil))), isnil nil, isnil (cons "ok" nil), isnil (cons true nil)) 
  in t id isnil
let t = fun x -> fun y ->
  let isnil = (annote_s_ x) y in
    (isnil (cons 1 (cons 2 (cons 3 nil))), isnil nil, isnil (cons "ok" nil), isnil (cons true nil)) 
  in t id isnil
//│ res: (bool, bool, bool, bool,)
//│    = [ false, true, false, false ]
//│ res: (bool, bool, bool, bool,)
//│    = [ false, true, false, false ]

// untype fun x y ->
//   let isnil = (x:id) y in
//   (isnil [ 1 ; 2 ; 3] , isnil [] , isnil ["ok"] , isnil [true])
fun x -> fun y ->
  let isnil = (x : Id) y in
    (isnil (cons 1 (cons 2 (cons 3 nil))), isnil nil, isnil (cons "ok" nil), isnil (cons true nil))
fun x -> fun y ->
  let isnil = x y in
    (isnil (cons 1 (cons 2 (cons 3 nil))), isnil nil, isnil (cons "ok" nil), isnil (cons true nil)) 
//│ res: Id -> (forall 'a, 'b, 'c, 'd, 'e, 'f, 'g, 'h, 'i, 'j, 'k, 'l, 'm, 'n, 'o, 'p, 'q, 'r, 's, 't, 'u, 'v, 'w. (anything -> ('p, 'r, 'w, 'e,)
//│   where
//│     'a :> List['b] -> List['b]
//│        <: List[nothing] -> 'c
//│     'b :> true
//│     'd <: 'c -> 'e
//│     'f :> List['g] -> List['g]
//│        <: 'h -> 'i
//│     'g :> 1
//│     'j :> List['k] -> List['k]
//│        <: 'l -> 'h
//│     'k :> 2
//│     'm :> List['n] -> List['n]
//│        <: List[nothing] -> 'l
//│     'n :> 3
//│     'o <: 'i -> 'p
//│     'q <: List[nothing] -> 'r
//│     's :> List['t] -> List['t]
//│        <: List[nothing] -> 'u
//│     't :> "ok"
//│     'v <: 'u -> 'w))
//│   where
//│     'x :> List['y] -> List['y]
//│        <: List[nothing] -> 'z
//│     'y :> true
//│     'a1 <: 'z -> anything
//│     'b1 :> List['c1] -> List['c1]
//│         <: 'd1 -> 'e1
//│     'c1 :> 1
//│     'f1 :> List['g1] -> List['g1]
//│         <: 'h1 -> 'd1
//│     'g1 :> 2
//│     'i1 :> List['j1] -> List['j1]
//│         <: List[nothing] -> 'h1
//│     'j1 :> 3
//│     'k1 <: 'e1 -> anything
//│     'l1 <: List[nothing] -> anything
//│     'm1 :> List['n1] -> List['n1]
//│         <: List[nothing] -> 'o1
//│     'n1 :> "ok"
//│     'p1 <: 'o1 -> anything
//│    = [Function: res]
//│ res: ('a -> anything) -> (forall 'a, 'b, 'c, 'd, 'e, 'f, 'g, 'h, 'i, 'j, 'k, 'l, 'm, 'n, 'o, 'p, 'q, 'r, 's, 't, 'u, 'v, 'w, 'x. ('a -> ('l, 'n, 's, 'x,)
//│   where
//│     'b :> List['c] -> List['c]
//│        <: 'd -> 'e
//│     'c :> 1
//│     'f :> List['g] -> List['g]
//│        <: 'h -> 'd
//│     'g :> 2
//│     'i :> List['j] -> List['j]
//│        <: List[nothing] -> 'h
//│     'j :> 3
//│     'k <: 'e -> 'l
//│     'm <: List[nothing] -> 'n
//│     'o :> List['p] -> List['p]
//│        <: List[nothing] -> 'q
//│     'p :> "ok"
//│     'r <: 'q -> 's
//│     't :> List['u] -> List['u]
//│        <: List[nothing] -> 'v
//│     'u :> true
//│     'w <: 'v -> 'x))
//│   where
//│     'y :> 2
//│     'z :> List['a1] -> List['a1]
//│        <: List[nothing] -> 'b1
//│     'a1 :> 3
//│     'c1 <: 'd1 -> anything
//│     'e1 <: List[nothing] -> anything
//│     'f1 :> List['g1] -> List['g1]
//│         <: List[nothing] -> 'h1
//│     'g1 :> "ok"
//│     'i1 <: 'h1 -> anything
//│     'j1 :> List['k1] -> List['k1]
//│         <: List[nothing] -> 'l1
//│     'k1 :> true
//│     'm1 <: 'l1 -> anything
//│     'n1 :> List['o1] -> List['o1]
//│         <: 'p1 -> 'd1
//│     'o1 :> 1
//│     'q1 :> List['y] -> List['y]
//│         <: 'b1 -> 'p1
//│    = [Function: res]

// (*let t1 = f delta	
// let t2 = f step*)

// let partage x = choose id x
// let departage x = choose id (x:id)
def partage x = choose id x
def departage x = choose id (x : Id)
//│ partage: 'a -> 'b
//│   where
//│     'c :> forall 'd, 'e, 'f, 'g, 'h, 'i. ('h -> 'i
//│   where
//│     'd :> 'e -> 'e -> 'e
//│        <: 'f -> 'g
//│     'g <: 'h -> 'i)
//│        <: 'a -> 'b
//│     'j :> 'k -> 'k -> 'k
//│        <: 'f -> 'l
//│     'l <: 'f -> 'l
//│     'f :> forall 'm. 'm -> 'm
//│        = [Function: partage]
//│ departage: 'a -> 'b
//│   where
//│     'a <: Id
//│     'c :> forall 'd, 'e, 'f, 'g, 'h, 'i. ('h -> 'i
//│   where
//│     'd :> 'e -> 'e -> 'e
//│        <: 'f -> 'g
//│     'g <: 'h -> 'i)
//│        <: Id -> 'b
//│     'j :> 'k -> 'k -> 'k
//│        <: 'f -> 'l
//│     'l <: 'f -> 'l
//│     'f :> forall 'm. 'm -> 'm
//│          = [Function: departage]

// let delta' = fun x -> (departage x) x
// untype fun x -> partage x x
def delta' = fun x -> (departage x) x
def delta'_ = fun x -> (partage x) x
//│ delta': 'a -> 'b
//│   where
//│     'c :> forall 'd. 'd -> 'd
//│     'e <: 'f
//│     'a <: 'g
//│     'f <: 'a -> 'b
//│     'g <: Id
//│     'h :> forall 'c, 'i, 'j, 'k, 'l, 'm. ('l -> 'm
//│   where
//│     'i :> 'j -> 'j -> 'j
//│        <: 'c -> 'k
//│     'k <: 'l -> 'm)
//│        <: Id -> 'e
//│     'n :> 'o -> 'o -> 'o
//│        <: 'c -> 'p
//│     'p <: 'c -> 'p
//│       = [Function: departage]
//│ delta'_: 'a -> 'b
//│   where
//│     'c <: 'd
//│     'a <: 'e
//│     'd <: 'a -> 'b
//│     'f :> forall 'g, 'h, 'i, 'j, 'k, 'l. ('k -> 'l
//│   where
//│     'g :> 'h -> 'h -> 'h
//│        <: 'i -> 'j
//│     'j <: 'k -> 'l)
//│        <: 'e -> 'c
//│     'm :> 'n -> 'n -> 'n
//│        <: 'i -> 'o
//│     'o <: 'i -> 'o
//│     'i :> forall 'p. 'p -> 'p
//│        = [Function: departage]

// let t = fun x -> (x:id) x, x
// let t = fun (x:id) -> x x, (x:id)
// let t = fun (x:id) -> x x, x
// untype fun x -> x (x:id), x
// untype fun x -> x x, (x:id)
def t = fun x -> ((x : Id) x, x)
def t = fun (x: Id) -> (x x, (x : Id))
def t = fun (x: Id) -> (x x, x)
def t = fun x -> (x (x : Id), x)
def t = fun x -> (x x, x : Id)
def t_ = fun x -> (x x, x)
//│ t: 'b -> ('c, 'b,)
//│   where
//│     'a <: 'c
//│     'b <: Id & 'a
//│  = [Function: t]
//│ t: Id -> ('a, Id,)
//│   where
//│     'b :> Id
//│        <: Id & 'b -> 'a
//│  = [Function: t1]
//│ t: Id -> ('a, 'b,)
//│   where
//│     'b :> Id
//│        <: Id & 'b -> 'a
//│  = [Function: t2]
//│ t: 'a -> ('b, 'a,)
//│   where
//│     'a <: Id & Id -> 'b
//│  = [Function: t3]
//│ t: 'a -> ('b, Id,)
//│   where
//│     'a <: 'a -> 'b & Id
//│  = [Function: t4]
//│ t_: 'a -> ('b, 'a,)
//│   where
//│     'a <: 'a -> 'b
//│   = [Function: t_]

// untype fun x -> (x:id), x x
fun x -> (x : Id, x x)
//│ res: 'a -> (Id, 'b,)
//│   where
//│     'a <: Id & 'a -> 'b
//│    = [Function: res]

// let ig x = () (* ignore *)
def ig x = null
//│ ig: anything -> null
//│   = [Function: ig]

// (* The following is not typable in System F (afaik) *)
// let aa f = f id
// untype fun g -> ig (g delta) ; (fun t -> ig (g t) ; t succ) (fun x -> succ (x 8))
// let ff = fun (g:['a > id] ['b] ('a -> 'b) -> 'b) ->
//         ig (g delta) ; (fun t -> ig (g t) ; t succ) (fun x -> succ (x 8))
def aa f = f id
def ff = fun (g: forall 'a 'b. (('a | Id) -> 'b) -> 'b) ->
  let _ = ig (g delta) in
    (fun t ->
      let _ = ig (g t) in
      t succ
    ) (fun x -> succ (x 8))
def ff_ = fun g ->
  let _ = ig (g delta) in
    (fun t ->
      let _ = ig (g t) in
      t succ
    ) (fun x -> succ (x 8))
//│ aa: 'a -> 'b
//│   where
//│     'a <: (forall 'c. 'c -> 'c) -> 'b
//│   = [Function: aa]
//│ ff: (forall 'a, 'b. (('a | Id) -> 'b) -> 'b) -> 'c
//│   where
//│     'd <: 'e
//│     'f <: 8 -> 'g
//│     'g <: 'h
//│     'h <: int
//│     'i :> int -> int
//│        <: 1 -> 'd
//│     'j :> forall 'e, 'k, 'l, 'm, 'n, 'o. ('m -> 'l
//│   where
//│     'k <: 'l
//│     'm <: 8 -> 'n
//│     'n <: 'e
//│     'e <: int
//│     'o :> int -> int
//│        <: 1 -> 'k)
//│        <: (forall 'p, 'q, 'r. ('p -> 'r
//│   where
//│     'p <: int
//│     'q :> int -> int
//│        <: 1 -> 'r)) -> 's
//│     't <: (forall 'p, 'q, 'r. ('p -> 'r
//│   where
//│     'p <: int
//│     'q :> int -> int
//│        <: 1 -> 'r)) -> 'e
//│     's <: 'c
//│     'u := forall 'a, 'b. (('a | Id) -> 'b) -> 'b
//│   = [Function: ff]
//│ ff_: ('a -> 'b & (forall 'a, 'c. (Id -> 'c
//│   where
//│     'a :> Id
//│        <: Id & 'a -> 'c)) -> 'b) -> 'd
//│   where
//│     'e <: 'f
//│     'f <: int
//│     'g :> int -> int
//│        <: 1 -> 'h
//│     'h <: 'b
//│     'i <: 8 -> 'e
//│     'j :> forall 'b, 'k, 'l, 'm, 'n, 'o. ('b -> 'o
//│   where
//│     'k <: 'l
//│     'l <: int
//│     'm :> int -> int
//│        <: 1 -> 'n
//│     'n <: 'o
//│     'b <: 8 -> 'k)
//│        <: (forall 'p, 'q, 'r. ('p -> 'r
//│   where
//│     'p <: int
//│     'q :> int -> int
//│        <: 1 -> 'r)) -> 's
//│     't <: (forall 'p, 'q, 'r. ('p -> 'r
//│   where
//│     'p <: int
//│     'q :> int -> int
//│        <: 1 -> 'r)) -> 'b
//│     's <: 'd
//│    = [Function: ff_]

// let bigtest = ff aa
def bigtest = ff aa
def bigtest_ = ff_ aa
//│ bigtest: int
//│        = 10
//│ bigtest_: int
//│         = 10

// (* Variable libre / variable li�e dans les annotations. *)
// let example f = (f:['a] 'a -> int -> 'b) f
// let mkpair x y = (x,y)
def example f = (f: forall 'a. 'a -> int -> 'b) f
def example_ f = f f
def mkpair x y = (x, y)
//│ example: 'a -> 'c
//│   where
//│     'a <: 'c -> int -> 'b & 'a
//│     'c :> int -> 'b
//│        = [Function: example]
//│ example_: 'a -> 'b
//│   where
//│     'a <: 'a -> 'b
//│         = [Function: example_]
//│ mkpair: 'a -> (forall 'b. 'b -> ('a, 'b,))
//│       = [Function: mkpair]

// untype example mkpair
// (* �a echoue parce qu'on instancie 'b avec un type contenant 'a *)
// (* Il faudrait que le message d'erreur soit plus clair. *)
example mkpair
example_ mkpair
//│ res: int -> (‘a2333, int,)
//│    = [Function (anonymous)]
//│ res: 'a -> (forall 'b. 'b -> (forall 'c. 'c -> ('b, 'c,)), 'a,)
//│    = [Function (anonymous)]



// (* Exemple MLF avec des fonctions et des constructions r�cursives. *)

// let rec x = 1 :: y
// and     y = 2 :: x

:RecursiveTypes // needed for this recursive def
:ng
rec def p = { x = cons 1 p.y; y = cons 2 p.x }
def x = p.x
def y = p.y
//│ p: {x: List[1 | 2], y: List[1 | 2]}
//│ x: List[1 | 2]
//│ y: List[1 | 2]
:NoRecursiveTypes

// let print_int x = print_string "#"; print_int x; print_string " "
// let intprint x = print_int x
def print_int x =
  let _ = print_string "#" in
  let _ = print_int x in
  print_string " "
def intprint x = print_int x
//│ int -> 'a
//│   where
//│     'a :> unit
//│   <:  print_int:
//│ int -> unit
//│          = [Function: print_int1]
//│ intprint: 'a -> 'b
//│   where
//│     'a <: int
//│     'b :> unit
//│         = [Function: intprint]

// let myNil l = l = []
def myNil l = eq l nil
//│ myNil: 'a -> 'b
//│   where
//│     'a <: 'a
//│     'c :> 'a -> bool
//│        <: List[nothing] -> 'b
//│      = [Function: myNil]

// let rec append x l =
//   if l = [] then [x]
//   else (car l)::(append x (cdr l))
rec def append x l =
  if eq l nil then cons x nil
  else cons (head l) (append x (tail l))
//│ append: 'a -> List['a] -> List['a]
//│       = [Function: append]

// let rec map l f =
//  if l = [] then []
//  else (f (car l)) :: (map (cdr l) f)
rec def map l f =
  if eq l nil then nil
  else cons (f (head l)) (map (tail l) f)
//│ map: List['a] -> ('a -> 'b) -> List['b]
//│    = [Function: map]

// let message () = print "** MESSAGE **"
def message (_: unit) = print "** MESSAGE **"
//│ message: unit -> 'a
//│   where
//│     'b := unit
//│     'c :> "** MESSAGE **"
//│     'd :> unit
//│        <: 'a
//│        = [Function: message]

// let intfa f = f 15
def intfa f = f 15
//│ intfa: 'a -> 'b
//│   where
//│     'a <: 15 -> 'b
//│      = [Function: intfa]

// let polyann (a:'x) (b:int) f (g:int -> 'x -> 'y) = g (f 10) a b
def polyann (a: 'x) (b: int) f (g: int -> 'x -> 'y) = g (f 10) a b
def polyann_ a b f g = g (f 10) a b
//│ polyann: 'x -> (forall 'a, 'b, 'c, 'd, 'e, 'f, 'x0, 'y, 'g, 'h. (int -> (forall 'a, 'b, 'c, 'i, 'j, 'k, 'x1, 'y0, 'l, 'm. ('m -> (forall 'a, 'b, 'c, 'm, 'n, 'o, 'p, 'q, 'x2, 'y1. ((int -> 'x2 -> 'y1) -> 'o
//│   where
//│     'n <: 'a -> 'b
//│     'b <: 'c -> 'o
//│     'm <: 10 -> 'p
//│     'q :> int -> 'x2 -> 'y1
//│        <: int -> 'x2 -> 'y1 & 'p -> 'n))
//│   where
//│     'i <: 'a -> 'j
//│     'j <: 'c -> 'b
//│     'k :> int -> 'x1 -> 'y0
//│        <: int -> 'x1 -> 'y0 & 'l -> 'i
//│     'm <: 10 -> 'l))
//│   where
//│     'c := int
//│     'd <: 'a -> 'e
//│     'e <: 'c -> 'b
//│     'f :> int -> 'x0 -> 'y
//│        <: int -> 'x0 -> 'y & 'g -> 'd
//│     'h <: 10 -> 'g))
//│   where
//│     'a <: 'x
//│     'x <: 'a
//│     'r := int
//│     's <: 'a -> 't
//│     't <: 'r -> 'b
//│     'u :> int -> 'x3 -> 'y2
//│        <: int -> 'x3 -> 'y2 & 'v -> 's
//│     'w <: 10 -> 'v
//│        = [Function: polyann]
//│ polyann_: 'a -> (forall 'a, 'b, 'c, 'd, 'e, 'f, 'g, 'h. ('g -> (forall 'a, 'b, 'g, 'i, 'j, 'k, 'l, 'm. ('m -> (forall 'a, 'b, 'g, 'm, 'n, 'o, 'p, 'q. ('o -> 'q
//│   where
//│     'm <: 10 -> 'n
//│     'o <: 'n -> 'p
//│     'p <: 'a -> 'b
//│     'b <: 'g -> 'q))
//│   where
//│     'i <: 'j -> 'k
//│     'k <: 'a -> 'l
//│     'l <: 'g -> 'b
//│     'm <: 10 -> 'j))
//│   where
//│     'c <: 'd -> 'e
//│     'e <: 'a -> 'f
//│     'f <: 'g -> 'b
//│     'h <: 10 -> 'd))
//│   where
//│     'r <: 's -> 't
//│     't <: 'a -> 'u
//│     'u <: nothing -> 'b
//│     'v <: 10 -> 's
//│         = [Function: polyann_]

// let voyage (f:'p -> 'q) x y = (y, f x)
def voyage (f: 'p -> 'q) x y = (y, f x)
def voyage_ f x y = (y, f x)
//│ voyage: ('p -> 'q) -> (forall 'a, 'b. ('b -> (forall 'a, 'b, 'c, 'd. ('d -> ('d, 'c,)
//│   where
//│     'a <: 'b -> 'c))
//│   where
//│     'a <: 'b -> anything))
//│   where
//│     'a :> 'p -> 'q
//│        <: 'p -> 'q & nothing -> anything
//│       = [Function: voyage]
//│ voyage_: 'a -> (forall 'a, 'b. ('b -> (forall 'a, 'b, 'c, 'd. ('d -> ('d, 'c,)
//│   where
//│     'a <: 'b -> 'c))
//│   where
//│     'a <: 'b -> 'a))
//│   where
//│     'a <: nothing -> 'a
//│        = [Function: voyage_]

// let main =

//   let print_sep s l =

//     let max_depth = 20 in

//     let rec alpha = print_list
//     and print_list n l =

//       if not(n < 0) then

//         if nil l then print_string "]"
//         else 
//           begin
//             intprint (car l);
//             print_string s;
//             print_list (n-1) (cdr l)
//           end
//       else 
// 	       begin
// 	         print_string ("... ]");
// 	         (* failwith ("T�te de liste : "^(string_of_int (car l))) *)
// 	       end
//     in
//     print_string "[";
//     print_list max_depth l;

//   in

//   print (myNil [1;2]);
//   print " ";
//   print (myNil ["foo";"bar"]);
//   print "\n";

//   let ll = [10; 20; 30; 40] @ [50; 60; 70] in
//   let ll2 = append 80 ll in
//   print_sep "; " ll2;
//   print_string "\n";
//   print_sep "" x;

//   ()

:RecursiveTypes // needed for this recursive def
:ng
def main =
  let print_sep = fun s -> fun l ->
    let max_depth = 20 in
      let rec p =
        { alpha = p.print_list;
          print_list = fun n -> fun l ->
            if not (n < 0) then
              if is_empty l then print_string "]"
              else
                let _ = intprint (head l) in
                let _ = print_string s in
                p.print_list (n - 1) (tail l)
            else
              print_string "... ]"
        } in
      let alpha = p.alpha in
      let print_list = p.print_list in
        let _ = print_string "[" in
        print_list max_depth l
  in
    let _ = print (myNil (cons 1 (cons 2 nil))) in
    let _ = print " " in
    let _ = print (myNil (cons "foo" (cons "bar" nil))) in
    let _ = print "\n" in
    let ll = concat (cons 10 (cons 20 (cons 30 (cons 40 nil)))) (cons 50 (cons 60 (cons 70 nil))) in
      let ll2 = append 80 ll in
        let _ = print_sep "; " ll2 in
        let _ = print_string "\n" in
        let _ = print_sep "" x in
        null
//│ main: null
:NoRecursiveTypes

// (* Des probl�mes d'unification � gogo. *)
// type sid = ['a] 'a -> 'a
// type siid = ['a,'b] ('a -> 'b) -> ('a -> 'b)
// type sdup = ['a,'b] ('a -> 'a) -> ('b -> 'b)
// type sdip = ['a]    ('a -> 'a) -> ('a -> 'a)
// type i = int
// type j = bool

// (*  PAGE 1 *)

// please unify ['a > ['a0 > sid] i -> 'a0] 'a -> 'a 
// (* with *) :   ['c > sdup] (i -> 'c) -> (i -> 'c)
// (* Result should be *) 
//          =   ['a0 > sdip] ['a = i -> 'a0] 'a -> 'a

// please unify ['a > ['a0 > sid] i -> 'a0] ['b > ['b0 > siid] j -> 'b0] 'a -> 'b
//          :   ['c > sdup] (i -> 'c) -> (j -> 'c)
//          =   ['c0 > sdip] (i -> 'c0) -> (j -> 'c0)

// please unify ['a > sid, 'b > sdup] 'a -> 'b  :   sid
//          =   ['a > sdip] 'a -> 'a

// please failon_unify ['a > sid, 'b = sdup] 'a -> 'b  :   sid

// please unify ['a > sid, 'b = siid] 'a -> 'b  :   sid
//          =   ['a = siid] 'a -> 'a

// please unify ['a > ['a1 > sid, 'a2 > siid] 'a1 -> 'a2] 'a -> 'a
//          :   ['c > ['c2 > siid] (i -> i) -> 'c2] 'c -> 'c
//          =   ['a > ['c2 > siid] (i -> i) -> 'c2] 'a -> 'a

// please unify ['a > ['a0 > siid] ('a0 -> i) -> i] 'a -> 'a
//          :   ['a > ['a0 > sdup] 'a0 -> i] ('a -> i) -> ('a -> i)
//          =   ['c0 > sdip, 'c = 'c0 -> i] ('c -> i) -> ('c -> i)

// please unify ['a > sid] ['b1 > ['c] 'c -> 'a]    ['c1 > ['c3] 'c3 -> 'a] 'b1 -> 'c1
//          :   ['a > sid] ['b2 > ['c] 'c -> i -> i, 'c2 = ['c3] 'c3 -> 'a] 'b2 -> 'c2
//          =   ['a = i -> i] ['b1 > ['c] 'c -> 'a] ['c1 = ['c3] 'c3 -> 'a] 'b1 -> 'c1

// please unify ['a > sid] ['b > sdup] ('b -> 'b) -> 'a
//          :   ['c > sid] 'c -> 'c
//          =   ['b > sdup] ('b -> 'b) -> ('b -> 'b)

// please failon_unify ['a] ['b = ['b0] 'b0 -> 'a] 'a -> 'b : sid


// (* PAGE 2 *)
// please unify ['a1 = ['b1 = sdup] ['c] 'c -> 'b1] 'a1 -> i
//          :   ['b2 = sdup] ['a2 = ['c3] 'c3 -> 'b2] 'a2 -> i
//          =   ['b2 = sdup] ['a2 = ['c3] 'c3 -> 'b2] 'a2 -> i

// please unify ['a1 = ['a2 = ['a3 = sdup] ['c] 'c -> 'a3 -> 'a3] 'a2 -> i] 'a1 -> i
//          :   ['a1 = ['a3 = sdup] ['a2 = ['c] 'c -> 'a3 -> 'a3] 'a2 -> i] 'a1 -> i
//          =   ['a1 = ['a3 = sdup] ['a2 = ['c] 'c -> 'a3 -> 'a3] 'a2 -> i] 'a1 -> i

// please failon_unify ['a1 = ['a2 > sdup] 'a2 -> 'a2] 'a1 -> i
//          :   ['a2 = sdup] ['a1 = 'a2 -> 'a2] 'a1 -> i

// please failon_unify ['a1 = ['a2 > sdup] ['a3 = ['a4 > siid] 'a2 -> 'a4] ['a5] 'a5 -> 'a3 -> i] 'a1 -> i
//          :   ['b2 > sdup] ['b3 = ['b4 > siid] 'b2 -> 'b4] ['b1 = ['b5] 'b5 -> 'b3 -> i] 'b1 -> i

// please unify ['a1 = ['a2 = sdup, 'a3 = sdup] 'a2 -> 'a3] 'a1 -> i
//          :   ['a1 = ['a = sdup] 'a -> 'a] 'a1 -> i
//          =   ['a1 = ['a = sdup] 'a -> 'a] 'a1 -> i

// please unify ['a1 = ['a2 = sdup, 'a3 = sdup] 'a2 -> 'a3] 'a1 -> i
//          :   ['a1 > ['a] 'a -> 'a] 'a1 -> i
//          =   ['a1 = ['a = sdup] 'a -> 'a] 'a1 -> i

// please unify ['a1 = ['a2 = ['a3 = sdup] ['b] 'b -> 'a3 -> i] ['c] 'c -> 'a2 -> i] 'a1 -> i
//          :   ['a3 = sdup] ['a1 = ['a2 = ['b] 'b -> 'a3 -> i] ['c] 'c -> 'a2 -> i] 'a1 -> i
//          =   ['a3 = sdup] ['a1 = ['a2 = ['b] 'b -> 'a3 -> i] ['c] 'c -> 'a2 -> i] 'a1 -> i

// please failon_unify ['a1 = ['a2 = ['a3 > sdup] ['b] 'b -> 'a3 -> i] ['c] 'c -> 'a2 -> i] 'a1 -> i
//          :   ['a3 = sdup] ['a2 = ['b] 'b -> 'a3 -> i] ['a1 = ['c] 'c -> 'a2 -> i] 'a1 -> i

// please unify ['a = ['a2 = ['b1 = sdup] i -> 'b1] ['a1 > ['c] 'c -> 'a2] 'a1 -> 'a1] 'a -> 'a
//          :   ['b1 = sdup] ['a = ['a1 > ['c] 'c -> i -> 'b1] 'a1 -> 'a1] 'a -> 'a
//          =   ['b1 = sdup] ['a = ['a1 > ['c] 'c -> i -> 'b1] 'a1 -> 'a1] 'a -> 'a

// please unify ['b > sid, 'a = ['a1 = siid, 'a2 = ['c] 'a1 -> 'b -> 'c, 'a3 = ['c] 'a1 -> 'c] 'a2 -> 'a3] 'a -> 'a
//          :   ['a = ['a1 = siid, 'a2 = ['c] 'a1 -> (i -> i) -> 'c, 'a3 = ['c] 'a1 -> 'c] 'a2 -> 'a3] 'a -> 'a
//          =   ['a = ['a1 = siid, 'a2 = ['c] 'a1 -> (i -> i) -> 'c, 'a3 = ['c] 'a1 -> 'c] 'a2 -> 'a3] 'a -> 'a

// please unify ['a1 = ['a2 = ['a3 = siid] i -> 'a3] j -> 'a2] i -> 'a1
//          :   ['a3 = siid] i -> j -> i -> 'a3
//          =   ['a3 = siid] i -> j -> i -> 'a3

// please failon_unify ['a1 = ['a2 = ['a3 = sdup] ['b] 'b -> 'a3 -> i] ['c] 'c -> 'a2 -> i] 'a1 -> i
//          :   ['a3 = sdup] ['a1 = ['a2 > ['b] 'b -> 'a3 -> i] ['c] 'c -> 'a2 -> i] 'a1 -> i


// please unify ['a1 = ['a2 = ['a3 = ['a4 = ['a5 = 0] 'a5 -> i]
//                                         ('a4 -> i) -> i]
//                                         ('a3 -> i) -> i] 'a2 -> i] 'a1 -> i
//          :   ['b1 = ['b2 = ['b3 = ['b4 = 0] ('b4 -> i) -> i]
//                                         ('b3 -> i) -> i]
//                                         ('b2 -> i) -> i] 'b1 -> i
//          =   ['c1 = ['c5 = 0] ((((('c5 -> i) -> i) -> i) -> i) -> i) -> i] 'c1 -> i

// please unify ['a1 > ['a2 > ['a3 > ['a4 > ['a5 > siid] 'a5 -> i]
//                                         ('a4 -> i) -> i]
//                                         ('a3 -> i) -> i] 'a2 -> i] 'a1 -> i
//          :   ['b1 > ['b2 > ['b3 > ['b4 > sdup] ('b4 -> i) -> i]
//                                         ('b3 -> i) -> i]
//                                         ('b2 -> i) -> i] 'b1 -> i
//          =   ['c1 > ['c5 > sdip] ((((('c5 -> i) -> i) -> i) -> i) -> i) -> i] 'c1 -> i

// (* Avec deux quantificateurs � remonter. *)
// please unify ['a2 > ['a4 > ['a6,'a7] ('a6 -> 'a7) -> i ] ('a4 -> i) -> i ] ('a2 -> i) -> i
//          :   ['b1 > ['b3 > ['b5 > ['b6,'b7] 'b6 -> 'b7 ] ('b5 -> i) -> i ] ('b3 -> i) -> i ] 'b1 -> i
//          =   ['c6,'c7] ((((('c6 -> 'c7) -> i) -> i) -> i) -> i) -> i


// (* Cet exemple cr�e un graphe mal form�. *)
// please failon_unify ['a] ['b = ['c] 'c -> 'a] 'b -> 'a
//          :   ['a] ['b > ['c] 'c -> list ('c)] 'b -> 'a

// (* Plus simple *)
// please failon_unify ['a] ['b = ['c] 'c -> 'a] 'b -> 'a
//          :   ['a] ['b > ['c] 'c -> 'c] 'b -> 'a

// (* Extrusion automatique de binders. *)
// please unify  ['a] ['b > ['c] 'c -> 'a] 'b -> 'a
//           :   ['a] ['b > ['c] 'c -> 'c] 'b -> 'a
//           =   ['c] ('c -> 'c) -> 'c

// (* Plus compliqu�. *)
// please unify  ['a] ['b > ['c] 'c -> 'a] 'b -> 'a
//           :   ['a] ['b > ['c] 'c -> list ('c)] 'b -> 'a
//           =   ['c] ('c -> list ('c)) -> list ('c)

// (* Variante *)
// please unify  ['a] ['b > ['c] ['d] 'c -> 'd] 'b -> 'a
//           :   ['a] ['b = ['c] 'c -> 'a] 'b -> 'a
//           =   ['a] ['b = ['c] 'c -> 'a] 'b -> 'a

// please failon_unify  ['a] ['b = ['c] ['d] 'c -> 'd] 'b -> 'a
//           :   ['a] ['b > ['c] 'c -> 'a] 'b -> 'a


// please unify ['a] ['b > ['c] ['d > ['e] 'c -> 'e] 'c -> 'd] 'b -> 'a
//          :   ['a] ['b > ['c] 'c -> 'a] 'b -> 'a
//          =   ['c] ['a > ['e] 'c -> 'e] ('c -> 'a) -> 'a

// please unify ['a] ['b > ['f] ['c] ['d > ['e] 'c -> 'e] 'f * 'c * 'd] 'b -> 'a
//          :   ['a] ['b > ['f] ['c] 'f * 'c * 'a] 'b -> 'a
//          =   ['c] ['a > ['e] 'c -> 'e] ['b > ['f] ('f * 'c * 'a)] 'b -> 'a

// please failon_unify ['a] ['b = ['c] ['d > ['e] 'c -> 'e] 'c -> 'd] 'b -> 'a
//          :   ['a] ['b > ['c] 'c -> 'a] 'b -> 'a

// please failon_unify ['a] ['b > ['c] ['d > ['e] 'c -> 'e] 'c -> 'd] 'b -> 'a
//          :   ['a] ['b = ['c] 'c -> 'a] 'b -> 'a



// please unify ['a] ['b > ['b1] ['c > ['c1] ['d > ['d1] list ('b1 * 'c1 * 'd1)] list ('d) ] list ('c) ] 'b -> 'a
//          :   ['a] (list (list (list ('a)))) -> 'a
//          =   ['b1] ['c1] ['d1] (list (list (list ('b1 * 'c1 * 'd1)))) -> ('b1 * 'c1 * 'd1)


// please notequiv ['b]['c] ('b * 'c)  -> ('b * 'c)
//          :   ['b]['c] ('b * 'c)  -> ('c * 'b)

// (* Unification d'une variable avec un sch�ma de types. *)
// type sid = ['a] 'a -> 'a
// let id y = y
// let succ n = n + 1
// let test = fun (x:'a) -> ((x:sid) , if true then x else id)
// untype fun (x:'a) -> ((x:sid) , if true then x else succ)
type Sid = forall 'a. 'a -> 'a
def id y = y
def succ n = n + 1
def test = fun (x : 'a) -> (x : Sid, if true then x else id)
def test2 = fun (x : 'a) -> (x : Sid, if true then x else succ)
//│ Defined type alias Sid
//│ id: 'a -> 'a
//│   = [Function: id1]
//│ succ: 'a -> 'b
//│   where
//│     'a <: int
//│     'c :> int -> int
//│        <: 1 -> 'b
//│     = [Function: succ1]
//│ test: 'a -> (Sid, 'b,)
//│   where
//│     'c <: 'a & Sid
//│     'a <: 'c
//│     'd :> 'e -> 'e -> 'e
//│        <: 'c -> 'f
//│     'f <: (forall 'g. 'g -> 'g) -> 'b
//│     = [Function: test]
//│ test2: 'a -> (Sid, 'b,)
//│   where
//│     'c <: 'a & Sid
//│     'a <: 'c
//│     'd :> 'e -> 'e -> 'e
//│        <: 'c -> 'f
//│     'f <: (forall 'g, 'h, 'i. ('g -> 'i
//│   where
//│     'g <: int
//│     'h :> int -> int
//│        <: 1 -> 'i)) -> 'b
//│      = [Function: test21]


// (* Typable dans MLF, mais pas dans systeme F. *)
// type sid = ['a] 'a -> 'a
// type sa = ['b] ['a > sid] ('a -> 'b) -> 'b
type Sa = forall 'a 'b. (('a | Sid) -> 'b) -> 'b
//│ Defined type alias Sa


// let auto (x:sid) = x x
// let id x = x
// let k x y = x
def auto (x: Sid) = x x
def auto_ x = x x
def id x = x
def k x y = x
//│ auto: Sid -> 'a
//│   where
//│     'b :> Sid
//│        <: Sid & 'b -> 'a
//│     = [Function: auto]
//│ auto_: 'a -> 'b
//│   where
//│     'a <: 'a -> 'b
//│      = [Function: auto_]
//│ id: 'a -> 'a
//│   = [Function: id2]
//│ k: 'a -> anything -> 'a
//│  = [Function: k]

// let church_zero = fun f -> id
// let church_un = id
// let church_succ n = fun f x -> f (n f x)
// untype fun g -> k (g auto) ((fun t -> g t ; t church_un) (fun x -> (church_succ x) church_zero))
// let f  = fun (g:sa) -> k (g auto) ((fun t -> g t ; t church_un) (fun x -> (church_succ x) church_zero))
// let a = fun f -> f id
def church_zero = fun f -> id
def church_un = id
def church_succ n = fun f -> fun x -> f (n f x)
def f = fun (g: Sa) -> k (g auto) ((fun t -> let _ = g t in t church_un) (fun x -> (church_succ x) church_zero))
def f_ = fun g -> k (g auto_) ((fun t -> let _ = g t in t church_un) (fun x -> (church_succ x) church_zero))
def a = fun f -> f id
//│ church_zero: anything -> (forall 'a. 'a -> 'a)
//│            = [Function: church_zero]
//│ church_un: 'a -> 'a
//│          = [Function: id2]
//│ church_succ: 'a -> (forall 'b, 'a, 'c, 'd, 'e, 'f. ('d -> (forall 'a, 'c, 'd, 'g, 'h, 'i. ('i -> 'h
//│   where
//│     'a <: 'd -> 'c
//│     'd <: 'g -> 'h
//│     'c <: 'i -> 'g))
//│   where
//│     'a <: 'd -> 'e
//│     'd <: 'f -> 'c
//│     'e <: 'b -> 'f))
//│   where
//│     'j <: 'b -> 'k
//│     'a <: 'b -> 'j
//│     'b <: 'k -> 'c
//│            = [Function: church_succ]
//│ f: Sa -> 'a
//│   where
//│     'b :> forall 'c, 'd, 'e, 'f, 'g. ('c -> 'h
//│   where
//│     'c <: 'd
//│     'e :> forall 'd, 'i, 'j, 'k, 'l, 'm. ('i -> (forall 'd, 'i, 'n, 'o, 'p, 'q. ('q -> 'p
//│   where
//│     'd <: 'i -> 'n
//│     'i <: 'o -> 'p
//│     'n <: 'q -> 'o))
//│   where
//│     'd <: 'i -> 'j
//│     'i <: 'k -> 'l
//│     'j <: 'm -> 'k)
//│        <: ('l -> (forall 'r. 'r -> 'r)) -> 'h
//│     'f <: 'm -> 's
//│     'd <: 'g -> 'f
//│     'g <: 's -> 'l)
//│        <: (forall 'r. 'r -> 'r) -> 't
//│     't <: 'u
//│     'v <: (forall 'r. 'r -> 'r) -> 'l
//│     'w <: 'x
//│     'y :> forall 'd, 'i, 'j, 'k, 'l, 'm. ('i -> (forall 'd, 'i, 'n, 'o, 'p, 'q. ('q -> 'p
//│   where
//│     'd <: 'i -> 'n
//│     'i <: 'o -> 'p
//│     'n <: 'q -> 'o))
//│   where
//│     'd <: 'i -> 'j
//│     'i <: 'k -> 'l
//│     'j <: 'm -> 'k)
//│        <: ('l -> (forall 'r. 'r -> 'r)) -> 'l
//│     'z :> Sa
//│        <: Sa & (forall 'a1, 'b1. (Sid -> 'b1
//│   where
//│     'a1 :> Sid
//│         <: Sid & 'a1 -> 'b1)) -> 'c1
//│     'l <: 'm -> 'd1
//│     'c1 <: 'e1
//│     'x <: 'm -> 'l
//│     'f1 :> 'l -> 'e1
//│         <: 'u -> 'a
//│     'm <: 'd1 -> 'l
//│  = [Function: f]
//│ f_: 'a -> 'b
//│   where
//│     'c <: 'd
//│     'e :> forall 'f, 'g, 'h, 'i, 'j, 'k. ('g -> (forall 'f, 'g, 'l, 'm, 'n, 'o. ('o -> 'n
//│   where
//│     'f <: 'g -> 'l
//│     'g <: 'm -> 'n
//│     'l <: 'o -> 'm))
//│   where
//│     'f <: 'g -> 'h
//│     'g <: 'i -> 'j
//│     'h <: 'k -> 'i)
//│        <: ('j -> (forall 'p. 'p -> 'p)) -> 'j
//│     'a <: (forall 'q, 'r. ('q -> 'r
//│   where
//│     'q <: 'q -> 'r)) -> 's
//│     't <: 'k -> 'u
//│     's <: 'v
//│     'd <: 'w -> 't
//│     'x :> 'j -> 'v
//│        <: 'y -> 'b
//│     'w <: 'u -> 'j
//│     'z :> forall 'f, 'j, 'k, 'a1, 'b1. ('a1 -> 'c1
//│   where
//│     'a1 <: 'f
//│     'b1 :> forall 'f, 'g, 'h, 'i, 'j, 'k. ('g -> (forall 'f, 'g, 'l, 'm, 'n, 'o. ('o -> 'n
//│   where
//│     'f <: 'g -> 'l
//│     'g <: 'm -> 'n
//│     'l <: 'o -> 'm))
//│   where
//│     'f <: 'g -> 'h
//│     'g <: 'i -> 'j
//│     'h <: 'k -> 'i)
//│         <: ('j -> (forall 'p. 'p -> 'p)) -> 'c1
//│     'j <: 'k -> 'd1
//│     'f <: 'k -> 'j
//│     'k <: 'd1 -> 'j)
//│        <: (forall 'p. 'p -> 'p) -> 'e1
//│     'e1 <: 'y
//│     'f1 <: (forall 'p. 'p -> 'p) -> 'j
//│   = [Function: f_]
//│ a: 'a -> 'b
//│   where
//│     'a <: (forall 'c. 'c -> 'c) -> 'b
//│  = [Function: a]

// let app x y = x y
// let test1 = f a
// let test2 = app f a
def app x y = x y
def test1 = f a
def test2 = app f a
//│ app: 'a -> (forall 'a, 'b, 'c. ('b -> 'c
//│   where
//│     'a <: 'b -> 'c))
//│   where
//│     'a <: nothing -> 'a
//│    = [Function: app]
//│ test1: Sid
//│      = [Function: id2]
//│ test2: Sid
//│      = [Function: id2]


// (* Create occur-checks. *)
// please failon_unify ['b] 'b -> ('b -> 'b)
//          :   ['a > ['c] ('c -> 'c) -> ('c -> 'c)]
//                   'a -> 'a

// please failon_unify ['i] 'i -> 'i
//          :   ['a > ['c] ('c -> 'c) -> ('c -> 'c)]
//              ['b > ['d] 'd -> 'a]
//              'b -> 'a

// ;;
// please failon_unify ['i] 'i -> 'i
//          :   ['a > ['c] ('c -> 'c) -> ('c -> 'c)]
//              ['b > ['d] 'd -> 'a]
//              'a -> 'b

// ;;


// let t = let x = fun y -> y in x x ;;
// let t = let x = ((fun y -> y) : ['a] 'a -> 'a) in x x ;;
// let t = let x = ((fun y -> y) : 'a) in x x ;;
def t = let x = fun y -> y in x x
def t = let x = (fun y -> y) : forall 'a. 'a -> 'a in x x
def t = let x = (fun y -> y) : 'a in x x
//│ t: 'a -> 'a
//│  = [Function (anonymous)]
//│ t: 'a -> 'a
//│  = [Function (anonymous)]
//│ t: 'a -> 'a
//│  = [Function (anonymous)]


// untype  fun x -> ( (((x:'a) : sid):'a), (x:'a) x)
// untype  fun x -> ( ((x:'a) : sid), (x:'a) x)
// untype  fun x -> ( ((x : sid):'a), (x:'a) x)
// untype  fun x -> ( (((x:'a) : sid):'a), x x)
// untype  fun x -> ( (x : sid), (x:'a) x)
// let t = fun x -> ( (((x:'a) : sid):'a), (x:'a))
fun x -> ( (((x : 'a) : Sid) : 'a), (x : 'a) x)
fun x -> ( ((x : 'a) : Sid), (x : 'a) x)
fun x -> ( ((x : Sid) : 'a), (x : 'a) x)
fun x -> ( (((x : 'a) : Sid) : 'a), x x)
fun x -> ( (x : Sid), (x : 'a) x)
fun x -> ( (((x : 'a) : Sid) : 'a), x : 'a)
//│ res: 'b -> ('a, 'c,)
//│   where
//│     'b <: 'a0
//│     'a1 <: ‘a -> ‘a
//│     'a :> Sid
//│     'a0 <: 'b -> 'c
//│    = [Function: res]
//│ res: 'b -> (Sid, 'c,)
//│   where
//│     'b <: 'a
//│     'a0 <: ‘a -> ‘a
//│     'a <: 'b -> 'c
//│    = [Function: res]
//│ res: 'b -> ('a, 'c,)
//│   where
//│     'a0 <: 'b -> 'c
//│     'b <: Sid & 'a0
//│     'a :> Sid
//│    = [Function: res]
//│ res: 'b -> ('a, 'c,)
//│   where
//│     'b <: 'b -> 'c
//│     'a0 <: ‘a -> ‘a
//│     'a :> Sid
//│    = [Function: res]
//│ res: 'b -> (Sid, 'c,)
//│   where
//│     'b <: Sid & 'a
//│     'a <: 'b -> 'c
//│    = [Function: res]
//│ res: 'b -> ('a, 'a0,)
//│   where
//│     'b <: 'b & 'a0
//│     'a1 <: ‘a -> ‘a
//│     'a :> Sid
//│    = [Function: res]

// (* R�cursion polymorphe. *)
// untype let rec id x = if true then x else id id x in id

// Same as `id1` in `ex_demo.mls`; works with `:RecursiveTypes`
:e
rec def id_ x = if true then x else id_ id_ x
//│ ╔══[ERROR] Cyclic-looking constraint while typing binding of lambda expression
//│ ║  l.1362: 	rec def id_ x = if true then x else id_ id_ x
//│ ║          	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  (α4340' -> α4346')  <:  α4345'    FunctionType  TypeVariable
//│ ╙──  ... looks like:  (α4340' -> α4346')  <:  α4345'
//│ ╔══[ERROR] Cyclic-looking constraint while typing binding of lambda expression
//│ ║  l.1362: 	rec def id_ x = if true then x else id_ id_ x
//│ ║          	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  (α4340' -> α4346')  <:  α4344'    FunctionType  TypeVariable
//│ ╙──  ... looks like:  (α4340' -> α4346')  <:  α4344'
//│ id_: 'id_
//│   where
//│     'id_ :> 'a -> 'b
//│     'a :> 'id_
//│        <: 'b
//│     'b :> 'id_
//│        <: 'a -> 'b
//│    = [Function: id_]

// let rec (id:sid) x = if true then x else id id x

def id: Sid
//│ id: Sid
//│   = <missing implementation>

// FIXME
rec def id x = if true then x else id id x
//│ ╔══[ERROR] Cyclic-looking constraint while typing binding of lambda expression
//│ ║  l.1391: 	rec def id x = if true then x else id id x
//│ ║          	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  (α4360' -> α4366')  <:  α4365'    FunctionType  TypeVariable
//│ ╙──  ... looks like:  (α4360' -> α4366')  <:  α4365'
//│ ╔══[ERROR] Cyclic-looking constraint while typing binding of lambda expression
//│ ║  l.1391: 	rec def id x = if true then x else id id x
//│ ║          	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  (α4360' -> α4366')  <:  α4364'    FunctionType  TypeVariable
//│ ╙──  ... looks like:  (α4360' -> α4366')  <:  α4364'
//│ 'id
//│   where
//│     'id :> 'a -> 'b
//│     'a :> 'id
//│        <: 'b
//│     'b :> 'id
//│        <: 'a -> 'b
//│   <:  id:
//│ Sid
//│ ╔══[ERROR] Cyclic-looking constraint while typing def definition
//│ ║  l.1391: 	rec def id x = if true then x else id id x
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‘a''  <:  α20_4383''    TraitTag  TypeVariable
//│ ╙──  ... looks like:  ‘a''  <:  α20_4362'
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1391: 	rec def id x = if true then x else id id x
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘a` is not a function
//│ ║  l.1072: 	type Sid = forall 'a. 'a -> 'a
//│ ║          	                  ^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.1391: 	rec def id x = if true then x else id id x
//│ ║          	                                   ^^^^^^^
//│ ╟── from reference:
//│ ║  l.1391: 	rec def id x = if true then x else id id x
//│ ╙──        	                            ^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1391: 	rec def id x = if true then x else id id x
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> ?b` is not an instance of type `'a`
//│ ║  l.1391: 	rec def id x = if true then x else id id x
//│ ║          	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `‘a`
//│ ║  l.1391: 	rec def id x = if true then x else id id x
//│ ║          	                                      ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.1072: 	type Sid = forall 'a. 'a -> 'a
//│ ╙──        	                  ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1391: 	rec def id x = if true then x else id id x
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> ?b` is not an instance of type `'a`
//│ ║  l.1391: 	rec def id x = if true then x else id id x
//│ ║          	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `‘a`
//│ ║  l.1391: 	rec def id x = if true then x else id id x
//│ ║          	                                      ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.1072: 	type Sid = forall 'a. 'a -> 'a
//│ ╙──        	                  ^^
//│   = [Function: id3]


// let z = print_string "Ok, all tests passed."


