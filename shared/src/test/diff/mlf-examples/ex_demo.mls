:GeneralizeCurriedFunctions
// :NoJS

// ============ Dummy classes to represent the types in the examples ============

class None
class Some[a]: { val: a }
type Option[a] = None | Some[a]
//│ Defined class None
//│ Defined class Some[+a]
//│ Defined type alias Option[+a]

class List[a]
  method Head: a
  method Tail: List[a]
//│ Defined class List[+a]
//│ Declared List.Head: List['a] -> 'a
//│ Declared List.Tail: List['a] -> List['a]

class Cons[a]: List[a] & { head: a; tail: List[a] }
  method Head = this.head
  method Tail = this.tail
def cons[a]: a -> List[a] -> List[a]
def cons head tail = Cons { head; tail }
//│ Defined class Cons[+a]
//│ Defined Cons.Head: Cons['a] -> 'a
//│ Defined Cons.Tail: Cons['a] -> List['a]
//│ cons: 'a -> List['a] -> List['a]
//│     = <missing implementation>
//│ 'b -> (forall 'a, 'tail. (List['a] & 'tail) -> (Cons['a | 'b] with {head: 'b, tail: 'tail}))
//│   <:  cons:
//│ 'a -> List['a] -> List['a]
//│     = [Function: cons]

class Nil[a]: List[a]
  method Head = error
  method Tail = this
def nil: List['a]
def nil = Nil {}
//│ Defined class Nil[+a]
//│ Defined Nil.Head: Nil[?] -> nothing
//│ Defined Nil.Tail: (Nil['a] & 'this) -> (Nil['a] & 'this)
//│ nil: List[nothing]
//│    = <missing implementation>
//│ Nil[nothing]
//│   <:  nil:
//│ List[nothing]
//│    = Nil {}

// ============ Type signatures for functions used in the examples ============

def head: forall 'a. List['a] -> 'a
def head l = l.Head
//│ head: List['a] -> 'a
//│     = <missing implementation>
//│ List['a] -> 'a
//│   <:  head:
//│ List['a] -> 'a
//│     = [Function: head]

def tail: forall 'a. List['a] -> List['a]
def tail l = l.Tail
//│ tail: List['a] -> List['a]
//│     = <missing implementation>
//│ List['a] -> List['a]
//│   <:  tail:
//│ List['a] -> List['a]
//│     = [Function: tail]

:ng
def print_bool: bool -> unit
def print_bool b = log b
//│ print_bool: bool -> unit
//│ anything -> unit
//│   <:  print_bool:
//│ bool -> unit

:ng
def print_int: int -> unit
def print_int i = log i
//│ print_int: int -> unit
//│ anything -> unit
//│   <:  print_int:
//│ int -> unit

:ng
def print_string: string -> unit
def print_string s = log s
//│ print_string: string -> unit
//│ anything -> unit
//│   <:  print_string:
//│ string -> unit



// (* A quick demo of MLF *)

// (* In the following, "untype expr" means that the expression expr should not be typable. *)

// type sid = ['a] 'a -> 'a
type Sid = forall 'a. 'a -> 'a
//│ Defined type alias Sid

// let id = fun x -> x
def id = fun x -> x
//│ id: 'a -> 'a
//│   = [Function: id]

// let delta = fun (x:sid) -> x x
def delta = fun (x: Sid) -> x x
def delta' = fun x -> x x
//│ delta: Sid -> Sid
//│      = [Function: delta]
//│ delta': ('a -> 'b & 'a) -> 'b
//│       = [Function: delta]

// let choose x y = if true then x else y
def choose x y = if true then x else y
//│ choose: 'a -> (forall 'b. 'b -> ('a | 'b))
//│       = [Function: choose]

// let succ n = n + 1
// ;;
def succ n = n + 1
//│ succ: int -> int
//│     = [Function: succ]

// let test1 = delta id
test1 = delta id
//│ test1: Sid
//│      = [Function: id]

// untype delta succ
:e
delta succ
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.135: 	delta succ
//│ ║         	^^^^^^^^^^
//│ ╟── type `‘a` is not an instance of type `int`
//│ ║  l.101: 	type Sid = forall 'a. 'a -> 'a
//│ ║         	                  ^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.124: 	def succ n = n + 1
//│ ╙──       	             ^
//│ res: error | Sid
//│    = 'function succ(n) {  return n + 1;}1'

// let test2 = delta (choose id id)
test2 = delta (choose id id)
//│ test2: Sid
//│      = [Function: id]

// untype delta (choose id succ)
:e
delta (choose id succ)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.155: 	delta (choose id succ)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘a` is not an instance of type `int`
//│ ║  l.101: 	type Sid = forall 'a. 'a -> 'a
//│ ║         	                  ^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.124: 	def succ n = n + 1
//│ ╙──       	             ^
//│ res: error | Sid
//│    = [Function: id]

// let test3 = choose id succ
test3 = choose id succ
//│ test3: int -> int
//│      = [Function: id]

// let test4 = choose succ id
// ;;
test4 = choose succ id
//│ test4: int -> int
//│      = [Function: succ]


// let eqstring s1 s2 = (s1^"A" = s2^"A")
def eqstring s1 s2 = eq (concat s1 "A") (concat s2 "A")
//│ eqstring: string -> string -> bool
//│         = [Function: eqstring]

// let eqint i1 i2 = (i1 - i2) = 0
def eqint i1 i2 = (i1 - i2) == 0
//│ eqint: int -> int -> bool
//│      = [Function: eqint]

// let eqbool b1 b2 = if b1 then b2 else (not b2)
def eqbool b1 b2 = if b1 then b2 else (not b2)
//│ eqbool: bool -> bool -> bool
//│       = [Function: eqbool]

// let ignore x = ()
def ignore x = null
//│ ignore: anything -> null
//│       = [Function: ignore]


def listiterA: ('a -> unit) -> List['a] -> unit
//│ listiterA: ('a -> unit) -> List['a] -> unit
//│          = <missing implementation>

// let rec listiter f ll =
//   if ll = [] then ()
//   else begin ignore (f (car ll)) ; listiter f (cdr ll) end
// ;;
rec def listiter f ll =
  if eq ll nil then null
  else
    let _ = ignore (f (head ll)) in 
    listiter f (tail ll)
//│ listiter: ('a -> anything & nothing -> anything) -> (forall 'a, 'b, 'a0, 'c. (List['a | 'a0] -> (null | 'c)
//│   where
//│     'b <: List['a0] -> 'c))
//│         = [Function: listiter]

// FIXME?
listiterA = listiter
//│ ('a -> anything & nothing -> anything) -> (forall 'a, 'b, 'a0, 'c. (List['a | 'a0] -> (null | 'c)
//│   where
//│     'b <: List['a0] -> 'c))
//│   <:  listiterA:
//│ ('a -> unit) -> List['a] -> unit
//│ ╔══[ERROR] Subtyping constraint of the form `forall ?b, ?a, ?c, ?listiter, ?d, ?e, ?f. ?listiter <: forall ?a0. (?a0 -> unit) -> List[?a0] -> unit` exceeded recursion depth limit (400)
//│ ║  l.220: 	listiterA = listiter
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ╟── while constraining:  α434'  <!<  ((α1087',) -> α1089')
//│ ╟── while constraining:  {(α1092' -> α1091') where: α434' <: ((α1087',) -> α1089')}  <!<  ((α1079',) -> α1081')
//│ ╟── while constraining:  ‹∀ 2. {(α440''' -> α439''') where: α434' <: ((α435''',) -> α437''')}›  <!<  ((α1079',) -> α1081')
//│ ╟── while constraining:  α434'  <!<  ((α1079',) -> α1081')
//│ ╟── while constraining:  {(α1084' -> α1083') where: α434' <: ((α1079',) -> α1081')}  <!<  ((α1071',) -> α1073')
//│ ╟── while constraining:  ‹∀ 2. {(α440''' -> α439''') where: α434' <: ((α435''',) -> α437''')}›  <!<  ((α1071',) -> α1073')
//│ ╟── while constraining:  α434'  <!<  ((α1071',) -> α1073')
//│ ╟── while constraining:  {(α1076' -> α1075') where: α434' <: ((α1071',) -> α1073')}  <!<  ((α1063',) -> α1065')
//│ ╟── while constraining:  ‹∀ 2. {(α440''' -> α439''') where: α434' <: ((α435''',) -> α437''')}›  <!<  ((α1063',) -> α1065')
//│ ╟── while constraining:  α434'  <!<  ((α1063',) -> α1065')
//│ ╟── while constraining:  {(α1068' -> α1067') where: α434' <: ((α1063',) -> α1065')}  <!<  ((α1055',) -> α1057')
//│ ╟── while constraining:  ‹∀ 2. {(α440''' -> α439''') where: α434' <: ((α435''',) -> α437''')}›  <!<  ((α1055',) -> α1057')
//│ ╟── while constraining:  α434'  <!<  ((α1055',) -> α1057')
//│ ╟── while constraining:  {(α1060' -> α1059') where: α434' <: ((α1055',) -> α1057')}  <!<  ((α1047',) -> α1049')
//│ ╟── while constraining:  ‹∀ 2. {(α440''' -> α439''') where: α434' <: ((α435''',) -> α437''')}›  <!<  ((α1047',) -> α1049')
//│ ╟── ......
//│ ╟── ......
//│ ╟── while constraining:  α434'  <!<  ((α479',) -> α481')
//│ ╟── while constraining:  {(α484' -> α483') where: α434' <: ((α479',) -> α481')}  <!<  ((α471',) -> α473')
//│ ╟── while constraining:  ‹∀ 2. {(α440''' -> α439''') where: α434' <: ((α435''',) -> α437''')}›  <!<  ((α471',) -> α473')
//│ ╟── while constraining:  α434'  <!<  ((α471',) -> α473')
//│ ╟── while constraining:  {(α476' -> α475') where: α434' <: ((α471',) -> α473')}  <!<  ((α463',) -> α465')
//│ ╟── while constraining:  ‹∀ 2. {(α440''' -> α439''') where: α434' <: ((α435''',) -> α437''')}›  <!<  ((α463',) -> α465')
//│ ╟── while constraining:  α434'  <!<  ((α463',) -> α465')
//│ ╟── while constraining:  {(α468' -> α467') where: α434' <: ((α463',) -> α465')}  <!<  (List[‘a'] -> Unit)
//│ ╟── while constraining:  ‹∀ 2. {(α460''' -> α459''') where: α434' <: ((α455''',) -> α457''')}›  <!<  (List[‘a'] -> Unit)
//│ ╟── while constraining:  (α451' -> ‹∀ 2. {(α460''' -> α459''') where: α434' <: ((α455''',) -> α457''')}›)  <!<  ((‘a' -> Unit) -> (List[‘a'] -> Unit))
//│ ╟── while constraining:  ‹∀ 1. (α425'' -> ‹∀ 2. {(α448''' -> α447''') where: α434' <: ((α443''',) -> α445''')}›)›  <!<  ((‘a' -> Unit) -> (List[‘a'] -> Unit))
//│ ╟── while constraining:  listiter424'  <!<  ((‘a' -> Unit) -> (List[‘a'] -> Unit))
//│ ╟── while constraining:  ‹∀ 0. listiter328'›  <!<  ((‘a' -> Unit) -> (List[‘a'] -> Unit))
//│ ╟── while constraining:  ‹∀ 0. ‹∀ 0. listiter328'››  <!<  ((‘a' -> Unit) -> (List[‘a'] -> Unit))
//│ ╙── while constraining:  ‹∀ 0. ‹∀ 0. listiter328'››  <!<  ‹∀ 0. (('a324' -> Unit) -> (List['a324'] -> Unit))›
//│          = [Function: listiter]



// (* Polymorphic recursion. *)
// untype let rec id x = if true then x else id id x in id

// * Requires polymorphic recursion, so this doesn't work:
:e
rec def id1 x = if true then x else id1 id1 x
//│ ╔══[ERROR] Subtyping constraint of the form `?a -> ?b
//│   where
//│     ?c <: ?a -> ?d <: ?id1` exceeded recursion depth limit (400)
//│ ║  l.270: 	rec def id1 x = if true then x else id1 id1 x
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── while constraining:  ‹∀ 1. {(α1117'' -> α1124'') where: α1122' <: ((α1117'',) -> α1123'')}›  <!<  ((α1229',) -> α1232')
//│ ╟── while constraining:  α1122'  <!<  ((α1229',) -> α1232')
//│ ╟── while constraining:  {(α1229' -> α1231') where: α1122' <: ((α1229',) -> α1232')}  <!<  ((α1225',) -> α1228')
//│ ╟── while constraining:  ‹∀ 1. {(α1117'' -> α1124'') where: α1122' <: ((α1117'',) -> α1123'')}›  <!<  ((α1225',) -> α1228')
//│ ╟── while constraining:  α1122'  <!<  ((α1225',) -> α1228')
//│ ╟── while constraining:  {(α1225' -> α1227') where: α1122' <: ((α1225',) -> α1228')}  <!<  ((α1221',) -> α1224')
//│ ╟── while constraining:  ‹∀ 1. {(α1117'' -> α1124'') where: α1122' <: ((α1117'',) -> α1123'')}›  <!<  ((α1221',) -> α1224')
//│ ╟── while constraining:  α1122'  <!<  ((α1221',) -> α1224')
//│ ╟── while constraining:  {(α1221' -> α1223') where: α1122' <: ((α1221',) -> α1224')}  <!<  ((α1217',) -> α1220')
//│ ╟── while constraining:  ‹∀ 1. {(α1117'' -> α1124'') where: α1122' <: ((α1117'',) -> α1123'')}›  <!<  ((α1217',) -> α1220')
//│ ╟── while constraining:  α1122'  <!<  ((α1217',) -> α1220')
//│ ╟── while constraining:  {(α1217' -> α1219') where: α1122' <: ((α1217',) -> α1220')}  <!<  ((α1213',) -> α1216')
//│ ╟── while constraining:  ‹∀ 1. {(α1117'' -> α1124'') where: α1122' <: ((α1117'',) -> α1123'')}›  <!<  ((α1213',) -> α1216')
//│ ╟── while constraining:  α1122'  <!<  ((α1213',) -> α1216')
//│ ╟── while constraining:  {(α1213' -> α1215') where: α1122' <: ((α1213',) -> α1216')}  <!<  ((α1209',) -> α1212')
//│ ╟── ......
//│ ╟── ......
//│ ╟── while constraining:  α1122'  <!<  ((α1137',) -> α1140')
//│ ╟── while constraining:  {(α1137' -> α1139') where: α1122' <: ((α1137',) -> α1140')}  <!<  ((α1133',) -> α1136')
//│ ╟── while constraining:  ‹∀ 1. {(α1117'' -> α1124'') where: α1122' <: ((α1117'',) -> α1123'')}›  <!<  ((α1133',) -> α1136')
//│ ╟── while constraining:  α1122'  <!<  ((α1133',) -> α1136')
//│ ╟── while constraining:  {(α1133' -> α1135') where: α1122' <: ((α1133',) -> α1136')}  <!<  ((α1129',) -> α1132')
//│ ╟── while constraining:  ‹∀ 1. {(α1117'' -> α1124'') where: α1122' <: ((α1117'',) -> α1123'')}›  <!<  ((α1129',) -> α1132')
//│ ╟── while constraining:  α1122'  <!<  ((α1129',) -> α1132')
//│ ╟── while constraining:  {(α1129' -> α1131') where: α1122' <: ((α1129',) -> α1132')}  <!<  ((α1125',) -> α1128')
//│ ╟── while constraining:  ‹∀ 1. {(α1117'' -> α1124'') where: α1122' <: ((α1117'',) -> α1123'')}›  <!<  ((α1125',) -> α1128')
//│ ╟── while constraining:  ‹∀ 1. {(α1117'' -> α1124'') where: α1122' <: ((α1117'',) -> α1123'')}›  <!<  α1122'
//│ ╟── while constraining:  α1127'  <!<  α1122'
//│ ╟── while constraining:  (α1125' -> α1127')  <!<  ((id11116',) -> α1122')
//│ ╟── while constraining:  {(α1125' -> α1127') where: α1122' <: ((α1125',) -> α1128')}  <!<  ((id11116',) -> α1122')
//│ ╟── while constraining:  ‹∀ 1. {(α1117'' -> α1124'') where: α1122' <: ((α1117'',) -> α1123'')}›  <!<  ((id11116',) -> α1122')
//│ ╙── while constraining:  ‹∀ 1. {(α1117'' -> α1124'') where: α1122' <: ((α1117'',) -> α1123'')}›  <!<  id11116'
//│ id1: ('a & 'b) -> 'b
//│   where
//│     'c <: 'a -> 'b
//│    = [Function: id1]


// let rec (id:sid) x = if true then x else id id x

def id2: Sid
//│ id2: Sid
//│    = <missing implementation>

// * (Note: absence of `rec` emulates annotated rec def.)
def id2 x = if true then x else id2 id2 x
//│ 'a -> 'a
//│   <:  id2:
//│ Sid
//│    = <no result>
//│      id2 is not implemented




// (* Existential types. *)
// (* Creating an encapsulation is explicit (unavoidable). *)
// (* Here, we build (Exist 'a . 'a * ('a -> unit))              *)
// (*        then    (Exist 'a . 'a * 'a * ('a -> 'a -> bool))   *)


// let make_ex1 x (f:['a] ('a * ('a -> 'c)) -> 'b) = f x
def make_ex1 x (f: forall 'a. (('a, 'a -> 'c),) -> 'b) = f x
//│ make_ex1: 'b -> (forall 'b, 'a, 'c, 'd. ((forall 'a0. ('a0, 'a0 -> 'c,) -> 'd) -> 'd
//│   where
//│     'b <: ('a, 'a -> 'c,)))
//│         = [Function: make_ex1]

:ng
ex1_1 = make_ex1 (("A String", print_string))
//│ ex1_1: (forall 'a. ('a, 'a -> 'c,) -> 'b) -> 'b
//│   where
//│     'd <: ('a0, 'a0 -> 'c,)

:ng
ex1_1 (fun ((x, f)) -> f x)

:ng
ex1_2 = if true then make_ex1 ((42, print_int)) else ex1_1
//│ ex1_2: (forall 'a, 'a0. ('a, 'a -> 'c,) -> 'b & ('a0, 'a0 -> 'c0,) -> 'b) -> 'b
//│   where
//│     'd <: ('a1, 'a1 -> 'c,)
//│     'e <: ('a2, 'a2 -> 'c0,)

:ng
ex1_2 (fun ((x, f)) -> f x)


// let make_ex2 x (f:['a] ('a * 'a * ('a -> 'a -> 'c)) -> 'b) = f x
// ;;
def make_ex2 x (f: forall 'a. (('a, 'a, 'a -> 'a -> 'c),) -> 'b) = f x
//│ make_ex2: 'b -> (forall 'b, 'a, 'c, 'd. ((forall 'a0. ('a0, 'a0, 'a0 -> 'a0 -> 'c,) -> 'd) -> 'd
//│   where
//│     'b <: ('a, 'a, 'a -> 'a -> 'c,)))
//│         = [Function: make_ex2]

// let ex_list1 = [ make_ex1 ("A String", print_string) ; 
// 		 make_ex1 (8250, print_int) ;
// 		 make_ex1 (true, print_bool) ]
// ;;
:ng
ex_list1 = cons (make_ex1 (("A String", print_string)))
  (cons (make_ex1 ((8250, print_int)))
  (cons (make_ex1 ((true, print_bool))) nil))
//│ ex_list1: List[forall 'b, 'a, 'c, 'd, 'a0, 'c0, 'e, 'a1, 'c1, 'f. ((forall 'a2, 'a3, 'a4. ('a2, 'a2 -> 'c1,) -> 'f & ('a3, 'a3 -> 'c,) -> 'f & ('a4, 'a4 -> 'c0,) -> 'f) -> 'f
//│   where
//│     'b <: ('a, 'a -> 'c,)
//│     'd <: ('a0, 'a0 -> 'c0,)
//│     'e <: ('a1, 'a1 -> 'c1,))]

// let ex_list2 = [ make_ex2 ("String", "String", eqstring) ;
// 		 make_ex2 ( 1250, 4890, eqint) ;
// 		 make_ex2 ( true, false, eqbool) ]
// ;;
ex_list2 = cons (make_ex2 (("String", "String", eqstring)))
  (cons (make_ex2 ((1250, 4890, eqint)))
  (cons (make_ex2 ((true, false, eqbool))) nil))
//│ ex_list2: List[forall 'b, 'a, 'c, 'd, 'a0, 'c0, 'e, 'a1, 'c1, 'f. ((forall 'a2, 'a3, 'a4. ('a2, 'a2, 'a2 -> 'a2 -> 'c1,) -> 'f & ('a3, 'a3, 'a3 -> 'a3 -> 'c,) -> 'f & ('a4, 'a4, 'a4 -> 'a4 -> 'c0,) -> 'f) -> 'f
//│   where
//│     'b <: ('a, 'a, 'a -> 'a -> 'c,)
//│     'd <: ('a0, 'a0, 'a0 -> 'a0 -> 'c0,)
//│     'e <: ('a1, 'a1, 'a1 -> 'a1 -> 'c1,))]
//│         = Cons {
//│             head: [Function (anonymous)],
//│             tail: Cons {
//│               head: [Function (anonymous)],
//│               tail: Cons { head: [Function (anonymous)], tail: Nil {} }
//│             }
//│           }


:ng
h = head ex_list1
//│ h: (forall 'a, 'a0, 'a1. ('a, 'a -> 'c,) -> 'b & ('a0, 'a0 -> 'c0,) -> 'b & ('a1, 'a1 -> 'c1,) -> 'b) -> 'b
//│   where
//│     'd <: ('a2, 'a2 -> 'c0,)
//│     'e <: ('a3, 'a3 -> 'c1,)
//│     'f <: ('a4, 'a4 -> 'c,)

:ng
h (fun ((x, f)) -> f x)

:ng
test1 = listiterA (fun ex -> ex (fun p -> p._2 p._1)) ex_list1
//│ test1: unit

// let test1 = listiter (fun ex -> ex (fun p -> (snd p) (fst p))) ex_list1
// ;;
// FIXME? probably similar to the `listiterA = listiter` case
:ng
test1 = listiter (fun ex -> ex (fun p -> p._2 p._1)) ex_list1
//│ ╔══[ERROR] Subtyping constraint of the form `?a <: (forall ?c, ?d, ?e, ?f, ?g, ?h, ?i, ?j, ?b, ?b0, ?b1. ?i) -> ?k` exceeded recursion depth limit (400)
//│ ║  l.426: 	test1 = listiter (fun ex -> ex (fun p -> p._2 p._1)) ex_list1
//│ ║         	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── while constraining:  {(α2571' -> α2570') where: α1900' <: ((α2566',) -> α2568')}  <!<  ((α2558',) -> α2560')
//│ ╟── while constraining:  ‹∀ 2. {(α1906''' -> α1905''') where: α1900' <: ((α1901''',) -> α1903''')}›  <!<  ((α2558',) -> α2560')
//│ ╟── while constraining:  α1900'  <!<  ((α2558',) -> α2560')
//│ ╟── while constraining:  {(α2563' -> α2562') where: α1900' <: ((α2558',) -> α2560')}  <!<  ((α2550',) -> α2552')
//│ ╟── while constraining:  ‹∀ 2. {(α1906''' -> α1905''') where: α1900' <: ((α1901''',) -> α1903''')}›  <!<  ((α2550',) -> α2552')
//│ ╟── while constraining:  α1900'  <!<  ((α2550',) -> α2552')
//│ ╟── while constraining:  {(α2555' -> α2554') where: α1900' <: ((α2550',) -> α2552')}  <!<  ((α2542',) -> α2544')
//│ ╟── while constraining:  ‹∀ 2. {(α1906''' -> α1905''') where: α1900' <: ((α1901''',) -> α1903''')}›  <!<  ((α2542',) -> α2544')
//│ ╟── while constraining:  α1900'  <!<  ((α2542',) -> α2544')
//│ ╟── while constraining:  {(α2547' -> α2546') where: α1900' <: ((α2542',) -> α2544')}  <!<  ((α2534',) -> α2536')
//│ ╟── while constraining:  ‹∀ 2. {(α1906''' -> α1905''') where: α1900' <: ((α1901''',) -> α1903''')}›  <!<  ((α2534',) -> α2536')
//│ ╟── while constraining:  α1900'  <!<  ((α2534',) -> α2536')
//│ ╟── while constraining:  {(α2539' -> α2538') where: α1900' <: ((α2534',) -> α2536')}  <!<  ((α2526',) -> α2528')
//│ ╟── while constraining:  ‹∀ 2. {(α1906''' -> α1905''') where: α1900' <: ((α1901''',) -> α1903''')}›  <!<  ((α2526',) -> α2528')
//│ ╟── while constraining:  α1900'  <!<  ((α2526',) -> α2528')
//│ ╟── ......
//│ ╟── ......
//│ ╟── while constraining:  {(α1971' -> α1970') where: α1900' <: ((α1966',) -> α1968')}  <!<  ((α1958',) -> α1960')
//│ ╟── while constraining:  ‹∀ 2. {(α1906''' -> α1905''') where: α1900' <: ((α1901''',) -> α1903''')}›  <!<  ((α1958',) -> α1960')
//│ ╟── while constraining:  α1900'  <!<  ((α1958',) -> α1960')
//│ ╟── while constraining:  {(α1963' -> α1962') where: α1900' <: ((α1958',) -> α1960')}  <!<  ((α1950',) -> α1952')
//│ ╟── while constraining:  ‹∀ 2. {(α1906''' -> α1905''') where: α1900' <: ((α1901''',) -> α1903''')}›  <!<  ((α1950',) -> α1952')
//│ ╟── while constraining:  α1900'  <!<  ((α1950',) -> α1952')
//│ ╟── while constraining:  {(α1955' -> α1954') where: α1900' <: ((α1950',) -> α1952')}  <!<  ((α1942',) -> α1944')
//│ ╟── while constraining:  ‹∀ 2. {(α1906''' -> α1905''') where: α1900' <: ((α1901''',) -> α1903''')}›  <!<  ((α1942',) -> α1944')
//│ ╟── while constraining:  α1900'  <!<  ((α1942',) -> α1944')
//│ ╟── while constraining:  {(α1947' -> α1946') where: α1900' <: ((α1942',) -> α1944')}  <!<  ((α1934',) -> α1936')
//│ ╟── while constraining:  ‹∀ 2. {(α1906''' -> α1905''') where: α1900' <: ((α1901''',) -> α1903''')}›  <!<  ((α1934',) -> α1936')
//│ ╟── while constraining:  α1900'  <!<  ((α1934',) -> α1936')
//│ ╟── while constraining:  {(α1939' -> α1938') where: α1900' <: ((α1934',) -> α1936')}  <!<  ((‹∀ 0. α1550'›,) -> α1933')
//│ ╟── while constraining:  ‹∀ 2. {(α1926''' -> α1925''') where: α1900' <: ((α1921''',) -> α1923''')}›  <!<  ((‹∀ 0. α1550'›,) -> α1933')
//│ ╙── while constraining:  α1889'  <!<  ((‹∀ 0. α1550'›,) -> α1933')
//│ test1: error

test1_ = listiter (fun ex -> ex (fun p -> p._2 p._1))
//│ test1_: List['a | (forall 'b, 'c. {_1: 'b, _2: 'b -> 'c} -> 'c) -> anything] -> (null | 'd)
//│   where
//│     'e <: List['a] -> 'd
//│       = [Function (anonymous)]

// * Also fails (expected):
// test1_ ex_list1

process ex = ex (fun p -> p._2 p._1)
//│ process: ((forall 'a, 'b. {_1: 'a, _2: 'a -> 'b} -> 'b) -> 'c) -> 'c
//│        = [Function: process]

:ng
process h

// * Also fails:
// listiter process ex_list1


// let test2 = listiter (fun ex -> ex (fun t -> 
//   let arg1 = fst t
//   and arg2 = fst (snd t)
//   and eqf  = snd (snd t) in
//   let areequal = eqf arg1 arg2
//   in print_bool areequal )) ex_list2
// ;;
:ng
test2 = listiterA (fun ex -> ex (fun t ->
  let arg1 = t._1 in
  let arg2 = t._2 in
  let eqf = t._3 in
  let areequal = eqf arg1 arg2 in
  print_bool areequal )) ex_list2
//│ test2: unit

:ng
test2_ = listiter (fun ex -> ex (fun t ->
  let arg1 = t._1 in
  let arg2 = t._2 in
  let eqf = t._3 in
  let areequal = eqf arg1 arg2 in
  print_bool areequal ))
//│ test2_: List['a | (forall 'b, 'c. {_1: 'b, _2: 'c, _3: 'b -> 'c -> bool} -> unit) -> anything] -> (null | 'd)
//│   where
//│     'e <: List['a] -> 'd

// * Also fails:
// test2_ ex_list2


// * ============ Annotated+untupled versions: ============

def make_ex1: ('x, 'x -> 'c) -> (forall 'b. (forall 'a. ('a, 'a -> 'c) -> 'b) -> 'b)
//│ make_ex1: ('x, 'x -> 'c,) -> (forall 'b. (forall 'a. ('a, 'a -> 'c,) -> 'b) -> 'b)
//│         = <missing implementation>

ex1_1 = make_ex1 ("A String", print_string)
//│ ex1_1: (forall 'a. ('a, 'a -> unit,) -> 'b) -> 'b
//│      = <no result>
//│        make_ex1 is not implemented

ex1_1 (fun (x, f) -> f x)
//│ = <no result>
//│   ex1_1 and make_ex1 are not implemented

ex1_2 = if true then make_ex1 (42, print_int) else ex1_1
//│ ex1_2: (forall 'a, 'a0. ('a, 'a -> unit,) -> 'b & ('a0, 'a0 -> unit,) -> 'b) -> 'b
//│      = <no result>
//│        make_ex1 is not implemented

ex1_2 (fun (x, f) -> f x)
//│ = <no result>
//│   ex1_2 and make_ex1 are not implemented


// let make_ex2 x (f:['a] ('a * 'a * ('a -> 'a -> 'c)) -> 'b) = f x
// ;;
def make_ex2: ('x, 'x, 'x -> 'c) -> (forall 'b. (forall 'a. ('a, 'a, 'a -> 'c) -> 'b) -> 'b)
//│ make_ex2: ('x, 'x, 'x -> 'c,) -> (forall 'b. (forall 'a. ('a, 'a, 'a -> 'c,) -> 'b) -> 'b)
//│         = <missing implementation>

// let ex_list1 = [ make_ex1 ("A String", print_string) ; 
// 		 make_ex1 (8250, print_int) ;
// 		 make_ex1 (true, print_bool) ]
// ;;
// :ng
ex_list1 = cons (make_ex1 ("A String", print_string))
  (cons (make_ex1 (8250, print_int))
  (cons (make_ex1 (true, print_bool)) nil))
//│ ex_list1: List[(forall 'a, 'a0, 'a1. ('a, 'a -> unit,) -> 'b & ('a0, 'a0 -> unit,) -> 'b & ('a1, 'a1 -> unit,) -> 'b) -> 'b]
//│         = <no result>
//│           make_ex1 is not implemented

// let ex_list2 = [ make_ex2 ("String", "String", eqstring) ;
// 		 make_ex2 ( 1250, 4890, eqint) ;
// 		 make_ex2 ( true, false, eqbool) ]
// ;;
ex_list2 = cons (make_ex2 ("String", "String", eqstring))
  (cons (make_ex2 (1250, 4890, eqint))
  (cons (make_ex2 (true, false, eqbool)) nil))
//│ ex_list2: List[(forall 'a, 'a0, 'a1. ('a, 'a, 'a -> string -> bool,) -> 'b & ('a0, 'a0, 'a0 -> int -> bool,) -> 'b & ('a1, 'a1, 'a1 -> bool -> bool,) -> 'b) -> 'b]
//│         = <no result>
//│           make_ex2 is not implemented

// let test1 = listiter (fun ex -> ex (fun p -> (snd p) (fst p))) ex_list1
// ;;
:ng
test1 = listiterA (fun ex -> ex (fun (a, b) -> b a)) ex_list1
//│ test1: unit

// * Still fail:
// test1_ ex_list1
// test2_ ex_list2





// (* Some examples for MLF inspired by standard encoding in System F. *)

// type Void   = ['x] 'x
// type Unit   = ['x] 'x -> 'x
// type Int    = ['x] ('x -> 'x) -> ('x -> 'x)
// type Bool   = ['x] (Unit -> 'x) -> (Unit -> 'x) -> 'x 
type Fvoid = forall 'a. 'a
type Funit = forall 'a. 'a -> 'a
type Fint  = forall 'a. ('a -> 'a) -> ('a -> 'a)
type Fbool = forall 'a. (Funit -> 'a) -> (Funit -> 'a) -> 'a
//│ Defined type alias Fvoid
//│ Defined type alias Funit
//│ Defined type alias Fint
//│ Defined type alias Fbool

// type Sum    = ['x] (Int -> 'x) -> (Int -> 'x) -> 'x
// type Pair   = ['x] (Int -> Int -> 'x) -> 'x
// type Triple = ['x] (Int -> Int -> Int -> 'x) -> 'x
type Sum    = forall 'a. (Fint -> 'a) -> (Fint -> 'a) -> 'a
type Pair   = forall 'a. (Fint -> Fint -> 'a) -> 'a
type Triple = forall 'a. (Fint -> Fint -> Fint -> 'a) -> 'a
//│ Defined type alias Sum
//│ Defined type alias Pair
//│ Defined type alias Triple

// (* Unit *)
// let c_unit = fun x -> x
def c_unit = fun x -> x
//│ c_unit: 'a -> 'a
//│       = [Function: c_unit]


// (* BOOLEANS, IFS, AND, OR, NOT. *)
// let c_true  = fun a b -> a c_unit
def c_true = fun a -> fun b -> a c_unit
//│ c_true: 'a -> (forall 'a. ('a -> 'b
//│   where
//│     'a <: (forall 'c. 'c -> 'c) -> 'b))
//│       = [Function: c_true]

// let c_false = fun a b -> b c_unit
def c_false = fun a -> fun b -> b c_unit
//│ c_false: anything -> ((forall 'a. 'a -> 'a) -> 'b) -> 'b
//│        = [Function: c_false]

// let c_if (cond:Bool) c_then c_else = cond c_then c_else 
def c_if (cond: Fbool) c_then c_else = cond c_then c_else
def c_if' cond c_then c_else = cond c_then c_else
//│ c_if: Fbool -> (forall 'a. 'a -> (forall 'a, 'b, 'c, 'd. ('c -> 'd
//│   where
//│     'b <: 'a -> 'c -> 'd)))
//│     = [Function: c_if]
//│ c_if': 'a -> (forall 'b. 'b -> (forall 'a, 'b, 'c, 'd. ('c -> 'd
//│   where
//│     'a <: 'b -> 'c -> 'd)))
//│      = [Function: c_if]

// let c_and (a:Bool) (b:Bool) = c_if a (fun z -> b) (fun z -> c_false)
def c_and (a: Fbool) (b: Fbool) = c_if a (fun z -> b) (fun z -> c_false)
def c_and' a b = c_if a (fun z -> b) (fun z -> c_false)
//│ c_and: Fbool -> Fbool -> (anything -> ((forall 'a. 'a -> 'a) -> 'b) -> 'b | Fbool)
//│      = [Function: c_and]
//│ c_and': Fbool -> (forall 'a. 'a -> (anything -> ((forall 'b. 'b -> 'b) -> 'c) -> 'c | 'a))
//│       = [Function: c_and]

// let c_or  (a:Bool) (b:Bool) = c_if a (fun z -> c_true) (fun z -> b)
def c_or (a: Fbool) (b: Fbool) = c_if a (fun z -> c_true) (fun z -> b)
def c_or' a b = c_if a (fun z -> c_true) (fun z -> b)
//│ c_or: Fbool -> Fbool -> (forall 'a. 'a -> (forall 'a. ('a -> 'b
//│   where
//│     'a <: (forall 'c. 'c -> 'c) -> 'b)) | Fbool)
//│     = [Function: c_or]
//│ c_or': Fbool -> (forall 'a. 'a -> (forall 'b. 'b -> (forall 'b. ('b -> 'c
//│   where
//│     'b <: (forall 'd. 'd -> 'd) -> 'c)) | 'a))
//│      = [Function: c_or]

// let c_not (a:Bool) = c_if a (fun z -> c_false) (fun z -> c_true)
def c_not (a: Fbool) = c_if a (fun z -> c_false) (fun z -> c_true)
def c_not' a = c_if a (fun z -> c_false) (fun z -> c_true)
//│ c_not: Fbool -> (forall 'a. 'a -> (forall 'a. (((forall 'b. 'b -> 'b) -> 'c) -> 'c
//│   where
//│     'a <: (forall 'b. 'b -> 'b) -> 'c)))
//│      = [Function: c_not]
//│ c_not': Fbool -> (forall 'a. 'a -> (forall 'a. (((forall 'b. 'b -> 'b) -> 'c) -> 'c
//│   where
//│     'a <: (forall 'b. 'b -> 'b) -> 'c)))
//│       = [Function: c_not]

// let c_or = (c_or : Bool -> Bool -> Bool)
def c_or2 = c_or : Fbool -> Fbool -> Fbool
def c_or2' = c_or' : Fbool -> Fbool -> Fbool
//│ c_or2: Fbool -> Fbool -> Fbool
//│      = [Function: c_or]
//│ c_or2': Fbool -> Fbool -> Fbool
//│       = [Function: c_or]


// (* CONSTRUCTORS FOR PAIRS ET TRIPLES. *)
// let c_pair x y   = fun f -> f x y
def c_pair x y = fun f -> f x y
//│ c_pair: 'a -> (forall 'b. 'b -> (forall 'c. ('a -> 'b -> 'c) -> 'c))
//│       = [Function: c_pair]

// let c_trip x y z = fun f -> f x y z
def c_trip x y z = fun f -> f x y z
//│ c_trip: 'a -> (forall 'b. 'b -> (forall 'c. 'c -> (forall 'd. ('a -> 'b -> 'c -> 'd) -> 'd)))
//│       = [Function: c_trip]


// (* PROJECTIONS FOR PRODUCTS. *)
// let c_1_2 (p:Pair) = p (fun x y -> x) 
def c_1_2 (p: Pair) = p (fun x -> fun y -> x)
def c_1_2' p = p (fun x -> fun y -> x)
//│ c_1_2: Pair -> Fint
//│      = [Function: c_1_2]
//│ c_1_2': ((forall 'a. 'a -> anything -> 'a) -> 'b) -> 'b
//│       = [Function: c_1_2]

// let c_2_2 (p:Pair) = p (fun x y -> y) 
def c_2_2 (t: Pair) = t (fun x -> fun y -> y)
def c_2_2' t = t (fun x -> fun y -> y)
//│ c_2_2: Pair -> Fint
//│      = [Function: c_2_2]
//│ c_2_2': ((anything -> (forall 'a. 'a -> 'a)) -> 'b) -> 'b
//│       = [Function: c_2_2]

// let c_1_3 (t:Triple) = t (fun x y z -> x)
def c_1_3 (t: Triple) = t (fun x -> fun y -> fun z -> x)
def c_1_3' t = t (fun x -> fun y -> fun z -> x)
//│ c_1_3: Triple -> Fint
//│      = [Function: c_1_3]
//│ c_1_3': ((forall 'a. 'a -> anything -> anything -> 'a) -> 'b) -> 'b
//│       = [Function: c_1_3]

// let c_2_3 (t:Triple) = t (fun x y z -> y) 
def c_2_3 (t: Triple) = t (fun x -> fun y -> fun z -> y)
def c_2_3' t = t (fun x -> fun y -> fun z -> y)
//│ c_2_3: Triple -> Fint
//│      = [Function: c_2_3]
//│ c_2_3': ((anything -> (forall 'a. 'a -> anything -> 'a)) -> 'b) -> 'b
//│       = [Function: c_2_3]

// let c_3_3 (t:Triple) = t (fun x y z -> z) 
def c_3_3 (t: Triple) = t (fun x -> fun y -> fun z -> z)
def c_3_3' t = t (fun x -> fun y -> fun z -> z)
//│ c_3_3: Triple -> Fint
//│      = [Function: c_3_3]
//│ c_3_3': ((anything -> anything -> (forall 'a. 'a -> 'a)) -> 'b) -> 'b
//│       = [Function: c_3_3]


// (* CONSTRUCTOR FOR A BINARY SUM. *)
// let c_sumg = fun x fg fd -> fg x
def c_sumg = fun x -> fun fg -> fun fd -> fg x
//│ c_sumg: 'a -> (forall 'b. 'b -> (forall 'a, 'b, 'c. ('b -> 'c
//│   where
//│     'b <: 'a -> 'c)))
//│       = [Function: c_sumg]

// let c_sumd = fun x fg fd -> fd x
def c_sumd = fun x -> fun fg -> fun fd -> fd x
//│ c_sumd: 'a -> anything -> (forall 'b. ('a -> 'b) -> 'b)
//│       = [Function: c_sumd]


// (* CASE FOR A SUM. *)
// let c_case (s:Sum) g d = s g d
def c_case (s: Sum) g d = s g d
def c_case' s g d = s g d
//│ c_case: Sum -> (forall 'a. 'a -> (forall 'a, 'b, 'c, 'd. ('c -> 'd
//│   where
//│     'b <: 'a -> 'c -> 'd)))
//│       = [Function: c_case]
//│ c_case': 'a -> (forall 'b. 'b -> (forall 'a, 'b, 'c, 'd. ('c -> 'd
//│   where
//│     'a <: 'b -> 'c -> 'd)))
//│        = [Function: c_case]


// (* Integers. *)
// let c_i0 = fun f x ->   x
def c_i0 = fun f -> fun x -> x
//│ c_i0: anything -> (forall 'a. 'a -> 'a)
//│     = [Function: c_i0]

// let c_i1 = fun f x -> f x
def c_i1 = fun f -> fun x -> f x
//│ c_i1: 'a -> (forall 'a, 'b, 'c. ('b -> 'c
//│   where
//│     'a <: 'b -> 'c))
//│     = [Function: c_i1]

// let c_i2 = fun f x -> f (f x)
def c_i2 = fun f -> fun x -> f (f x)
//│ c_i2: 'a -> (forall 'a, 'b, 'c, 'd. ('b -> 'd
//│   where
//│     'a <: 'b -> 'c & 'c -> 'd))
//│     = [Function: c_i2]

// let c_succ (n:Int) = fun f x -> n f (f x)
def c_succ (n: Fint) = fun f -> fun x -> n f (f x)
def c_succ' n = fun f -> fun x -> n f (f x)
//│ c_succ: Fint -> (forall 'a. 'a -> (forall 'a, 'b, 'c, 'd, 'e. ('e -> 'd
//│   where
//│     'b <: 'a -> 'c -> 'd
//│     'a <: 'e -> 'c)))
//│       = [Function: c_succ]
//│ c_succ': 'a -> (forall 'b. 'b -> (forall 'a, 'b, 'c, 'd, 'e. ('e -> 'd
//│   where
//│     'a <: 'b -> 'c -> 'd
//│     'b <: 'e -> 'c)))
//│        = [Function: c_succ]

// let c_iszero (n:Int) = n (fun x -> c_false) c_true
def c_iszero (n: Fint) = n (fun x -> c_false) c_true
def c_iszero' n = n (fun x -> c_false) c_true
//│ c_iszero: Fint -> (forall 'a. 'a -> (forall 'a. (((forall 'b. 'b -> 'b) -> 'c) -> 'c
//│   where
//│     'a <: (forall 'b. 'b -> 'b) -> 'c)))
//│         = [Function: c_iszero]
//│ c_iszero': (('a -> 'a -> ((forall 'b. 'b -> 'b) -> 'c) -> 'c) -> (forall 'a. 'a -> (forall 'a. ('a -> 'd
//│   where
//│     'a <: (forall 'b. 'b -> 'b) -> 'd))) -> 'e) -> 'e
//│          = [Function: c_iszero]

// let c_add n (m:Int) = m c_succ n
def c_add n (m: Fint) = m c_succ n
def c_add' n m = m c_succ' n
//│ c_add: (Fint & 'a) -> Fint -> (forall 'b. 'b -> (forall 'b, 'c, 'd, 'e, 'f. ('f -> 'e
//│   where
//│     'c <: 'b -> 'd -> 'e
//│     'b <: 'f -> 'd)) | 'a)
//│      = [Function: c_add]
//│ c_add': 'a -> ((forall 'b. 'b -> (forall 'c. 'c -> (forall 'b, 'c, 'd, 'e, 'f. ('f -> 'e
//│   where
//│     'b <: 'c -> 'd -> 'e
//│     'c <: 'f -> 'd)))) -> 'a -> 'g) -> 'g
//│       = [Function: c_add]

// let c_mul n (m:Int) = m (c_add n) c_i0
def c_mul m (n: Fint) = m (c_add n) c_i0
def c_mul' m n = m (c_add' n) c_i0
//│ c_mul: 'a -> (forall 'a. (Fint -> 'b
//│   where
//│     'a <: (Fint -> (forall 'c. 'c -> (forall 'c, 'd, 'e, 'f, 'g. ('g -> 'f
//│   where
//│     'd <: 'c -> 'e -> 'f
//│     'c <: 'g -> 'e)) | Fint)) -> ('a -> (forall 'h. 'h -> 'h)) -> 'b))
//│      = [Function: c_mul]
//│ c_mul': 'a -> (forall 'a. ('b -> 'c
//│   where
//│     'a <: (((forall 'd. 'd -> (forall 'e. 'e -> (forall 'd, 'e, 'f, 'g, 'h. ('h -> 'g
//│   where
//│     'd <: 'e -> 'f -> 'g
//│     'e <: 'h -> 'f)))) -> 'b -> 'i) -> 'i) -> ('d -> (forall 'j. 'j -> 'j)) -> 'c))
//│       = [Function: c_mul]

// let c_pow n (m:Int) = m (c_mul n) c_i1
def c_pow m (n: Fint) = m (c_mul n) c_i1
def c_pow' m n = m (c_mul' n) c_i1
//│ c_pow: 'a -> (forall 'a. (Fint -> 'b
//│   where
//│     'a <: (forall 'c. (Fint -> 'd
//│   where
//│     'c <: (Fint -> (forall 'e. 'e -> (forall 'e, 'f, 'g, 'h, 'i. ('i -> 'h
//│   where
//│     'f <: 'e -> 'g -> 'h
//│     'e <: 'i -> 'g)) | Fint)) -> ('j -> (forall 'k. 'k -> 'k)) -> 'd)) -> (forall 'j. 'j -> (forall 'j, 'l, 'm. ('l -> 'm
//│   where
//│     'j <: 'l -> 'm))) -> 'b))
//│      = [Function: c_pow]
//│ c_pow': 'a -> (forall 'a. ('b -> 'c
//│   where
//│     'a <: (forall 'b. ('d -> 'e
//│   where
//│     'b <: (((forall 'f. 'f -> (forall 'g. 'g -> (forall 'f, 'g, 'h, 'i, 'j. ('j -> 'i
//│   where
//│     'f <: 'g -> 'h -> 'i
//│     'g <: 'j -> 'h)))) -> nothing -> 'k) -> 'k) -> ('d -> (forall 'l. 'l -> 'l)) -> 'e)) -> (forall 'd. 'd -> (forall 'd, 'm, 'n. ('m -> 'n
//│   where
//│     'd <: 'm -> 'n))) -> 'c))
//│       = [Function: c_pow]


// let c_pred (n:Int) =
//    let s p = c_pair (c_2_2 p) (c_succ (c_2_2 p))
//   and z = c_pair c_i0 c_i0 in
//   c_1_2 (n s z)
def c_pred (n: Fint) =
  let s = fun p -> c_pair (c_2_2 p) (c_succ (c_2_2 p)) in
  let z = c_pair c_i0 c_i0 in
  c_1_2 (n s z)
def c_pred' n =
  let s = fun p -> c_pair (c_2_2' p) (c_succ' (c_2_2' p)) in
  let z = c_pair c_i0 c_i0 in
  c_1_2' (n s z)
//│ c_pred: Fint -> Fint
//│       = [Function: c_pred]
//│ c_pred': ((forall 'a. (('a -> (forall 'b. 'b -> 'b)) -> 'a) -> (nothing -> (forall 'c. 'c -> (forall 'a, 'c, 'd, 'e, 'f. ('f -> 'e
//│   where
//│     'a <: 'c -> 'd -> 'e
//│     'c <: 'f -> 'd))) -> 'g) -> 'g) -> (forall 'a. (('a -> (forall 'h. 'h -> 'h)) -> ('a -> (forall 'h. 'h -> 'h)) -> 'i) -> 'i) -> (forall 'a, 'j. 'j -> 'a -> 'j) -> 'k) -> 'k
//│        = [Function: c_pred]


// let c_printint (n:Int) = print_int (n (fun x -> x+1) 0); print " "
:ng
def c_printint (n: Fint) =
  let _ = print_int (n (fun x -> x + 1) 0) in
  print_string " "
def c_printint' n =
  let _ = print_int (n (fun x -> x + 1) 0) in
  print_string " "
//│ c_printint: Fint -> unit
//│ c_printint': ((int -> int) -> 0 -> int) -> unit

def c_printint2 (n: Fint) = toString (n (fun x -> x + 1) 0)
def c_printint2' n = toString (n (fun x -> x + 1) 0)
//│ c_printint2: Fint -> string
//│            = [Function: c_printint2]
//│ c_printint2': ((int -> int) -> 0 -> anything) -> string
//│             = [Function: c_printint2]

// let c_i2 = c_succ c_i1
def c_i2 = c_succ c_i1
def c_i2' = c_succ' c_i1
//│ c_i2: 'a -> (forall 'a, 'b, 'c, 'd, 'e. ('e -> 'd
//│   where
//│     'b <: 'a -> 'c -> 'd
//│     'a <: 'e -> 'c))
//│     = [Function (anonymous)]
//│ c_i2': 'a -> (forall 'a, 'b, 'c, 'd, 'e. ('e -> 'd
//│   where
//│     'b <: 'a -> 'c -> 'd
//│     'a <: 'e -> 'c))
//│      = [Function (anonymous)]

// let c_i3 = c_succ c_i2
def c_i3 = c_succ c_i2
def c_i3' = c_succ' c_i2
//│ c_i3: 'a -> (forall 'a, 'b, 'c, 'd, 'e. ('e -> 'd
//│   where
//│     'b <: 'a -> 'c -> 'd
//│     'a <: 'e -> 'c))
//│     = [Function (anonymous)]
//│ c_i3': 'a -> (forall 'a, 'b, 'c, 'd, 'e. ('e -> 'd
//│   where
//│     'b <: 'a -> 'c -> 'd
//│     'a <: 'e -> 'c))
//│      = [Function (anonymous)]

// let c_i4 = c_succ c_i3
def c_i4 = c_succ c_i3
def c_i4' = c_succ' c_i3
//│ c_i4: 'a -> (forall 'a, 'b, 'c, 'd, 'e. ('e -> 'd
//│   where
//│     'b <: 'a -> 'c -> 'd
//│     'a <: 'e -> 'c))
//│     = [Function (anonymous)]
//│ c_i4': 'a -> (forall 'a, 'b, 'c, 'd, 'e. ('e -> 'd
//│   where
//│     'b <: 'a -> 'c -> 'd
//│     'a <: 'e -> 'c))
//│      = [Function (anonymous)]


// (* Fails with value restriction. *)
// (* Passes with relaxed value restriction. *)
// let rec (to_church:int -> Int) n =
//   if n = 0 then fun f x -> x
//   else fun f x -> f ((to_church (n-1)) f x)
def to_church: int -> Fint
//│ to_church: int -> Fint
//│          = <missing implementation>

// * See to_church_3 in `ex_casparticuliers.mls`
rec def to_church n =
  if n == 0 then fun f -> fun x -> x
  else fun f -> fun x -> f ((to_church (n - 1) : Fint) f x)
//│ int -> (forall 'b. 'b -> (forall 'b, 'a, 'c. (('c & 'a) -> 'c
//│   where
//│     'b <: 'a -> 'a & 'a -> 'c)))
//│   <:  to_church:
//│ int -> Fint
//│          = [Function: to_church]


// let rec to_church n =
//   if n = 0 then fun f x -> x
//   else fun f x -> f ((to_church (n-1)) f x)
rec def to_church' n =
  if n == 0 then fun f -> fun x -> x
  else fun f -> fun x -> f ((to_church (n - 1)) f x)
//│ to_church': int -> (forall 'b. 'b -> (forall 'b, 'a, 'c. (('c & 'a) -> 'c
//│   where
//│     'b <: 'a -> 'a & 'a -> 'c)))
//│           = [Function: to_church]


// let rec c_fact (n:Int) =
//   c_if (c_iszero n) (fun (u:Unit) -> c_i1)
//     (fun (u:Unit) -> c_mul n (c_fact (c_pred n)))
rec def c_fact (n: Fint) =
  c_if (c_iszero n) (fun (u: Funit) -> c_i1)
    (fun (u: Funit) -> c_mul n (c_fact (c_pred n)))
rec def c_fact' n =
  c_if' (c_iszero' n) (fun _ -> c_i1)
    (fun _ -> c_mul' n (c_fact' (c_pred' n)))
//│ c_fact: Fint -> (forall 'a, 'b. ('a & 'b) -> (forall 'a, 'b, 'c, 'd, 'e, 'f, 'g, 'h. (('c & 'h) -> ('d | 'g | 'c)
//│   where
//│     'a <: 'c -> 'd
//│     'e <: 'b -> 'f -> 'g
//│     'b <: 'h -> 'f)) | Fint)
//│       = [Function: c_fact]
//│ c_fact': (('a -> 'a -> ((forall 'b. 'b -> 'b) -> 'c) -> 'c) -> (forall 'd. 'd -> (forall 'd. ('a -> 'e
//│   where
//│     'd <: (forall 'b. 'b -> 'b) -> 'e))) -> ('a -> (forall 'f. 'f -> (forall 'f, 'g, 'h. ('g -> 'h
//│   where
//│     'f <: 'g -> 'h)))) -> (forall 'a, 'i, 'j. ('a -> 'k
//│   where
//│     'i <: ((('a -> (forall 'l. 'l -> 'l)) -> 'm & ('a -> (forall 'l. 'l -> 'l)) -> 'a) -> (nothing -> (forall 'n. 'n -> (forall 'm, 'n, 'o, 'p, 'q. ('q -> 'p
//│   where
//│     'm <: 'n -> 'o -> 'p
//│     'n <: 'q -> 'o))) -> 'r) -> 'r) -> ((('a -> (forall 's. 's -> 's)) -> ('a -> (forall 's. 's -> 's)) -> 't) -> 't) -> (forall 'u. 'u -> 'a -> 'u) -> 'j & (((forall 'a. 'a -> (forall 'v. 'v -> (forall 'a, 'v, 'w, 'x, 'y. ('y -> 'x
//│   where
//│     'a <: 'v -> 'w -> 'x
//│     'v <: 'y -> 'w)))) -> nothing -> 'z) -> 'z) -> ('a -> (forall 's. 's -> 's)) -> 'k)) -> 'a1 & 'i) -> 'a1
//│   where
//│     'j <: ('a -> 'a -> ((forall 'b. 'b -> 'b) -> 'c) -> 'c) -> (forall 'd. 'd -> (forall 'd. ('a -> 'e
//│   where
//│     'd <: (forall 'b. 'b -> 'b) -> 'e))) -> ('a -> (forall 'f. 'f -> (forall 'f, 'g, 'h. ('g -> 'h
//│   where
//│     'f <: 'g -> 'h)))) -> (forall 'a, 'j. ('a -> 'b1
//│   where
//│     'j <: ((('a -> (forall 'l. 'l -> 'l)) -> 'm & ('a -> (forall 'l. 'l -> 'l)) -> 'a) -> (nothing -> (forall 'n. 'n -> (forall 'm, 'n, 'o, 'p, 'q. ('q -> 'p
//│   where
//│     'm <: 'n -> 'o -> 'p
//│     'n <: 'q -> 'o))) -> 'r) -> 'r) -> ((('a -> (forall 's. 's -> 's)) -> ('a -> (forall 's. 's -> 's)) -> 't) -> 't) -> (forall 'u. 'u -> 'a -> 'u) -> 'j & (((forall 'a. 'a -> (forall 'v. 'v -> (forall 'a, 'v, 'w, 'x, 'y. ('y -> 'x
//│   where
//│     'a <: 'v -> 'w -> 'x
//│     'v <: 'y -> 'w)))) -> nothing -> 'z) -> 'z) -> ('a -> (forall 's. 's -> 's)) -> 'b1)) -> 'a
//│        = [Function: c_fact]


// let print_fact n =
//   print_string "Factorial " ;
//   print_int n ;
//   print_string " = " ;
//   c_printint (c_fact (to_church n)) ;
//   print_string "\n" ;
//   ()
:ng
def print_fact n =
  let _ = print_string "Factorial " in
  let _ = print_int n in
  let _ = print_string " = " in
  let _ = c_printint (c_fact (to_church n)) in
          print_string "\n"
def print_fact' n =
  let _ = print_string "Factorial " in
  let _ = print_int n in
  let _ = print_string " = " in
  let _ = c_printint' (c_fact' (to_church' n)) in
          print_string "\n"
//│ print_fact: int -> unit
//│ print_fact': int -> unit

def print_fact2 n =
  concat "Factorial " (
  concat (toString n) (
  concat " = "
         (c_printint2 (c_fact (to_church n))) ))
def print_fact2' n =
  concat "Factorial " (
  concat (toString n) (
  concat " = "
         (c_printint2' (c_fact' (to_church' n))) ))
//│ print_fact2: int -> string
//│            = [Function: print_fact2]
//│ print_fact2': int -> string
//│             = [Function: print_fact2]

// let essai =
//   print_string "Church integers :\n";
//   let c_i5 = c_add c_i3 c_i2 in
//   let c_i10 = c_mul c_i5 c_i2 in
//   let c_i9 = c_pred c_i10 in
//   let c_99 = c_add (c_mul c_i9 c_i10) c_i9 in
//   let c_98 = c_pred c_99 in
//   print_string "This should be 98 : " ;
//   c_printint c_98;
//   print_string "\n\n" ;
this_should_be_98 =
  let c_i5 = c_add c_i3 c_i2 in
  let c_i10 = c_mul c_i5 c_i2 in
  let c_i9 = c_pred c_i10 in
  let c_99 = c_add (c_mul c_i9 c_i10) c_i9 in
  let c_98 = c_pred c_99 in
  c_printint2 c_98
//│ this_should_be_98: string
//│                  = '98'

// FIXME?
this_should_be_98' =
  let c_i5' = c_add' c_i3' c_i2 in
  let c_i10' = c_mul' c_i5' c_i2 in
  let c_i9' = c_pred' c_i10' in
  let c_99' = c_add' (c_mul' c_i9' c_i10') c_i9' in
  let c_98' = c_pred' c_99' in
  c_printint2' c_98'
//│ ╔══[ERROR] Subtyping constraint of the form `?a <: (forall ?b, ?c. ?c) -> ?d` exceeded recursion depth limit (400)
//│ ║  l.1089: 	  let c_i10' = c_mul' c_i5' c_i2 in
//│ ║          	               ^^^^^^^^^^^^^^^^^
//│ ╟── while constraining:  ‹∀ 2. (α3957''' -> α3959''')›  <!<  ('a7153'' -> 'a7153'')
//│ ╟── while constraining:  α7144''  <!<  ('a7153'' -> 'a7153'')
//│ ╟── while constraining:  (α7144'',)  <!<  (('a7153'' -> 'a7153''),)
//│ ╟── while constraining:  (('a7153'' -> 'a7153'') -> ('a7153'' -> 'a7153''))  <!<  ((α7144'',) -> α7149'')
//│ ╟── while constraining:  ‹∀ 0. (('a3195' -> 'a3195') -> ('a3195' -> 'a3195'))›  <!<  ((α7144'',) -> α7149'')
//│ ╟── while constraining:  Fint  <!<  ((α7144'',) -> α7149'')
//│ ╟── while constraining:  α7139''  <!<  ((α7144'',) -> α7149'')
//│ ╟── while constraining:  {(α7152'' -> α7151'') where: α7139'' <: ((α7144'',) -> α7149''), α7144'' <: ((α7152'',) -> α7150'')}  <!<  ((α7134'',) -> α7135'')
//│ ╟── while constraining:  ‹∀ 3. {(α7148'''' -> α7147'''') where: α7139'' <: ((α7144'',) -> α7145''''), α7144'' <: ((α7148'''',) -> α7146'''')}›  <!<  ((α7134'',) -> α7135'')
//│ ╟── while constraining:  ‹∀ 3. {(α7148'''' -> α7147'''') where: α7139'' <: ((α7144'',) -> α7145''''), α7144'' <: ((α7148'''',) -> α7146'''')}›  <!<  α7133''
//│ ╟── while constraining:  (α7144'' -> ‹∀ 3. {(α7148'''' -> α7147'''') where: α7139'' <: ((α7144'',) -> α7145''''), α7144'' <: ((α7148'''',) -> α7146'''')}›)  <!<  ((α7128'',) -> α7133'')
//│ ╟── while constraining:  ‹∀ 2. (α7138''' -> ‹∀ 3. {(α7143'''' -> α7142'''') where: α7139'' <: ((α7138''',) -> α7140''''), α7138''' <: ((α7143'''',) -> α7141'''')}›)›  <!<  ((α7128'',) -> α7133'')
//│ ╟── while constraining:  α7137''  <!<  ((α7128'',) -> α7133'')
//│ ╟── while constraining:  ‹∀ 0. α4384'›  <!<  ((α7128'',) -> α7133'')
//│ ╟── while constraining:  α7123''  <!<  ((α7128'',) -> α7133'')
//│ ╟── ......
//│ ╟── ......
//│ ╟── while constraining:  ‹∀ 3. {(α6102'''' -> α6101'''') where: α5966'' <: ((α6098'',) -> α6099''''), α6098'' <: ((α6102'''',) -> α6100'''')}›  <!<  α6036''
//│ ╟── while constraining:  (α6098'' -> ‹∀ 3. {(α6102'''' -> α6101'''') where: α5966'' <: ((α6098'',) -> α6099''''), α6098'' <: ((α6102'''',) -> α6100'''')}›)  <!<  ((α6031'',) -> α6036'')
//│ ╟── while constraining:  ‹∀ 2. (α5965''' -> ‹∀ 3. {(α5970'''' -> α5969'''') where: α5966'' <: ((α5965''',) -> α5967''''), α5965''' <: ((α5970'''',) -> α5968'''')}›)›  <!<  ((α6031'',) -> α6036'')
//│ ╟── while constraining:  α5966''  <!<  ((α6031'',) -> α6036'')
//│ ╟── while constraining:  {(α6039'' -> α6038'') where: α5966'' <: ((α6031'',) -> α6036''), α6031'' <: ((α6039'',) -> α6037'')}  <!<  ((‹∀ 0. ‹∀ 1. (α3720'' -> ‹∀ 2. (α3721''' -> α3721''')›)››,) -> α5955'')
//│ ╟── while constraining:  ‹∀ 3. {(α6035'''' -> α6034'''') where: α5966'' <: ((α6031'',) -> α6032''''), α6031'' <: ((α6035'''',) -> α6033'''')}›  <!<  ((‹∀ 0. ‹∀ 1. (α3720'' -> ‹∀ 2. (α3721''' -> α3721''')›)››,) -> α5955'')
//│ ╟── while constraining:  ‹∀ 3. {(α6035'''' -> α6034'''') where: α5966'' <: ((α6031'',) -> α6032''''), α6031'' <: ((α6035'''',) -> α6033'''')}›  <!<  α5954''
//│ ╟── while constraining:  (α6031'' -> ‹∀ 3. {(α6035'''' -> α6034'''') where: α5966'' <: ((α6031'',) -> α6032''''), α6031'' <: ((α6035'''',) -> α6033'''')}›)  <!<  ((α5953'',) -> α5954'')
//│ ╟── while constraining:  ‹∀ 2. (α5965''' -> ‹∀ 3. {(α5970'''' -> α5969'''') where: α5966'' <: ((α5965''',) -> α5967''''), α5965''' <: ((α5970'''',) -> α5968'''')}›)›  <!<  ((α5953'',) -> α5954'')
//│ ╟── while constraining:  α5958''  <!<  ((α5953'',) -> α5954'')
//│ ╟── while constraining:  ‹∀ 1. α5912''›  <!<  ((α5953'',) -> α5954'')
//│ ╟── while constraining:  α5946''  <!<  ((α5953'',) -> α5954'')
//│ ╟── while constraining:  {(α5956'' -> α5955'') where: α5946'' <: ((α5953'',) -> α5954'')}  <!<  ((‹∀ 0. α4384'›,) -> α5952'')
//│ ╟── while constraining:  ‹∀ 2. {(α5950''' -> α5949''') where: α5946'' <: ((α5947''',) -> α5948''')}›  <!<  ((‹∀ 0. α4384'›,) -> α5952'')
//│ ╙── while constraining:  α5945''  <!<  ((‹∀ 0. α4384'›,) -> α5952'')
//│ this_should_be_98': string
//│                   = '98'

//   print_fact2 0 ;
//   print_fact2 1 ;
//   print_fact2 2 ;
//   print_fact2 3 ;
//   print_fact2 4 ;
//   print_fact2 5 ;
//   print_fact2 6 ;
//   ()
print_fact2 0
print_fact2 1
print_fact2 2
print_fact2 3
print_fact2 4
print_fact2 5
print_fact2 6
//│ res: string
//│    = 'Factorial 0 = 1'
//│ res: string
//│    = 'Factorial 1 = 1'
//│ res: string
//│    = 'Factorial 2 = 2'
//│ res: string
//│    = 'Factorial 3 = 6'
//│ res: string
//│    = 'Factorial 4 = 24'
//│ res: string
//│    = 'Factorial 5 = 120'
//│ res: string
//│    = 'Factorial 6 = 720'

print_fact2' 0
print_fact2' 1
print_fact2' 2
print_fact2' 3
print_fact2' 4
print_fact2' 5
print_fact2' 6
//│ res: string
//│    = 'Factorial 6 = 720'
//│ res: string
//│    = 'Factorial 6 = 720'
//│ res: string
//│    = 'Factorial 6 = 720'
//│ res: string
//│    = 'Factorial 6 = 720'
//│ res: string
//│    = 'Factorial 6 = 720'
//│ res: string
//│    = 'Factorial 6 = 720'
//│ res: string
//│    = 'Factorial 6 = 720'



