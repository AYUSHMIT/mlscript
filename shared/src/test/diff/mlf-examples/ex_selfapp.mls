:NoRecursiveTypes
:GeneralizeCurriedFunctions
// :DistributeForalls

// (*
//  * This example was written by Susumu NISHIMURA 
//  * According to him, it requires impredicative polymorphism.
//  *)

// (* my list definition *)

// type mylist ('b) = Nil | Cons of ('b * mylist ('b));;
class Nil
class Cons[a]: { head: a; tail: List[a] }
type List[a] = Nil | Cons[a]
def Nil = Nil {}
def Cons (head, tail) = Cons { head; tail }
//│ Defined class Nil
//│ Defined class Cons[+a]
//│ Defined type alias List[+a]
//│ Nil: Nil
//│    = Nil {}
//│ Cons: ('b, 'c,) -> 'd
//│   where
//│     'd :> Cons['a] with {head: 'head, tail: 'tail}
//│     'b <: 'head & 'a
//│     'c <: List['a] & 'tail
//│     = [Function: Cons1]

// let rec foo =
//   fun xs ->
//     begin match xs with
//       Nil -> Nil
//     | Cons (x,xs) -> Cons (x+1, foo (foo xs))
//     end
:RecursiveTypes // needed for this recursive def
rec def foo = fun xs -> case xs of
  { Nil -> Nil
  | Cons -> Cons (xs.head + 1, foo (foo xs.tail))
  }
//│ foo: 'a -> 'tail
//│   where
//│     'tail :> (Cons[int] with {tail: 'tail}) | Nil
//│     'a <: (Cons[?] with {head: int, tail: 'a}) | Nil
//│    = [Function: foo]
:NoRecursiveTypes



// (* Type def: ba = forall b.(int->b->b)->b->b *)
// type ba = ['b] (int -> 'b -> 'b) -> 'b -> 'b
// (* z can be typed more polymorphic. *)
// type baa = ['a, 'b] ('a  -> 'b -> 'b)-> 'b -> 'b 
type Ba = forall 'b. (int -> 'b -> 'b) -> 'b -> 'b
type Baa = forall 'a 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│ Defined type alias Ba
//│ Defined type alias Baa


// LP: this Baa type is a bit weird. It's equivalent to:
def b: (nothing -> 'b -> 'b) -> 'b -> 'b
//│ b: (nothing -> 'b -> 'b) -> 'b -> 'b
//│  = <missing implementation>

// LP: indeed:
b: Baa
//│ res: Baa
//│    = <no result>
//│      b is not implemented
:ng
b = error: Baa
//│ Baa
//│   <:  b:
//│ (nothing -> 'b -> 'b) -> 'b -> 'b



// (* build and foldr *)
// let build = 
//   fun (g : ['b] (('a -> 'b -> 'b) -> 'b -> 'b)) -> 
//     g (fun x xs -> Cons (x,xs)) Nil

:e // due to tapping
// :e // works with quantif extrus
def build = fun (g: forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> g (fun x -> fun xs -> Cons (x, xs)) Nil
//│ ╔══[ERROR] Cyclic-looking constraint while typing lambda expression
//│ ║  l.85: 	def build = fun (g: forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> g (fun x -> fun xs -> Cons (x, xs)) Nil
//│ ║        	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  (cons<> & {head: head26_184', tail: tail27_186', Cons#a: mut a22_185'..a22_185'})  <:  List[a22_185']    ComposedType  TypeRef
//│ ╙──  ... looks like:  (cons<> & {head: head26_176'''', tail: tail27_178'''', Cons#a: mut a22_177''''..a22_177''''})  <:  List[a22_177'''']
//│ build: (forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> 'c
//│   where
//│     'd <: 'e
//│     'f <: 'g
//│     'h <: Nil -> 'c
//│     'i :> Cons['a0] with {head: 'head, tail: 'tail}
//│        <: 'j
//│     'e <: 'head & 'a0
//│     'g <: List['a0] & 'tail
//│     'k :> forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│        <: (forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) & (forall 'j, 'l, 'm, 'n, 'o, 'p, 'a1, 'head0, 'tail0. ('l -> (forall 'j, 'l, 'q, 'r, 's, 'a2, 'head1, 'tail1, 't. ('r -> 't
//│   where
//│     'l <: 'q
//│     'r <: 'j
//│     's :> Cons['a2] with {head: 'head1, tail: 'tail1}
//│        <: 't
//│     'q <: 'head1 & 'a2
//│     'j <: List['a2] & 'tail1))
//│   where
//│     'l <: 'm
//│     'n <: 'o
//│     'p :> Cons['a1] with {head: 'head0, tail: 'tail0}
//│        <: 'j
//│     'm <: 'head0 & 'a1
//│     'o <: List['a1] & 'tail0)) -> 'h
//│      = [Function: build]

// * ^ Not sure why this one only works with recursive types:
:RecursiveTypes
def build = fun (g: forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> g (fun x -> fun xs -> Cons (x, xs)) Nil
//│ build: (forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> 'c
//│   where
//│     'd <: 'e
//│     'f :> forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│        <: (forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) & (forall 'g, 'a0, 'tail, 'h, 'i, 'head, 'j, 'k, 'l. ('l -> (forall 'l, 'm, 'a1, 'tail0, 'n, 'o, 'p, 'head0, 'q. ('o -> 'q
//│   where
//│     'm <: List['a1] & 'tail0
//│     'l <: 'n
//│     'o <: 'm
//│     'p :> Cons['a1] with {head: 'head0, tail: 'tail0}
//│        <: 'q
//│     'n <: 'a1 & 'head0))
//│   where
//│     'g <: List['a0] & 'tail
//│     'h <: 'g
//│     'i :> Cons['a0] with {head: 'head, tail: 'tail}
//│        <: 'j
//│     'k <: 'a0 & 'head
//│     'l <: 'k)) -> 'r
//│     'j <: List['a2] & 'tail1
//│     's <: 'j
//│     'r <: Nil -> 'c
//│     't :> Cons['a2] with {head: 'head1, tail: 'tail1}
//│        <: 'j
//│     'e <: 'a2 & 'head1
//│      = [Function: build1]
:NoRecursiveTypes


def build_ = fun g -> g (fun x -> fun xs -> Cons (x, xs)) Nil
//│ build_: 'b -> 'c
//│   where
//│     'b <: (forall 'd, 'e, 'f, 'g, 'h, 'a, 'head, 'tail, 'i. ('d -> (forall 'd, 'j, 'k, 'l, 'm, 'a0, 'head0, 'tail0, 'n. ('k -> 'n
//│   where
//│     'd <: 'j
//│     'k <: 'l
//│     'm :> Cons['a0] with {head: 'head0, tail: 'tail0}
//│        <: 'n
//│     'j <: 'head0 & 'a0
//│     'l <: List['a0] & 'tail0))
//│   where
//│     'd <: 'e
//│     'f <: 'g
//│     'h :> Cons['a] with {head: 'head, tail: 'tail}
//│        <: 'i
//│     'e <: 'head & 'a
//│     'g <: List['a] & 'tail)) -> 'o
//│     'p <: 'q
//│     'r <: 'i
//│     'o <: Nil -> 'c
//│     's :> Cons['a1] with {head: 'head1, tail: 'tail1}
//│        <: 'i
//│     'q <: 'head1 & 'a1
//│     'i <: List['a1] & 'tail1
//│       = [Function: build_]

:e
build_ : forall 'a. (forall 'b. (('a -> 'b -> 'b) -> 'b -> 'b)) -> List['a]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.179: 	build_ : forall 'a. (forall 'b. (('a -> 'b -> 'b) -> 'b -> 'b)) -> List['a]
//│ ║         	^^^^^^
//│ ╟── type `‘b` does not match type `Cons[?a] | Nil`
//│ ║  l.179: 	build_ : forall 'a. (forall 'b. (('a -> 'b -> 'b) -> 'b -> 'b)) -> List['a]
//│ ║         	                            ^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.15: 	type List[a] = Nil | Cons[a]
//│ ║        	               ^^^^^^^^^^^^^
//│ ╟── from applied type reference:
//│ ║  l.14: 	class Cons[a]: { head: a; tail: List[a] }
//│ ╙──      	                                ^^^^^^^
//│ res: (forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> List['a]
//│    = [Function: build_]


class Ls[A] method Head: A
def cons: ('a, Ls['a]) -> Ls['a]
def nil: Ls['a]
//│ Defined class Ls[+A]
//│ Declared Ls.Head: Ls['A] -> 'A
//│ cons: ('a, Ls['a],) -> Ls['a]
//│     = <missing implementation>
//│ nil: Ls[nothing]
//│    = <missing implementation>

def build2 = fun (g: forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> g (fun x -> fun xs -> cons (x, xs)) nil
//│ build2: (forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> 'c
//│   where
//│     'd :> Ls['a0]
//│     'e :> forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│        <: (forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) & (forall 'f, 'a1, 'g, 'h. ('f -> (forall 'f, 'a2, 'i, 'j. ('i -> 'j
//│   where
//│     'f <: 'a2
//│     'i <: Ls['a2]
//│     'j :> Ls['a2]))
//│   where
//│     'f <: 'a1
//│     'g <: Ls['a1]
//│     'h :> Ls['a1])) -> 'k
//│     'k <: Ls['j] -> 'c
//│     'l <: 'a0
//│     'm <: Ls['a0]
//│       = <no result>
//│         cons is not implemented

def build2_ = fun g -> g (fun x -> fun xs -> cons (x, xs)) nil
//│ build2_: 'b -> 'c
//│   where
//│     'd <: Ls['a]
//│     'e :> Ls['a]
//│     'f <: 'a
//│     'g <: Ls['h] -> 'c
//│     'b <: (forall 'i, 'a0, 'j, 'k. ('k -> (forall 'h, 'k, 'l, 'a1. ('l -> 'h
//│   where
//│     'l <: Ls['a1]
//│     'h :> Ls['a1]
//│     'k <: 'a1))
//│   where
//│     'i <: Ls['a0]
//│     'j :> Ls['a0]
//│     'k <: 'a0)) -> 'g
//│        = <no result>
//│          cons is not implemented

:e
build2_ : forall 'a. (forall 'b. (('a -> 'b -> 'b) -> 'b -> 'b)) -> Ls['a]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.246: 	build2_ : forall 'a. (forall 'b. (('a -> 'b -> 'b) -> 'b -> 'b)) -> Ls['a]
//│ ║         	^^^^^^^
//│ ╟── type `‘b` is not an instance of type `Ls`
//│ ║  l.246: 	build2_ : forall 'a. (forall 'b. (('a -> 'b -> 'b) -> 'b -> 'b)) -> Ls['a]
//│ ║         	                             ^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.197: 	def cons: ('a, Ls['a]) -> Ls['a]
//│ ╙──       	               ^^^^^^
//│ res: (forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> Ls['a]
//│    = <no result>
//│      build2_ and cons are not implemented


// let rec foldr =
//   fun k z xs -> 
//     begin match xs with
//       Nil -> z
//     | Cons (x, xs) -> k x (foldr k z xs)
//     end
rec def foldr = fun k -> fun z -> fun xs ->
  case xs of
    { Nil -> z
    | Cons -> k xs.head (foldr k z xs.tail)
    }
//│ foldr: ('head -> 'a -> 'a) -> 'a -> 'b -> 'a
//│   where
//│     'b <: (Cons[?] with {head: 'head, tail: 'b}) | Nil
//│      = [Function: foldr]


// (* encoding `foo' with foldr *)

// let (z : baa) = fun c n -> n
def z = (fun c -> fun n -> n) : Baa
def z_ = fun c -> fun n -> n
//│ z: Baa
//│  = [Function: z]
//│ z_: anything -> (forall 'a. 'a -> 'a)
//│   = [Function: z_]


// let rec (k : int -> ba -> ba) = fun x (xs : ba) c n -> c (x+1) (xs k z c n)

def k: int -> Ba -> Ba
//│ k: int -> Ba -> Ba
//│  = <missing implementation>

// * The following tests don't benefit from `:RecursiveTypes`,
// *  but they produce LOTS of spammy error messages unless we enable it:
:RecursiveTypes

// FIXME
rec def k = fun x -> fun (xs: Ba) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.300: 	rec def k = fun x -> fun (xs: Ba) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘b887` is not an instance of type `'b886`
//│ ║  l.54: 	type Ba = forall 'b. (int -> 'b -> 'b) -> 'b -> 'b
//│ ║        	                 ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.54: 	type Ba = forall 'b. (int -> 'b -> 'b) -> 'b -> 'b
//│ ║        	                 ^^
//│ ╟── from reference:
//│ ║  l.300: 	rec def k = fun x -> fun (xs: Ba) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ╙──       	                                                                           ^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.300: 	rec def k = fun x -> fun (xs: Ba) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘b886` is not an instance of type `'b`
//│ ║  l.54: 	type Ba = forall 'b. (int -> 'b -> 'b) -> 'b -> 'b
//│ ║        	                 ^^
//│ ╟── but it flows into application with expected type `‘b`
//│ ║  l.300: 	rec def k = fun x -> fun (xs: Ba) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ║         	                                                       ^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.54: 	type Ba = forall 'b. (int -> 'b -> 'b) -> 'b -> 'b
//│ ╙──      	                 ^^
//│ int -> Ba -> (nothing -> ('b | ‘b886 | ‘b887) -> (‘b886 & 'b & 'a) & int -> (‘b886 | ‘b887 | 'a) -> (‘b886 & 'a & 'c)) -> (‘b886 & 'b & 'a) -> (‘b886 | 'c)
//│   <:  k:
//│ int -> Ba -> Ba
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.300: 	rec def k = fun x -> fun (xs: Ba) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘b887` is not an instance of type `'b919`
//│ ║  l.54: 	type Ba = forall 'b. (int -> 'b -> 'b) -> 'b -> 'b
//│ ║        	                 ^^
//│ ╟── but it flows into reference with expected type `‘b919`
//│ ║  l.300: 	rec def k = fun x -> fun (xs: Ba) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ║         	                                                                           ^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.54: 	type Ba = forall 'b. (int -> 'b -> 'b) -> 'b -> 'b
//│ ╙──      	                 ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.300: 	rec def k = fun x -> fun (xs: Ba) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘b886` is not an instance of type `'b919`
//│ ║  l.54: 	type Ba = forall 'b. (int -> 'b -> 'b) -> 'b -> 'b
//│ ║        	                 ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.54: 	type Ba = forall 'b. (int -> 'b -> 'b) -> 'b -> 'b
//│ ╙──      	                 ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.300: 	rec def k = fun x -> fun (xs: Ba) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘b919` is not an instance of type `'b886`
//│ ║  l.54: 	type Ba = forall 'b. (int -> 'b -> 'b) -> 'b -> 'b
//│ ║        	                 ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.54: 	type Ba = forall 'b. (int -> 'b -> 'b) -> 'b -> 'b
//│ ║        	                 ^^
//│ ╟── from quantified type variable:
//│ ║  l.55: 	type Baa = forall 'a 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│ ╙──      	                     ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.300: 	rec def k = fun x -> fun (xs: Ba) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘b919` is not an instance of type `'b`
//│ ║  l.54: 	type Ba = forall 'b. (int -> 'b -> 'b) -> 'b -> 'b
//│ ║        	                 ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.54: 	type Ba = forall 'b. (int -> 'b -> 'b) -> 'b -> 'b
//│ ║        	                 ^^
//│ ╟── from application:
//│ ║  l.300: 	rec def k = fun x -> fun (xs: Ba) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ╙──       	                                                       ^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.300: 	rec def k = fun x -> fun (xs: Ba) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘b920` is not an instance of type `'b919`
//│ ║  l.54: 	type Ba = forall 'b. (int -> 'b -> 'b) -> 'b -> 'b
//│ ║        	                 ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.54: 	type Ba = forall 'b. (int -> 'b -> 'b) -> 'b -> 'b
//│ ║        	                 ^^
//│ ╟── from reference:
//│ ║  l.300: 	rec def k = fun x -> fun (xs: Ba) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ╙──       	                                                                           ^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.300: 	rec def k = fun x -> fun (xs: Ba) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘b920` is not an instance of type `'b886`
//│ ║  l.54: 	type Ba = forall 'b. (int -> 'b -> 'b) -> 'b -> 'b
//│ ║        	                 ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.54: 	type Ba = forall 'b. (int -> 'b -> 'b) -> 'b -> 'b
//│ ║        	                 ^^
//│ ╟── from reference:
//│ ║  l.300: 	rec def k = fun x -> fun (xs: Ba) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ╙──       	                                                                           ^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.300: 	rec def k = fun x -> fun (xs: Ba) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘b886` is not an instance of type `'b`
//│ ║  l.54: 	type Ba = forall 'b. (int -> 'b -> 'b) -> 'b -> 'b
//│ ║        	                 ^^
//│ ╟── but it flows into application with expected type `‘b`
//│ ║  l.300: 	rec def k = fun x -> fun (xs: Ba) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ║         	                                                       ^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.54: 	type Ba = forall 'b. (int -> 'b -> 'b) -> 'b -> 'b
//│ ╙──      	                 ^^
//│  = [Function: k]

:e
rec def k = fun x -> fun xs -> fun c -> fun n -> c (x + 1) (xs k z_ c n)
//│ 'k
//│   where
//│     'k :> int -> ('k -> (anything -> (forall 'a. 'a -> 'a)) -> 'b -> 'c -> 'd) -> (int -> 'd -> 'e & 'b) -> 'c -> 'e
//│   <:  k:
//│ int -> Ba -> Ba
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.412: 	rec def k = fun x -> fun xs -> fun c -> fun n -> c (x + 1) (xs k z_ c n)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> (forall ?b. ?b -> ?b)` is not an instance of type `'b978`
//│ ║  l.282: 	def z_ = fun c -> fun n -> n
//│ ║         	         ^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `‘b978`
//│ ║  l.412: 	rec def k = fun x -> fun xs -> fun c -> fun n -> c (x + 1) (xs k z_ c n)
//│ ║         	                                                                 ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.54: 	type Ba = forall 'b. (int -> 'b -> 'b) -> 'b -> 'b
//│ ╙──      	                 ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.412: 	rec def k = fun x -> fun xs -> fun c -> fun n -> c (x + 1) (xs k z_ c n)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> ?b -> ?c` is not an instance of type `'b978`
//│ ║  l.412: 	rec def k = fun x -> fun xs -> fun c -> fun n -> c (x + 1) (xs k z_ c n)
//│ ║         	                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into application with expected type `‘b978`
//│ ║  l.412: 	rec def k = fun x -> fun xs -> fun c -> fun n -> c (x + 1) (xs k z_ c n)
//│ ║         	                                                 ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.54: 	type Ba = forall 'b. (int -> 'b -> 'b) -> 'b -> 'b
//│ ╙──      	                 ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.412: 	rec def k = fun x -> fun xs -> fun c -> fun n -> c (x + 1) (xs k z_ c n)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘b978` is not a function
//│ ║  l.54: 	type Ba = forall 'b. (int -> 'b -> 'b) -> 'b -> 'b
//│ ║        	                 ^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.412: 	rec def k = fun x -> fun xs -> fun c -> fun n -> c (x + 1) (xs k z_ c n)
//│ ║         	                                                            ^^^^
//│ ╟── from application:
//│ ║  l.412: 	rec def k = fun x -> fun xs -> fun c -> fun n -> c (x + 1) (xs k z_ c n)
//│ ╙──       	                                                 ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.412: 	rec def k = fun x -> fun xs -> fun c -> fun n -> c (x + 1) (xs k z_ c n)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘b978` is not a function
//│ ║  l.54: 	type Ba = forall 'b. (int -> 'b -> 'b) -> 'b -> 'b
//│ ║        	                 ^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.412: 	rec def k = fun x -> fun xs -> fun c -> fun n -> c (x + 1) (xs k z_ c n)
//│ ║         	                                                            ^^^^^^^^^
//│ ╟── from application:
//│ ║  l.412: 	rec def k = fun x -> fun xs -> fun c -> fun n -> c (x + 1) (xs k z_ c n)
//│ ╙──       	                                                 ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.412: 	rec def k = fun x -> fun xs -> fun c -> fun n -> c (x + 1) (xs k z_ c n)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘b996` is not an instance of type `'b978`
//│ ║  l.54: 	type Ba = forall 'b. (int -> 'b -> 'b) -> 'b -> 'b
//│ ║        	                 ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.54: 	type Ba = forall 'b. (int -> 'b -> 'b) -> 'b -> 'b
//│ ║        	                 ^^
//│ ╟── from reference:
//│ ║  l.412: 	rec def k = fun x -> fun xs -> fun c -> fun n -> c (x + 1) (xs k z_ c n)
//│ ╙──       	                                                                      ^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.412: 	rec def k = fun x -> fun xs -> fun c -> fun n -> c (x + 1) (xs k z_ c n)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘b996` is not a function
//│ ║  l.54: 	type Ba = forall 'b. (int -> 'b -> 'b) -> 'b -> 'b
//│ ║        	                 ^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.412: 	rec def k = fun x -> fun xs -> fun c -> fun n -> c (x + 1) (xs k z_ c n)
//│ ║         	                                                            ^^^^
//│ ╟── from reference:
//│ ║  l.412: 	rec def k = fun x -> fun xs -> fun c -> fun n -> c (x + 1) (xs k z_ c n)
//│ ╙──       	                                                                      ^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.412: 	rec def k = fun x -> fun xs -> fun c -> fun n -> c (x + 1) (xs k z_ c n)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘b978` is not an instance of type `'b`
//│ ║  l.54: 	type Ba = forall 'b. (int -> 'b -> 'b) -> 'b -> 'b
//│ ║        	                 ^^
//│ ╟── but it flows into application with expected type `‘b`
//│ ║  l.412: 	rec def k = fun x -> fun xs -> fun c -> fun n -> c (x + 1) (xs k z_ c n)
//│ ║         	                                                 ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.54: 	type Ba = forall 'b. (int -> 'b -> 'b) -> 'b -> 'b
//│ ╙──      	                 ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.412: 	rec def k = fun x -> fun xs -> fun c -> fun n -> c (x + 1) (xs k z_ c n)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> ?b -> ?c` is not an instance of type `'b`
//│ ║  l.412: 	rec def k = fun x -> fun xs -> fun c -> fun n -> c (x + 1) (xs k z_ c n)
//│ ║         	                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into application with expected type `‘b`
//│ ║  l.412: 	rec def k = fun x -> fun xs -> fun c -> fun n -> c (x + 1) (xs k z_ c n)
//│ ║         	                                                 ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.54: 	type Ba = forall 'b. (int -> 'b -> 'b) -> 'b -> 'b
//│ ╙──      	                 ^^
//│  = [Function: k1]

rec def k_ = fun x -> fun xs -> fun c -> fun n -> c (x + 1) (xs k_ z_ c n)
//│ k_: 'k_
//│   where
//│     'k_ :> int -> ('k_ -> (anything -> (forall 'a. 'a -> 'a)) -> 'b -> 'c -> 'd) -> (int -> 'd -> 'e & 'b) -> 'c -> 'e
//│   = [Function: k_]


// (* untyped terms *)
// (* let z = fun c -> fun n -> n *)
// (* let rec k = fun x xs c cn -> c (x+1) (xs k z c n) *)

// (* System F terms *)
// (* let z = /\b -> fun (c : int -> b -> b) -> fun (n : b) -> n *)
// (* let rec (k : int -> (forall b.(int->b->b)->b->b)			*)
// (*	            -> (forall b.(int->b->b)->b->b)) =			*)
// (*     \(a : int) -> \(as : forall b.(int->b->b)->b->b) ->		*)
// (*         /\b -> \(c : int->b->b) -> \(n : b) ->			*)
// (*             ((as[forall b.(int->b->b)->b->b] k z)[b] c z)		*)


// (* definition with build and foldr *)
// let bfoo xs = build (foldr k z xs)

// :e // FIXME? fails with genLamBodies
def bfoo xs = build (foldr k z xs)
//│ bfoo: 'c -> 'd
//│   where
//│     'e <: 'c -> 'f
//│     'f <: forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│     'g <: 'h
//│     'i :> forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│        <: (forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) & (forall 'j, 'a0, 'tail, 'k, 'l, 'head, 'm, 'n, 'o. ('o -> (forall 'o, 'p, 'a1, 'tail0, 'q, 'r, 's, 'head0, 't. ('r -> 't
//│   where
//│     'p <: List['a1] & 'tail0
//│     'o <: 'q
//│     'r <: 'p
//│     's :> Cons['a1] with {head: 'head0, tail: 'tail0}
//│        <: 't
//│     'q <: 'a1 & 'head0))
//│   where
//│     'j <: List['a0] & 'tail
//│     'k <: 'j
//│     'l :> Cons['a0] with {head: 'head, tail: 'tail}
//│        <: 'm
//│     'n <: 'a0 & 'head
//│     'o <: 'n)) -> 'u
//│     'v <: List['a2] & 'tail1
//│     'w <: 'v
//│     'u <: Nil -> 'x
//│     'y :> Cons['a2] with {head: 'head1, tail: 'tail1}
//│        <: 'm
//│     'h <: 'a2 & 'head1
//│     'x <: 'd
//│     'm <: Baa -> 'e
//│     'foldr <: (int -> Ba -> Ba) -> 'm
//│     = [Function: bfoo]

// FIXedME // works with quantif extrus
:e // due to tapping
def bfoo_ xs = build_ (foldr k_ z_ xs)
//│ ╔══[ERROR] Type mismatch in lambda expression:
//│ ║  l.575: 	def bfoo_ xs = build_ (foldr k_ z_ xs)
//│ ║         	          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?b -> (forall ?c. ?c -> ?c)` does not match type `Cons[?a] | Nil`
//│ ║  l.282: 	def z_ = fun c -> fun n -> n
//│ ║         	         ^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.15: 	type List[a] = Nil | Cons[a]
//│ ║        	               ^^^^^^^^^^^^^
//│ ╟── from applied type reference:
//│ ║  l.14: 	class Cons[a]: { head: a; tail: List[a] }
//│ ╙──      	                                ^^^^^^^
//│ bfoo_: 'b -> 'c
//│   where
//│     'd <: 'head & 'a
//│     'e <: List['a] & 'tail
//│     'f <: 'c
//│     'g <: ('h -> (forall 'i. 'i -> 'i)) -> 'j
//│     'foldr <: (forall 'h, 'k_, 'k, 'l, 'm, 'n. 'k_) -> 'g
//│     'j <: 'b -> 'o
//│     'o <: 'p
//│     'p <: (forall 'h, 'q, 'r, 's, 't, 'u, 'a0, 'head0, 'tail0. ('q -> (forall 'q, 'v, 'w, 'x, 'y, 'a1, 'head1, 'tail1, 'z. ('w -> 'z
//│   where
//│     'q <: 'v
//│     'w <: 'x
//│     'y :> Cons['a1] with {head: 'head1, tail: 'tail1}
//│        <: 'z
//│     'v <: 'head1 & 'a1
//│     'x <: List['a1] & 'tail1))
//│   where
//│     'q <: 'r
//│     's <: 't
//│     'u :> Cons['a0] with {head: 'head0, tail: 'tail0}
//│        <: 'h
//│     'r <: 'head0 & 'a0
//│     't <: List['a0] & 'tail0)) -> 'h
//│     'a1 <: 'd
//│     'b1 <: 'e
//│     'h <: Nil -> 'f
//│     'c1 :> Cons['a] with {head: 'head, tail: 'tail}
//│         <: 'h
//│   where
//│     'k_ :> int -> ('k_ -> ('h -> (forall 'i. 'i -> 'i)) -> 'k -> 'l -> 'm) -> (int -> 'm -> 'n & 'k) -> 'l -> 'n
//│      = [Function: bfoo_]


def lst = Cons (0, Cons (0, Cons (0, Nil)))
//│ lst: Cons[0] with {tail: Cons[0] with {tail: Cons[0] with {tail: Nil}}}
//│    = Cons {
//│        head: 0,
//│        tail: Cons { head: 0, tail: Cons { head: 0, tail: Nil {} } }
//│      }

// (* test run *)
// let lst0 = Cons (0, Cons (0, Cons (0, Cons (0, Nil))));;
def lst0 = Cons (0, Cons (0, Cons (0, Cons (0, Nil))))
//│ lst0: Cons[0] with {tail: Cons[0] with {tail: Cons[0] with {tail: Cons[0] with {tail: Nil}}}}
//│     = Cons {
//│         head: 0,
//│         tail: Cons { head: 0, tail: Cons { head: 0, tail: [Cons] } }
//│       }

// foo lst0;;
foo lst0
//│ res: 'tail
//│   where
//│     'tail :> (Cons[int] with {tail: 'tail}) | Nil
//│    = Cons {
//│        head: 1,
//│        tail: Cons { head: 2, tail: Cons { head: 4, tail: [Cons] } }
//│      }

// bfoo lst0;;
bfoo lst0
//│ res: 'tail
//│   where
//│     'tail :> (Cons[int] with {tail: 'tail}) | Nil
//│    = Cons {
//│        head: 1,
//│        tail: Cons { head: 2, tail: Cons { head: 4, tail: [Cons] } }
//│      }

:e // FIXME?
bfoo_ lst0
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.659: 	bfoo_ lst0
//│ ║         	^^^^^^^^^^
//│ ╟── function of type `?b -> (forall ?c. ?c -> ?c)` does not match type `Cons[?a] | Nil`
//│ ║  l.282: 	def z_ = fun c -> fun n -> n
//│ ║         	         ^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.15: 	type List[a] = Nil | Cons[a]
//│ ║        	               ^^^^^^^^^^^^^
//│ ╟── from applied type reference:
//│ ║  l.14: 	class Cons[a]: { head: a; tail: List[a] }
//│ ╙──      	                                ^^^^^^^
//│ res: error
//│    = Cons {
//│        head: 1,
//│        tail: Cons { head: 2, tail: Cons { head: 4, tail: [Cons] } }
//│      }


// (* This does not type :
// type baa = ['a, 'b] ('a  -> 'b -> 'b)-> 'b -> 'b
//   let rec (k : int -> baa -> baa) = fun x (xs : baa) c n -> c (x+1) (xs k z c n)
// *)
def k: int -> Baa -> Baa
//│ k: int -> Baa -> Baa
//│  = <missing implementation>

:e
rec def k = fun x -> fun (xs: Baa) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.688: 	rec def k = fun x -> fun (xs: Baa) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── operator application of type `int` is not an instance of type `'a2012`
//│ ║  l.688: 	rec def k = fun x -> fun (xs: Baa) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ║         	                                                           ^^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.55: 	type Baa = forall 'a 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│ ╙──      	                  ^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.688: 	rec def k = fun x -> fun (xs: Baa) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘b2014` is not an instance of type `'b2013`
//│ ║  l.55: 	type Baa = forall 'a 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│ ║        	                     ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.55: 	type Baa = forall 'a 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│ ║        	                     ^^
//│ ╟── from reference:
//│ ║  l.688: 	rec def k = fun x -> fun (xs: Baa) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ╙──       	                                                                            ^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.688: 	rec def k = fun x -> fun (xs: Baa) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘b2013` is not an instance of type `'b`
//│ ║  l.55: 	type Baa = forall 'a 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│ ║        	                     ^^
//│ ╟── but it flows into application with expected type `‘b`
//│ ║  l.688: 	rec def k = fun x -> fun (xs: Baa) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ║         	                                                        ^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.55: 	type Baa = forall 'a 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│ ╙──      	                     ^^
//│ int -> Baa -> (nothing -> ('b | ‘b2013 | ‘b2014) -> (‘b2013 & 'b & 'a) & int -> (‘b2013 | ‘b2014 | 'a) -> (‘b2013 & 'a & 'c)) -> (‘b2013 & 'b & 'a) -> (‘b2013 | 'c)
//│   <:  k:
//│ int -> Baa -> Baa
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.688: 	rec def k = fun x -> fun (xs: Baa) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘b2014` is not an instance of type `'b2048`
//│ ║  l.55: 	type Baa = forall 'a 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│ ║        	                     ^^
//│ ╟── but it flows into reference with expected type `‘b2048`
//│ ║  l.688: 	rec def k = fun x -> fun (xs: Baa) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ║         	                                                                            ^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.55: 	type Baa = forall 'a 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│ ╙──      	                     ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.688: 	rec def k = fun x -> fun (xs: Baa) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘b2013` is not an instance of type `'b2048`
//│ ║  l.55: 	type Baa = forall 'a 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│ ║        	                     ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.55: 	type Baa = forall 'a 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│ ╙──      	                     ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.688: 	rec def k = fun x -> fun (xs: Baa) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘b2048` is not an instance of type `'b2013`
//│ ║  l.55: 	type Baa = forall 'a 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│ ║        	                     ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.55: 	type Baa = forall 'a 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│ ╙──      	                     ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.688: 	rec def k = fun x -> fun (xs: Baa) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── operator application of type `int` is not an instance of type `'a2047`
//│ ║  l.688: 	rec def k = fun x -> fun (xs: Baa) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ║         	                                                           ^^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.55: 	type Baa = forall 'a 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│ ╙──      	                  ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.688: 	rec def k = fun x -> fun (xs: Baa) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘b2048` is not an instance of type `'b`
//│ ║  l.55: 	type Baa = forall 'a 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│ ║        	                     ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.55: 	type Baa = forall 'a 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│ ║        	                     ^^
//│ ╟── from application:
//│ ║  l.688: 	rec def k = fun x -> fun (xs: Baa) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ╙──       	                                                        ^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.688: 	rec def k = fun x -> fun (xs: Baa) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘b2049` is not an instance of type `'b2048`
//│ ║  l.55: 	type Baa = forall 'a 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│ ║        	                     ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.55: 	type Baa = forall 'a 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│ ║        	                     ^^
//│ ╟── from reference:
//│ ║  l.688: 	rec def k = fun x -> fun (xs: Baa) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ╙──       	                                                                            ^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.688: 	rec def k = fun x -> fun (xs: Baa) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘b2049` is not an instance of type `'b2013`
//│ ║  l.55: 	type Baa = forall 'a 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│ ║        	                     ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.55: 	type Baa = forall 'a 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│ ║        	                     ^^
//│ ╟── from reference:
//│ ║  l.688: 	rec def k = fun x -> fun (xs: Baa) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ╙──       	                                                                            ^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.688: 	rec def k = fun x -> fun (xs: Baa) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘b2013` is not an instance of type `'b`
//│ ║  l.55: 	type Baa = forall 'a 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│ ║        	                     ^^
//│ ╟── but it flows into application with expected type `‘b`
//│ ║  l.688: 	rec def k = fun x -> fun (xs: Baa) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ║         	                                                        ^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.55: 	type Baa = forall 'a 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│ ╙──      	                     ^^
//│  = [Function: k2]

:e // FIXME?
def k = fun x -> fun (xs: Baa) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ 'a -> (forall 'a, 'b, 'c, 'd, 'e, 'f, 'g, 'h, 'i, 'j, 'k. (Baa -> (forall 'a, 'b, 'c, 'd, 'l, 'm, 'n, 'o, 'p, 'q, 'r, 's. ('p -> (forall 'a, 'b, 'd, 'p, 't, 'u, 'v, 'w, 'x, 'y, 'z, 'a1. ('a1 -> 'y
//│   where
//│     'a <: int
//│     'd <: (int -> Baa -> Baa) -> 't
//│     'p <: 'u -> 'v
//│     'w :> int -> int
//│        <: 1 -> 'u
//│     'v <: 'x -> 'y
//│     't <: Baa -> 'z
//│     'z <: 'p -> 'b
//│     'b <: 'a1 -> 'x))
//│   where
//│     'l <: 'm -> 'b
//│     'n <: Baa -> 'o
//│     'o <: 'p -> 'q
//│     'a <: int
//│     'q <: 'c -> 'm
//│     'd <: (int -> Baa -> Baa) -> 'n
//│     'p <: 'r -> 'l
//│     's :> int -> int
//│        <: 1 -> 'r))
//│   where
//│     'a <: int
//│     'd :> Baa
//│        <: Baa & (int -> Baa -> Baa) -> 'e
//│     'f <: 'g -> 'b
//│     'e <: Baa -> 'h
//│     'h <: 'c -> 'i
//│     'i <: 'c -> 'g
//│     'c <: 'j -> 'f
//│     'k :> int -> int
//│        <: 1 -> 'j))
//│   where
//│     'b1 <: 'c1 -> 'd1
//│     'e1 :> int -> int
//│         <: 1 -> 'c1
//│     'a <: int
//│     'f1 :> Baa
//│         <: Baa & (int -> Baa -> Baa) -> 'g1
//│     'd1 <: 'h1 -> 'b
//│     'g1 <: Baa -> 'i1
//│     'i1 <: 'b1 -> 'j1
//│     'j1 <: 'c -> 'h1
//│   <:  k:
//│ int -> Baa -> Baa
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.815: 	def k = fun x -> fun (xs: Baa) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── operator application of type `int` is not an instance of type `'a`
//│ ║  l.815: 	def k = fun x -> fun (xs: Baa) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ║         	                                                       ^^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.55: 	type Baa = forall 'a 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│ ╙──      	                  ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.815: 	def k = fun x -> fun (xs: Baa) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘b2403` is not an instance of type `'b`
//│ ║  l.55: 	type Baa = forall 'a 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│ ║        	                     ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.55: 	type Baa = forall 'a 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│ ╙──      	                     ^^
//│  = [Function: k3]

// * Using `k` here on purpose to simulate an annotated rec def
def k_ = fun x -> fun xs -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ k_: 'a -> (forall 'a, 'b, 'c, 'd, 'e, 'f, 'g, 'h, 'i, 'j, 'k. ('d -> (forall 'a, 'b, 'c, 'd, 'l, 'm, 'n, 'o, 'p, 'q, 'r, 's. ('p -> (forall 'a, 'b, 'd, 'p, 't, 'u, 'v, 'w, 'x, 'y, 'z, 'a1. ('a1 -> 'y
//│   where
//│     'a <: int
//│     'd <: (int -> Baa -> Baa) -> 't
//│     'p <: 'u -> 'v
//│     'w :> int -> int
//│        <: 1 -> 'u
//│     'v <: 'x -> 'y
//│     't <: Baa -> 'z
//│     'z <: 'p -> 'b
//│     'b <: 'a1 -> 'x))
//│   where
//│     'l <: 'm -> 'b
//│     'n <: Baa -> 'o
//│     'o <: 'p -> 'q
//│     'a <: int
//│     'q <: 'c -> 'm
//│     'd <: (int -> Baa -> Baa) -> 'n
//│     'p <: 'r -> 'l
//│     's :> int -> int
//│        <: 1 -> 'r))
//│   where
//│     'a <: int
//│     'd <: (int -> Baa -> Baa) -> 'e
//│     'f <: 'g -> 'b
//│     'e <: Baa -> 'h
//│     'h <: 'c -> 'i
//│     'i <: 'c -> 'g
//│     'c <: 'j -> 'f
//│     'k :> int -> int
//│        <: 1 -> 'j))
//│   where
//│     'b1 <: 'c1 -> 'd1
//│     'e1 :> int -> int
//│         <: 1 -> 'c1
//│     'a <: int
//│     'f1 <: (int -> Baa -> Baa) -> 'g1
//│     'd1 <: 'h1 -> 'b
//│     'g1 <: Baa -> 'i1
//│     'i1 <: 'b1 -> 'j1
//│     'j1 <: 'c -> 'h1
//│   = [Function: k_1]

rec def k_ = fun x -> fun xs -> fun c -> fun n -> c (x + 1) (xs k_ z c n)
//│ k_: 'k_
//│   where
//│     'k_ :> int -> ('k_ -> Baa -> 'a -> 'b -> 'c) -> (int -> 'c -> 'd & 'a) -> 'b -> 'd
//│   = [Function: k_2]

// k = k_ // nope

rec def k_ = fun x -> fun xs -> fun c -> fun n -> c (x + 1) (xs k_ z_ c n)
//│ k_: 'k_
//│   where
//│     'k_ :> int -> ('k_ -> (anything -> (forall 'a. 'a -> 'a)) -> 'b -> 'c -> 'd) -> (int -> 'd -> 'e & 'b) -> 'c -> 'e
//│   = [Function: k_3]

// k = k_ // nope


