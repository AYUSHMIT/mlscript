:NoRecursiveTypes
:GeneralizeCurriedFunctions
// :DistributeForalls

// (*
//  * This example was written by Susumu NISHIMURA 
//  * According to him, it requires impredicative polymorphism.
//  *)

// (* my list definition *)

// type mylist ('b) = Nil | Cons of ('b * mylist ('b));;
class Nil
class Cons[a]: { head: a; tail: List[a] }
type List[a] = Nil | Cons[a]
Nil = Nil {}
Cons (head, tail) = Cons { head; tail }
//│ Defined class Nil
//│ Defined class Cons[+a]
//│ Defined type alias List[+a]
//│ Nil: Nil
//│    = Nil {}
//│ Cons: ('b & 'head & 'a, List['a] & 'c & 'tail,) -> ((Cons['a] with {head: 'head, tail: 'tail}) | 'd)
//│     = [Function: Cons1]

// let rec foo =
//   fun xs ->
//     begin match xs with
//       Nil -> Nil
//     | Cons (x,xs) -> Cons (x+1, foo (foo xs))
//     end

:RecursiveTypes // * This used to make the following definition work but it no longer does
:e
rec def foo = fun xs -> case xs of
  { Nil -> Nil
  | Cons -> Cons (xs.head + 1, foo (foo xs.tail))
  }
//│ ╔══[ERROR] Cyclic-looking constraint while typing binding of lambda expression; a type annotation may be required
//│ ║  l.35: 	rec def foo = fun xs -> case xs of
//│ ║        	              ^^^^^^^^^^^^^^^^^^^^
//│ ║  l.36: 	  { Nil -> Nil
//│ ║        	^^^^^^^^^^^^^^^
//│ ║  l.37: 	  | Cons -> Cons (xs.head + 1, foo (foo xs.tail))
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.38: 	  }
//│ ║        	^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  (‹∀ 0. α32'› | α78_100')  <:  α65_105'    ComposedType  TypeVariable
//│ ╙──  ... looks like:  (‹∀ 0. α32'› | α78_91'')  <:  α65_86''
//│ foo: ('b & ((Cons['tail] with {head: int & 'head, tail: 'tail & 'tail0}) & 'c | Nil & 'd)) -> ((Cons['a | int] with {head: 'head0 | int, tail: 'tail1 | 'e}) | Nil | 'f)
//│   where
//│     'e :> (Cons['a | int] with {head: int, tail: 'e}) | Nil
//│     'tail0 <: (Cons['tail] with {head: int & 'head, tail: 'tail0}) | Nil
//│    = [Function: foo]
// * This version works but only with :RecursiveTypes
rec def foo = fun xs -> case xs of
  { Nil -> Nil
  | Cons -> Cons (xs.head + 1, foo xs.tail)
  }
//│ foo: ('b & ((Cons['tail] with {head: int & 'head, tail: 'tail & 'tail0}) & 'c | Nil & 'd)) -> ((Cons['a | int] with {head: 'head0 | int, tail: 'tail1 | 'e}) | Nil | 'f)
//│   where
//│     'e :> (Cons['a | int] with {head: int, tail: 'e}) | Nil
//│     'tail0 <: (Cons['tail] with {head: int & 'head, tail: 'tail0}) | Nil
//│    = [Function: foo1]
:NoRecursiveTypes


// (* Type def: ba = forall b.(int->b->b)->b->b *)
// type ba = ['b] (int -> 'b -> 'b) -> 'b -> 'b
// (* z can be typed more polymorphic. *)
// type baa = ['a, 'b] ('a  -> 'b -> 'b)-> 'b -> 'b 
type Ba = forall 'b. (int -> 'b -> 'b) -> 'b -> 'b
type Baa = forall 'a 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│ Defined type alias Ba
//│ Defined type alias Baa


// LP: this Baa type is a bit weird. It's equivalent to:
def b: (nothing -> 'b -> 'b) -> 'b -> 'b
//│ b: (nothing -> 'b -> 'b) -> 'b -> 'b
//│  = <missing implementation>

// LP: indeed:
b: Baa
//│ res: Baa
//│    = <no result>
//│      b is not implemented
:ng
b = error: Baa
//│ Baa
//│   <:  b:
//│ (nothing -> 'b -> 'b) -> 'b -> 'b



// (* build and foldr *)
// let build = 
//   fun (g : ['b] (('a -> 'b -> 'b) -> 'b -> 'b)) -> 
//     g (fun x xs -> Cons (x,xs)) Nil

:e // works with :RecursiveTypes
def build = fun (g: forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> g (fun x -> fun xs -> Cons (x, xs)) Nil
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.103: 	def build = fun (g: forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> g (fun x -> fun xs -> Cons (x, xs)) Nil
//│ ║         	                                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  (cons<> & {head: head26_304'', tail: tail27_301'', Cons#a: mut a22_302''..a22_302''})  <:  List[a22_302'']    ComposedType  TypeRef
//│ ╙──  ... looks like:  (cons<> & {head: head26_298'''', tail: tail27_295'''', Cons#a: mut a22_296''''..a22_296''''})  <:  List[a22_296'''']
//│ build: (forall 'b. (('a & 'c & 'a0) -> 'b -> 'b) -> 'b -> 'b) -> (error | 'd)
//│      = [Function: build]

// * ^ Not sure why this one only works with recursive types:
:RecursiveTypes
// :e // FIXME? refreshing-extr
def build = fun (g: forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> g (fun x -> fun xs -> Cons (x, xs)) Nil
//│ build: (forall 'b. (('a & 'c & 'a0) -> 'b -> 'b) -> 'b -> 'b) -> ('tail | 'd)
//│   where
//│     'tail :> (Cons['a0 | 'c] with {head: 'head | 'c, tail: 'tail}) | Nil
//│      = [Function: build1]
:NoRecursiveTypes


def build_ = fun g -> g (fun x -> fun xs -> Cons (x, xs)) Nil
//│ build_: ((forall 'b. 'b -> (forall 'c, 'd, 'e, 'head, 'tail, 'a. (List['a] & 'd & 'c & 'tail) -> ((Cons['a | 'b] with {head: 'head | 'b, tail: 'tail}) | 'e))) -> (Nil -> 'f & 'g) & 'h) -> 'f
//│       = [Function: build_]

:e
build_ : forall 'a. (forall 'b. (('a -> 'b -> 'b) -> 'b -> 'b)) -> List['a]
//│ ╔══[ERROR] Cyclic-looking constraint while typing type ascription; a type annotation may be required
//│ ║  l.129: 	build_ : forall 'a. (forall 'b. (('a -> 'b -> 'b) -> 'b -> 'b)) -> List['a]
//│ ║         	^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  (cons<> & {head: head26_479', tail: tail27_476', Cons#a: mut a22_477'..a22_477'})  <:  List[‘a_461']    ComposedType  TypeRef
//│ ╙──  ... looks like:  (cons<> & {head: head26_473'''', tail: tail27_470'''', Cons#a: mut a22_471''''..a22_471''''})  <:  List[‘a_461']
//│ res: (forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> List['a]
//│    = [Function: build_]


class Ls[A] method Head: A
def cons: ('a, Ls['a]) -> Ls['a]
def nil: Ls['a]
//│ Defined class Ls[+A]
//│ Declared Ls.Head: Ls['A] -> 'A
//│ cons: ('a, Ls['a],) -> Ls['a]
//│     = <missing implementation>
//│ nil: Ls[nothing]
//│    = <missing implementation>

// :e // FIXME? refreshing-extr
def build2 = fun (g: forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> g (fun x -> fun xs -> cons (x, xs)) nil
//│ build2: (forall 'b. (('a & 'c) -> 'b -> 'b) -> 'b -> 'b) -> (Ls['a0 | 'c] | 'd)
//│       = <no result>
//│         cons is not implemented

def build2_ = fun g -> g (fun x -> fun xs -> cons (x, xs)) nil
//│ build2_: ((forall 'b. 'b -> (forall 'a, 'c, 'd. (Ls['a] & 'c) -> (Ls['a | 'b] | 'd))) -> (Ls['d] -> 'e & 'f) & 'g) -> 'e
//│        = <no result>
//│          cons is not implemented

build2_ : forall 'a. (forall 'b. (('a -> 'b -> 'b) -> 'b -> 'b)) -> Ls['a]
//│ res: (forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> Ls['a]
//│    = <no result>
//│      build2_ and cons are not implemented


// let rec foldr =
//   fun k z xs -> 
//     begin match xs with
//       Nil -> z
//     | Cons (x, xs) -> k x (foldr k z xs)
//     end
rec def foldr = fun k -> fun z -> fun xs ->
  case xs of
    { Nil -> z
    | Cons -> k xs.head (foldr k z xs.tail)
    }
//│ foldr: ('head -> (('a | 'b) -> 'c & 'd) & 'e & 'head0 -> 'a -> 'a) -> (forall 'f. ('a & 'f) -> (forall 'head1, 'g, 'tail, 'h, 'i, 'j. ('j & ((Cons['tail] with {head: 'head & 'head1, tail: 'tail & 'tail0}) & 'h | Nil & 'i)) -> ('f | 'g | 'c)))
//│   where
//│     'tail0 <: (Cons['tail] with {head: 'head0, tail: 'tail0}) | Nil
//│      = [Function: foldr]


// (* encoding `foo' with foldr *)

// let (z : baa) = fun c n -> n
def z = (fun c -> fun n -> n) : Baa
def z_ = fun c -> fun n -> n
//│ z: Baa
//│  = [Function: z]
//│ z_: 'a -> (forall 'b. 'b -> 'b)
//│   = [Function: z_]


// let rec (k : int -> ba -> ba) = fun x (xs : ba) c n -> c (x+1) (xs k z c n)

def k: int -> Ba -> Ba
//│ k: int -> Ba -> Ba
//│  = <missing implementation>

// * The following tests don't benefit from `:RecursiveTypes`
// :RecursiveTypes

:e
rec def k = fun x -> fun (xs: Ba) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.205: 	rec def k = fun x -> fun (xs: Ba) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.73: 	type Ba = forall 'b. (int -> 'b -> 'b) -> 'b -> 'b
//│ ║        	                 ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.73: 	type Ba = forall 'b. (int -> 'b -> 'b) -> 'b -> 'b
//│ ║        	                 ^^
//│ ╟── from quantified type variable:
//│ ║  l.74: 	type Baa = forall 'a 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│ ╙──      	                     ^^
//│ (int & 'c) -> Ba -> (forall 'd, 'e, 'f, 'g, 'h, 'a, 'i, 'b, 'b0. ('a -> 'b -> ('b & 'b0) & (int | 'd) -> (('b0 | 'j | 'h) -> 'f & 'e) & 'i & 'g -> anything -> anything & (int | 'd) -> anything -> 'j) -> (forall 'g. nothing -> ('g | 'f)))
//│   <:  k:
//│ int -> Ba -> Ba
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.205: 	rec def k = fun x -> fun (xs: Ba) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.73: 	type Ba = forall 'b. (int -> 'b -> 'b) -> 'b -> 'b
//│ ║        	                 ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.73: 	type Ba = forall 'b. (int -> 'b -> 'b) -> 'b -> 'b
//│ ║        	                 ^^
//│ ╟── from quantified type variable:
//│ ║  l.74: 	type Baa = forall 'a 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│ ╙──      	                     ^^
//│  = [Function: k]

:e
rec def k = fun x -> fun xs -> fun c -> fun n -> c (x + 1) (xs k z_ c n)
//│ 'k
//│   where
//│     'k :> forall 'a. (int & 'a) -> (forall 'b, 'c, 'd, 'e, 'f, 'g, 'h. 'f -> (forall 'i, 'j, 'l, 'm, 'n. ((int | 'm) -> (('c | 'n) -> 'i & 'j) & 'h & 'l) -> (forall 'o, 'p. ('e & 'o) -> ('p | 'i))))
//│     'f <: 'k -> ((forall 'q. 'q -> (forall 'r. 'r -> 'r)) -> ('h -> ('e -> 'c & 'b) & 'd) & 'g)
//│   <:  k:
//│ int -> Ba -> Ba
//│ ╔══[ERROR] Cyclic-looking constraint while typing def definition; a type annotation may be required
//│ ║  l.236: 	rec def k = fun x -> fun xs -> fun c -> fun n -> c (x + 1) (xs k z_ c n)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 3. (α953_1137'''' -> ‹∀ 4. (α954_1142''''' -> α970_1143''''')›)›  <:  α952_1106    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 3. (α953_1060'''' -> ‹∀ 4. (α954_1065''''' -> α970_1066''''')›)›  <:  α952_1053'''
//│  = [Function: k1]

rec def k_ = fun x -> fun xs -> fun c -> fun n -> c (x + 1) (xs k_ z_ c n)
//│ k_: 'k_
//│   where
//│     'k_ :> forall 'a. (int & 'a) -> (forall 'b, 'c, 'd, 'e, 'f, 'g, 'h. 'e -> (forall 'i, 'j, 'k, 'l, 'm. ((int | 'l) -> (('h | 'k) -> 'j & 'i) & 'd & 'm) -> (forall 'n, 'o. ('g & 'n) -> ('o | 'j))))
//│     'e <: 'k_ -> ((forall 'p. 'p -> (forall 'q. 'q -> 'q)) -> ('d -> ('g -> 'h & 'b) & 'c) & 'f)
//│   = [Function: k_]


// (* untyped terms *)
// (* let z = fun c -> fun n -> n *)
// (* let rec k = fun x xs c cn -> c (x+1) (xs k z c n) *)

// (* System F terms *)
// (* let z = /\b -> fun (c : int -> b -> b) -> fun (n : b) -> n *)
// (* let rec (k : int -> (forall b.(int->b->b)->b->b)			*)
// (*	            -> (forall b.(int->b->b)->b->b)) =			*)
// (*     \(a : int) -> \(as : forall b.(int->b->b)->b->b) ->		*)
// (*         /\b -> \(c : int->b->b) -> \(n : b) ->			*)
// (*             ((as[forall b.(int->b->b)->b->b] k z)[b] c z)		*)


// (* definition with build and foldr *)
// let bfoo xs = build (foldr k z xs)

// :e // FIXME? fails with genLamBodies
def bfoo xs = build (foldr k z xs)
//│ bfoo: ('b & 'c & ((Cons['head] with {head: int & 'head0 & 'head1, tail: 'tail & 'd}) & 'e | Nil & 'f)) -> ('tail0 | 'g)
//│   where
//│     'tail0 :> (Cons['a | 'head2 | int | 'h] with {head: 'head2 | int | 'h, tail: 'tail0}) | Nil
//│     'd <: Cons['head] & 'i | Nil & 'j
//│     'i <: {head: int & 'head1 & 'head3 & 'head, tail: 'd}
//│     = [Function: bfoo]

// FIXedME // works with quantif extrus
:e // due to tapping
def bfoo_ xs = build_ (foldr k_ z_ xs)
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.286: 	def bfoo_ xs = build_ (foldr k_ z_ xs)
//│ ║         	                       ^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 3. (α1149_1564'''' -> ‹∀ 4. (α1150_1569''''' -> α1166_1570''''')›)›  <:  ((k_1146_1493''#,) -> α1157_1534'')    PolymorphicType  FunctionType
//│ ╙──  ... looks like:  ‹∀ 3. (α1149_1503'''' -> ‹∀ 4. (α1150_1508''''' -> α1166_1509''''')›)›  <:  ((k_1146'#,) -> α1157_1497''')
//│ bfoo_: 'a -> (error | 'b)
//│      = [Function: bfoo_]


lst = Cons (0, Cons (0, Cons (0, Nil)))
//│ lst: Cons[0] with {tail: Cons[0] with {tail: Cons[0] with {tail: Nil}}}
//│    = Cons {
//│        head: 0,
//│        tail: Cons { head: 0, tail: Cons { head: 0, tail: Nil {} } }
//│      }

// (* test run *)
// let lst0 = Cons (0, Cons (0, Cons (0, Cons (0, Nil))));;
lst0 = Cons (0, Cons (0, Cons (0, Cons (0, Nil))))
//│ lst0: Cons[0] with {tail: Cons[0] with {tail: Cons[0] with {tail: Cons[0] with {tail: Nil}}}}
//│     = Cons {
//│         head: 0,
//│         tail: Cons { head: 0, tail: Cons { head: 0, tail: [Cons] } }
//│       }

// foo lst0;;
foo lst0
//│ res: 'a
//│   where
//│     'a :> (Cons[int] with {tail: 'a}) | Nil
//│    = Cons {
//│        head: 1,
//│        tail: Cons { head: 1, tail: Cons { head: 1, tail: [Cons] } }
//│      }

// bfoo lst0;;
bfoo lst0
//│ res: 'tail
//│   where
//│     'tail :> (Cons[int] with {tail: 'tail}) | Nil
//│    = Cons {
//│        head: 1,
//│        tail: Cons { head: 2, tail: Cons { head: 4, tail: [Cons] } }
//│      }

// :e // FIXME?
bfoo_ lst0
//│ res: error
//│    = Cons {
//│        head: 1,
//│        tail: Cons { head: 2, tail: Cons { head: 4, tail: [Cons] } }
//│      }


// (* This does not type :
// type baa = ['a, 'b] ('a  -> 'b -> 'b)-> 'b -> 'b
//   let rec (k : int -> baa -> baa) = fun x (xs : baa) c n -> c (x+1) (xs k z c n)
// *)
def k: int -> Baa -> Baa
//│ k: int -> Baa -> Baa
//│  = <missing implementation>

:e
rec def k = fun x -> fun (xs: Baa) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.351: 	rec def k = fun x -> fun (xs: Baa) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.74: 	type Baa = forall 'a 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│ ║        	                     ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.74: 	type Baa = forall 'a 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│ ╙──      	                     ^^
//│ (int & 'c) -> Baa -> (forall 'd, 'a, 'e, 'f, 'g, 'b, 'h, 'i, 'b0. ('a -> 'b -> ('b & 'b0) & (int | 'h) -> (('b0 | 'j | 'g) -> 'e & 'd) & 'i & 'f -> anything -> anything & (int | 'h) -> anything -> 'j) -> (forall 'f. nothing -> ('f | 'e)))
//│   <:  k:
//│ int -> Baa -> Baa
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.351: 	rec def k = fun x -> fun (xs: Baa) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.74: 	type Baa = forall 'a 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│ ║        	                     ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.74: 	type Baa = forall 'a 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│ ╙──      	                     ^^
//│  = [Function: k2]

:e // FIXME?
def k = fun x -> fun (xs: Baa) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ (int & 'c) -> Baa -> (forall 'b, 'd, 'e, 'b0, 'a, 'f, 'b1, 'g, 'h, 'b2, 'a0. ((int | 'h) -> (('b2 | 'b | 'e) -> 'f & 'd) & 'a0 -> 'b1 -> ('b1 & 'b) & 'a -> 'b0 -> ('b0 & 'b2) & 'g) -> (forall 'b3, 'i, 'j, 'b4, 'k. ('b1 & 'b0 & 'e & 'j & 'b4 & 'i & 'b3) -> ('k | 'f)))
//│   <:  k:
//│ int -> Baa -> Baa
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.376: 	def k = fun x -> fun (xs: Baa) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── operator application of type `int` is not an instance of type `'a_2061`
//│ ║  l.376: 	def k = fun x -> fun (xs: Baa) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ║         	                                                       ^^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.74: 	type Baa = forall 'a 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│ ╙──      	                  ^^
//│  = [Function: k3]

// * Using `k` here on purpose to simulate an annotated rec def
def k_ = fun x -> fun xs -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ k_: (int & 'a) -> (forall 'b, 'c, 'd, 'e, 'f, 'g, 'h. ((int -> Baa -> Baa) -> (Baa -> ('e -> ('c -> 'b & 'h) & 'f) & 'd) & 'g) -> (forall 'i, 'j, 'k, 'l, 'm. ((int | 'i) -> (('b | 'j) -> 'l & 'k) & 'e & 'm) -> (forall 'n, 'o. ('c & 'n) -> ('o | 'l))))
//│   = [Function: k_1]

rec def k_ = fun x -> fun xs -> fun c -> fun n -> c (x + 1) (xs k_ z c n)
//│ k_: 'k_
//│   where
//│     'k_ :> forall 'a. (int & 'a) -> (forall 'b, 'c, 'd, 'e, 'f, 'g, 'h. 'g -> (forall 'i, 'j, 'k, 'l, 'm. ((int | 'm) -> (('b | 'i) -> 'j & 'k) & 'e & 'l) -> (forall 'n, 'o. ('c & 'n) -> ('o | 'j))))
//│     'g <: 'k_ -> (Baa -> ('e -> ('c -> 'b & 'h) & 'f) & 'd)
//│   = [Function: k_2]

// k = k_ // nope

rec def k_ = fun x -> fun xs -> fun c -> fun n -> c (x + 1) (xs k_ z_ c n)
//│ k_: 'k_
//│   where
//│     'k_ :> forall 'a. (int & 'a) -> (forall 'b, 'c, 'd, 'e, 'f, 'g, 'h. 'e -> (forall 'i, 'j, 'k, 'l, 'm. ((int | 'k) -> (('c | 'j) -> 'l & 'm) & 'h & 'i) -> (forall 'n, 'o. ('f & 'n) -> ('o | 'l))))
//│     'e <: 'k_ -> ((forall 'p. 'p -> (forall 'q. 'q -> 'q)) -> ('h -> ('f -> 'c & 'b) & 'g) & 'd)
//│   = [Function: k_3]

// k = k_ // nope


