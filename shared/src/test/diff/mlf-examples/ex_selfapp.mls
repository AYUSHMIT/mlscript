:GeneralizeCurriedFunctions

// (*
//  * This example was written by Susumu NISHIMURA 
//  * According to him, it requires impredicative polymorphism.
//  *)

// (* my list definition *)

// type mylist ('b) = Nil | Cons of ('b * mylist ('b));;
class Nil
class Cons[a]: { head: a; tail: List[a] }
type List[a] = Nil | Cons[a]
def Nil = Nil {}
def Cons (head, tail) = Cons { head; tail }
//│ Defined class Nil
//│ Defined class Cons[+a]
//│ Defined type alias List[+a]
//│ Nil: Nil
//│    = Nil {}
//│ Cons: ('head & 'a, List['a] & 'tail,) -> (Cons['a] with {head: 'head, tail: 'tail})
//│     = [Function: Cons1]

// let rec foo =
//   fun xs ->
//     begin match xs with
//       Nil -> Nil
//     | Cons (x,xs) -> Cons (x+1, foo (foo xs))
//     end
rec def foo = fun xs -> case xs of
  { Nil -> Nil
  | Cons -> Cons (xs.head + 1, foo (foo xs.tail))
  }
//│ foo: 'a -> 'tail
//│   where
//│     'tail :> (Cons[int] with {tail: 'tail}) | Nil
//│     'a <: (Cons[?] with {head: int, tail: 'a}) | Nil
//│    = [Function: foo]



// (* Type def: ba = forall b.(int->b->b)->b->b *)
// type ba = ['b] (int -> 'b -> 'b) -> 'b -> 'b
// (* z can be typed more polymorphic. *)
// type baa = ['a, 'b] ('a  -> 'b -> 'b)-> 'b -> 'b 
type Ba = forall 'b. (int -> 'b -> 'b) -> 'b -> 'b
type Baa = forall 'a 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│ Defined type alias Ba
//│ Defined type alias Baa

// (* build and foldr *)
// let build = 
//   fun (g : ['b] (('a -> 'b -> 'b) -> 'b -> 'b)) -> 
//     g (fun x xs -> Cons (x,xs)) Nil
def build = fun (g: forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> g (fun x -> fun xs -> Cons (x, xs)) Nil
def build' = fun g -> g (fun x -> fun xs -> Cons (x, xs)) Nil
//│ build: (forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> 'tail
//│   where
//│     'tail :> (Cons['a] with {tail: 'tail}) | Nil
//│      = [Function: build]
//│ build': ((forall 'b. 'b -> (forall 'a, 'tail. (List['a] & 'tail) -> (Cons['a | 'b] with {head: 'b, tail: 'tail}))) -> Nil -> 'c) -> 'c
//│       = [Function: build]

// let rec foldr =
//   fun k z xs -> 
//     begin match xs with
//       Nil -> z
//     | Cons (x, xs) -> k x (foldr k z xs)
//     end
rec def foldr = fun k -> fun z -> fun xs ->
  case xs of
    { Nil -> z
    | Cons -> k xs.head (foldr k z xs.tail)
    }
//│ foldr: ('head -> 'a -> 'a) -> 'a -> 'b -> 'a
//│   where
//│     'b <: (Cons[?] with {head: 'head, tail: 'b}) | Nil
//│      = [Function: foldr]


// (* encoding `foo' with foldr *)

// let (z : baa) = fun c n -> n
def z = (fun c -> fun n -> n) : Baa
def z' = fun c -> fun n -> n
//│ z: Baa
//│  = [Function: z]
//│ z': anything -> (forall 'a. 'a -> 'a)
//│   = [Function: z]

// let rec (k : int -> ba -> ba) = fun x (xs : ba) c n -> c (x+1) (xs k z c n)
// FIXME
def k: int -> Ba -> Ba
rec def k = fun x -> fun (xs: Ba) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ k: int -> Ba -> Ba
//│  = <missing implementation>
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.94: 	rec def k = fun x -> fun (xs: Ba) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ║        	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.46: 	type Ba = forall 'b. (int -> 'b -> 'b) -> 'b -> 'b
//│ ║        	                 ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.46: 	type Ba = forall 'b. (int -> 'b -> 'b) -> 'b -> 'b
//│ ║        	                 ^^
//│ ╟── from quantified type variable:
//│ ║  l.47: 	type Baa = forall 'a 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│ ╙──      	                     ^^
//│ int -> Ba -> (nothing -> anything -> nothing & int -> anything -> nothing) -> anything -> anything
//│   <:  k:
//│ int -> Ba -> Ba
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.94: 	rec def k = fun x -> fun (xs: Ba) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.46: 	type Ba = forall 'b. (int -> 'b -> 'b) -> 'b -> 'b
//│ ║        	                 ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.46: 	type Ba = forall 'b. (int -> 'b -> 'b) -> 'b -> 'b
//│ ╙──      	                 ^^
//│  = [Function: k]

rec def k' = fun x -> fun xs -> fun c -> fun n -> c (x + 1) (xs k z' c n)
//│ k': int -> ((int -> Ba -> Ba) -> (anything -> (forall 'a. 'a -> 'a)) -> 'b -> 'c -> 'd) -> (forall 'e. (int -> 'd -> 'e & 'b) -> 'c -> 'e)
//│   = [Function: k]


// (* untyped terms *)
// (* let z = fun c -> fun n -> n *)
// (* let rec k = fun x xs c cn -> c (x+1) (xs k z c n) *)

// (* System F terms *)
// (* let z = /\b -> fun (c : int -> b -> b) -> fun (n : b) -> n *)
// (* let rec (k : int -> (forall b.(int->b->b)->b->b)			*)
// (*	            -> (forall b.(int->b->b)->b->b)) =			*)
// (*     \(a : int) -> \(as : forall b.(int->b->b)->b->b) ->		*)
// (*         /\b -> \(c : int->b->b) -> \(n : b) ->			*)
// (*             ((as[forall b.(int->b->b)->b->b] k z)[b] c z)		*)


// (* definition with build and foldr *)
// let bfoo xs = build (foldr k z xs)
def bfoo xs = build (foldr k z xs)
//│ bfoo: 'a -> 'tail
//│   where
//│     'tail :> (Cons[int] with {tail: 'tail}) | Nil
//│     'a <: (Cons[?] with {head: int, tail: 'a}) | Nil
//│     = [Function: bfoo]

// FIXME
def bfoo' xs = build' (foldr k' z' xs)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.151: 	def bfoo' xs = build' (foldr k' z' xs)
//│ ║         	               ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?b -> (forall ?c. ?c -> ?c)` does not match type `Cons[?a] | Nil`
//│ ║  l.85: 	def z' = fun c -> fun n -> n
//│ ║        	         ^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.13: 	type List[a] = Nil | Cons[a]
//│ ║        	               ^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.56: 	def build' = fun g -> g (fun x -> fun xs -> Cons (x, xs)) Nil
//│ ╙──      	                                                     ^^
//│ bfoo': 'a -> error
//│   where
//│     'a <: (Cons[?] with {head: int, tail: 'a}) | Nil
//│      = [Function: bfoo]


// (* test run *)
// let lst0 = Cons (0, Cons (0, Cons (0, Cons (0, Nil))));;
// FIXME: spurious cycle
def lst0 = Cons (0, Cons (0, Cons (0, Cons (0, Nil))))
//│ ╔══[ERROR] Cyclic-looking constraint while typing application
//│ ║  l.173: 	def lst0 = Cons (0, Cons (0, Cons (0, Cons (0, Nil))))
//│ ║         	                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  (cons<> & {head: head455', tail: tail458', Cons#a: mut a456'..a456'})  <:  List[a472']    ComposedType  TypeRef
//│ ╙──  ... looks like:  (cons<> & {head: head33'', tail: tail35'', Cons#a: mut a34''..a34''})  <:  List[a34'']
//│ ╔══[ERROR] Cyclic-looking constraint while typing application
//│ ║  l.173: 	def lst0 = Cons (0, Cons (0, Cons (0, Cons (0, Nil))))
//│ ║         	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  (cons<> & {head: head463', tail: tail466', Cons#a: mut a464'..a464'})  <:  List[a479']    ComposedType  TypeRef
//│ ╙──  ... looks like:  (cons<> & {head: head33'', tail: tail35'', Cons#a: mut a34''..a34''})  <:  List[a34'']
//│ lst0: (Cons[0] with {tail: (Cons[0] with {tail: Cons[0] with {tail: Cons[0] with {tail: Nil}}}) | error}) | error
//│     = Cons {
//│         head: 0,
//│         tail: Cons { head: 0, tail: Cons { head: 0, tail: [Cons] } }
//│       }

// foo lst0;;
foo lst0
//│ res: 'tail
//│   where
//│     'tail :> (Cons[int] with {tail: 'tail}) | Nil
//│    = Cons {
//│        head: 1,
//│        tail: Cons { head: 2, tail: Cons { head: 4, tail: [Cons] } }
//│      }

// bfoo lst0;;
bfoo lst0
bfoo' lst0
//│ res: 'tail
//│   where
//│     'tail :> (Cons[int] with {tail: 'tail}) | Nil
//│    = Cons {
//│        head: 1,
//│        tail: Cons { head: 2, tail: Cons { head: 4, tail: [Cons] } }
//│      }
//│ res: error
//│    = Cons {
//│        head: 1,
//│        tail: Cons { head: 2, tail: Cons { head: 4, tail: [Cons] } }
//│      }


// (* This does not type :
// type baa = ['a, 'b] ('a  -> 'b -> 'b)-> 'b -> 'b
//   let rec (k : int -> baa -> baa) = fun x (xs : baa) c n -> c (x+1) (xs k z c n)
// *)
:e
def k: int -> Baa -> Baa
rec def k = fun x -> fun (xs: Baa) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ k: int -> Baa -> Baa
//│  = <missing implementation>
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.225: 	rec def k = fun x -> fun (xs: Baa) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.47: 	type Baa = forall 'a 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│ ║        	                     ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.47: 	type Baa = forall 'a 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│ ╙──      	                     ^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.225: 	rec def k = fun x -> fun (xs: Baa) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── operator application of type `int` does not match type `nothing`
//│ ║  l.225: 	rec def k = fun x -> fun (xs: Baa) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ║         	                                                           ^^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.47: 	type Baa = forall 'a 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│ ╙──      	                  ^^
//│ int -> Baa -> (nothing -> anything -> nothing & int -> anything -> nothing) -> anything -> anything
//│   <:  k:
//│ int -> Baa -> Baa
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.225: 	rec def k = fun x -> fun (xs: Baa) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.47: 	type Baa = forall 'a 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│ ║        	                     ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.47: 	type Baa = forall 'a 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│ ╙──      	                     ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.225: 	rec def k = fun x -> fun (xs: Baa) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── operator application of type `int` does not match type `nothing`
//│ ║  l.225: 	rec def k = fun x -> fun (xs: Baa) -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ ║         	                                                           ^^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.47: 	type Baa = forall 'a 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│ ╙──      	                  ^^
//│  = [Function: k1]

rec def k' = fun x -> fun xs -> fun c -> fun n -> c (x + 1) (xs k z c n)
//│ k': int -> (forall 'a, 'b, 'c. ((int -> Baa -> Baa) -> Baa -> 'a -> 'b -> 'c) -> (forall 'd. (int -> 'c -> 'd & 'a) -> 'b -> 'd))
//│   = [Function: k1]
