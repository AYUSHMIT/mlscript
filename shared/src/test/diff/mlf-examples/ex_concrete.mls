:NoRecursiveTypes
:GeneralizeCurriedFunctions

// type mylist ('b) = Nil | Cons of ('b * mylist ('b))
// ;;
class Nil
class Cons[a]: { head: a; tail: List[a] }
type List[a] = Nil | Cons[a]
def Nil = Nil {}
def Cons (head, tail) = Cons { head; tail }
//│ Defined class Nil
//│ Defined class Cons[+a]
//│ Defined type alias List[+a]
//│ Nil: Nil
//│    = [Function: Nil1]
//│ Cons: ('head & 'a, List['a] & 'tail,) -> (Cons['a] with {head: 'head, tail: 'tail})
//│     = [Function: Cons1]

// let un = Nil ;;
// let deux = Nil ;;
// let trois = Cons (10, un) ;;
// let quatre = Cons ("ok", deux) ;;
// let cinq = Cons ("zozo", quatre) ;;
def un = Nil
def deux = Nil
def trois = Cons (10, un)
def quatre = Cons ("ok", deux)
def cinq = Cons ("zozo", quatre)
//│ un: Nil
//│   = [Function: un]
//│ deux: Nil
//│     = [Function: deux]
//│ trois: Cons[10] with {tail: Nil}
//│      = [Function: trois]
//│ quatre: Cons["ok"] with {tail: Nil}
//│       = [Function: quatre]
//│ cinq: Cons["ok" | "zozo"] with {head: "zozo", tail: Cons["ok"] with {tail: Nil}}
//│     = [Function: cinq]

// let id x = x 
def id x = x
//│ id: 'a -> 'a
//│   = [Function: id]

// let rec mymap f l =
//   begin match l with
//   | Nil -> Nil
//   | Cons (car,cdr) -> Cons (f car, mymap f cdr) 
//   end
:RecursiveTypes // needed for this recursive def
rec def map f l = case l of
  { Nil -> Nil
  | Cons -> Cons (f l.head, map f l.tail)
  }
//│ map: ('head -> 'head0) -> 'a -> 'tail
//│   where
//│     'tail :> (Cons['head0] with {tail: 'tail}) | Nil
//│     'a <: (Cons[?] with {head: 'head, tail: 'a}) | Nil
//│    = [Function: map]
:NoRecursiveTypes



