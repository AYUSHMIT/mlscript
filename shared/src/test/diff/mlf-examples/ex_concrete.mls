:NoRecursiveTypes
:GeneralizeCurriedFunctions

// type mylist ('b) = Nil | Cons of ('b * mylist ('b))
// ;;
class Nil
class Cons[a]: { head: a; tail: List[a] }
type List[a] = Nil | Cons[a]
Nil = Nil {}
Cons (head, tail) = Cons { head; tail }
//│ Defined class Nil
//│ Defined class Cons[+a]
//│ Defined type alias List[+a]
//│ Nil: Nil
//│    = Nil {}
//│ Cons: ('b & 'head & 'a, List['a] & 'c & 'tail,) -> ((Cons['a] with {head: 'head, tail: 'tail}) | 'd)
//│     = [Function: Cons1]

// let un = Nil ;;
// let deux = Nil ;;
// let trois = Cons (10, un) ;;
// let quatre = Cons ("ok", deux) ;;
// let cinq = Cons ("zozo", quatre) ;;
un = Nil
deux = Nil
trois = Cons (10, un)
quatre = Cons ("ok", deux)
cinq = Cons ("zozo", quatre)
//│ un: Nil
//│   = Nil {}
//│ deux: Nil
//│     = Nil {}
//│ trois: Cons[10] with {tail: Nil}
//│      = Cons { head: 10, tail: Nil {} }
//│ quatre: Cons["ok"] with {tail: Nil}
//│       = Cons { head: 'ok', tail: Nil {} }
//│ cinq: Cons["ok" | "zozo"] with {head: "zozo", tail: Cons["ok"] with {tail: Nil}}
//│     = Cons { head: 'zozo', tail: Cons { head: 'ok', tail: Nil {} } }

// let id x = x 
def id x = x
//│ id: 'a -> 'a
//│   = [Function: id]

// let rec mymap f l =
//   begin match l with
//   | Nil -> Nil
//   | Cons (car,cdr) -> Cons (f car, mymap f cdr) 
//   end
:RecursiveTypes // needed for this recursive def
rec def map f l = case l of
  { Nil -> Nil
  | Cons -> Cons (f l.head, map f l.tail)
  }
//│ map: ('head -> 'b & 'c & 'head0 -> 'a) -> (forall 'd, 'tail, 'a0, 'tail0, 'e, 'f, 'head1, 'head2, 'g. ('f & ((Cons['tail] with {head: 'head & 'head2, tail: 'tail & 'tail1}) & 'e | Nil & 'g)) -> ((Cons['a | 'a0 | 'b] with {head: 'head1 | 'b, tail: 'tail0 | 'h}) | Nil | 'd))
//│   where
//│     'h :> (Cons['a] with {tail: 'h}) | Nil
//│     'tail1 <: (Cons['tail] with {head: 'head0, tail: 'tail1}) | Nil
//│    = [Function: map]
:NoRecursiveTypes



