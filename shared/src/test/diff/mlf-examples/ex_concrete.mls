:NoRecursiveTypes
:GeneralizeCurriedFunctions

// type mylist ('b) = Nil | Cons of ('b * mylist ('b))
// ;;
class Nil
class Cons[a]: { head: a; tail: List[a] }
type List[a] = Nil | Cons[a]
def Nil = Nil {}
def Cons (head, tail) = Cons { head; tail }
//│ Defined class Nil
//│ Defined class Cons[+a]
//│ Defined type alias List[+a]
//│ Nil: Nil
//│    = Nil {}
//│ Cons: ('b, 'c,) -> (forall 'b, 'c, 'a. (Cons['a | 'b] with {head: 'b, tail: 'c}
//│   where
//│     'c <: List['a]
//│     'c <: List['a]))
//│     = [Function: Cons1]

// let un = Nil ;;
// let deux = Nil ;;
// let trois = Cons (10, un) ;;
// let quatre = Cons ("ok", deux) ;;
// let cinq = Cons ("zozo", quatre) ;;
def un = Nil
def deux = Nil
def trois = Cons (10, un)
def quatre = Cons ("ok", deux)
def cinq = Cons ("zozo", quatre)
//│ un: Nil
//│   = Nil {}
//│ deux: Nil
//│     = Nil {}
//│ trois: Cons[10 | 'a] with {head: 10, tail: 'b}
//│   where
//│     'b <: List['a]
//│     'b <: List['a]
//│      = Cons { head: 10, tail: Nil {} }
//│ quatre: Cons["ok" | 'a] with {head: "ok", tail: 'b}
//│   where
//│     'b <: List['a]
//│     'b <: List['a]
//│       = Cons { head: 'ok', tail: Nil {} }
//│ cinq: Cons["zozo" | 'a] with {head: "zozo", tail: 'b}
//│   where
//│     'b <: List['a]
//│     'b <: List['a]
//│     = Cons { head: 'zozo', tail: Cons { head: 'ok', tail: Nil {} } }

// let id x = x 
def id x = x
//│ id: 'a -> 'a
//│   = [Function: id]

// let rec mymap f l =
//   begin match l with
//   | Nil -> Nil
//   | Cons (car,cdr) -> Cons (f car, mymap f cdr) 
//   end
:RecursiveTypes // needed for this recursive def
rec def map f l = case l of
  { Nil -> Nil
  | Cons -> Cons (f l.head, map f l.tail)
  }
//│ map: ('head -> 'a) -> 'b -> 'c
//│   where
//│     'c :> (Cons['a] with {tail: 'c}) | Nil
//│     'b <: (Cons[?] with {head: 'head, tail: 'b}) | Nil
//│    = [Function: map]
:NoRecursiveTypes



