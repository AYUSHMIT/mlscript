:NoRecursiveTypes
:GeneralizeCurriedFunctions
:DistributeForalls

// ============ Dummy classes to represent the types in the examples ============

class List[a]
  method Head: a
  method Tail: List[a]
//│ Defined class List[+a]
//│ Declared List.Head: List['a] -> 'a
//│ Declared List.Tail: List['a] -> List['a]

class Cons[a]: List[a] & { head: a; tail: List[a] }
  method Head = this.head
  method Tail = this.tail
def cons[a]: a -> List[a] -> List[a]
def cons head tail = Cons { head; tail }
//│ Defined class Cons[+a]
//│ Defined Cons.Head: Cons['a] -> 'a
//│ Defined Cons.Tail: Cons['a] -> List['a]
//│ cons: 'a -> List['a] -> List['a]
//│     = <missing implementation>
//│ 'b -> (forall 'c. (List['c] & 'c) -> (forall 'b, 'c, 'head, 'a, 'tail. (Cons['a] with {head: 'head, tail: 'tail}
//│   where
//│     'b <: 'head & 'a
//│     'c <: List['a] & 'tail
//│     'b <: 'head & 'a
//│     'c <: List['a] & 'tail)))
//│   <:  cons:
//│ 'a -> List['a] -> List['a]
//│ /!!!\ Uncaught error: java.util.NoSuchElementException: key not found: List
//│ 	at: scala.collection.immutable.BitmapIndexedMapNode.apply(HashMap.scala:631)
//│ 	at: scala.collection.immutable.HashMap.apply(HashMap.scala:132)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrain$65(ConstraintSolver.scala:659)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrain$65$adapted(ConstraintSolver.scala:432)
//│ 	at: mlscript.utils.package$GenHelper$.$bar$greater$extension(package.scala:101)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrain$62(ConstraintSolver.scala:432)
//│ 	at: scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:30)
//│ 	at: mlscript.ConstraintSolver.recImpl$1(ConstraintSolver.scala:390)
//│ 	at: mlscript.ConstraintSolver.rec$1(ConstraintSolver.scala:375)

class Nil[a]: List[a]
  method Head = error
  method Tail = this
def nil: List['a]
def nil = Nil {}
//│ Defined class Nil[+a]
//│ Defined Nil.Head: Nil[?] -> nothing
//│ Defined Nil.Tail: (Nil['a] & 'this) -> (Nil['a] & 'this)
//│ nil: List[nothing]
//│    = <missing implementation>
//│ Nil[nothing]
//│   <:  nil:
//│ List[nothing]
//│    = Nil {}

// ============ Type signatures for functions used in the examples ============

def head: forall 'a. List['a] -> 'a
def head l = l.Head
//│ head: List['a] -> 'a
//│     = <missing implementation>
//│ (List['a] & 'a) -> (forall 'a, 'b. ('b
//│   where
//│     'a <: List['b]))
//│   <:  head:
//│ List['a] -> 'a
//│ /!!!\ Uncaught error: java.util.NoSuchElementException: key not found: List
//│ 	at: scala.collection.immutable.BitmapIndexedMapNode.apply(HashMap.scala:631)
//│ 	at: scala.collection.immutable.HashMap.apply(HashMap.scala:132)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrain$65(ConstraintSolver.scala:659)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrain$65$adapted(ConstraintSolver.scala:432)
//│ 	at: mlscript.utils.package$GenHelper$.$bar$greater$extension(package.scala:101)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrain$62(ConstraintSolver.scala:432)
//│ 	at: scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:30)
//│ 	at: mlscript.ConstraintSolver.recImpl$1(ConstraintSolver.scala:390)
//│ 	at: mlscript.ConstraintSolver.rec$1(ConstraintSolver.scala:375)

def tail: forall 'a. List['a] -> List['a]
def tail l = l.Tail
//│ tail: List['a] -> List['a]
//│     = <missing implementation>
//│ (List['b] & 'b) -> (forall 'b, 'a. (List['a]
//│   where
//│     'b <: List['a]))
//│   <:  tail:
//│ List['a] -> List['a]
//│ /!!!\ Uncaught error: java.util.NoSuchElementException: key not found: List
//│ 	at: scala.collection.immutable.BitmapIndexedMapNode.apply(HashMap.scala:631)
//│ 	at: scala.collection.immutable.HashMap.apply(HashMap.scala:132)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrain$65(ConstraintSolver.scala:659)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrain$65$adapted(ConstraintSolver.scala:432)
//│ 	at: mlscript.utils.package$GenHelper$.$bar$greater$extension(package.scala:101)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrain$62(ConstraintSolver.scala:432)
//│ 	at: scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:30)
//│ 	at: mlscript.ConstraintSolver.recImpl$1(ConstraintSolver.scala:390)
//│ 	at: mlscript.ConstraintSolver.rec$1(ConstraintSolver.scala:375)

def is_empty: forall 'a. List['a] -> bool
def is_empty l = eq l nil
//│ is_empty: List[?] -> bool
//│         = <missing implementation>
//│ 'a -> (forall 'a. (bool
//│   where
//│     'a <: 'a))
//│   <:  is_empty:
//│ List[?] -> bool
//│         = [Function: is_empty]



// (* Use the value restriction ! *)

// type option ('a) = None | Some of 'a
class None
class Some[a]: { val: a }
type Option[a] = None | Some[a]
def None = None {}
def Some val = Some { val }
//│ Defined class None
//│ Defined class Some[+a]
//│ Defined type alias Option[+a]
//│ None: None
//│     = None {}
//│ Some: 'a -> (forall 'a, 'val. (Some['val]
//│   where
//│     'a <: 'val
//│     'a <: 'val))
//│     = [Function: Some1]

// let create_hashtbl () = []
def create_hashtbl _ = nil
//│ create_hashtbl: anything -> List[nothing]
//│               = [Function: create_hashtbl]

// let hashtbl_add table key element = (key, element) :: table
def hashtbl_add table key element = cons ((key, element)) table
//│ hashtbl_add: (List['a] & 'a) -> (forall 'b. 'b -> (forall 'c. 'c -> (forall 'a, 'b, 'c, 'd. (List[('b, 'c,) | 'd]
//│   where
//│     'a <: List['d]))))
//│            = [Function: hashtbl_add]

// let rec find table key = 
//   if nil table then None
//   else if fst (car table) = key then Some (snd (car table))
//   else find (cdr table) key

:RecursiveTypes // needed for this recursive def
rec def find table key =
  if is_empty table then None
  else if eq (head table)._1 key then Some (head table)._2
  else find (tail table) key
//│ find: List[?] -> anything -> (None | Some[nothing])
//│     = [Function: find]
:NoRecursiveTypes

// ^ FIXME type pp error
// :ns
// find

:ng
find(error:List[(int, string)])(unit)
//│ res: None | Some[nothing]

def find_A: forall 'a 'b. List[('a, 'b)] -> 'a -> (None | Some['b])
//│ find_A: List[(anything, 'b,)] -> anything -> (None | Some['b])
//│       = <missing implementation>

// :e // FIXME?
def find_A table key =
  if is_empty table then None
  else if eq (head table)._1 key then Some (head table)._2
  else find_A (tail table) key
//│ (List['a] & 'c) -> (forall 'd. 'd -> (forall 'a, 'c, 'd, 'val, 'b. (None | Some['val] | Some['b]
//│   where
//│     'c <: List['a] & List[{_1: 'a}] & List[{_2: 'a & 'val}] & List[('a, 'b,)]
//│     'd <: 'a
//│     'a <: 'val
//│     'c <: List['a] & List[{_1: 'a}] & List[{_2: 'a & 'val}] & List[('a, 'b,)]
//│     'd <: 'a
//│     'a <: 'val
//│     'c <: List['a] & List[{_1: 'a}] & List[{_2: 'a & 'val}] & List[('a, 'b,)]
//│     'd <: 'a
//│     'c <: List['a] & List[{_1: 'a}] & List[{_2: 'a & 'val}] & List[('a, 'b,)]
//│     'd <: 'a
//│     'c <: List['a] & List[{_1: 'a}] & List[{_2: 'a & 'val}] & List[('a, 'b,)]
//│     'd <: 'a)))
//│   <:  find_A:
//│ List[(anything, 'b,)] -> anything -> (None | Some['b])
//│ /!!!\ Uncaught error: java.util.NoSuchElementException: key not found: List
//│ 	at: scala.collection.immutable.BitmapIndexedMapNode.apply(HashMap.scala:631)
//│ 	at: scala.collection.immutable.HashMap.apply(HashMap.scala:132)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrain$65(ConstraintSolver.scala:659)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrain$65$adapted(ConstraintSolver.scala:432)
//│ 	at: mlscript.utils.package$GenHelper$.$bar$greater$extension(package.scala:101)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrain$62(ConstraintSolver.scala:432)
//│ 	at: scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:30)
//│ 	at: mlscript.ConstraintSolver.recImpl$1(ConstraintSolver.scala:390)
//│ 	at: mlscript.ConstraintSolver.rec$1(ConstraintSolver.scala:375)

// let nfind table key =
//   begin match find table key with
//   | None -> fun f x -> x
//   | Some n -> n
//   end
def nfind table key =
  let opt = find table key in
  case opt of
  { None -> fun f -> fun x -> x
  | Some -> opt.val
  }
//│ nfind: List[?] -> anything -> anything -> (forall 'a. 'a -> 'a)
//│      = [Function: nfind]

// type Int = ['a] ('a -> 'a) -> ('a -> 'a)
type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ Defined type alias ChurchInt

// let succ (n:Int) = fun f x -> f (n f x)
def succ (n: ChurchInt) = fun f -> fun x -> f (n f x)
def succ_ n = fun f -> fun x -> f (n f x)
//│ succ: ChurchInt -> (forall 'b. (nothing -> anything & 'b) -> (forall 'c, 'a, 'd, 'e. ('e -> (forall 'b, 'e, 'f, 'g, 'h. ('h
//│   where
//│     'f <: 'b -> 'e -> 'g
//│     'b <: 'g -> 'h))
//│   where
//│     'c <: 'a -> 'a
//│     'd :> 'a -> 'a)))
//│     = [Function: succ]
//│ succ_: (nothing -> nothing -> 'a & 'a) -> (forall 'b. (nothing -> 'a & 'b) -> (forall 'c. 'c -> (forall 'a, 'b, 'c, 'd, 'e. ('e
//│   where
//│     'a <: 'b -> 'c -> 'd
//│     'b <: 'd -> 'e))))
//│      = [Function: succ_]

// let add (n:Int) (m:Int) = n succ m

//:e // due to tapping
def add (n: ChurchInt) (m: ChurchInt) = n succ m
//│ /!!!\ Uncaught error: java.util.NoSuchElementException: key not found: ChurchInt
//│ 	at: scala.collection.immutable.BitmapIndexedMapNode.apply(HashMap.scala:635)
//│ 	at: scala.collection.immutable.BitmapIndexedMapNode.apply(HashMap.scala:633)
//│ 	at: scala.collection.immutable.HashMap.apply(HashMap.scala:132)
//│ 	at: mlscript.TyperDatatypes$TypeRef.expandWith(TyperDatatypes.scala:334)
//│ 	at: mlscript.TyperDatatypes$TypeRef.expand(TyperDatatypes.scala:332)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrain$65(ConstraintSolver.scala:674)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrain$65$adapted(ConstraintSolver.scala:432)
//│ 	at: mlscript.utils.package$GenHelper$.$bar$greater$extension(package.scala:101)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrain$62(ConstraintSolver.scala:432)
//│ 	at: scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)

def add_ n m = n succ_ m
//│ add_: ((forall 'a. (nothing -> nothing -> 'a & 'a) -> (forall 'b. (nothing -> 'a & 'b) -> (forall 'c. 'c -> (forall 'a, 'b, 'c, 'd, 'e. ('e
//│   where
//│     'a <: 'b -> 'c -> 'd
//│     'b <: 'd -> 'e))))) -> nothing -> 'a & 'f) -> (forall 'g. 'g -> (forall 'f. ('h
//│   where
//│     'f <: (forall 'a. (nothing -> nothing -> 'a & 'a) -> (forall 'b. (nothing -> 'a & 'b) -> (forall 'c. 'c -> (forall 'a, 'b, 'c, 'd, 'e. ('e
//│   where
//│     'a <: 'b -> 'c -> 'd
//│     'b <: 'd -> 'e))))) -> 'g -> 'h)))
//│     = [Function: add_]

// let printInt (n:Int) = print (n (fun x -> x+1) 0)
def printInt (n: ChurchInt) = toString (n (fun x -> x + 1) 0)
def printInt_ n = toString (n (fun x -> x + 1) 0)
//│ printInt: ChurchInt -> (forall 'a. (string
//│   where
//│     'a <: (int -> int) -> 0 -> anything))
//│         = [Function: printInt]
//│ printInt_: ((int -> int) -> 0 -> 'a & 'a) -> (forall 'a. (string
//│   where
//│     'a <: (int -> int) -> 0 -> 'a))
//│          = [Function: printInt_]

// let table = create_hashtbl ()
// let table = hashtbl_add table "one" (fun f x -> f x)
// let table = hashtbl_add table "two" (fun f x -> f (f x))
table = create_hashtbl null
table = hashtbl_add table "one" (fun f -> fun x -> f x)
table = hashtbl_add table "two" (fun f -> fun x -> f (f x))
//│ table: List[nothing]
//│      = Nil {}
//│ /!!!\ Uncaught error: java.util.NoSuchElementException: key not found: List
//│ 	at: scala.collection.immutable.BitmapIndexedMapNode.apply(HashMap.scala:631)
//│ 	at: scala.collection.immutable.HashMap.apply(HashMap.scala:132)
//│ 	at: mlscript.TyperDatatypes$TypeRef.expandWith(TyperDatatypes.scala:334)
//│ 	at: mlscript.TyperDatatypes$TypeRef.expand(TyperDatatypes.scala:332)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrain$65(ConstraintSolver.scala:675)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrain$65$adapted(ConstraintSolver.scala:432)
//│ 	at: mlscript.utils.package$GenHelper$.$bar$greater$extension(package.scala:101)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrain$62(ConstraintSolver.scala:432)
//│ 	at: scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:30)

// let zog =
//   printInt (add (nfind table "one") (nfind table "two"))

// :e // FIXME? failed with genLamBodies but works with quantif extrus
// * Note: this one requires `:DistributeForalls`
//:e // due to tapping
zog = printInt (add (nfind table "one") (nfind table "two"))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.307: 	zog = printInt (add (nfind table "one") (nfind table "two"))
//│ ║         	                ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> (forall ?b. ?b -> ?b)` is not an instance of type `int`
//│ ║  l.214: 	  { None -> fun f -> fun x -> x
//│ ║         	            ^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into application with expected type `int`
//│ ║  l.307: 	zog = printInt (add (nfind table "one") (nfind table "two"))
//│ ╙──       	                     ^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.307: 	zog = printInt (add (nfind table "one") (nfind table "two"))
//│ ║         	                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> (forall ?b. ?b -> ?b)` is not an instance of type `int`
//│ ║  l.214: 	  { None -> fun f -> fun x -> x
//│ ║         	            ^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into application with expected type `int`
//│ ║  l.307: 	zog = printInt (add (nfind table "one") (nfind table "two"))
//│ ╙──       	                                         ^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.307: 	zog = printInt (add (nfind table "one") (nfind table "two"))
//│ ║         	      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `int` is not a function
//│ ║  l.307: 	zog = printInt (add (nfind table "one") (nfind table "two"))
//│ ║         	                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from function type:
//│ ║  l.221: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║         	                            ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.270: 	def printInt (n: ChurchInt) = toString (n (fun x -> x + 1) 0)
//│ ╙──       	                 ^^^^^^^^^
//│ zog: error | string
//│   where
//│     'a <: (int -> int) -> 0 -> anything
//│    = '0'

// Repro:

// :e // FIXME? failed with genLamBodies but works with quantif extrus
//:e // due to tapping
a = add (nfind table "one")
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.347: 	a = add (nfind table "one")
//│ ║         	    ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> (forall ?b. ?b -> ?b)` is not an instance of type `int`
//│ ║  l.214: 	  { None -> fun f -> fun x -> x
//│ ║         	            ^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into application with expected type `int`
//│ ║  l.347: 	a = add (nfind table "one")
//│ ╙──       	         ^^^^^^^^^^^^^^^^^
//│ a: int -> int | error
//│  = [Function (anonymous)]

b = (nfind table "two")
//│ b: anything -> (forall 'a. 'a -> 'a)
//│  = [Function (anonymous)]

// * Note: this one requires `:DistributeForalls`
// :d
//:e // due to tapping
a b
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.367: 	a b
//│ ║         	^^^
//│ ╟── function of type `?a -> (forall ?b. ?b -> ?b)` is not an instance of type `int`
//│ ║  l.214: 	  { None -> fun f -> fun x -> x
//│ ║         	            ^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `int`
//│ ║  l.367: 	a b
//│ ╙──       	  ^
//│ res: error | int
//│    = [Function (anonymous)]

//:e // due to tapping
zog_ = printInt_ (add_ (nfind table "one") (nfind table "two"))
//│ zog_: string
//│   where
//│     'a <: (int -> int) -> 0 -> anything
//│     = '0'

