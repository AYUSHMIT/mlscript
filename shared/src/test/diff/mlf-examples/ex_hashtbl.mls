:NoRecursiveTypes
:GeneralizeCurriedFunctions
:DistributeForalls

// ============ Dummy classes to represent the types in the examples ============

class List[a]
  method Head: a
  method Tail: List[a]
//│ Defined class List[+a]
//│ Declared List.Head: List['a] -> 'a
//│ Declared List.Tail: List['a] -> List['a]

class Cons[a]: List[a] & { head: a; tail: List[a] }
  method Head = this.head
  method Tail = this.tail
def cons[a]: a -> List[a] -> List[a]
def cons head tail = Cons { head; tail }
//│ Defined class Cons[+a]
//│ Defined Cons.Head: Cons['a] -> 'a
//│ Defined Cons.Tail: Cons['a] -> List['a]
//│ cons: 'a -> List['a] -> List['a]
//│     = <missing implementation>
//│ 'b -> (forall 'b, 'head, 'a, 'c, 'tail, 'd. ('c -> 'd
//│   where
//│     'b <: 'head & 'a
//│     'c <: List['a] & 'tail
//│     'd :> Cons['a] with {head: 'head, tail: 'tail}))
//│   where
//│     'e :> Cons['a0] with {head: 'head0, tail: 'tail0}
//│     'b <: 'head0 & 'a0
//│     'f <: List['a0] & 'tail0
//│   <:  cons:
//│ 'a -> List['a] -> List['a]
//│     = [Function: cons]

class Nil[a]: List[a]
  method Head = error
  method Tail = this
def nil: List['a]
def nil = Nil {}
//│ Defined class Nil[+a]
//│ Defined Nil.Head: Nil[?] -> nothing
//│ Defined Nil.Tail: (Nil['a] & 'this) -> (Nil['a] & 'this)
//│ nil: List[nothing]
//│    = <missing implementation>
//│ Nil[nothing]
//│   <:  nil:
//│ List[nothing]
//│    = Nil {}

// ============ Type signatures for functions used in the examples ============

def head: forall 'a. List['a] -> 'a
def head l = l.Head
//│ head: List['a] -> 'a
//│     = <missing implementation>
//│ 'b -> 'c
//│   where
//│     'a <: 'c
//│     'b <: List['a]
//│   <:  head:
//│ List['a] -> 'a
//│     = [Function: head]

def tail: forall 'a. List['a] -> List['a]
def tail l = l.Tail
//│ tail: List['a] -> List['a]
//│     = <missing implementation>
//│ 'b -> 'c
//│   where
//│     'b <: List['a]
//│     'c :> List['a]
//│   <:  tail:
//│ List['a] -> List['a]
//│     = [Function: tail]

def is_empty: forall 'a. List['a] -> bool
def is_empty l = eq l nil
//│ is_empty: List[?] -> bool
//│         = <missing implementation>
//│ 'a -> 'b
//│   where
//│     'a <: 'a
//│     'c :> 'a -> bool
//│        <: List[nothing] -> 'b
//│   <:  is_empty:
//│ List[?] -> bool
//│         = [Function: is_empty]



// (* Use the value restriction ! *)

// type option ('a) = None | Some of 'a
class None
class Some[a]: { val: a }
type Option[a] = None | Some[a]
def None = None {}
def Some val = Some { val }
//│ Defined class None
//│ Defined class Some[+a]
//│ Defined type alias Option[+a]
//│ None: None
//│     = None {}
//│ Some: 'a -> 'b
//│   where
//│     'a <: 'val
//│     'b :> Some['val]
//│     = [Function: Some1]

// let create_hashtbl () = []
def create_hashtbl _ = nil
//│ create_hashtbl: anything -> List[nothing]
//│               = [Function: create_hashtbl]

// let hashtbl_add table key element = (key, element) :: table
def hashtbl_add table key element = cons ((key, element)) table
//│ hashtbl_add: 'a -> (forall 'a, 'b, 'c, 'd. ('d -> (forall 'a, 'd, 'e, 'f, 'g, 'h. ('h -> 'g
//│   where
//│     'e :> List['f] -> List['f]
//│        <: 'a -> 'g
//│     'f :> ('d, 'h,)))
//│   where
//│     'b :> List['c] -> List['c]
//│        <: 'a -> anything
//│     'c :> ('d, nothing,)))
//│   where
//│     'i :> List['j] -> List['j]
//│        <: 'a -> anything
//│     'j :> (nothing, nothing,)
//│            = [Function: hashtbl_add]

// let rec find table key = 
//   if nil table then None
//   else if fst (car table) = key then Some (snd (car table))
//   else find (cdr table) key

:RecursiveTypes // needed for this recursive def
rec def find table key =
  if is_empty table then None
  else if eq (head table)._1 key then Some (head table)._2
  else find (tail table) key
//│ find: List[?] -> anything -> (None | Some[nothing])
//│     = [Function: find]
:NoRecursiveTypes

// ^ FIXME type pp error
// :ns
// find

:ng
find(error:List[(int, string)])(unit)
//│ res: None | Some[string]

def find_A: forall 'a 'b. List[('a, 'b)] -> 'a -> (None | Some['b])
//│ find_A: List[(anything, 'b,)] -> anything -> (None | Some['b])
//│       = <missing implementation>

:e // FIXME?
def find_A table key =
  if is_empty table then None
  else if eq (head table)._1 key then Some (head table)._2
  else find_A (tail table) key
//│ 'c -> (forall 'c, 'd, 'a, 'a0, 'a1, 'e, 'f, 'g, 'h, 'i, 'j, 'k, 'l, 'm, 'n, 'o, 'p, 'q, 'r. ('s -> 't
//│   where
//│     'c <: List['d] & List['a] & List['a0] & List['a1]
//│     'e := bool
//│     'f :> forall 'u. 'u -> 'u -> 'u
//│        <: None -> 'g
//│     'g <: 'v -> 't
//│     'h <: {_1: 'i}
//│     'a <: 'h
//│     'i <: 'd
//│     'j :> 'd -> bool
//│        <: 's -> 'k
//│     'k <: bool
//│     'l :> forall 'u. 'u -> 'u -> 'u
//│        <: 'w -> 'm
//│     'n <: {_2: 'o}
//│     'a0 <: 'n
//│     'o <: 'd
//│     'd <: 'val
//│     'p :> Some['val]
//│        <: 'w
//│     'm <: 'x -> 'v
//│     'q :> List['a1]
//│        <: List[('d, 'b,)]
//│     'r :> 'd -> (None | Some['b])
//│        <: 's -> 'x))
//│   where
//│     'y := bool
//│     'z :> forall 'u. 'u -> 'u -> 'u
//│        <: None -> 'a1
//│     'c <: List['d] & List['a2] & List['a3] & List['a4]
//│     'a1 <: 'b1 -> 'd
//│     'c1 <: {_1: 'd1}
//│     'a2 <: 'c1
//│     'd1 <: 'd
//│     'e1 :> 'd -> bool
//│         <: nothing -> 'f1
//│     'f1 <: bool
//│     'g1 :> forall 'u. 'u -> 'u -> 'u
//│         <: 'h1 -> 'i1
//│     'j1 <: {_2: 'k1}
//│     'a3 <: 'j1
//│     'k1 <: 'l1
//│     'l1 <: 'val0
//│     'm1 :> Some['val0]
//│         <: 'h1
//│     'i1 <: 'n1 -> 'b1
//│     'o1 :> List['a4]
//│         <: List[('d, 'b0,)]
//│     'p1 :> 'd -> (None | Some['b0])
//│         <: nothing -> 'n1
//│   <:  find_A:
//│ List[(anything, 'b,)] -> anything -> (None | Some['b])
//│ ╔══[ERROR] Cyclic-looking constraint while typing def definition
//│ ║  l.161: 	def find_A table key =
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.162: 	  if is_empty table then None
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.163: 	  else if eq (head table)._1 key then Some (head table)._2
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.164: 	  else find_A (tail table) key
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  (None | Some['b414_733''])  <:  α20_763''    ComposedType  TypeVariable
//│ ╙──  ... looks like:  (None | Some['b414_477''])  <:  α20'
//│ ╔══[ERROR] Cyclic-looking constraint while typing def definition
//│ ║  l.161: 	def find_A table key =
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.162: 	  if is_empty table then None
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.163: 	  else if eq (head table)._1 key then Some (head table)._2
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.164: 	  else find_A (tail table) key
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  (None | Some['b414_793''])  <:  α20_794''    ComposedType  TypeVariable
//│ ╙──  ... looks like:  (None | Some['b414_762'''])  <:  α20'
//│       = <no result>
//│         find_A is not implemented

// let nfind table key =
//   begin match find table key with
//   | None -> fun f x -> x
//   | Some n -> n
//   end
def nfind table key =
  let opt = find table key in
  case opt of
  { None -> fun f -> fun x -> x
  | Some -> opt.val
  }
//│ nfind: List['a] -> (forall 'a, 'val, 'b. ('a -> ('a -> (forall 'c. 'c -> 'c) | 'val)
//│   where
//│     'a <: {val: 'val}
//│     'b <: None | Some['a] & 'a))
//│   where
//│     'd <: {val: 'a}
//│     'e <: None | Some['a] & 'd
//│      = [Function: nfind]

// type Int = ['a] ('a -> 'a) -> ('a -> 'a)
type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ Defined type alias ChurchInt

// let succ (n:Int) = fun f x -> f (n f x)
def succ (n: ChurchInt) = fun f -> fun x -> f (n f x)
def succ_ n = fun f -> fun x -> f (n f x)
//│ succ: ChurchInt -> (forall 'a, 'b, 'c, 'd, 'e, 'f. ('d -> (forall 'b, 'c, 'd, 'g, 'h, 'i. ('i -> 'h
//│   where
//│     'b <: 'd -> 'c
//│     'd <: 'g -> 'h
//│     'c <: 'i -> 'g))
//│   where
//│     'b <: 'd -> 'e
//│     'd <: 'f -> 'c
//│     'e <: 'a -> 'f))
//│   where
//│     'j <: 'a -> 'k
//│     'b :> ChurchInt
//│        <: ChurchInt & 'a -> 'j
//│     'a <: 'k -> 'c
//│     = [Function: succ]
//│ succ_: 'a -> (forall 'b, 'c, 'a, 'd, 'e, 'f. ('f -> (forall 'c, 'a, 'f, 'g, 'h, 'i. ('g -> 'i
//│   where
//│     'c <: 'g -> 'h
//│     'a <: 'f -> 'c
//│     'f <: 'h -> 'i))
//│   where
//│     'd <: 'b -> 'e
//│     'a <: 'f -> 'd
//│     'f <: 'e -> 'c))
//│   where
//│     'j <: 'b -> 'k
//│     'b <: 'k -> 'c
//│     'a <: 'b -> 'j
//│      = [Function: succ_]

// let add (n:Int) (m:Int) = n succ m

:e // due to tapping
def add (n: ChurchInt) (m: ChurchInt) = n succ m
//│ ╔══[ERROR] Type mismatch in lambda expression:
//│ ║  l.305: 	def add (n: ChurchInt) (m: ChurchInt) = n succ m
//│ ║         	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘a1142` is not an instance of type `'a`
//│ ║  l.266: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║         	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.266: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ╙──       	                        ^^
//│ add: ChurchInt -> (forall 'a, 'b, 'c. (ChurchInt -> 'd
//│   where
//│     'a <: (forall 'e, 'b, 'f, 'g, 'h, 'c. (ChurchInt -> (forall 'b, 'g, 'c, 'i, 'j, 'k. ('i -> (forall 'g, 'i, 'l, 'm, 'n, 'o. ('o -> 'n
//│   where
//│     'g <: 'i -> 'l
//│     'i <: 'm -> 'n
//│     'l <: 'o -> 'm))
//│   where
//│     'g <: 'i -> 'j
//│     'i <: 'k -> 'c
//│     'j <: 'b -> 'k))
//│   where
//│     'e <: 'b -> 'f
//│     'g :> ChurchInt
//│        <: ChurchInt & 'h -> 'e
//│     'h <: 'f -> 'c)) -> 'c
//│     'b := ChurchInt
//│     'c <: 'b -> 'd))
//│   where
//│     'a :> ChurchInt
//│        <: ChurchInt & (forall 'e, 'b, 'f, 'g, 'h, 'c. (ChurchInt -> (forall 'b, 'g, 'c, 'i, 'j, 'k. ('i -> (forall 'g, 'i, 'l, 'm, 'n, 'o. ('o -> 'n
//│   where
//│     'g <: 'i -> 'l
//│     'i <: 'm -> 'n
//│     'l <: 'o -> 'm))
//│   where
//│     'g <: 'i -> 'j
//│     'i <: 'k -> 'c
//│     'j <: 'b -> 'k))
//│   where
//│     'e <: 'b -> 'f
//│     'g :> ChurchInt
//│        <: ChurchInt & 'h -> 'e
//│     'h <: 'f -> 'c)) -> 'p
//│     'q := ChurchInt
//│     'p <: 'q -> 'c
//│    = [Function: add]

def add_ n m = n succ_ m
//│ add_: 'a -> (forall 'a, 'b. ('c -> 'd
//│   where
//│     'a <: (forall 'e, 'f, 'g, 'b, 'h. ('h -> (forall 'f, 'b, 'h, 'i, 'j, 'k. ('k -> (forall 'h, 'k, 'l, 'm, 'n, 'o. ('m -> 'o
//│   where
//│     'l <: 'm -> 'n
//│     'h <: 'k -> 'l
//│     'k <: 'n -> 'o))
//│   where
//│     'i <: 'f -> 'j
//│     'h <: 'k -> 'i
//│     'k <: 'j -> 'b))
//│   where
//│     'e <: 'f -> 'g
//│     'f <: 'g -> 'b
//│     'h <: 'f -> 'e)) -> 'b
//│     'b <: 'c -> 'd))
//│   where
//│     'a <: (forall 'e, 'f, 'g, 'b, 'h. ('h -> (forall 'f, 'b, 'h, 'i, 'j, 'k. ('k -> (forall 'h, 'k, 'l, 'm, 'n, 'o. ('m -> 'o
//│   where
//│     'l <: 'm -> 'n
//│     'h <: 'k -> 'l
//│     'k <: 'n -> 'o))
//│   where
//│     'i <: 'f -> 'j
//│     'h <: 'k -> 'i
//│     'k <: 'j -> 'b))
//│   where
//│     'e <: 'f -> 'g
//│     'f <: 'g -> 'b
//│     'h <: 'f -> 'e)) -> 'p
//│     'p <: 'f -> 'b
//│     = [Function: add_]

// let printInt (n:Int) = print (n (fun x -> x+1) 0)
def printInt (n: ChurchInt) = toString (n (fun x -> x + 1) 0)
def printInt_ n = toString (n (fun x -> x + 1) 0)
//│ printInt: ChurchInt -> 'a
//│   where
//│     'b :> ChurchInt
//│        <: ChurchInt & (forall 'c, 'd, 'e. ('c -> 'e
//│   where
//│     'c <: int
//│     'd :> int -> int
//│        <: 1 -> 'e)) -> 'f
//│     'g <: int
//│     'h :> int -> int
//│        <: 1 -> 'f
//│     'f <: 0 -> 'f
//│     'a :> string
//│         = [Function: printInt]
//│ printInt_: 'a -> 'b
//│   where
//│     'a <: (forall 'c, 'd, 'e. ('c -> 'e
//│   where
//│     'c <: int
//│     'd :> int -> int
//│        <: 1 -> 'e)) -> 'f
//│     'g <: int
//│     'h :> int -> int
//│        <: 1 -> 'f
//│     'f <: 0 -> 'f
//│     'b :> string
//│          = [Function: printInt_]

// let table = create_hashtbl ()
// let table = hashtbl_add table "one" (fun f x -> f x)
// let table = hashtbl_add table "two" (fun f x -> f (f x))
table = create_hashtbl null
table = hashtbl_add table "one" (fun f -> fun x -> f x)
table = hashtbl_add table "two" (fun f -> fun x -> f (f x))
//│ table: List[nothing]
//│      = Nil {}
//│ table: List[("one", forall 'a. ('a -> (forall 'a, 'b, 'c. ('b -> 'c
//│   where
//│     'a <: 'b -> 'c))
//│   where
//│     'a <: nothing -> 'a),)]
//│      = Cons { head: [ 'one', [Function (anonymous)] ], tail: Nil {} }
//│ table: List[("one" | "two", forall 'a, 'b, 'c. (('a & 'c) -> (forall 'a, 'c, 'd, 'e, 'f. ('d -> 'f
//│   where
//│     'a <: 'd -> 'e & 'e -> 'f
//│     'c <: 'd -> 'f))
//│   where
//│     'a <: nothing -> 'b & 'b -> 'c
//│     'c <: nothing -> 'c),)]
//│      = Cons {
//│          head: [ 'two', [Function (anonymous)] ],
//│          tail: Cons { head: [ 'one', [Function (anonymous)] ], tail: Nil {} }
//│        }

// let zog =
//   printInt (add (nfind table "one") (nfind table "two"))

// :e // FIXME? failed with genLamBodies but works with quantif extrus
// * Note: this one requires `:DistributeForalls`
:e // due to tapping
zog = printInt (add (nfind table "one") (nfind table "two"))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.450: 	zog = printInt (add (nfind table "one") (nfind table "two"))
//│ ║         	                ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘a1689` is not an instance of type `'a`
//│ ║  l.266: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║         	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.266: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ╙──       	                        ^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.450: 	zog = printInt (add (nfind table "one") (nfind table "two"))
//│ ║         	                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘a1881` is not an instance of type `'a`
//│ ║  l.266: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║         	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.266: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ╙──       	                        ^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.450: 	zog = printInt (add (nfind table "one") (nfind table "two"))
//│ ║         	      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘a1966` is not an instance of type `'a`
//│ ║  l.266: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║         	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.266: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ╙──       	                        ^^
//│ zog: error | string
//│    = '0'

// Repro:

// :e // FIXME? failed with genLamBodies but works with quantif extrus
:e // due to tapping
a = add (nfind table "one")
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.485: 	a = add (nfind table "one")
//│ ║         	    ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘a2127` is not an instance of type `'a`
//│ ║  l.266: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║         	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.266: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ╙──       	                        ^^
//│ a: ChurchInt -> 'a | error
//│   where
//│     'b <: (forall 'c, 'd, 'e, 'f, 'g, 'h. (ChurchInt -> (forall 'd, 'f, 'h, 'i, 'j, 'k. ('i -> (forall 'f, 'i, 'l, 'm, 'n, 'o. ('o -> 'n
//│   where
//│     'f <: 'i -> 'l
//│     'i <: 'm -> 'n
//│     'l <: 'o -> 'm))
//│   where
//│     'f <: 'i -> 'j
//│     'i <: 'k -> 'h
//│     'j <: 'd -> 'k))
//│   where
//│     'c <: 'd -> 'e
//│     'f :> ChurchInt
//│        <: ChurchInt & 'g -> 'c
//│     'g <: 'e -> 'h)) -> 'h
//│     'd := ChurchInt
//│     'h <: 'd -> 'a
//│  = [Function (anonymous)]

b = (nfind table "two")
//│ b: ('a & 'b) -> (forall 'a, 'b, 'c, 'd, 'e, 'f. (('f & 'c) -> ('e | 'f)
//│   where
//│     'a <: 'c -> 'd & 'd -> 'e
//│     'b <: 'c -> 'e
//│     'a <: 'c -> 'd & 'd -> 'e
//│     'b <: 'c -> 'e))
//│   where
//│     'a <: nothing -> 'g & 'g -> 'b
//│     'b <: nothing -> 'b
//│     'a <: nothing -> 'g & 'g -> 'b
//│     'b <: nothing -> 'b
//│  = [Function (anonymous)]

// * Note: this one requires `:DistributeForalls`
// :d
:e // due to tapping
a b
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.532: 	a b
//│ ║         	^^^
//│ ╟── type `‘a2445` is not an instance of type `'a`
//│ ║  l.266: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║         	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.266: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ╙──       	                        ^^
//│ res: 'a -> (forall 'a, 'b, 'c, 'd, 'e. ('e -> 'd
//│   where
//│     'f <: 'a -> 'b
//│     'a <: 'c -> 'd
//│     'b <: 'e -> 'c)) | error | ChurchInt
//│   where
//│     'f <: 'a -> 'g
//│     'a <: 'h -> 'b
//│     'g <: nothing -> 'h
//│    = [Function (anonymous)]

:e // due to tapping
zog_ = printInt_ (add_ (nfind table "one") (nfind table "two"))
//│ ╔══[ERROR] Subtyping constraint of the form `forall ?a, ?b, ?c, ?d, ?e. (?a -> ?e
//│   where
//│     ?a <: (forall ?f, ?g, ?h. (?f -> ?h
//│   where
//│     ?f <: int
//│     ?g :> int -> int
//│        <: 1 -> ?h)) -> ?d
//│     ?b <: int
//│     ?c :> int -> int
//│        <: 1 -> ?i
//│     ?d <: 0 -> ?j
//│     ?e :> string) <: ?k -> ?l` took too many steps and ran out of fuel (5000)
//│ ║  l.554: 	zog_ = printInt_ (add_ (nfind table "one") (nfind table "two"))
//│ ║         	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟──  + ‹∀ 1. {(α1412'' -> ‹∀ 2. {(α1413''' -> α1414''') where: α1412'' <: ((α1413''',) -> α1414''')}›) where: α1412'' <: ((α1413_1415'',) -> α1414_1416'')}›
//│ ╟──  + ‹∀ 1. {(α1412'' -> ‹∀ 2. {(α1413''' -> α1414''') where: α1412'' <: ((α1413''',) -> α1414''')}›) where: α1412'' <: ((α1413_1415'',) -> α1414_1416'')}›
//│ ╟──  + ‹∀ 1. {(α1412'' -> ‹∀ 2. {(α1413''' -> α1414''') where: α1412'' <: ((α1413''',) -> α1414''')}›) where: α1412'' <: ((α1413_1415'',) -> α1414_1416'')}›
//│ ╟──  + ‹∀ 1. {(α1412'' -> ‹∀ 2. {(α1413''' -> α1414''') where: α1412'' <: ((α1413''',) -> α1414''')}›) where: α1412'' <: ((α1413_1415'',) -> α1414_1416'')}›
//│ ║  l.254: 	  | Some -> opt.val
//│ ║         	            ^^^^^^^
//│ ╟──  + val850_2995'
//│ ║  l.254: 	  | Some -> opt.val
//│ ║         	            ^^^^^^^
//│ ╟──  + (‹∀ 3. (α847'''' -> ‹∀ 4. (α848''''' -> α848''''')›)› | val850_2995')
//│ ╟──  + (‹∀ 3. (α847'''' -> ‹∀ 4. (α848''''' -> α848''''')›)› | val850_2995')
//│ ║  l.554: 	zog_ = printInt_ (add_ (nfind table "one") (nfind table "two"))
//│ ║         	                                            ^^^^^^^^^^^^^^^^^
//│ ╟──  + (‹∀ 3. (α847'''' -> ‹∀ 4. (α848''''' -> α848''''')›)› | val850_2995')
//│ ║  l.554: 	zog_ = printInt_ (add_ (nfind table "one") (nfind table "two"))
//│ ║         	                                            ^^^^^^^^^^^^^^^^^
//│ ╟──  + (‹∀ 3. (α847'''' -> ‹∀ 4. (α848''''' -> α848''''')›)› | val850_2995')
//│ ╟──  + (‹∀ 3. (α847'''' -> ‹∀ 4. (α848''''' -> α848''''')›)› | val850_2995')
//│ ╟──  + (‹∀ 3. (α847'''' -> ‹∀ 4. (α848''''' -> α848''''')›)› | val850_2995')
//│ ║  l.353: 	def add_ n m = n succ_ m
//│ ║         	                       ^
//│ ╟──  + (‹∀ 3. (α847'''' -> ‹∀ 4. (α848''''' -> α848''''')›)› | val850_2995')
//│ ╟──  + (‹∀ 3. (α847'''' -> ‹∀ 4. (α848''''' -> α848''''')›)› | val850_2995')
//│ ╟──  + (‹∀ 3. (α847'''' -> ‹∀ 4. (α848''''' -> α848''''')›)› | val850_2995')
//│ ╟──  + (‹∀ 3. (α847'''' -> ‹∀ 4. (α848''''' -> α848''''')›)› | val850_2995')
//│ ║  l.423: 	table = hashtbl_add table "two" (fun f -> fun x -> f (f x))
//│ ║         	                                                        ^
//│ ╟──  + (‹∀ 3. (α847'''' -> ‹∀ 4. (α848''''' -> α848''''')›)› | val850_2995')
//│ ╟──  + (‹∀ 3. (α847'''' -> ‹∀ 4. (α848''''' -> α848''''')›)› | val850_2995')
//│ ╟──  + α1021_3230'
//│ ╟──  - ((α1022_4249',) -> α1024_4293')
//│ ║  l.271: 	def succ_ n = fun f -> fun x -> f (n f x)
//│ ╙──       	                                   ^^^
//│ zog_: error
//│     = '0'

