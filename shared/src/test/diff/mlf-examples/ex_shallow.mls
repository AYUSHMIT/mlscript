:NoRecursiveTypes
:GeneralizeCurriedFunctions

// type sid = ['a] 'a -> 'a;;
// type nat = ['a] ('a -> 'a) -> 'a -> 'a
type Sid = forall 'a. 'a -> 'a
type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ Defined type alias Sid
//│ Defined type alias ChurchInt

// let auto (x:sid) = x x
// let id x = x
// let k x y = x
def auto (x: Sid) = x x
def auto_ x = x x
def id x = x
def k x y = x
//│ auto: Sid -> 'a
//│   where
//│     'b :> Sid
//│        <: Sid & 'b -> 'a
//│     = [Function: auto]
//│ auto_: 'a -> 'b
//│   where
//│     'a <: 'a -> 'b
//│      = [Function: auto_]
//│ id: 'a -> 'a
//│   = [Function: id]
//│ k: 'a -> anything -> 'a
//│  = [Function: k]

// (* church_zero is like the sequence *)
// let church_zero = fun f -> id
def church_zero = fun f -> id
//│ church_zero: anything -> (forall 'a. 'a -> 'a)
//│            = [Function: church_zero]

// (* church_un is like apply *)
// let church_one = fun f x -> f x
def church_one = fun f -> fun x -> f x
//│ church_one: 'a -> (forall 'a, 'b, 'c. ('b -> 'c
//│   where
//│     'a <: 'b -> 'c))
//│   where
//│     'a <: nothing -> 'a
//│           = [Function: church_one]

// (* church_un is like apply_twice *)
// let church_two = fun f x -> f (f x)
def church_two = fun f -> fun x -> f (f x)
//│ church_two: 'a -> (forall 'a, 'b, 'c, 'd. ('b -> 'd
//│   where
//│     'a <: 'b -> 'c & 'c -> 'd))
//│   where
//│     'a <: nothing -> 'e & 'e -> 'a
//│           = [Function: church_two]

// let church_succ n = fun f x -> f (n f x)
def church_succ n = fun f -> fun x -> f (n f x)
//│ church_succ: 'a -> (forall 'a, 'b, 'c, 'd, 'e, 'f. ('d -> (forall 'a, 'c, 'd, 'g, 'h, 'i. ('i -> 'h
//│   where
//│     'a <: 'd -> 'c
//│     'd <: 'g -> 'h
//│     'c <: 'i -> 'g))
//│   where
//│     'a <: 'd -> 'e
//│     'd <: 'f -> 'c
//│     'e <: 'b -> 'f))
//│   where
//│     'a <: 'b -> 'j
//│     'b <: 'k -> 'c
//│     'j <: 'b -> 'k
//│            = [Function: church_succ]

// (* We build the a0 of the icfp version paper *)
// type a1 = ['b] ['a > sid] ('a -> 'b) -> 'b
// let a1 = fun f -> f id;;
// let a3 = (fun z z' -> z church_two);;
// let a2 (x:a1) =  (x auto); (fun y -> x y; y church_succ) a3;;
// let a0 = a2 a1;;
type A1 = forall 'a 'b. (('a | Sid) -> 'b) -> 'b
def a1 = fun f -> f id
def a3 = fun z -> fun _ -> z church_two
def a2 (x: A1) =
  let _ = x auto in
  (fun y ->
    let _ = x y in
    y church_succ
  ) a3
def a2_ (x: A1) =
  let _ = x auto_ in
  (fun y ->
    let _ = x y in
    y church_succ
  ) a3
def a0 = a2 a1
def a0_ = a2_ a1
//│ Defined type alias A1
//│ a1: 'a -> 'b
//│   where
//│     'a <: (forall 'c. 'c -> 'c) -> 'b
//│   = [Function: a1]
//│ a3: 'a -> (forall 'a. ('b -> 'c
//│   where
//│     'a <: (forall 'b, 'd. ('b -> (forall 'b, 'e, 'f, 'g. ('e -> 'g
//│   where
//│     'b <: 'e -> 'f & 'f -> 'g))
//│   where
//│     'b <: nothing -> 'd & 'd -> 'b)) -> 'c))
//│   where
//│     'a <: (forall 'b, 'd. ('b -> (forall 'b, 'e, 'f, 'g. ('e -> 'g
//│   where
//│     'b <: 'e -> 'f & 'f -> 'g))
//│   where
//│     'b <: nothing -> 'd & 'd -> 'b)) -> 'b
//│   = [Function: a3]
//│ a2: A1 -> 'a
//│   where
//│     'b <: (forall 'c, 'd, 'e, 'f, 'g. ('c -> (forall 'c, 'd, 'g, 'h, 'i, 'j. ('h -> (forall 'c, 'h, 'k, 'l, 'm, 'n. ('n -> 'm
//│   where
//│     'c <: 'h -> 'k
//│     'h <: 'l -> 'm
//│     'k <: 'n -> 'l))
//│   where
//│     'c <: 'h -> 'i
//│     'h <: 'j -> 'g
//│     'i <: 'd -> 'j))
//│   where
//│     'c <: 'd -> 'e
//│     'd <: 'f -> 'g
//│     'e <: 'd -> 'f)) -> 'g
//│     'o :> forall 'p. ('p -> (forall 'p. ('g -> 'q
//│   where
//│     'p <: (forall 'd, 'g, 'r. ('g -> (forall 'g, 's, 't, 'u. ('s -> 'u
//│   where
//│     'g <: 's -> 't & 't -> 'u))
//│   where
//│     'g <: 'd -> 'r & 'r -> 'g)) -> 'q))
//│   where
//│     'p <: (forall 'd, 'g, 'r. ('g -> (forall 'g, 's, 't, 'u. ('s -> 'u
//│   where
//│     'g <: 's -> 't & 't -> 'u))
//│   where
//│     'g <: 'd -> 'r & 'r -> 'g)) -> 'g)
//│        <: (forall 'c, 'd, 'e, 'f, 'g. ('c -> (forall 'c, 'd, 'g, 'h, 'i, 'j. ('h -> (forall 'c, 'h, 'k, 'l, 'm, 'n. ('n -> 'm
//│   where
//│     'c <: 'h -> 'k
//│     'h <: 'l -> 'm
//│     'k <: 'n -> 'l))
//│   where
//│     'c <: 'h -> 'i
//│     'h <: 'j -> 'g
//│     'i <: 'd -> 'j))
//│   where
//│     'c <: 'd -> 'e
//│     'd <: 'f -> 'g
//│     'e <: 'd -> 'f)) -> 'v
//│     'v <: 'a
//│     'w := A1
//│   = [Function: a2]
//│ a2_: A1 -> 'a
//│   where
//│     'b :> forall 'c. ('c -> (forall 'c. ('d -> 'e
//│   where
//│     'c <: (forall 'f, 'd, 'g. ('d -> (forall 'd, 'h, 'i, 'j. ('h -> 'j
//│   where
//│     'd <: 'h -> 'i & 'i -> 'j))
//│   where
//│     'd <: 'f -> 'g & 'g -> 'd)) -> 'e))
//│   where
//│     'c <: (forall 'f, 'd, 'g. ('d -> (forall 'd, 'h, 'i, 'j. ('h -> 'j
//│   where
//│     'd <: 'h -> 'i & 'i -> 'j))
//│   where
//│     'd <: 'f -> 'g & 'g -> 'd)) -> 'd)
//│        <: (forall 'k, 'f, 'l, 'm, 'd. ('k -> (forall 'k, 'f, 'd, 'n, 'o, 'p. ('n -> (forall 'k, 'n, 'q, 'r, 's, 't. ('t -> 's
//│   where
//│     'k <: 'n -> 'q
//│     'n <: 'r -> 's
//│     'q <: 't -> 'r))
//│   where
//│     'k <: 'n -> 'o
//│     'n <: 'p -> 'd
//│     'o <: 'f -> 'p))
//│   where
//│     'k <: 'f -> 'l
//│     'f <: 'm -> 'd
//│     'l <: 'f -> 'm)) -> 'u
//│     'u <: 'a
//│     'v := A1
//│     'w <: (forall 'k, 'f, 'l, 'm, 'd. ('k -> (forall 'k, 'f, 'd, 'n, 'o, 'p. ('n -> (forall 'k, 'n, 'q, 'r, 's, 't. ('t -> 's
//│   where
//│     'k <: 'n -> 'q
//│     'n <: 'r -> 's
//│     'q <: 't -> 'r))
//│   where
//│     'k <: 'n -> 'o
//│     'n <: 'p -> 'd
//│     'o <: 'f -> 'p))
//│   where
//│     'k <: 'f -> 'l
//│     'f <: 'm -> 'd
//│     'l <: 'f -> 'm)) -> 'd
//│    = [Function: a2_]
//│ a0: 'a -> 'b
//│   where
//│     'c <: (forall 'a, 'd. ('a -> (forall 'a, 'e, 'f, 'g. ('e -> 'g
//│   where
//│     'a <: 'e -> 'f & 'f -> 'g))
//│   where
//│     'a <: nothing -> 'd & 'd -> 'a)) -> 'b
//│   = [Function (anonymous)]
//│ a0_: 'a -> 'b
//│   where
//│     'c <: (forall 'a, 'd. ('a -> (forall 'a, 'e, 'f, 'g. ('e -> 'g
//│   where
//│     'a <: 'e -> 'f & 'f -> 'g))
//│   where
//│     'a <: nothing -> 'd & 'd -> 'a)) -> 'b
//│    = [Function (anonymous)]

// let test0 = 
//   (fun f -> f (fun h -> h id))
//     (fun (g:a1) ->
//       k (g (fun (x:sid) -> x x))
//         ((fun t -> (fun u v -> v) (g t) (t (fun f x -> x)))
//            (fun x -> ((fun f x -> f x) x) (fun f x -> x))))
// ;;
def test0 =
  (fun f -> f (fun h -> h id))
    (fun (g: A1) ->
      k (g (fun (x: Sid) -> x x))
        ((fun t -> (fun u -> fun v -> v) (g t) (t (fun f -> fun x -> x)))
          (fun x -> ((fun f -> fun x -> f x) x) (fun f -> fun x -> x))))
def test0_ =
  (fun f -> f (fun h -> h id))
    (fun g ->
      k (g (fun x -> x x))
        ((fun t -> (fun u -> fun v -> v) (g t) (t (fun f -> fun x -> x)))
          (fun x -> ((fun f -> fun x -> f x) x) (fun f -> fun x -> x))))
//│ test0: Sid
//│      = [Function: id]
//│ test0_: 'a -> 'a
//│       = [Function: id]


// (** Encoding in F+eta **)
// (* we repace sa by sb and build a coercion function form sb to sc *)

// type a1_sid = ['b] ['a = sid] ('a -> 'b) -> 'b;;
// type a1_nat = ['b] ['a = nat -> nat] ('a -> 'b) -> 'b;;
type A1_sid = forall 'a 'b. (('a & Sid | Sid) -> 'b) -> 'b
type A1_nat = forall 'a 'b. (('a & ChurchInt -> ChurchInt | ChurchInt -> ChurchInt) -> 'b) -> 'b
//│ Defined type alias A1_sid
//│ Defined type alias A1_nat

// let a1_sid_to_nat (g : a1_sid) =
//   let r = fun f -> g (fun (x : sid) -> f x) in
//   (r : a1_nat);;

:e // due to tapping
def a1_sid_to_nat (g: A1_sid) =
  let r = fun f -> g (fun (x: Sid) -> f x) in
  (r: A1_nat)
//│ ╔══[ERROR] Type mismatch in lambda expression:
//│ ║  l.262: 	def a1_sid_to_nat (g: A1_sid) =
//│ ║         	                  ^^^^^^^^^^^^^
//│ ║  l.263: 	  let r = fun f -> g (fun (x: Sid) -> f x) in
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.264: 	  (r: A1_nat)
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── type `‘b1161` is not an instance of type `'b`
//│ ║  l.253: 	type A1_nat = forall 'a 'b. (('a & ChurchInt -> ChurchInt | ChurchInt -> ChurchInt) -> 'b) -> 'b
//│ ║         	                        ^^
//│ ╟── but it flows into application with expected type `‘b`
//│ ║  l.263: 	  let r = fun f -> g (fun (x: Sid) -> f x) in
//│ ║         	                                      ^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.253: 	type A1_nat = forall 'a 'b. (('a & ChurchInt -> ChurchInt | ChurchInt -> ChurchInt) -> 'b) -> 'b
//│ ╙──       	                        ^^
//│ a1_sid_to_nat: A1_sid -> A1_nat
//│   where
//│     'a :> (ChurchInt -> ChurchInt) -> ‘b
//│        <: 'b -> 'c
//│     'd :> A1_sid
//│        <: A1_sid & (forall 'a, 'e, 'f. (Sid -> 'f
//│   where
//│     'a <: 'e -> 'f
//│     'e := Sid)) -> 'c
//│     'b := Sid
//│     'c <: ‘b
//│              = [Function: a1_sid_to_nat]

def a1_sid_to_nat_ g =
  let r = fun f -> g (fun x -> f x) in
  r
//│ a1_sid_to_nat_: ((forall 'a, 'b, 'c. ('b -> 'c
//│   where
//│     'a <: 'b -> 'c)) -> 'd & 'e) -> (forall 'd, 'e. ('d -> 'f
//│   where
//│     'e <: (forall 'd, 'g, 'h. ('g -> 'h
//│   where
//│     'd <: 'g -> 'h)) -> 'f
//│     'd <: nothing -> 'd))
//│               = [Function: a1_sid_to_nat_]

// (* the term is as above but abstract over sb and uses the coercion *)

// let test_in_F_eta = 
//   (fun f -> f (fun h -> h id))
//     (fun (g : a1_sid) ->
//       k (g (fun (x : sid) -> x x))
//         ((fun t -> (fun u v -> v) ((a1_sid_to_nat g) t) (t (fun f x -> x)))
//            (fun x -> ((fun f x -> f x) x) (fun f x -> x))))
// ;;

:e // FIXME?
def test_in_F_eta = 
  (fun f -> f (fun h -> h id))
    (fun (g: A1_sid) ->
      k (g (fun (x : Sid) -> x x))
        ((fun t -> (fun u -> fun v -> v) ((a1_sid_to_nat g) t) (t (fun f -> fun x -> x)))
          (fun x -> ((fun f -> fun x -> f x) x) (fun f -> fun x -> x))))
//│ ╔══[ERROR] Type mismatch in lambda expression:
//│ ║  l.320: 	    (fun (g: A1_sid) ->
//│ ║         	     ^^^^^^^^^^^^^^^^^^
//│ ║  l.321: 	      k (g (fun (x : Sid) -> x x))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.322: 	        ((fun t -> (fun u -> fun v -> v) ((a1_sid_to_nat g) t) (t (fun f -> fun x -> x)))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.323: 	          (fun x -> ((fun f -> fun x -> f x) x) (fun f -> fun x -> x))))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘b1409` is not an instance of type `'b`
//│ ║  l.253: 	type A1_nat = forall 'a 'b. (('a & ChurchInt -> ChurchInt | ChurchInt -> ChurchInt) -> 'b) -> 'b
//│ ║         	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.253: 	type A1_nat = forall 'a 'b. (('a & ChurchInt -> ChurchInt | ChurchInt -> ChurchInt) -> 'b) -> 'b
//│ ║         	                        ^^
//│ ╟── from application:
//│ ║  l.263: 	  let r = fun f -> g (fun (x: Sid) -> f x) in
//│ ╙──       	                   ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in lambda expression:
//│ ║  l.320: 	    (fun (g: A1_sid) ->
//│ ║         	     ^^^^^^^^^^^^^^^^^^
//│ ║  l.321: 	      k (g (fun (x : Sid) -> x x))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.322: 	        ((fun t -> (fun u -> fun v -> v) ((a1_sid_to_nat g) t) (t (fun f -> fun x -> x)))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.323: 	          (fun x -> ((fun f -> fun x -> f x) x) (fun f -> fun x -> x))))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘b1469` is not an instance of type `'b`
//│ ║  l.253: 	type A1_nat = forall 'a 'b. (('a & ChurchInt -> ChurchInt | ChurchInt -> ChurchInt) -> 'b) -> 'b
//│ ║         	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.253: 	type A1_nat = forall 'a 'b. (('a & ChurchInt -> ChurchInt | ChurchInt -> ChurchInt) -> 'b) -> 'b
//│ ║         	                        ^^
//│ ╟── from application:
//│ ║  l.263: 	  let r = fun f -> g (fun (x: Sid) -> f x) in
//│ ╙──       	                   ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.319: 	  (fun f -> f (fun h -> h id))
//│ ║         	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.320: 	    (fun (g: A1_sid) ->
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.321: 	      k (g (fun (x : Sid) -> x x))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.322: 	        ((fun t -> (fun u -> fun v -> v) ((a1_sid_to_nat g) t) (t (fun f -> fun x -> x)))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.323: 	          (fun x -> ((fun f -> fun x -> f x) x) (fun f -> fun x -> x))))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘b1551` is not an instance of type `'b`
//│ ║  l.253: 	type A1_nat = forall 'a 'b. (('a & ChurchInt -> ChurchInt | ChurchInt -> ChurchInt) -> 'b) -> 'b
//│ ║         	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.253: 	type A1_nat = forall 'a 'b. (('a & ChurchInt -> ChurchInt | ChurchInt -> ChurchInt) -> 'b) -> 'b
//│ ║         	                        ^^
//│ ╟── from application:
//│ ║  l.263: 	  let r = fun f -> g (fun (x: Sid) -> f x) in
//│ ╙──       	                   ^^^^^^^^^^^^^^^^^^^^^^^
//│ test_in_F_eta: error | Sid
//│              = [Function: id]

def test_in_F_eta_ = 
  (fun f -> f (fun h -> h id))
    (fun g ->
      k (g (fun x -> x x))
        ((fun t -> (fun u -> fun v -> v) ((a1_sid_to_nat_ g) t) (t (fun f -> fun x -> x)))
          (fun x -> ((fun f -> fun x -> f x) x) (fun f -> fun x -> x))))
//│ test_in_F_eta_: 'a -> 'a
//│               = [Function: id]

// (*
// (* Le terme dans la syntaxe de Joe Wells *)
//   (fn f => f (fn h => h id))
//     (fn g => 
//         k (g (fn x => x x))
//           ((fn t => (fn u v => v) (g t) (t (fn f x => x)))
//              (fn x => ((fn f x => f x) x) (fn f x => x))))

// *)

// (* We can also build a version of a0 that should not be in F+eta. 
// To do that we require x to return its argument. 
// *)

// type a1' = ['a > sid] ('a -> 'a) -> 'a -> 'a;;
type A1' = forall 'a. (('a | Sid) -> ('a | Sid)) -> ('a | Sid) -> ('a | Sid)
//│ Defined type alias A1'

// let either x y = if true then x else y;;
// let a1' = fun f x -> f (f (either id x));;
// let a2' (x:a1') = x auto id; (fun y -> x y church_two; y church_succ) a3;;
// let a0' = a2' a1';;

def either x y = if true then x else y
//│ either: 'a -> (forall 'a, 'b, 'c, 'd, 'e, 'f. ('e -> 'f
//│   where
//│     'c :> 'd -> 'd -> 'd
//│        <: 'a -> 'b
//│     'b <: 'e -> 'f))
//│   where
//│     'g :> 'h -> 'h -> 'h
//│        <: 'a -> 'i
//│     'i <: nothing -> 'b
//│       = [Function: either]

def a1' = fun f -> fun x -> f (f (either id x))
//│ a1': 'a -> (forall 'a, 'b, 'c, 'd, 'e. ('f -> 'g
//│   where
//│     'c :> forall 'h. 'h -> 'h
//│     'a <: 'i -> 'j & 'j -> 'g
//│     'd :> forall 'k, 'l, 'c, 'm, 'n, 'o. ('n -> 'o
//│   where
//│     'k :> 'l -> 'l -> 'l
//│        <: 'c -> 'm
//│     'm <: 'n -> 'o)
//│        <: 'f -> 'i
//│     'e :> 'p -> 'p -> 'p
//│        <: 'c -> 'b
//│     'b <: 'c -> 'b))
//│   where
//│     'a <: 'q -> 'r & 'r -> 'b
//│     's :> forall 'h. 'h -> 'h
//│     't :> forall 'k, 'l, 'c, 'm, 'n, 'o. ('n -> 'o
//│   where
//│     'k :> 'l -> 'l -> 'l
//│        <: 'c -> 'm
//│     'm <: 'n -> 'o)
//│        <: 'c -> 'q
//│     'u :> 'v -> 'v -> 'v
//│        <: 's -> 'w
//│     'w <: 'c -> 'b
//│    = [Function: either]

def a2' (x: A1') =
  let _ = x auto id in
  (fun y ->
    let _ = x y church_two in
    y church_succ
  ) a3
//│ a2': A1' -> 'a
//│   where
//│     'b <: (forall 'c, 'd, 'e, 'f, 'g. ('c -> (forall 'c, 'd, 'g, 'h, 'i, 'j. ('h -> (forall 'c, 'h, 'k, 'l, 'm, 'n. ('n -> 'm
//│   where
//│     'c <: 'h -> 'k
//│     'h <: 'l -> 'm
//│     'k <: 'n -> 'l))
//│   where
//│     'c <: 'h -> 'i
//│     'h <: 'j -> 'g
//│     'i <: 'd -> 'j))
//│   where
//│     'c <: 'd -> 'e
//│     'd <: 'f -> 'g
//│     'e <: 'd -> 'f)) -> 'g
//│     'o :> forall 'p. ('p -> (forall 'p. ('g -> 'q
//│   where
//│     'p <: (forall 'd, 'g, 'r. ('g -> (forall 'g, 's, 't, 'u. ('s -> 'u
//│   where
//│     'g <: 's -> 't & 't -> 'u))
//│   where
//│     'g <: 'd -> 'r & 'r -> 'g)) -> 'q))
//│   where
//│     'p <: (forall 'd, 'g, 'r. ('g -> (forall 'g, 's, 't, 'u. ('s -> 'u
//│   where
//│     'g <: 's -> 't & 't -> 'u))
//│   where
//│     'g <: 'd -> 'r & 'r -> 'g)) -> 'g)
//│        <: (forall 'c, 'd, 'e, 'f, 'g. ('c -> (forall 'c, 'd, 'g, 'h, 'i, 'j. ('h -> (forall 'c, 'h, 'k, 'l, 'm, 'n. ('n -> 'm
//│   where
//│     'c <: 'h -> 'k
//│     'h <: 'l -> 'm
//│     'k <: 'n -> 'l))
//│   where
//│     'c <: 'h -> 'i
//│     'h <: 'j -> 'g
//│     'i <: 'd -> 'j))
//│   where
//│     'c <: 'd -> 'e
//│     'd <: 'f -> 'g
//│     'e <: 'd -> 'f)) -> 'v
//│     'w := A1'
//│     'v <: 'a
//│    = [Function: either]

def a2'_ x =
  let _ = x auto_ id in
  (fun y ->
    let _ = x y church_two in
    y church_succ
  ) a3
//│ a2'_: ('a -> (forall 'a, 'b, 'c. ('b -> (forall 'b, 'd, 'e, 'f. ('d -> 'f
//│   where
//│     'b <: 'd -> 'e & 'e -> 'f))
//│   where
//│     'b <: 'a -> 'c & 'c -> 'b)) -> 'b & (forall 'g, 'h. ('g -> 'h
//│   where
//│     'g <: 'g -> 'h)) -> (forall 'i. 'i -> 'i) -> 'b) -> 'j
//│   where
//│     'k <: (forall 'l, 'a, 'm, 'n, 'b. ('l -> (forall 'l, 'a, 'b, 'o, 'p, 'q. ('o -> (forall 'l, 'o, 'r, 's, 't, 'u. ('u -> 't
//│   where
//│     'l <: 'o -> 'r
//│     'o <: 's -> 't
//│     'r <: 'u -> 's))
//│   where
//│     'l <: 'o -> 'p
//│     'o <: 'q -> 'b
//│     'p <: 'a -> 'q))
//│   where
//│     'l <: 'a -> 'm
//│     'a <: 'n -> 'b
//│     'm <: 'a -> 'n)) -> 'b
//│     'v :> forall 'w. ('w -> (forall 'w. ('b -> 'x
//│   where
//│     'w <: (forall 'a, 'b, 'c. ('b -> (forall 'b, 'd, 'e, 'f. ('d -> 'f
//│   where
//│     'b <: 'd -> 'e & 'e -> 'f))
//│   where
//│     'b <: 'a -> 'c & 'c -> 'b)) -> 'x))
//│   where
//│     'w <: (forall 'a, 'b, 'c. ('b -> (forall 'b, 'd, 'e, 'f. ('d -> 'f
//│   where
//│     'b <: 'd -> 'e & 'e -> 'f))
//│   where
//│     'b <: 'a -> 'c & 'c -> 'b)) -> 'b)
//│        <: (forall 'l, 'a, 'm, 'n, 'b. ('l -> (forall 'l, 'a, 'b, 'o, 'p, 'q. ('o -> (forall 'l, 'o, 'r, 's, 't, 'u. ('u -> 't
//│   where
//│     'l <: 'o -> 'r
//│     'o <: 's -> 't
//│     'r <: 'u -> 's))
//│   where
//│     'l <: 'o -> 'p
//│     'o <: 'q -> 'b
//│     'p <: 'a -> 'q))
//│   where
//│     'l <: 'a -> 'm
//│     'a <: 'n -> 'b
//│     'm <: 'a -> 'n)) -> 'y
//│     'y <: 'j
//│     = [Function: either]

def a0' = a2' a1'
//│ a0': 'a -> 'b
//│   where
//│     'c <: (forall 'a, 'd. ('a -> (forall 'a, 'e, 'f, 'g. ('e -> 'g
//│   where
//│     'a <: 'e -> 'f & 'f -> 'g))
//│   where
//│     'a <: nothing -> 'd & 'd -> 'a)) -> 'b
//│    = [Function: either]

:e // works with quantif extrus
def a0'_ = a2'_ a1'
//│ ╔══[ERROR] Cyclic-looking constraint while typing application
//│ ║  l.573: 	def a0'_ = a2'_ a1'
//│ ║         	           ^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 0. ‹∀ 1. (α46'' -> α46'')››  <:  α36_2835'    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 0. ‹∀ 1. (α46'' -> α46'')››  <:  α36''
//│ a0'_: 'a -> 'b | error
//│   where
//│     'c <: (forall 'a, 'd. ('a -> (forall 'a, 'e, 'f, 'g. ('e -> 'g
//│   where
//│     'a <: 'e -> 'f & 'f -> 'g))
//│   where
//│     'a <: nothing -> 'd & 'd -> 'a)) -> 'b
//│     = [Function: either]

// * ^ Strangely, this one works with recursive types:
:RecursiveTypes
:e // FIXME?
def a0'_ = a2'_ a1'
//│ ╔══[ERROR] Cyclic-looking constraint while typing application
//│ ║  l.592: 	def a0'_ = a2'_ a1'
//│ ║         	           ^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 0. ‹∀ 1. (α46'' -> α46'')››  <:  α36_3076'    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 0. ‹∀ 1. (α46'' -> α46'')››  <:  α36''
//│ a0'_: 'a -> 'b | error
//│   where
//│     'c <: (forall 'a, 'd. ('a -> (forall 'a, 'e, 'f, 'g. ('e -> 'g
//│   where
//│     'a <: 'e -> 'f & 'f -> 'g))
//│   where
//│     'a <: nothing -> 'd & 'd -> 'a)) -> 'b
//│     = [Function: either]
:NoRecursiveTypes

// type a1'_sid = ['a = sid] ('a -> 'a) -> 'a -> 'a;;
// type a1'_nat = ['a = nat] ('a -> 'a) -> 'a -> 'a;;
type A1'_sid = forall 'a. (('a & Sid | Sid) -> ('a & Sid | Sid)) -> ('a & Sid | Sid) -> ('a & Sid | Sid)
type A1'_nat = forall 'a. (('a & ChurchInt | ChurchInt) -> ('a & ChurchInt | ChurchInt)) -> ('a & ChurchInt | ChurchInt) -> ('a & ChurchInt | ChurchInt)
//│ Defined type alias A1'_sid
//│ Defined type alias A1'_nat

// (* There is no coercion from a1'_sid to a1'_nat, hence we can conjecture that a0'
//    is not in F+eta. *)


