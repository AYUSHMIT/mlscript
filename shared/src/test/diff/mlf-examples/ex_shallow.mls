:NoRecursiveTypes
:GeneralizeCurriedFunctions

// type sid = ['a] 'a -> 'a;;
// type nat = ['a] ('a -> 'a) -> 'a -> 'a
type Sid = forall 'a. 'a -> 'a
type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ Defined type alias Sid
//│ Defined type alias ChurchInt

// let auto (x:sid) = x x
// let id x = x
// let k x y = x
def auto (x: Sid) = x x
def auto_ x = x x
def id x = x
def k x y = x
//│ auto: Sid -> (Sid | 'a)
//│     = [Function: auto]
//│ auto_: ('a -> 'b & 'a) -> 'b
//│      = [Function: auto_]
//│ id: 'a -> 'a
//│   = [Function: id]
//│ k: 'a -> (forall 'b. 'b -> 'a)
//│  = [Function: k]

// (* church_zero is like the sequence *)
// let church_zero = fun f -> id
def church_zero = fun f -> id
//│ church_zero: 'a -> (forall 'b. 'b -> 'b)
//│            = [Function: church_zero]

// (* church_un is like apply *)
// let church_one = fun f x -> f x
def church_one = fun f -> fun x -> f x
//│ church_one: ('a -> 'b & 'c) -> (forall 'd, 'e. ('a & 'd) -> ('e | 'b))
//│           = [Function: church_one]

// (* church_un is like apply_twice *)
// let church_two = fun f x -> f (f x)
def church_two = fun f -> fun x -> f (f x)
//│ church_two: (('a | 'b) -> 'c & 'd -> 'b & 'e) -> (forall 'f, 'g. ('d & 'f) -> ('c | 'g))
//│           = [Function: church_two]

// let church_succ n = fun f x -> f (n f x)
def church_succ n = fun f -> fun x -> f (n f x)
//│ church_succ: ('a -> ('b -> 'c & 'd) & 'e) -> (forall 'f, 'g, 'h. (('c | 'f) -> 'g & 'a & 'h) -> (forall 'i, 'j. ('b & 'i) -> ('j | 'g)))
//│            = [Function: church_succ]

// (* We build the a0 of the icfp version paper *)
// type a1 = ['b] ['a > sid] ('a -> 'b) -> 'b
// let a1 = fun f -> f id;;
// let a3 = (fun z z' -> z church_two);;
// let a2 (x:a1) =  (x auto); (fun y -> x y; y church_succ) a3;;
// let a0 = a2 a1;;
type A1 = forall 'a 'b. (('a | Sid) -> 'b) -> 'b
def a1 = fun f -> f id
def a3 = fun z -> fun _ -> z church_two
def a2 (x: A1) =
  let _ = x auto in
  (fun y ->
    let _ = x y in
    y church_succ
  ) a3
def a2_ (x: A1) =
  let _ = x auto_ in
  (fun y ->
    let _ = x y in
    y church_succ
  ) a3
def a0 = a2 a1
def a0_ = a2_ a1
//│ Defined type alias A1
//│ a1: ((forall 'a. 'a -> 'a) -> 'b & 'c) -> 'b
//│   = [Function: a1]
//│ a3: ((forall 'a, 'b, 'c, 'd, 'e. (('d | 'e) -> 'a & 'b -> 'e & 'c) -> (forall 'f, 'g. ('b & 'f) -> ('a | 'g))) -> 'h & 'i) -> (forall 'j, 'k. 'j -> ('k | 'h))
//│   = [Function: a3]
//│ a2: A1 -> (forall 'a. 'a -> (forall 'b, 'c, 'd, 'e. (('f | 'c) -> 'd & ('g | 'h) -> ('f & 'i) & 'j -> 'h & 'e & 'k & 'l) -> (forall 'm, 'n. ('j & 'n & 'o & 'p) -> ('m | 'd)) | 'b | 'q) | 'r)
//│   = [Function: a2]
//│ a2_: A1 -> (forall 'a. 'a -> (forall 'b, 'c, 'd, 'e. (('f | 'd) -> 'e & ('g | 'h) -> ('f & 'i) & 'j -> 'h & 'b & 'k & 'l) -> (forall 'm, 'n. ('j & 'm & 'o & 'p) -> ('n | 'e)) | 'c | 'q) | 'r)
//│    = [Function: a2_]
//│ a0: 'a -> (forall 'b, 'c, 'd, 'e. (('f | 'b) -> 'c & 'g -> 'f & 'h -> 'g & 'd) -> (forall 'i, 'j. ('h & 'i) -> ('j | 'c)) | 'e)
//│   = [Function: a0]
//│ a0_: 'a -> (forall 'b, 'c, 'd, 'e. (('f | 'b) -> 'c & 'g -> 'f & 'h -> 'g & 'd) -> (forall 'i, 'j. ('h & 'i) -> ('j | 'c)) | 'e)
//│    = [Function: a0_]

// let test0 = 
//   (fun f -> f (fun h -> h id))
//     (fun (g:a1) ->
//       k (g (fun (x:sid) -> x x))
//         ((fun t -> (fun u v -> v) (g t) (t (fun f x -> x)))
//            (fun x -> ((fun f x -> f x) x) (fun f x -> x))))
// ;;
def test0 =
  (fun f -> f (fun h -> h id))
    (fun (g: A1) ->
      k (g (fun (x: Sid) -> x x))
        ((fun t -> (fun u -> fun v -> v) (g t) (t (fun f -> fun x -> x)))
          (fun x -> ((fun f -> fun x -> f x) x) (fun f -> fun x -> x))))
def test0_ =
  (fun f -> f (fun h -> h id))
    (fun g ->
      k (g (fun x -> x x))
        ((fun t -> (fun u -> fun v -> v) (g t) (t (fun f -> fun x -> x)))
          (fun x -> ((fun f -> fun x -> f x) x) (fun f -> fun x -> x))))
//│ test0: Sid
//│      = [Function: test0]
//│ test0_: 'a -> 'a
//│       = [Function: test0_]


// (** Encoding in F+eta **)
// (* we repace sa by sb and build a coercion function form sb to sc *)

// type a1_sid = ['b] ['a = sid] ('a -> 'b) -> 'b;;
// type a1_nat = ['b] ['a = nat -> nat] ('a -> 'b) -> 'b;;
type A1_sid = forall 'a 'b. (('a & Sid | Sid) -> 'b) -> 'b
type A1_nat = forall 'a 'b. (('a & ChurchInt -> ChurchInt | ChurchInt -> ChurchInt) -> 'b) -> 'b
//│ Defined type alias A1_sid
//│ Defined type alias A1_nat

// let a1_sid_to_nat (g : a1_sid) =
//   let r = fun f -> g (fun (x : sid) -> f x) in
//   (r : a1_nat);;

// :e // due to tapping
// :e // skolem extrusion
def a1_sid_to_nat (g: A1_sid) =
  let r = fun f -> g (fun (x: Sid) -> f x) in
  (r: A1_nat)
//│ a1_sid_to_nat: A1_sid -> A1_nat
//│              = [Function: a1_sid_to_nat]

def a1_sid_to_nat_ g =
  let r = fun f -> g (fun x -> f x) in
  r
//│ a1_sid_to_nat_: ((forall 'a, 'b. ('a & 'c) -> ('b | 'd)) -> 'e & 'f) -> (forall 'g, 'h, 'i, 'j. (('i | 'c) -> ('d & 'j) & 'g) -> ('h | 'e))
//│               = [Function: a1_sid_to_nat_]

// (* the term is as above but abstract over sb and uses the coercion *)

// let test_in_F_eta = 
//   (fun f -> f (fun h -> h id))
//     (fun (g : a1_sid) ->
//       k (g (fun (x : sid) -> x x))
//         ((fun t -> (fun u v -> v) ((a1_sid_to_nat g) t) (t (fun f x -> x)))
//            (fun x -> ((fun f x -> f x) x) (fun f x -> x))))
// ;;

// :e // FIXME?
// :e // FIXME? refreshing-extr
def test_in_F_eta = 
  (fun f -> f (fun h -> h id))
    (fun (g: A1_sid) ->
      k (g (fun (x : Sid) -> x x))
        ((fun t -> (fun u -> fun v -> v) ((a1_sid_to_nat g) t) (t (fun f -> fun x -> x)))
          (fun x -> ((fun f -> fun x -> f x) x) (fun f -> fun x -> x))))
//│ test_in_F_eta: Sid
//│              = [Function: test_in_F_eta]

def test_in_F_eta_ = 
  (fun f -> f (fun h -> h id))
    (fun g ->
      k (g (fun x -> x x))
        ((fun t -> (fun u -> fun v -> v) ((a1_sid_to_nat_ g) t) (t (fun f -> fun x -> x)))
          (fun x -> ((fun f -> fun x -> f x) x) (fun f -> fun x -> x))))
//│ test_in_F_eta_: 'a -> 'a
//│               = [Function: test_in_F_eta_]

// (*
// (* Le terme dans la syntaxe de Joe Wells *)
//   (fn f => f (fn h => h id))
//     (fn g => 
//         k (g (fn x => x x))
//           ((fn t => (fn u v => v) (g t) (t (fn f x => x)))
//              (fn x => ((fn f x => f x) x) (fn f x => x))))

// *)

// (* We can also build a version of a0 that should not be in F+eta. 
// To do that we require x to return its argument. 
// *)

// type a1' = ['a > sid] ('a -> 'a) -> 'a -> 'a;;
type A1' = forall 'a. (('a | Sid) -> ('a | Sid)) -> ('a | Sid) -> ('a | Sid)
//│ Defined type alias A1'

// let either x y = if true then x else y;;
// let a1' = fun f x -> f (f (either id x));;
// let a2' (x:a1') = x auto id; (fun y -> x y church_two; y church_succ) a3;;
// let a0' = a2' a1';;

def either x y = if true then x else y
//│ either: 'a -> (forall 'b, 'c, 'd. ('d & 'b & 'c) -> ('a | 'c))
//│       = [Function: either]

def a1' = fun f -> fun x -> f (f (either id x))
//│ a1': (('a | 'b) -> 'c & (forall 'd, 'e. 'd -> 'd | 'e) -> 'a & 'f) -> (forall 'g, 'h, 'i, 'j, 'k, 'l. ('e & 'l & 'j & 'g & 'h & 'i) -> ('k | 'c))
//│    = [Function: a1$]

def a2' (x: A1') =
  let _ = x auto id in
  (fun y ->
    let _ = x y church_two in
    y church_succ
  ) a3
//│ a2': A1' -> (forall 'a. 'a -> (forall 'b, 'c, 'd, 'e. (('f | 'b) -> 'c & ('g | 'h) -> ('f & 'i) & 'j -> 'h & 'd & 'k & 'l) -> (forall 'm, 'n. ('j & 'm & 'o & 'p) -> ('n | 'c)) | 'e | 'q) | 'r)
//│    = [Function: a2$]

def a2'_ x =
  let _ = x auto_ id in
  (fun y ->
    let _ = x y church_two in
    y church_succ
  ) a3
//│ a2'_: ((forall 'a, 'b, 'c. ((forall 'd, 'e, 'f, 'g, 'h. (('h | 'g) -> 'f & 'e -> 'g & 'd) -> (forall 'i, 'j. ('e & 'i) -> ('f | 'j))) -> 'a & 'b) -> (forall 'k, 'l. 'k -> ('l | 'a)) | 'c) -> ((forall 'd, 'e, 'f, 'g, 'h. (('h | 'g) -> 'f & 'e -> 'g & 'd) -> (forall 'i, 'j. ('e & 'i) -> ('f | 'j))) -> 'm & 'n) & (forall 'o, 'p. ('o -> 'p & 'o) -> 'p) -> ((forall 'q. 'q -> 'q) -> 'r & 's) & 't) -> (forall 'u. 'u -> (forall 'v, 'w, 'x, 'y. (('z | 'w) -> 'x & ('a1 | 'b1) -> ('z & 'c1) & 'd1 -> 'b1 & 'y & 'e1 & 'f1) -> (forall 'g1, 'h1. ('d1 & 'g1 & 'i1 & 'j1) -> ('h1 | 'x)) | 'v | 'k1) | 'l1)
//│     = [Function: a2$_]

def a0' = a2' a1'
//│ a0': 'a -> (forall 'b, 'c, 'd, 'e. (('f | 'c) -> 'd & 'g -> 'f & 'h -> 'g & 'e) -> (forall 'i, 'j. ('h & 'j) -> ('i | 'd)) | 'b)
//│    = [Function: a0$]

:e
def a0'_ = a2'_ a1'
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.224: 	def a0'_ = a2'_ a1'
//│ ║         	           ^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 2. (α95_1774''' -> α99_1775''')›  <:  α212_1752'    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 2. (α95_109''' -> α99_110''')›  <:  α212_216''
//│ a0'_: error
//│     = [Function: a0$_]

// * ^ Still doesn't works with recursive types:
:RecursiveTypes
// :e // fails after new-refreshing-extrusion // Works since inconsistent constrained types...
:e
def a0'_ = a2'_ a1'
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.238: 	def a0'_ = a2'_ a1'
//│ ║         	           ^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 2. (α95_1855''' -> α99_1856''')›  <:  α212_1833'    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 2. (α95_109''' -> α99_110''')›  <:  α212_216''
//│ a0'_: error
//│     = [Function: a0$_1]
:NoRecursiveTypes

// type a1'_sid = ['a = sid] ('a -> 'a) -> 'a -> 'a;;
// type a1'_nat = ['a = nat] ('a -> 'a) -> 'a -> 'a;;
type A1'_sid = forall 'a. (('a & Sid | Sid) -> ('a & Sid | Sid)) -> ('a & Sid | Sid) -> ('a & Sid | Sid)
type A1'_nat = forall 'a. (('a & ChurchInt | ChurchInt) -> ('a & ChurchInt | ChurchInt)) -> ('a & ChurchInt | ChurchInt) -> ('a & ChurchInt | ChurchInt)
//│ Defined type alias A1'_sid
//│ Defined type alias A1'_nat

// (* There is no coercion from a1'_sid to a1'_nat, hence we can conjecture that a0'
//    is not in F+eta. *)





// * === With Constrained Types ===

:DontDistributeForalls
:ConstrainedTypes




def a1 = fun f -> f id
def a3 = fun z -> fun _ -> z church_two
def a2 (x: A1) =
  let _ = x auto in
  (fun y ->
    let _ = x y in
    y church_succ
  ) a3
def a2_ (x: A1) =
  let _ = x auto_ in
  (fun y ->
    let _ = x y in
    y church_succ
  ) a3
def a0 = a2 a1
def a0_ = a2_ a1
//│ a1: ((forall 'a. 'a -> 'a) -> 'b & 'c) -> 'b
//│   = [Function: a11]
//│ a3: 'a -> (forall 'a, 'b, 'c. ('c -> 'b
//│   where
//│     'a <: (forall 'd, 'e, 'f, 'g, 'h. (('d | 'h) -> 'g & 'f -> 'h & 'e) -> (forall 'i, 'j. ('f & 'i) -> ('g | 'j))) -> 'b))
//│   = [Function: a31]
//│ a2: A1 -> (forall 'a, 'b, 'c. ('b -> 'a | 'c
//│   where
//│     forall 'd, 'e, 'f, 'g, 'h, 'i. ('h -> ('g -> 'd & 'e) & 'f) -> (forall 'j, 'k, 'l. (('d | 'j) -> 'k & 'h & 'l) -> (forall 'm, 'n. ('g & 'm) -> ('n | 'k))) | 'i <: (forall 'o, 'p, 'q, 'r, 's. (('r | 'o) -> 's & 'q -> 'o & 'p) -> (forall 't, 'u. ('q & 't) -> ('s | 'u))) -> 'a))
//│   = [Function: a21]
//│ a2_: A1 -> (forall 'a, 'b, 'c. ('b -> 'a | 'c
//│   where
//│     forall 'd, 'e, 'f, 'g, 'h, 'i. ('i -> ('g -> 'e & 'd) & 'h) -> (forall 'j, 'k, 'l. (('e | 'l) -> 'j & 'i & 'k) -> (forall 'm, 'n. ('g & 'm) -> ('n | 'j))) | 'f <: (forall 'o, 'p, 'q, 'r, 's. (('o | 'p) -> 'r & 's -> 'p & 'q) -> (forall 't, 'u. ('s & 't) -> ('r | 'u))) -> 'a))
//│    = [Function: a2_1]
//│ a0: 'a -> 'b
//│   where
//│     forall 'c, 'd, 'e, 'f, 'g. ('c -> ('d -> 'f & 'e) & 'g) -> (forall 'h, 'i, 'j. (('f | 'h) -> 'i & 'c & 'j) -> (forall 'k, 'l. ('d & 'k) -> ('l | 'i))) <: (forall 'm, 'n, 'o, 'p, 'q. (('o | 'n) -> 'm & 'q -> 'n & 'p) -> (forall 'r, 's. ('q & 'r) -> ('m | 's))) -> 'b
//│   = [Function: a01]
//│ a0_: 'a -> 'b
//│   where
//│     forall 'c, 'd, 'e, 'f, 'g. ('d -> ('e -> 'c & 'g) & 'f) -> (forall 'h, 'i, 'j. (('c | 'h) -> 'i & 'd & 'j) -> (forall 'k, 'l. ('e & 'k) -> ('l | 'i))) <: (forall 'm, 'n, 'o, 'p, 'q. (('q | 'm) -> 'n & 'o -> 'm & 'p) -> (forall 'r, 's. ('o & 'r) -> ('n | 's))) -> 'b
//│    = [Function: a0_1]

def a1' = fun f -> fun x -> f (f (either id x))
//│ a1': 'a -> (forall 'b, 'c, 'd, 'a, 'e, 'f, 'g. (('h & 'c & 'b & 'f & 'd) -> 'e
//│   where
//│     'a <: (forall 'h, 'i. 'i -> 'i | 'h) -> 'g & 'g -> 'e))
//│    = [Function: a1$1]

// * Strangely, constrained types make this one FAIL!
:e
def a2' (x: A1') =
  let _ = x auto id in
  (fun y ->
    let _ = x y church_two in
    y church_succ
  ) a3
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.321: 	    let _ = x y church_two in
//│ ║         	            ^^^^^^^^^^^^^^
//│ ╟── type `‘a_2349` is not a function
//│ ║  l.6: 	type Sid = forall 'a. 'a -> 'a
//│ ║       	                  ^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.41: 	def church_two = fun f -> fun x -> f (f x)
//│ ║        	                                   ^^^^^^^
//│ ╟── from reference:
//│ ║  l.41: 	def church_two = fun f -> fun x -> f (f x)
//│ ╙──      	                                   ^
//│ a2': A1' -> (forall 'a, 'b, 'c. ('b -> 'a | 'c
//│   where
//│     forall 'd, 'e, 'f, 'g, 'h, 'i. ('f -> ('h -> 'i & 'd) & 'g) -> (forall 'j, 'k, 'l. (('i | 'j) -> 'k & 'f & 'l) -> (forall 'm, 'n. ('h & 'm) -> ('n | 'k))) | 'e <: (forall 'o, 'p, 'q, 'r, 's. (('q | 'r) -> 'o & 's -> 'r & 'p) -> (forall 't, 'u. ('s & 't) -> ('o | 'u))) -> 'a))
//│    = [Function: a2$1]

def a2'_ x =
  let _ = x auto_ id in
  (fun y ->
    let _ = x y church_two in
    y church_succ
  ) a3
//│ a2'_: ((forall 'a, 'b. 'b -> (forall 'c, 'd, 'b. ('d -> 'c
//│   where
//│     'b <: (forall 'e, 'f, 'g, 'h, 'i. (('g | 'i) -> 'e & 'h -> 'i & 'f) -> (forall 'j, 'k. ('h & 'j) -> ('e | 'k))) -> 'c)) | 'a) -> ((forall 'e, 'f, 'g, 'h, 'i. (('g | 'i) -> 'e & 'h -> 'i & 'f) -> (forall 'j, 'k. ('h & 'j) -> ('e | 'k))) -> 'l & 'm) & (forall 'n, 'o. ('n -> 'o & 'n) -> 'o) -> ((forall 'p. 'p -> 'p) -> 'q & 'r) & 's) -> (forall 't, 'u, 'v. ('u -> 't | 'v
//│   where
//│     forall 'w, 'x, 'y, 'z, 'a1, 'b1. ('x -> ('y -> 'w & 'b1) & 'a1) -> (forall 'c1, 'd1, 'e1. (('w | 'c1) -> 'd1 & 'x & 'e1) -> (forall 'f1, 'g1. ('y & 'f1) -> ('g1 | 'd1))) | 'z <: (forall 'e, 'f, 'g, 'h, 'i. (('g | 'i) -> 'e & 'h -> 'i & 'f) -> (forall 'j, 'k. ('h & 'j) -> ('e | 'k))) -> 't))
//│     = [Function: a2$_1]

def a0' = a2' a1'
//│ a0': 'a -> 'b
//│   where
//│     forall 'c, 'd, 'e, 'f, 'g. ('c -> ('g -> 'd & 'e) & 'f) -> (forall 'h, 'i, 'j. (('d | 'h) -> 'i & 'c & 'j) -> (forall 'k, 'l. ('g & 'k) -> ('l | 'i))) <: (forall 'm, 'n, 'o, 'p, 'q. (('o | 'm) -> 'q & 'p -> 'm & 'n) -> (forall 'r, 's. ('p & 'r) -> ('q | 's))) -> 'b
//│    = [Function: a0$1]

:e
def a0'_ = a2'_ a1'
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.361: 	def a0'_ = a2'_ a1'
//│ ║         	           ^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 0. ‹∀ 1. (α43_44'' -> α43_44'')››  <:  α33_2712'    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 0. ‹∀ 1. (α43_44'' -> α43_44'')››  <:  α33_35''
//│ a0'_: error
//│     = [Function: a0$_2]

// * ^ Strangely, this one works with recursive types:
:RecursiveTypes
def a0'_ = a2'_ a1'
//│ a0'_: 'a -> 'b
//│   where
//│     forall 'c, 'd, 'e, 'f, 'g. ('d -> ('c -> 'g & 'f) & 'e) -> (forall 'h, 'i, 'j. (('g | 'h) -> 'i & 'd & 'j) -> (forall 'k, 'l. ('c & 'k) -> ('l | 'i))) <: (forall 'm, 'n, 'o, 'p, 'q. (('q | 'p) -> 'm & 'n -> 'p & 'o) -> (forall 'r, 's. ('n & 'r) -> ('m | 's))) -> 'b
//│     = [Function: a0$_3]
:NoRecursiveTypes


