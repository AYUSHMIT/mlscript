// :NoRecursiveTypes // Makes several signature checks fail
:GeneralizeCurriedFunctions
:DistributeForalls

// (*** L'annotation est n�cessaire sur z, mais z n'est utilis� qu'une seule fois. ***)
// type sid = ['a] 'a -> 'a
type Sid = forall 'a. 'a -> 'a
//│ Defined type alias Sid

// let t (z:sid) = ( (fun a -> z) : ['a,'b] 'b -> 'a -> 'a )
def t (z: Sid) = (fun a -> z) : forall 'a 'b. 'b -> 'a -> 'a
//│ t: Sid -> (forall 'a. anything -> 'a -> 'a)
//│   where
//│     'b :> Sid
//│        <: Sid & ‘a -> ‘a
//│     'c :> ‘b
//│  = [Function: t]

// (* Une seule instance, mais polymorphe. *)
// let t z = ( (fun a -> z) : ['a,'b] 'b -> 'a -> 'a );;
def t z = (fun a -> z) : forall 'a 'b. 'b -> 'a -> 'a
//│ t: 'b -> (forall 'a. 'b -> 'a -> 'a)
//│   where
//│     'b <: ‘a -> ‘a
//│     'c :> ‘b
//│  = [Function: t1]

def t z = fun a -> z
//│ t: 'a -> anything -> 'a
//│  = [Function: t2]


// (*** Ne type pas avec les value-restriction. Emb�tant. ***)

// type Int = ['a] ('a -> 'a) -> ('a -> 'a)
// ;;
type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ Defined type alias ChurchInt

// let zero f x = x
// ;;

def zero f x = x
//│ zero: anything -> (forall 'a. 'a -> 'a)
//│     = [Function: zero]

def zero_ty: ChurchInt
//│ zero_ty: ChurchInt
//│        = <missing implementation>

// let succ (n:Int) = fun f x -> f (n f x)
// ;;
def succ_ty: ChurchInt -> ChurchInt
def succ (n: ChurchInt) = fun f -> fun x -> f (n f x)
def succ' n = fun f -> fun x -> f (n f x)
//│ succ_ty: ChurchInt -> ChurchInt
//│        = <missing implementation>
//│ succ: ChurchInt -> (forall 'a. 'a -> (forall 'b, 'a, 'c, 'd, 'e, 'f. ('f -> 'e
//│   where
//│     'b <: 'a -> 'c
//│     'a <: 'd -> 'e
//│     'c <: 'f -> 'd)))
//│   where
//│     'b := ChurchInt
//│     = [Function: succ]
//│ succ': 'a -> (forall 'b. 'b -> (forall 'a, 'b, 'c, 'd, 'e, 'f. ('f -> 'e
//│   where
//│     'a <: 'b -> 'c
//│     'b <: 'd -> 'e
//│     'c <: 'f -> 'd)))
//│      = [Function: succ]

// * Note: without constrained types we wouldn't get the principal type of succ'

// * Require distrib – see Scratch3
succ_ty = succ
succ_ty = succ'
//│ ChurchInt -> (forall 'a. 'a -> (forall 'b, 'a, 'c, 'd, 'e, 'f. ('f -> 'e
//│   where
//│     'b <: 'a -> 'c
//│     'a <: 'd -> 'e
//│     'c <: 'f -> 'd)))
//│   where
//│     'b := ChurchInt
//│   <:  succ_ty:
//│ ChurchInt -> ChurchInt
//│        = [Function: succ]
//│ 'a -> (forall 'b. 'b -> (forall 'a, 'b, 'c, 'd, 'e, 'f. ('f -> 'e
//│   where
//│     'a <: 'b -> 'c
//│     'b <: 'd -> 'e
//│     'c <: 'f -> 'd)))
//│   <:  succ_ty:
//│ ChurchInt -> ChurchInt
//│        = [Function: succ]

// :d
succ'
//│ res: 'a -> (forall 'b. 'b -> (forall 'a, 'b, 'c, 'd, 'e, 'f. ('f -> 'e
//│   where
//│     'a <: 'b -> 'c
//│     'b <: 'd -> 'e
//│     'c <: 'f -> 'd)))
//│    = [Function: succ]

// :d
// :e
succ' {}
//│ res: 'a -> (forall 'a, 'b, 'c, 'd, 'e. ('e -> 'd
//│   where
//│     'f <: 'a -> 'b
//│     'a <: 'c -> 'd
//│     'b <: 'e -> 'c))
//│    = [Function: succ]

succ' {} {}
//│ res: 'a -> 'b
//│   where
//│     'c <: 'd -> 'e
//│     'd <: 'f -> 'b
//│     'e <: 'a -> 'f
//│    = [Function: succ]

:e
succ' {} {} {}
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.125: 	succ' {} {} {}
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── record literal of type `anything` is not a function
//│ ║  l.125: 	succ' {} {} {}
//│ ║         	      ^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.55: 	def succ' n = fun f -> fun x -> f (n f x)
//│ ╙──      	                                   ^^^
//│ res: error
//│    = [Function: succ]

fun x -> succ' x x x x x x x x x
//│ res: 'a -> 'b
//│   where
//│     'c <: 'a -> 'd
//│     'd <: 'a -> 'e
//│     'e <: 'a -> 'f
//│     'f <: 'a -> 'g
//│     'g <: 'a -> 'b
//│     'a <: 'h
//│     'i :> forall 'j. 'j -> (forall 'h, 'j, 'k, 'l, 'm, 'n. ('n -> 'm
//│   where
//│     'h <: 'j -> 'k
//│     'j <: 'l -> 'm
//│     'k <: 'n -> 'l))
//│        <: 'a -> 'o
//│     'o <: 'a -> 'p
//│     'p <: 'a -> 'c
//│    = [Function: succ]


// let rec to_church n =
//   if n = 0 then zero
//   else succ (to_church (n-1))
// ;;

def to_church_ty: int -> ChurchInt
//│ to_church_ty: int -> ChurchInt
//│             = <missing implementation>

// * NOTE:
// *  The type inferred for the succ version with *annotated* param seems less powerful
// *  as the following only successfully type checks with `:DistributeForalls`:
:e // FIXME?
rec def to_church_1 n =
  if n == 0 then zero
  else succ (to_church_1 (n - 1))
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.171: 	rec def to_church_1 n =
//│ ║         	                    ^^^
//│ ║  l.172: 	  if n == 0 then zero
//│ ║         	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.173: 	  else succ (to_church_1 (n - 1))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘a376` is not an instance of type `'a`
//│ ║  l.37: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║        	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.37: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ╙──      	                        ^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.171: 	rec def to_church_1 n =
//│ ║         	                    ^^^
//│ ║  l.172: 	  if n == 0 then zero
//│ ║         	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.173: 	  else succ (to_church_1 (n - 1))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘a379` is not an instance of type `'a376`
//│ ║  l.37: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║        	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.37: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║        	                        ^^
//│ ╟── from reference:
//│ ║  l.54: 	def succ (n: ChurchInt) = fun f -> fun x -> f (n f x)
//│ ╙──      	                                                   ^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.171: 	rec def to_church_1 n =
//│ ║         	                    ^^^
//│ ║  l.172: 	  if n == 0 then zero
//│ ║         	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.173: 	  else succ (to_church_1 (n - 1))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘a379` is not an instance of type `'a`
//│ ║  l.37: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║        	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.37: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║        	                        ^^
//│ ╟── from reference:
//│ ║  l.54: 	def succ (n: ChurchInt) = fun f -> fun x -> f (n f x)
//│ ╙──      	                                                   ^
//│ to_church_1: int -> (forall 'b. (('a | ‘a376 | ‘a379) -> 'b & ('a | ‘a376 | ‘a379) -> (‘a376 & 'a)) -> (forall 'b. (‘a376 & 'b & 'a) -> 'b))
//│            = [Function: to_church_1]

rec def to_church_1_t n =
  if n == 0 then zero
  else succ_ty (to_church_1_t (n - 1))
//│ to_church_1_t: int -> (anything -> (forall 'a. 'a -> 'a) | ChurchInt)
//│              = [Function: to_church_1_t]

rec def to_church_1_tt n =
  if n == 0 then zero_ty
  else succ_ty (to_church_1_tt (n - 1))
//│ to_church_1_tt: int -> ChurchInt
//│               = <no result>
//│                 zero_ty is not implemented

// def succ: (forall 'N. ('N -> 'N) -> ('N -> 'N)) -> (forall 'M. ('M -> 'M) -> ('M -> 'M))

// * Error happens when destroying constrained types, hinting that this is probably related to polym-recur
// :d
:e
// rec def to_church_1 n =
//   succ (to_church_1 n)
rec def wat =
  succ wat
//│ ╔══[ERROR] Type mismatch in binding of application:
//│ ║  l.243: 	  succ wat
//│ ║         	  ^^^^^^^^
//│ ╟── type `‘a460` is not an instance of type `'a`
//│ ║  l.37: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║        	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.37: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ╙──      	                        ^^
//│ ╔══[ERROR] Type mismatch in binding of application:
//│ ║  l.243: 	  succ wat
//│ ║         	  ^^^^^^^^
//│ ╟── type `‘a463` is not an instance of type `'a460`
//│ ║  l.37: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║        	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.37: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║        	                        ^^
//│ ╟── from reference:
//│ ║  l.54: 	def succ (n: ChurchInt) = fun f -> fun x -> f (n f x)
//│ ╙──      	                                                   ^
//│ ╔══[ERROR] Type mismatch in binding of application:
//│ ║  l.243: 	  succ wat
//│ ║         	  ^^^^^^^^
//│ ╟── type `‘a463` is not an instance of type `'a`
//│ ║  l.37: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║        	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.37: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║        	                        ^^
//│ ╟── from reference:
//│ ║  l.54: 	def succ (n: ChurchInt) = fun f -> fun x -> f (n f x)
//│ ╙──      	                                                   ^
//│ wat: (('a | ‘a460 | ‘a463) -> 'b & ('a | ‘a460 | ‘a463) -> (‘a460 & 'a)) -> (‘a460 & 'a) -> 'b
//│ Runtime error:
//│   ReferenceError: wat is not defined

// works when `succ` is not annotated with the parameter type
// :e // FIXME should be caught by cycle checker!
:ng
rec def nani =
  succ' nani
//│ nani: ('a -> 'b & 'a -> 'a) -> anything -> 'b

// * The one with annotated rec occurrence works...
def to_church_1_repro n =
  succ (to_church_ty n)
//│ to_church_1_repro: 'a -> 'b
//│   where
//│     'a <: int
//│     'c := ChurchInt
//│     'b :> forall 'd. 'd -> (forall 'd, 'e, 'f, 'g, 'h, 'i. ('i -> 'h
//│   where
//│     'e <: 'd -> 'f
//│     'd <: 'g -> 'h
//│     'f <: 'i -> 'g))
//│     'e := ChurchInt
//│                  = <no result>
//│                    to_church_ty is not implemented



rec def to_church_1_st n =
  if n == 0 then zero
  else succ_ty (to_church_1_st (n - 1))
//│ to_church_1_st: int -> (anything -> (forall 'a. 'a -> 'a) | ChurchInt)
//│               = [Function: to_church_1_st]

// :e // FIXME should be caught by cycle checker!
rec def to_church_2 n =
  if n == 0 then zero
  else succ' (to_church_2 (n - 1))
//│ to_church_2: int -> (forall 'a. ('b -> 'a & 'b -> 'b) -> (forall 'a. ('a & 'b) -> 'a))
//│            = [Function: to_church_1_st]

// :e // FIXME should be caught by cycle checker!
// Requires :RecursiveTypes
:ng // FIXME codegen: `ReferenceError: to_church_2 is not defined`
to_church_ty = to_church_2
//│ int -> (forall 'a. ('b -> 'a & 'b -> 'b) -> (forall 'a. ('a & 'b) -> 'a))
//│   <:  to_church_ty:
//│ int -> ChurchInt

// (* Marche *)
// let rec to_church n =
//   if n = 0 then fun f x -> x
//   else fun f x -> f ((to_church (n-1) : Int) f x)
// ;;

:e // FIXME?
rec def to_church_3 n =
  if n == 0 then fun f -> fun x -> x
  else fun f -> fun x -> f ((to_church_3 (n - 1) : ChurchInt) f x)
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.334: 	rec def to_church_3 n =
//│ ║         	                    ^^^
//│ ║  l.335: 	  if n == 0 then fun f -> fun x -> x
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.336: 	  else fun f -> fun x -> f ((to_church_3 (n - 1) : ChurchInt) f x)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘a729` is not an instance of type `'a728`
//│ ║  l.37: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║        	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.37: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║        	                        ^^
//│ ╟── from reference:
//│ ║  l.336: 	  else fun f -> fun x -> f ((to_church_3 (n - 1) : ChurchInt) f x)
//│ ╙──       	                                                                ^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.334: 	rec def to_church_3 n =
//│ ║         	                    ^^^
//│ ║  l.335: 	  if n == 0 then fun f -> fun x -> x
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.336: 	  else fun f -> fun x -> f ((to_church_3 (n - 1) : ChurchInt) f x)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘a728` is not an instance of type `'a`
//│ ║  l.37: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║        	                        ^^
//│ ╟── but it flows into application with expected type `‘a`
//│ ║  l.336: 	  else fun f -> fun x -> f ((to_church_3 (n - 1) : ChurchInt) f x)
//│ ║         	                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.37: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ╙──      	                        ^^
//│ to_church_3: int -> (('a | ‘a728 | ‘a729) -> 'b & ('a | ‘a728 | ‘a729) -> (‘a728 & 'a)) -> (forall 'c. (‘a728 & 'c & 'a) -> (‘a728 | 'c | 'b))
//│            = [Function: to_church_3]

// (* Ne Marche Pas *)
// let rec to_church n =
//   if n = 0 then fun f x -> x
//   else (fun f x -> f ((to_church (n-1)) f x) : Int)
// ;;
rec def to_church_4 n =
  if n == 0 then fun f -> fun x -> x
  else fun f -> fun x -> f ((to_church_4 (n - 1)) f x) : ChurchInt
//│ to_church_4: int -> ((ChurchInt | 'a) -> (anything -> nothing) -> nothing -> anything) -> (forall 'b. ('b & 'a) -> (ChurchInt | 'b))
//│            = [Function: to_church_4]


// (* La r�cursion est monomorphe. *)
// let rec to_church n =
//   if n = 0 then fun f x -> x
//   else fun f x -> f ((to_church (n-1)) f x)
// ;;

rec def to_church_5 n =
  if n == 0 then fun f -> fun x -> x
  else fun f -> fun x -> f ((to_church_5 (n - 1)) f x)
//│ to_church_5: int -> ('a -> ('a & 'b)) -> (forall 'c. ('c & 'a) -> ('c | 'b))
//│            = [Function: to_church_5]


:e // FIXME?
to_church_ty = to_church_1
//│ int -> (forall 'b. (('a | ‘a376 | ‘a379) -> 'b & ('a | ‘a376 | ‘a379) -> (‘a376 & 'a)) -> (forall 'b. (‘a376 & 'b & 'a) -> 'b))
//│   <:  to_church_ty:
//│ int -> ChurchInt
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.398: 	to_church_ty = to_church_1
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘a379` is not an instance of type `'a`
//│ ║  l.37: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║        	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.37: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ╙──      	                        ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.398: 	to_church_ty = to_church_1
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘a376` is not an instance of type `'a`
//│ ║  l.37: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║        	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.37: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ╙──      	                        ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.398: 	to_church_ty = to_church_1
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘a` is not an instance of type `'a376`
//│ ║  l.37: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║        	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.37: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ╙──      	                        ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.398: 	to_church_ty = to_church_1
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘a` is not an instance of type `'a`
//│ ║  l.37: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║        	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.37: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ╙──      	                        ^^
//│             = [Function: to_church_1]

to_church_ty = to_church_1_t
//│ int -> (anything -> (forall 'a. 'a -> 'a) | ChurchInt)
//│   <:  to_church_ty:
//│ int -> ChurchInt
//│             = [Function: to_church_1_t]

to_church_ty = to_church_1_tt
//│ int -> ChurchInt
//│   <:  to_church_ty:
//│ int -> ChurchInt
//│             = <no result>
//│               to_church_1_tt and zero_ty are not implemented

to_church_ty = to_church_1_st
//│ int -> (anything -> (forall 'a. 'a -> 'a) | ChurchInt)
//│   <:  to_church_ty:
//│ int -> ChurchInt
//│             = [Function: to_church_1_st]

// :e // FIXME should be caught by cycle checker!
:ng
to_church_ty = to_church_2
//│ int -> (forall 'a. ('b -> 'a & 'b -> 'b) -> (forall 'a. ('a & 'b) -> 'a))
//│   <:  to_church_ty:
//│ int -> ChurchInt

:e // FIXME?
to_church_ty = to_church_3
//│ int -> (('a | ‘a728 | ‘a729) -> 'b & ('a | ‘a728 | ‘a729) -> (‘a728 & 'a)) -> (forall 'c. (‘a728 & 'c & 'a) -> (‘a728 | 'c | 'b))
//│   <:  to_church_ty:
//│ int -> ChurchInt
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.467: 	to_church_ty = to_church_3
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘a729` is not an instance of type `'a`
//│ ║  l.37: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║        	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.37: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ╙──      	                        ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.467: 	to_church_ty = to_church_3
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘a728` is not an instance of type `'a`
//│ ║  l.37: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║        	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.37: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ╙──      	                        ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.467: 	to_church_ty = to_church_3
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘a` is not an instance of type `'a`
//│ ║  l.37: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║        	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.37: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║        	                        ^^
//│ ╟── from application:
//│ ║  l.336: 	  else fun f -> fun x -> f ((to_church_3 (n - 1) : ChurchInt) f x)
//│ ╙──       	                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.467: 	to_church_ty = to_church_3
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘a` is not an instance of type `'a728`
//│ ║  l.37: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║        	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.37: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ╙──      	                        ^^
//│             = [Function: to_church_3]

:e
to_church_ty = to_church_4
//│ int -> ((ChurchInt | 'a) -> (anything -> nothing) -> nothing -> anything) -> (forall 'b. ('b & 'a) -> (ChurchInt | 'b))
//│   <:  to_church_ty:
//│ int -> ChurchInt
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.513: 	to_church_ty = to_church_4
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `(?a -> ?a) -> ?a -> ?a` is not an instance of type `'a`
//│ ║  l.37: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║        	                            ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.37: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ╙──      	                        ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.513: 	to_church_ty = to_church_4
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘a` is not a function
//│ ║  l.37: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║        	                        ^^
//│ ╟── Note: constraint arises from function type:
//│ ║  l.37: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║        	                            ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from application:
//│ ║  l.379: 	  else fun f -> fun x -> f ((to_church_4 (n - 1)) f x) : ChurchInt
//│ ╙──       	                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│             = [Function: to_church_4]

// :e
to_church_ty = to_church_5
//│ int -> ('a -> ('a & 'b)) -> (forall 'c. ('c & 'a) -> ('c | 'b))
//│   <:  to_church_ty:
//│ int -> ChurchInt
//│             = [Function: to_church_5]




// (* Echoue avec la value restriction. *)
// let rec (to_church:int -> Int) n =
//   if n = 0 then fun f x -> x
//   else fun f x -> f ((to_church (n-1)) f x)
// ;;


// // * It seems this one may need polymorphic recursion...?
// // *  ...but it's just a version with succ inlined!?
// :e
rec def to_church_ty n =
  if n == 0 then fun f -> fun x -> x
  else fun f -> fun x -> f ((to_church_ty (n - 1)) f x)
//│ int -> ('a -> ('a & 'b)) -> (forall 'c. ('c & 'a) -> ('c | 'b))
//│   <:  to_church_ty:
//│ int -> ChurchInt
//│             = [Function: to_church_ty6]

// * ... since we can fix it by using the annotation for rec calls:
def to_church_ty n =
  if n == 0 then fun f -> fun x -> x
  else fun f -> fun x -> f ((to_church_ty (n - 1)) f x)
//│ 'a -> 'b
//│   where
//│     'a <: int
//│     'c :> int -> bool
//│        <: 0 -> 'd
//│     'd <: bool
//│     'e :> forall 'f. 'f -> 'f -> 'f
//│        <: ('g -> (forall 'h. 'h -> 'h)) -> 'i
//│     'i <: (forall 'j. 'j -> (forall 'a, 'g, 'j, 'k, 'l, 'm, 'n, 'o, 'p. ('n -> 'p
//│   where
//│     'k :> int -> int
//│        <: 1 -> 'l
//│     'l <: int
//│     'm :> ChurchInt
//│        <: 'j -> 'g
//│     'g <: 'n -> 'o
//│     'a <: int
//│     'j <: 'o -> 'p))) -> 'b
//│   <:  to_church_ty:
//│ int -> ChurchInt
//│             = [Function: to_church_ty7]


// (* �a coince. *)
// let tc n = (to_church n : Int);;

// :e // FIXME?
def tc n = to_church_1 n : ChurchInt
//│ tc: 'a -> ChurchInt
//│   where
//│     'b <: (‘a -> ‘a) -> ‘a -> ‘a
//│     'to_church_1 <: 'a -> anything
//│   = [Function: tc]

def tc n = to_church_ty n : ChurchInt
//│ tc: 'a -> ChurchInt
//│   where
//│     'a <: int
//│     'b :> ChurchInt
//│     'c <: (‘a -> ‘a) -> ‘a -> ‘a
//│   = [Function: tc1]

// :e // FIXME should be caught by cycle checker!
def tc n = to_church_2 n : ChurchInt // Requires :RecursiveTypes
//│ tc: 'a -> ChurchInt
//│   where
//│     'to_church_2 <: 'a -> anything
//│     'b <: (‘a -> ‘a) -> ‘a -> ‘a
//│   = [Function: tc2]

// FIXME stupid type
def tc n = to_church_3 n
//│ tc: 'a -> 'b
//│   where
//│     'to_church_3 <: 'a -> 'b
//│   = [Function: tc3]
// FIXME
tc 1 id
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.629: 	tc 1 id
//│ ║         	^^^^^^^
//│ ╟── type `‘a7281352` is not an instance of type `'a`
//│ ║  l.37: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║        	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.37: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║        	                        ^^
//│ ╟── from application:
//│ ║  l.336: 	  else fun f -> fun x -> f ((to_church_3 (n - 1) : ChurchInt) f x)
//│ ╙──       	                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ res: 'a -> 'a | error
//│    = [Function (anonymous)]
// FIXME
tc: int -> ChurchInt
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.645: 	tc: int -> ChurchInt
//│ ║         	^^
//│ ╟── type `‘a729` is not an instance of type `'a`
//│ ║  l.37: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║        	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.37: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ╙──      	                        ^^
//│ res: int -> ChurchInt
//│    = [Function: tc3]

// FIXME
def tc n = to_church_3 n : ChurchInt
//│ tc: 'a -> ChurchInt
//│   where
//│     'b <: (‘a -> ‘a) -> ‘a -> ‘a
//│     'to_church_3 <: 'a -> anything
//│   = [Function: tc4]

// (* Duplicate with to_church1 ("Marche") above *)
// (* Avec la value restriction : �a passe. *)
// let rec to_church n =
//   if n = 0 then fun f x -> x
//   else fun f x -> f ((to_church (n-1) : Int) f x)


// (*** Les annotations de type ne commutent pas. ***)
// type sid = ['a] 'a -> 'a
// type z = ['a,'b] ('a -> 'b) -> ('a -> 'b)
type Z = forall 'a 'b. ('a -> 'b) -> ('a -> 'b)
//│ Defined type alias Z

// let f x = (x:sid), ((x:sid):z)
def f x = ((x : Sid), ((x : Sid) : Z))
//│ f: 'b -> (Sid, Z,)
//│   where
//│     'b <: Sid
//│     'a := ‘a -> ‘b
//│  = [Function: f]

// (* Ne type pas ... c'est une instance polymorphe. Interdit. *)
// untype fun x -> (x:sid), (x:z)
fun x -> ((x : Sid), (x : Z))
//│ res: 'a -> (Sid, Z,)
//│   where
//│     'a <: Sid & Z
//│    = [Function: res]

