
:GeneralizeCurriedFunctions
// :DistributeForalls

def z f x = x
//│ z: anything -> (forall 'a. 'a -> 'a)
//│  = [Function: z]

// def s n = fun f -> fun x -> f (n f x)
// def s n = fun f -> f (n f)
// def s n = fun f -> fun x -> (n f x)
def s n = fun f -> n f
// def s n = n
//│ s: 'a -> (forall 'a, 'b, 'c. ('b -> 'c
//│   where
//│     'a <: 'b -> 'c))
//│   where
//│     'a <: nothing -> 'a
//│  = [Function: s]

:ns
s
//│ res: forall 'a, 'b, 'c. ('a -> (forall 'd, 'e. ('d -> 'e
//│   where
//│     'a <: 'd -> 'e))
//│   where
//│     'a <: 'b -> 'c)
//│    = [Function: s]

type ChurchInt = forall 'N. ('N -> 'N) -> ('N -> 'N)
//│ Defined type alias ChurchInt

def zero: ChurchInt
def succ: ChurchInt -> ChurchInt
//│ zero: ChurchInt
//│     = <missing implementation>
//│ succ: ChurchInt -> ChurchInt
//│     = <missing implementation>

// def z f x = x

// def succ: ChurchInt -> ChurchInt

// def to_church: int -> ChurchInt
def to_church: int -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ to_church: int -> (forall 'M. ('M -> 'M) -> 'M -> 'M)
//│          = <missing implementation>

// :d
// rec def to_ch n =
//   if n == 0 then zero
//   else s (to_ch (n - 1))
// rec def to_ch n =
//   if n == 0 then zero
//   else s (to_ch n)
// rec def to_ch n =
//   if true then zero
//   else s (to_ch n)
// rec def to_ch n =
//   if true then zero
//   else s (to_church n)
def to_ch n =
  if true then z
  else s (to_church n)
// def to_ch n =
//   if true then zero
//   else s (to_church n)
// def to_ch n =
//   s (to_church n)
// rec def to_ch n =
//   s (to_church n)
// def to_ch (n:int) =
//   s (to_church n)
// def to_ch =
//   s (to_church 0)
//│ to_ch: 'a -> 'b
//│   where
//│     'a <: int
//│     'c :> 'd -> 'd -> 'd
//│        <: ('e -> (forall 'f. 'f -> 'f)) -> 'g
//│     'g <: 'h -> 'b
//│     'i :> forall 'M. ('M -> 'M) -> 'M -> 'M
//│        <: 'e
//│     'h :> forall 'e, 'j, 'k. ('j -> 'k
//│   where
//│     'e <: 'j -> 'k)
//│     'e <: 'h -> 'e
//│      = <no result>
//│        to_church is not implemented

// rec def to_ch n =
//   s (to_ch (n - 1))
// rec def to_ch n =
//   s (to_ch n)
// rec def to_ch n =
//   to_ch n

// :ns
// to_ch
// to_ch: ChurchInt
// :re
// to_ch 1 2

// :DistributeForalls
// :d
:e // FIXME?
to_church = to_ch
//│ 'a -> 'b
//│   where
//│     'a <: int
//│     'c :> 'd -> 'd -> 'd
//│        <: ('e -> (forall 'f. 'f -> 'f)) -> 'g
//│     'g <: 'h -> 'b
//│     'i :> forall 'M. ('M -> 'M) -> 'M -> 'M
//│        <: 'e
//│     'h :> forall 'e, 'j, 'k. ('j -> 'k
//│   where
//│     'e <: 'j -> 'k)
//│     'e <: 'h -> 'e
//│   <:  to_church:
//│ int -> (forall 'M. ('M -> 'M) -> 'M -> 'M)
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.107: 	to_church = to_ch
//│ ║         	^^^^^^^^^^^^^^^^^
//│ ╟── type `‘M185` is not an instance of type `'M182`
//│ ║  l.45: 	def to_church: int -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ║        	                              ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.45: 	def to_church: int -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ╙──      	                              ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.107: 	to_church = to_ch
//│ ║         	^^^^^^^^^^^^^^^^^
//│ ╟── type `‘M185` is not an instance of type `'M`
//│ ║  l.45: 	def to_church: int -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ║        	                              ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.45: 	def to_church: int -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ╙──      	                              ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.107: 	to_church = to_ch
//│ ║         	^^^^^^^^^^^^^^^^^
//│ ╟── type `‘M182` is not an instance of type `'M`
//│ ║  l.45: 	def to_church: int -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ║        	                              ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.45: 	def to_church: int -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ╙──      	                              ^^
//│          = <no result>
//│            to_ch and to_church are not implemented




// * Older minimized example that was fixed:

// also works with `zero`
def to_ch n =
  if true then z
  else s (to_church n)
//│ to_ch: 'a -> 'b
//│   where
//│     'c <: 'd -> 'b
//│     'e :> forall 'M. ('M -> 'M) -> 'M -> 'M
//│        <: 'f
//│     'd :> forall 'f, 'g, 'h. ('g -> 'h
//│   where
//│     'f <: 'g -> 'h)
//│     'f <: 'd -> 'a
//│     'a <: int
//│     'i :> 'j -> 'j -> 'j
//│        <: ('a -> (forall 'k. 'k -> 'k)) -> 'c
//│      = <no result>
//│        to_church, to_ch and to_church are not implemented

:e // FIXME?
to_church = to_ch
//│ 'a -> 'b
//│   where
//│     'c <: 'd -> 'b
//│     'e :> forall 'M. ('M -> 'M) -> 'M -> 'M
//│        <: 'f
//│     'd :> forall 'f, 'g, 'h. ('g -> 'h
//│   where
//│     'f <: 'g -> 'h)
//│     'f <: 'd -> 'a
//│     'a <: int
//│     'i :> 'j -> 'j -> 'j
//│        <: ('a -> (forall 'k. 'k -> 'k)) -> 'c
//│   <:  to_church:
//│ int -> (forall 'M. ('M -> 'M) -> 'M -> 'M)
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.177: 	to_church = to_ch
//│ ║         	^^^^^^^^^^^^^^^^^
//│ ╟── type `‘M322` is not an instance of type `'M319`
//│ ║  l.45: 	def to_church: int -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ║        	                              ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.45: 	def to_church: int -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ╙──      	                              ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.177: 	to_church = to_ch
//│ ║         	^^^^^^^^^^^^^^^^^
//│ ╟── type `‘M322` is not an instance of type `'M`
//│ ║  l.45: 	def to_church: int -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ║        	                              ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.45: 	def to_church: int -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ╙──      	                              ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.177: 	to_church = to_ch
//│ ║         	^^^^^^^^^^^^^^^^^
//│ ╟── type `‘M319` is not an instance of type `'M`
//│ ║  l.45: 	def to_church: int -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ║        	                              ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.45: 	def to_church: int -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ╙──      	                              ^^
//│          = <no result>
//│            to_ch, to_church, to_ch and to_church are not implemented

// * Marking it `rec` (on a minimized version) makes it fail
// *  This is because of `destroyConstrainedTypes` which is invoked on rec defs:
// *  (disabling the destruction fixes this problem)

rec def to_ch n =
  s (to_church n)
//│ to_ch: int -> (forall 'a, 'b, 'c. ('b -> 'c
//│   where
//│     'a <: 'b -> 'c))
//│      = <no result>
//│        to_church, to_ch, to_church, to_ch and to_church are not implemented

:e
to_church = to_ch
//│ int -> (forall 'a, 'b, 'c. ('b -> 'c
//│   where
//│     'a <: 'b -> 'c))
//│   <:  to_church:
//│ int -> (forall 'M. ('M -> 'M) -> 'M -> 'M)
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.235: 	to_church = to_ch
//│ ║         	^^^^^^^^^^^^^^^^^
//│ ╟── type `‘M393` is not an instance of type `'M390`
//│ ║  l.45: 	def to_church: int -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ║        	                              ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.45: 	def to_church: int -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ╙──      	                              ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.235: 	to_church = to_ch
//│ ║         	^^^^^^^^^^^^^^^^^
//│ ╟── type `‘M393` is not an instance of type `'M`
//│ ║  l.45: 	def to_church: int -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ║        	                              ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.45: 	def to_church: int -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ╙──      	                              ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.235: 	to_church = to_ch
//│ ║         	^^^^^^^^^^^^^^^^^
//│ ╟── type `‘M390` is not an instance of type `'M`
//│ ║  l.45: 	def to_church: int -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ║        	                              ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.45: 	def to_church: int -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ╙──      	                              ^^
//│          = <no result>
//│            to_ch, to_church, to_ch, to_church, to_ch and to_church are not implemented


// * But distributivity allows getting around the recursion limitation by recovering _some_ of the lost expressiveness
:DistributeForalls


rec def to_ch n =
  s (to_church n)
//│ to_ch: int -> (forall 'a, 'b, 'c. ('b -> 'c
//│   where
//│     'a <: 'b -> 'c))
//│      = <no result>
//│        to_church, to_ch, to_church, to_ch, to_church, to_ch and to_church are not implemented

to_church = to_ch
//│ int -> (forall 'a, 'b, 'c. ('b -> 'c
//│   where
//│     'a <: 'b -> 'c))
//│   <:  to_church:
//│ int -> (forall 'M. ('M -> 'M) -> 'M -> 'M)
//│          = <no result>
//│            to_ch, to_church, to_ch, to_church, to_ch, to_church, to_ch and to_church are not implemented


rec def to_ch n =
  if n == 0 then zero
  else succ (to_ch (n - 1))
//│ to_ch: int -> ChurchInt
//│      = <no result>
//│        zero is not implemented

to_church = to_ch
//│ int -> ChurchInt
//│   <:  to_church:
//│ int -> (forall 'M. ('M -> 'M) -> 'M -> 'M)
//│          = <no result>
//│            to_ch and zero are not implemented


rec def to_ch n =
  if n == 0 then z
  else s (to_ch (n - 1))
//│ to_ch: int -> anything -> (forall 'a. 'a -> 'a)
//│      = [Function: to_ch4]

to_church = to_ch
//│ int -> anything -> (forall 'a. 'a -> 'a)
//│   <:  to_church:
//│ int -> (forall 'M. ('M -> 'M) -> 'M -> 'M)
//│          = [Function: to_ch4]


rec def to_ch_weird n =
  s (to_ch_weird n)
//│ to_ch_weird: anything -> anything -> nothing
//│            = [Function: to_ch_weird]



