

:e
42: ?
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.4: 	42: ?
//│ ║       	^^
//│ ╟── integer literal of type `42` does not match type `nothing`
//│ ╟── Note: constraint arises from type wildcard:
//│ ║  l.4: 	42: ?
//│ ╙──     	    ^
//│ res: anything
//│    = 42

:e // FIXME new rigidification semantics
def n: ?
n = 42
//│ n: anything
//│  = <missing implementation>
//│ 42
//│   <:  n:
//│ anything
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.17: 	n = 42
//│ ║        	^^^^^^
//│ ╟── integer literal of type `42` does not match type `nothing`
//│ ║  l.17: 	n = 42
//│ ║        	    ^^
//│ ╟── Note: constraint arises from type wildcard:
//│ ║  l.16: 	def n: ?
//│ ╙──      	       ^
//│  = 42


def f x = x : ?
//│ f: nothing -> anything
//│  = [Function: f]

class E[A]
  method In: A -> A
  method In = id
//│ Defined class E[=A]
//│ Declared E.In: E['A] -> 'A -> 'A
//│ Defined E.In: E['A] -> (forall 'a. 'a -> 'a)

:e
E{} : E[?]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.47: 	E{} : E[?]
//│ ║        	^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.47: 	E{} : E[?]
//│ ║        	        ^
//│ ╟── Note: constraint arises from type wildcard:
//│ ║  l.47: 	E{} : E[?]
//│ ╙──      	        ^
//│ res: E[?]
//│    = E {}

:e // FIXME new rigidification semantics
def e: E[?]
def e = E{}
//│ e: E[?]
//│  = <missing implementation>
//│ E['A]
//│   <:  e:
//│ E[?]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.62: 	def e = E{}
//│ ║        	^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.61: 	def e: E[?]
//│ ║        	         ^
//│ ╟── Note: constraint arises from type wildcard:
//│ ║  l.61: 	def e: E[?]
//│ ╙──      	         ^
//│  = [Function: e]


type Als1[A] = int -> A
//│ Defined type alias Als1[+A]

:e
add 1 : Als1[?]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.84: 	add 1 : Als1[?]
//│ ║        	^^^^^
//│ ╟── type `int` does not match type `nothing`
//│ ╟── Note: constraint arises from type wildcard:
//│ ║  l.84: 	add 1 : Als1[?]
//│ ╙──      	             ^
//│ res: Als1[?]
//│    = [Function (anonymous)]

:e // FIXME new rigidification semantics
def a1: Als1[?]
a1 = add 1
//│ a1: Als1[?]
//│   = <missing implementation>
//│ int -> int
//│   <:  a1:
//│ Als1[?]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.97: 	a1 = add 1
//│ ║        	^^^^^^^^^^
//│ ╟── type `int` does not match type `nothing`
//│ ╟── Note: constraint arises from type wildcard:
//│ ║  l.96: 	def a1: Als1[?]
//│ ╙──      	             ^
//│   = [Function (anonymous)]


type Als2[A] = A -> int
//│ Defined type alias Als2[-A]

:e
add 1 : Als2[?]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.117: 	add 1 : Als2[?]
//│ ║         	^^^^^
//│ ╟── type `anything` is not an instance of type `int`
//│ ║  l.117: 	add 1 : Als2[?]
//│ ╙──       	             ^
//│ res: Als2[?]
//│    = [Function (anonymous)]

:e // FIXME new rigidification semantics
def a2: Als2[?]
a2 = add 1
//│ a2: Als2[?]
//│   = <missing implementation>
//│ int -> int
//│   <:  a2:
//│ Als2[?]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.129: 	a2 = add 1
//│ ║         	^^^^^^^^^^
//│ ╟── type `anything` is not an instance of type `int`
//│ ║  l.128: 	def a2: Als2[?]
//│ ╙──       	             ^
//│   = [Function (anonymous)]


def q: ?
//│ q: anything
//│  = <missing implementation>

:e // FIXME new rigidification semantics
q = 1
//│ 1
//│   <:  q:
//│ anything
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.149: 	q = 1
//│ ║         	^^^^^
//│ ╟── integer literal of type `1` does not match type `nothing`
//│ ║  l.149: 	q = 1
//│ ║         	    ^
//│ ╟── Note: constraint arises from type wildcard:
//│ ║  l.144: 	def q: ?
//│ ╙──       	       ^
//│  = 1

:e
q + 1
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.165: 	q + 1
//│ ║         	^^^
//│ ╟── type `anything` is not an instance of type `int`
//│ ║  l.144: 	def q: ?
//│ ║         	       ^
//│ ╟── but it flows into reference with expected type `int`
//│ ║  l.165: 	q + 1
//│ ╙──       	^
//│ res: error
//│    = 2

:e
q q
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.179: 	q q
//│ ║         	^^^
//│ ╟── type `anything` is not a function
//│ ║  l.144: 	def q: ?
//│ ║         	       ^
//│ ╟── but it flows into reference with expected type `anything -> ?a`
//│ ║  l.179: 	q q
//│ ╙──       	^
//│ res: error
//│ Runtime error:
//│   TypeError: q is not a function


:NoJS

class Expr[A]
  method Inv: A -> A
//│ Defined class Expr[=A]
//│ Declared Expr.Inv: Expr['A] -> 'A -> 'A

def e: Expr[?]
def f: Expr[?] -> Expr[?]
//│ e: Expr[?]
//│ f: Expr[?] -> Expr[?]

// * `Expr[?] <: Expr[?]` is false
// * because each `?` stands for an unknown type ranging from Bot to Top
:e
f e
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.209: 	f e
//│ ║         	^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.201: 	def e: Expr[?]
//│ ║         	            ^
//│ ╟── Note: constraint arises from type wildcard:
//│ ║  l.202: 	def f: Expr[?] -> Expr[?]
//│ ╙──       	            ^
//│ res: error


