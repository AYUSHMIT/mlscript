
class None: {}
class Some[A]: { value: A }
type Option[A] = Some[A] | None
//│ Defined class None
//│ Defined class Some
//│ Defined type Option

type List[A] = Cons[A] | None
class Cons[A]: Some[A] & { tail: List[A] }
//│ Defined type List
//│ Defined class Cons

// TODO will be no longer needed with new class ctors
def Cons{value; tail} = Cons(Some{value} with {tail})
//│ Cons: {tail: List['a], value: 'a} -> cons & (Some['a] & {tail: List['a]})

rec def map2 f ls = case ls of {
  | Cons -> Cons{value = f ls.value; tail = map2 f ls.tail}
  | None -> None{}
  }
//│ map2: ('a -> 'b) -> ((cons & {tail: 'c, value: 'a}) | ((none & anything) & ~cons)) as 'c -> (cons & (Some['b] & {tail: List['b]})) | none




def safeDiv x (y: ~0) = div x y
//│ safeDiv: int -> int & ~0 -> int

:e
safeDiv 1 0
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.31: 	safeDiv 1 0
//│ ║        	^^^^^^^^^^^
//│ ╟── expression of type `0` does not match type `~0`
//│ ║  l.31: 	safeDiv 1 0
//│ ║        	          ^
//│ ╟── Note: constraint arises from type negation:
//│ ║  l.27: 	def safeDiv x (y: ~0) = div x y
//│ ╙──      	                  ^^
//│ res: int | error

fun x -> safeDiv 1 x
//│ res: ~0 & int -> int

fun x -> case x of { int -> safeDiv 1 x | _ -> None{} }
//│ res: ((int & ~0 & int) | (anything & ~int)) -> int | none

// TOOD mayeb we shouldn't refine x's type here...
fun (x: int) -> safeDiv 1 x
//│ res: ~0 & int & int -> int

def tryDiv: int -> int -> Option[int]
//│ tryDiv: int -> int -> Option[int]

def tryDiv x y = case y of { 0 -> None{} | _ -> Some { value = safeDiv x y } }
//│ int -> ((0 & anything) | (~0 & int & ~0)) -> none | (some & {value: int})  <:  f: int -> int -> Option[int]

tryDiv 1 1
tryDiv 1 0
//│ res: Option[int]
//│ res: Option[int]

