:NoJS


rec def x = {u = x}
//│ x: {u: 'a} as 'a

:ns
{u = x; v = x}
//│ res: {u: forall 'a. {u: 'b} as 'b, v: forall 'a. {u: 'b} as 'b}

// > FIXME: foralls?
{u = x; v = x}
//│ res: {u: {u: 'a} as 'a, v: {u: 'a} as 'a}




class C[A]: {x: A}
  method X = this.x
//│ Defined class C
//│ Defined C.X: C['A] -> 'A

c = C{x = 1}
//│ c: C['A .. 1 | 'A] with {x: 1}

def mkC() = C{x = 1}
//│ mkC: () -> (C['A .. 1 | 'A] with {x: 1})

def arg = if true then c else 0
//│ arg: 0 | (C['A .. 1 | 'A] with {x: 1})

def arg = if true then mkC() else 0
//│ arg: 0 | (C['A .. 1 | 'A] with {x: 1})


def arg = if true then C{x = 42} else 0
//│ arg: 0 | (C['A .. 42 | 'A] with {x: 42})

def arg = if true then c else 0
//│ arg: 0 | (C['A .. 1 | 'A] with {x: 1})

:ns
def arg = if true then C{x = 42} else C{x = 1}
//│ arg: forall 'x, 'A, 'x0, 'A0, 'a. c & {x: 42, C#A :> 'A <: 42} | c & {x: 1, C#A :> 'A0 <: 1}

:ns
arg
//│ res: forall 'x, 'A, 'x0, 'A0, 'a. c & {x: 42, C#A :> 'A <: 42} | c & {x: 1, C#A :> 'A0 <: 1}

arg
//│ res: (C['A .. 42 | 'A] with {x: 42}) | (C['A0 .. 1 | 'A0] with {x: 1})

C.X
//│ res: C['A] -> 'A

:ns
C.X
//│ res: C['A] -> 'A

res arg
//│ res: 1 | 42

arg.X
//│ res: 1 | 42

:e
arg: C[nothing]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.67: 	arg: C[nothing]
//│ ║        	^^^
//│ ╟── integer literal of type `42` does not match type `nothing`
//│ ║  l.43: 	def arg = if true then C{x = 42} else C{x = 1}
//│ ║        	                             ^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.67: 	arg: C[nothing]
//│ ╙──      	       ^^^^^^^
//│ res: C[nothing]


test x = case x of { C -> x.X }
//│ test: C['A] -> 'A

test x = case x of { C -> x.X | int -> x }
//│ test: (C['A] | int & 'a) -> ('A | 'a)


