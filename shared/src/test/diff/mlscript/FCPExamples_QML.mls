// :NoJS

// =============== Sec 2 ===============
let id x = x in id
(id 3, id false)
//│ res: 'a -> 'a
//│    = [Function (anonymous)]
//│ res: (3, false,)
//│    = [ 3, false ]

let poly f = (f 1, f true) in poly
//│ res: (true -> 'a & 1 -> 'b) -> ('b, 'a,)
//│    = [Function (anonymous)]
let poly f = let y = f in (y 1, y true) in poly
//│ res: (true -> 'a & 1 -> 'b) -> ('b, 'a,)
//│    = [Function (anonymous)]

// Altered from
// let poly f = let y = f {forall 'a. 'a -> 'a} in (y 1, y true)
def poly = fun (f : (forall 'a. 'a -> 'a)) -> (f 1, f true)
//│ poly: (forall 'a. 'a -> 'a) -> (1, true,)
//│     = [Function: poly]

def app : ('a -> 'b) -> 'a -> 'b
//│ app: ('a -> 'b) -> 'a -> 'b
//│    = <missing implementation>

def revapp : 'a -> ('a -> 'b) -> 'b
//│ revapp: 'a -> ('a -> 'b) -> 'b
//│       = <missing implementation>

app poly (fun x -> x)
//│ res: (1, true,)
//│    = <no result>
//│      app is not implemented

revapp (fun x -> x) poly
//│ res: (1, true,)
//│    = <no result>
//│      revapp is not implemented

class List[A]
  method Get: A
//│ Defined class List[+A]
//│ Declared List.Get: List['A] -> 'A

def single : 'a -> List['a]
//│ single: 'a -> List['a]
//│       = <missing implementation>

def ids = single (fun x -> x)
//│ ids: List[forall 'a. 'a -> 'a]
//│    = <no result>
//│      single is not implemented

single ids
//│ res: List[List[forall 'a. 'a -> 'a]]
//│    = <no result>
//│      single is not implemented

def map: ('a -> 'b) -> List['a] -> List['b]
def head: List['a] -> 'a
//│ map: ('a -> 'b) -> List['a] -> List['b]
//│    = <missing implementation>
//│ head: List['a] -> 'a
//│     = <missing implementation>

map head (single ids)
//│ res: List[forall 'a. 'a -> 'a]
//│    = <no result>
//│      map is not implemented
app (map head) (single ids)
//│ res: List[forall 'a. 'a -> 'a]
//│    = <no result>
//│      app is not implemented

def fst: forall 'a 'b. (('a, 'b),) -> 'a
def fst ((x, _),) = x
def snd: forall 'a 'b. (('a, 'b),) -> 'b
def snd ((_, x),) = x
//│ fst: ('a, anything,) -> 'a
//│    = <missing implementation>
//│ ('a, anything,) -> 'a
//│   <:  fst:
//│ ('a, anything,) -> 'a
//│    = [Function: fst]
//│ snd: (anything, 'b,) -> 'b
//│    = <missing implementation>
//│ (anything, 'a,) -> 'a
//│   <:  snd:
//│ (anything, 'b,) -> 'b
//│    = [Function: snd]

// def pack : 
def pack t = fun f -> f t
//│ pack: 'a -> ('a -> 'b) -> 'b
//│     = [Function: pack]

def open p t = p t
//│ open: ('a -> 'b) -> 'a -> 'b
//│     = [Function: open]

// Altered from
// let f = {exists 'a. 'a * ('a -> 'a) * ('a -> int)} (0, (fun x -> x + 1) , (fun x -> x));
// open {exists 'a. a * ('a -> 'a) * ('a -> int)} g = f in (snd (snd g)) (fst g);;
let f = pack ((0, (fun x -> x + 1, fun x -> x),),) in
  open f (fun x -> (snd (snd x)) (fst x))
//│ res: 0
//│    = 0


// =============== Sec 3 ===============

def run : (forall 'g. 'g -> 'a) -> 'a
//│ run: (nothing -> 'a) -> 'a
//│    = <missing implementation>

def e : 'g -> int
//│ e: anything -> int
//│  = <missing implementation>

// 
(fun (f : (forall 'g. int -> 'g)) -> f 1)
//│ res: (int -> anything) -> nothing
//│    = [Function: res]

run e
//│ res: int
//│    = <no result>
//│      run is not implemented

fun (x : (forall 'a. 'a -> 'a)) -> x
//│ res: (forall 'a. 'a -> 'a) -> (forall 'a. 'a -> 'a)
//│    = [Function: res]


let abstype = pack ((id, id),) in
  let module = pack ((id, app),) in
  open abstype (fun x -> (snd x) (fst x 1))
//│ res: 1
//│    = <no result>
//│      app is not implemented

let abstype = pack ((id, id),) in
  let module = pack ((id, app),) in
  open module (fun x -> (snd x) (fun a -> ((a, a),)) (fst x 1))
//│ res: ((1, 1,),)
//│    = <no result>
//│      app is not implemented

def mod = let rec mod a b = if a < b then a else mod (a - b) b in mod
//│ mod: int -> int -> int
//│    = [Function: mod]

// exists r. forall b. Sig[a, r, b]
// (forall r. (forall b. Sig[a, r, b]) -> y) -> y

// :GeneralizeCurriedFunctions

type ExSmall = (forall 'r. ('a -> 'r, 'r -> int -> 'a) -> 'y) -> 'y
//│ Defined type alias ExSmall

// def sbase : ExSmall
def sbase (f : forall 'r. ('a -> 'r, 'r -> int -> 'a) -> 'y) = f (fun a -> a, fun r -> fun (i : int) -> r)
def sstep = fun xx -> xx (fun (xinit, xsub) -> 
  let init a = (xinit a, xinit a) in
  let sub r i =
    if mod i 2 == 0
    then xsub (fst r) (i / 2)
    else xsub (snd r) (i / 2) in
      fun (f : forall 'r. ('a -> 'r, 'r -> int -> 'a) -> 'y) ->
      f (init, sub)) 
//│ sbase: (forall 'r. ('a -> 'r, 'r -> int -> 'a,) -> 'b) -> 'b
//│      = [Function: sbase]
//│ sstep: ((forall 'a, 'b, 'c, 'd. ('a -> 'b & 'a -> 'c, 'b -> int -> 'a & 'c -> int -> 'a,) -> (forall 'r. ('a -> 'r, 'r -> int -> 'a,) -> 'd) -> 'd) -> 'e) -> 'e
//│      = [Function: sstep]

let mkSArray n = if n == 0 then sbase else sstep (sstep sbase) in
  mkSArray 1 (fun (xinit, xsub) -> xsub (xinit 2) 2)
//│ res: 2
//│    = 2

// FIXME
let rec mkSArray n = if n == 0 then sbase else sstep (mkSArray (n - 1)) in
  mkSArray 2 (fun (xinit, xsub) -> xinit 2)
//│ ╔══[ERROR] Subtyping constraint of the form `?a -> ?b <: ?mkSArray` exceeded recursion depth limit (300)
//│ ║  l.187: 	let rec mkSArray n = if n == 0 then sbase else sstep (mkSArray (n - 1)) in
//│ ║         	                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── while constraining:  'a918'  <!<  'a1104'
//│ ╟── while constraining:  'a956'  <!<  'a1104'
//│ ╟── while constraining:  'a994'  <!<  'a1104'
//│ ╟── while constraining:  'a1032'  <!<  'a1104'
//│ ╟── while constraining:  'a1070'  <!<  'a1104'
//│ ╟── while constraining:  'a1108'  <!<  'a1104'
//│ ╟── while constraining:  'a1108'  <!<  α497_1114''
//│ ╟── while constraining:  'a1108'  <!<  α492_1133''
//│ ╟── while constraining:  'a1108'  <!<  'a544_1132''
//│ ╟── while constraining:  'a1108'  <!<  α542_1131''
//│ ╟── while constraining:  'a1108'  <!<  α541_1130''
//│ ╟── while constraining:  'a1108'  <!<  α540_1129''
//│ ╟── while constraining:  (Int -> 'a1108')  <!<  ((α539_1128'',) -> α540_1129'')
//│ ╟── while constraining:  (Int -> 'a1108')  <!<  α538_1127''
//│ ╟── while constraining:  (‘r_1112'''' -> (Int -> 'a1108'))  <!<  ((α537_1119'',) -> α538_1127'')
//│ ╟── ......
//│ ╟── ......
//│ ╟── while constraining:  (‹∀ 2. ((('a838' -> 'r543_835'''), ('r543_835''' -> (Int -> 'a842')),) -> 'y843')› -> α845')  <!<  ((‹∀ 1. ((α490_566'', α491_579'',) -> (‹∀ 2. ((('a544_585'' -> 'r543_592'''), ('r543_592''' -> (Int -> 'a544_585'')),) -> 'y545_593'')› -> α547_594''))›,) -> α595_799')
//│ ╟── while constraining:  (‹∀ 2. ((('a838' -> 'r543_835'''), ('r543_835''' -> (Int -> 'a842')),) -> 'y843')› -> α845')  <!<  α489_798'
//│ ╟── while constraining:  (‹∀ 2. ((('a838' -> 'r543_835'''), ('r543_835''' -> (Int -> 'a842')),) -> 'y843')› -> α845')  <!<  α796'
//│ ╟── while constraining:  (‹∀ 2. ((('a838' -> 'r543_835'''), ('r543_835''' -> (Int -> 'a842')),) -> 'y843')› -> α845')  <!<  α800'
//│ ╟── while constraining:  (‹∀ 2. ((('a838' -> 'r543_835'''), ('r543_835''' -> (Int -> 'a842')),) -> 'y843')› -> α845')  <!<  α20_792'
//│ ╟── while constraining:  (‹∀ 2. ((('a838' -> 'r543_835'''), ('r543_835''' -> (Int -> 'a842')),) -> 'y843')› -> α845')  <!<  α797'
//│ ╟── while constraining:  (‹∀ 2. ((('a838' -> 'r543_835'''), ('r543_835''' -> (Int -> 'a842')),) -> 'y843')› -> α845')  <!<  α595_799'
//│ ╟── while constraining:  α472_807'  <!<  α595_799'
//│ ╟── while constraining:  (‹∀ 1. ((('a465_801' -> 'r464_805''), ('r464_805'' -> (Int -> 'a465_801')),) -> 'y466_806')› -> α472_807')  <!<  ((‹∀ 1. ((α490_566'', α491_579'',) -> (‹∀ 2. ((('a544_585'' -> 'r543_592'''), ('r543_592''' -> (Int -> 'a544_585'')),) -> 'y545_593'')› -> α547_594''))›,) -> α595_799')
//│ ╟── while constraining:  ‹∀ 0. (‹∀ 1. ((('a465' -> 'r464_467''), ('r464_467'' -> (Int -> 'a465')),) -> 'y466')› -> α472')›  <!<  ((‹∀ 1. ((α490_566'', α491_579'',) -> (‹∀ 2. ((('a544_585'' -> 'r543_592'''), ('r543_592''' -> (Int -> 'a544_585'')),) -> 'y545_593'')› -> α547_594''))›,) -> α595_799')
//│ ╟── while constraining:  ‹∀ 0. (‹∀ 1. ((('a465' -> 'r464_467''), ('r464_467'' -> (Int -> 'a465')),) -> 'y466')› -> α472')›  <!<  α489_798'
//│ ╟── while constraining:  ‹∀ 0. (‹∀ 1. ((('a465' -> 'r464_467''), ('r464_467'' -> (Int -> 'a465')),) -> 'y466')› -> α472')›  <!<  α796'
//│ ╟── while constraining:  α800'  <!<  α796'
//│ ╟── while constraining:  (α788' -> α800')  <!<  ((α795',) -> α796')
//│ ╙── while constraining:  (α788' -> α800')  <!<  mkSArray787'
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.188: 	  mkSArray 2 (fun (xinit, xsub) -> xinit 2)
//│ ║         	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘r_1449'_1453` is not a function
//│ ║  l.171: 	      fun (f : forall 'r. ('a -> 'r, 'r -> int -> 'a) -> 'y) ->
//│ ║         	                      ^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.188: 	  mkSArray 2 (fun (xinit, xsub) -> xinit 2)
//│ ║         	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type variable:
//│ ║  l.171: 	      fun (f : forall 'r. ('a -> 'r, 'r -> int -> 'a) -> 'y) ->
//│ ╙──       	                                                         ^^
//│ res: error | ‘r_1444'_1448
//│    = [ [ 2, 2 ], [ 2, 2 ] ]

type Sig[a, r, b] = (((a -> r, r -> int -> a), r -> int -> a -> r), (a -> b -> b) -> b -> r -> b)
type ExSig = (forall 'r. (forall 'b. (('a -> 'r, 'r -> int -> 'a), 'r -> int -> 'a -> 'r), ('a -> 'b -> 'b) -> 'b -> 'r -> 'b) -> 'y) -> 'y
//│ Defined type alias Sig[=a, =r, =b]
//│ Defined type alias ExSig

def base : ExSig
def base (f : forall 'r. (forall 'b. (('a -> 'r, 'r -> int -> 'a), 'r -> int -> 'a -> 'r), ('a -> 'b -> 'b) -> 'b -> 'r -> 'b) -> 'y) =
  f (((fun a -> a, fun r -> fun (i : int) -> r), fun r -> fun (i : int) -> fun a -> a), fun f -> fun b -> fun r -> f r b)
//│ base: ExSig
//│     = <missing implementation>
//│ (forall 'r. ((('a -> 'r, 'r -> int -> 'a,), 'r -> int -> 'a -> 'r,), ('a -> 'b -> 'b) -> 'b -> 'r -> 'b,) -> 'c) -> 'c
//│   <:  base:
//│ ExSig
//│     = [Function: base]

def step = fun xx -> xx (fun (((xinit, xsub), xupdate), xfold) ->
  let init a = (xinit a, xinit a) in
  let sub r i =
    if mod i 2 == 0
    then xsub (fst r) (i / 2)
    else xsub (snd r) (i / 2) in
  let update r i a =
    if mod i 2 == 0
    then (xupdate (fst r) (i / 2) a, snd r)
    else (fst r, xupdate (snd r) (i / 2) a) in
  let fold f b r = xfold f (xfold f b (fst r) (snd r)) in
    fun (f : forall 'r . (forall 'b. (('a -> 'r, 'r -> int -> 'a), 'r -> int -> 'a -> 'r), ('a -> 'b -> 'b) -> 'b -> 'r -> 'b) -> 'y) ->
    f (((init, sub), update), fold))
//│ step: ((forall 'a, 'b, 'a0, 'b0, 'c, 'd. ((('a -> 'b & 'a -> 'a0, 'b -> int -> 'a & 'a0 -> int -> 'a,), 'b -> int -> 'a -> 'b & 'a0 -> int -> 'a -> 'a0,), ('a -> 'b0 -> 'b0) -> 'b0 -> 'a0 -> 'b -> 'c & ('a -> 'b0 -> 'b0) -> 'c -> 'b0,) -> (forall 'r. ((('a -> 'r, 'r -> int -> 'a,), 'r -> int -> 'a -> 'r,), ('a -> 'b0 -> 'b0) -> 'b0 -> 'r -> 'b0,) -> 'd) -> 'd) -> 'e) -> 'e
//│     = [Function: step]

let mkArray n = if n == 0 then base else step base in
  mkArray 1 (fun (((xinit, xsub), xupdate), xfold) -> xinit 2)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.275: 	let mkArray n = if n == 0 then base else step base in
//│ ║         	                                         ^^^^^^^^^
//│ ╟── type `‘r_1931''_2009` is not an instance of type `'r_1931''_2012`
//│ ║  l.240: 	type ExSig = (forall 'r. (forall 'b. (('a -> 'r, 'r -> int -> 'a), 'r -> int -> 'a -> 'r), ('a -> 'b -> 'b) -> 'b -> 'r -> 'b) -> 'y) -> 'y
//│ ║         	                     ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.240: 	type ExSig = (forall 'r. (forall 'b. (('a -> 'r, 'r -> int -> 'a), 'r -> int -> 'a -> 'r), ('a -> 'b -> 'b) -> 'b -> 'r -> 'b) -> 'y) -> 'y
//│ ╙──       	                     ^^
//│ res: error | ‘r_2042'_2048
//│    = [ 2, 2 ]

// FIXME
let rec mkArray n = if n == 0 then base else step (mkArray (n - 1)) in
  mkArray 2 (fun (((xinit, xsub), xupdate), xfold) -> xinit 2)
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.281: 	let rec mkArray n = if n == 0 then base else step (mkArray (n - 1)) in
//│ ║         	                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘r_2079''_2157` is not an instance of type `'r_2079''_2160`
//│ ║  l.240: 	type ExSig = (forall 'r. (forall 'b. (('a -> 'r, 'r -> int -> 'a), 'r -> int -> 'a -> 'r), ('a -> 'b -> 'b) -> 'b -> 'r -> 'b) -> 'y) -> 'y
//│ ║         	                     ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.240: 	type ExSig = (forall 'r. (forall 'b. (('a -> 'r, 'r -> int -> 'a), 'r -> int -> 'a -> 'r), ('a -> 'b -> 'b) -> 'b -> 'r -> 'b) -> 'y) -> 'y
//│ ╙──       	                     ^^
//│ res: ‘r_2197'_2203
//│    = [ [ 2, 2 ], [ 2, 2 ] ]

// =============== Sec 7 ===============

def choose: 'a -> 'a -> 'a
//│ choose: 'a -> 'a -> 'a
//│       = <missing implementation>

choose (head ids)
//│ res: 'a -> (forall 'b. 'a | 'b -> 'b)
//│    = <no result>
//│      choose is not implemented

