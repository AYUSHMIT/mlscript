
// FIXME
class Test1: { x: int }
//│ Defined class Test1

Test1
//│ res: {x: int} -> Test1 & {x: int}

Test1 { x = 123 }
//│ res: Test1 & {x: int}

:e
Test1 { x = "oops" }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.13: 	Test1 { x = "oops" }
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `"oops"` does not match type `int`
//│ ║  l.13: 	Test1 { x = "oops" }
//│ ║        	            ^^^^^^
//│ ╟── but it flows into record literal with expected type `{x: int}`
//│ ║  l.13: 	Test1 { x = "oops" }
//│ ║        	      ^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.3: 	class Test1: { x: int }
//│ ╙──     	                  ^^^
//│ res: (Test1 & {x: int}) | error

def Test1 = fun x -> Test1 { x = x }
//│ Test1: int -> Test1 & {x: int}

class Test11: { x: int }
def Test11 x = Test11 { x }
//│ Defined class Test11
//│ Test11: int -> Test11 & {x: int}


:e
type Test1 = { x: int }
//│ ╔══[ERROR] Type 'Test1' is already defined.
//│ ║  l.38: 	type Test1 = { x: int }
//│ ╙──      	     ^^^^^
//│ Defined type Test1

// FIXME
type Test2 = { x: int }
//│ Defined type Test2

:pe
class Test = { x: int }
//│ /!\ Parse error: Expected ":":1:12, found "= { x: int" at l.49:12: class Test = { x: int }

:pe
type Test: { x: int }
//│ /!\ Parse error: Expected "=":1:10, found ": { x: int" at l.53:10: type Test: { x: int }

// FIXME
type Test3 = int -> int
//│ Defined type Test3

// FIXME
type Test4 = int -> int -> int
//│ Defined type Test4

// FIXME
type Test5 = (int -> int) -> int
//│ Defined type Test5


type T = int
//│ Defined type T

:e
type T = int
type T = int
//│ ╔══[ERROR] Type 'T' is already defined.
//│ ║  l.73: 	type T = int
//│ ╙──      	     ^
//│ ╔══[ERROR] Type 'T' is already defined.
//│ ║  l.74: 	type T = int
//│ ╙──      	     ^
//│ Defined type T
//│ Defined type T

:e
type TypeA = int
foo 42
def foo = 1
foo 42
//│ Defined type TypeA
//│ ╔══[ERROR] identifier not found: foo
//│ ║  l.86: 	foo 42
//│ ╙──      	^^^
//│ res: error
//│ foo: 1
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.88: 	foo 42
//│ ║        	^^^^^^
//│ ╟── expression of type `1` is not a function
//│ ║  l.87: 	def foo = 1
//│ ║        	          ^
//│ ╟── but it flows into reference with expected type `42 -> ?a`
//│ ║  l.88: 	foo 42
//│ ╙──      	^^^
//│ res: error

42: TypeA
//│ res: TypeA

type TypeOops = TypeOops
type TypeB = TypeC
def test = fun x -> (x: TypeB)
test 42
type TypeC = TypeA
//│ Defined type TypeOops
//│ Defined type TypeB
//│ Defined type TypeC
//│ test: TypeB -> TypeB
//│ res: TypeB


// FIXME:
def test = fun (x: TypeB) -> x
//│ test: TypeB -> nothing

