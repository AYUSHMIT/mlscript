:NoJS

// ============ Sec 4.2 ============
// alternative: elimination form of `List` with definition of `mem` and `fold_left`

// ------------ Dummy classes to represent the types in the examples ------------

class List[a]
  method Get: a
//│ Defined class List[+a]
//│ Declared List.Get: List['a] -> 'a

// Used to represent `::` in the papers
def cons[a]: a -> List[a] -> List[a]
//│ cons: 'a -> List['a] -> List['a]

// Used to represent `[]` in the papers
def nil: List['a]
//│ nil: List[nothing]

def match_list: forall 'a 'b. List['a] -> 'b -> ('a -> List['a] -> 'b) -> 'b
//│ match_list: List['a] -> 'b -> ('a -> List['a] -> 'b) -> 'b

// ------------ Type signatures for functions used in the examples ------------
// (I guess)

rec def mem x l = match_list l false (fun head -> fun tail -> if eq head x then true else mem x tail)
//│ mem: anything -> List[?] -> bool

rec def fold_left f x l = match_list l x (fun head -> fun tail -> fold_left f (f x head) tail)
//│ fold_left: ('b -> 'a -> 'b) -> 'b -> List['a] -> 'b

// ------------ polymorphic methods ------------

class Collection[a]: { l: List[a] }
  method Mem x = mem x this.l
  method Fold f x = fold_left f x this.l
//│ Defined class Collection[+a]
//│ Defined Collection.Mem: Collection[?] -> anything -> bool
//│ Defined Collection.Fold: Collection['a] -> ('b -> 'a -> 'b) -> 'b -> 'b

def coll_mem c x = c.Mem x
//│ coll_mem: Collection[?] -> anything -> bool

// typo in the paper? it was `fun x -> fun y -> ...`
def simple_and_double c =
  let l1 = c.Fold (fun y -> fun x -> cons x y) nil in
  let l2 = c.Fold (fun y -> fun x -> cons ((x, x),) y) nil in
  (l1, l2)
//│ simple_and_double: Collection['a | 'a0] -> (List['a0], List[('a, 'a,)],)
