
def test f = f (fun b -> if b then 1 else 2)
//│ test: ((bool -> (1 | 2)) -> 'a) -> 'a
//│     = [Function: test]

test (fun k -> (k true, k false))
//│ res: (1 | 2, 1 | 2,)
//│    = [ 1, 2 ]


class Class: {x : int}
  method Test = 12
//│ Defined class Class
//│ Defined Class.Test: Class -> 12

c = Class{x = 1}
//│ c: Class & {x: 1}
//│  = Class { x: 1 }

:js
def useCls c = case c of { Class -> c.x | int -> "oops" }
//│ // Query 1
//│ globalThis.useCls = function useCls(c) {
//│   let temp;
//│   return (temp = c, temp instanceof Class ? c.x : Number.isInteger(temp) ? "oops" : (function () {
//│     throw new Error("non-exhaustive case expression");
//│   })());
//│ };
//│ res = useCls;
//│ // End of generated code
//│ useCls: ((Class with {x: 'a}) | int) -> ("oops" | 'a)
//│       = [Function: useCls]

useCls c
//│ res: "oops" | 1
//│    = 1

useCls (c with { x = 2 })
//│ /!!!\ Uncaught error: scala.NotImplementedError: an implementation is missing
//│ 	at: scala.Predef$.$qmark$qmark$qmark(Predef.scala:344)
//│ 	at: mlscript.TyperDatatypes$MiscBaseType.freshenAbove(TyperDatatypes.scala:109)
//│ 	at: mlscript.TyperDatatypes$MiscBaseType.freshenAbove(TyperDatatypes.scala:108)
//│ 	at: mlscript.NormalForms$LhsNf.$anonfun$freshenAbove$1(NormalForms.scala:28)
//│ 	at: scala.Option.map(Option.scala:242)
//│ 	at: mlscript.NormalForms$LhsNf.freshenAbove(NormalForms.scala:28)
//│ 	at: mlscript.NormalForms$Conjunct.freshenAbove(NormalForms.scala:229)
//│ 	at: mlscript.NormalForms$DNF.$anonfun$instantiate$1(NormalForms.scala:358)
//│ 	at: scala.collection.immutable.List.map(List.scala:246)
//│ 	at: mlscript.NormalForms$DNF.instantiate(NormalForms.scala:358)

:js
trait T
  method Test2 = 1
//│ Defined trait T
//│ Defined T.Test2: t -> 1
//│ // End of generated code

:js
class D: T & {z: int}
//│ Defined class D
//│ // Prelude
//│ class D {
//│   constructor(fields) {
//│     this.z = fields.z;
//│   }
//│ }
//│ // End of generated code

def useTrt t = case t of { T -> t.y | Class -> t.x }
//│ useTrt: ((Class with {x: 'a}) & ~t | {y: 'a} & t) -> 'a
//│       = [Function: useTrt]

:e
useTrt c
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.74: 	useTrt c
//│ ║        	^^^^^^^^
//│ ╟── expression of type `Class & {x: ?x} & t | Class & {x: ?x} & ~?a` does not have field 'y'
//│ ╟── Note: constraint arises from field selection:
//│ ║  l.69: 	def useTrt t = case t of { T -> t.y | Class -> t.x }
//│ ║        	                                ^^^
//│ ╟── from refined scrutinee:
//│ ║  l.69: 	def useTrt t = case t of { T -> t.y | Class -> t.x }
//│ ╙──      	                    ^
//│ res: 1 | error
//│ Runtime error:
//│   ReferenceError: T is not defined

:re
useTrt (c with { y = 1 })
//│ /!!!\ Uncaught error: scala.NotImplementedError: an implementation is missing
//│ 	at: scala.Predef$.$qmark$qmark$qmark(Predef.scala:344)
//│ 	at: mlscript.TyperDatatypes$MiscBaseType.freshenAbove(TyperDatatypes.scala:109)
//│ 	at: mlscript.TyperDatatypes$MiscBaseType.freshenAbove(TyperDatatypes.scala:108)
//│ 	at: mlscript.NormalForms$LhsNf.$anonfun$freshenAbove$1(NormalForms.scala:28)
//│ 	at: scala.Option.map(Option.scala:242)
//│ 	at: mlscript.NormalForms$LhsNf.freshenAbove(NormalForms.scala:28)
//│ 	at: mlscript.NormalForms$Conjunct.freshenAbove(NormalForms.scala:229)
//│ 	at: mlscript.NormalForms$DNF.$anonfun$instantiate$1(NormalForms.scala:358)
//│ 	at: scala.collection.immutable.List.map(List.scala:246)
//│ 	at: mlscript.NormalForms$DNF.instantiate(NormalForms.scala:358)

d = D{z = 1213}
//│ d: D & {z: 1213}
//│  = D { z: 1213 }

d: {z: 'a}
//│ res: {z: 1213}
//│    = D { z: 1213 }


