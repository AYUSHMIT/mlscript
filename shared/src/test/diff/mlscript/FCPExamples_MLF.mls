:NoJS

:GeneralizeCurriedFunctions
:NoRecursiveTypes


// ------------ Dummy classes to represent the types in the examples ------------

class List[a]
  method Get: a
//│ Defined class List[+a]
//│ Declared List.Get: List['a] -> 'a

class ST[S, A]
  method Inv_S: S -> S
  method Cov_A: A
//│ Defined class ST[=S, +A]
//│ Declared ST.Inv_S: ST['S, ?] -> 'S -> 'S
//│ Declared ST.Cov_A: ST['S, 'A] -> 'A


// ============ Type signatures for functions used in the examples ============

def choose x y = if true then x else y
//│ choose: 'a -> (forall 'a, 'b, 'c, 'd, 'e, 'f. ('e -> 'f
//│   where
//│     'c :> 'd -> 'd -> 'd
//│        <: 'a -> 'b
//│     'b <: 'e -> 'f))
//│   where
//│     'g :> 'h -> 'h -> 'h
//│        <: 'a -> 'i
//│     'i <: nothing -> 'b

def id x = x
//│ id: 'a -> 'a

def auto (x: forall 'a. 'a -> 'a) = x x
//│ auto: (forall 'a. 'a -> 'a) -> 'b
//│   where
//│     'c :> forall 'a. 'a -> 'a
//│        <: (forall 'a. 'a -> 'a) & 'c -> 'b

def app f x = f x
//│ app: 'a -> (forall 'a, 'b, 'c. ('b -> 'c
//│   where
//│     'a <: 'b -> 'c))
//│   where
//│     'a <: nothing -> 'a

def inc: int -> int
//│ inc: int -> int

// Used to represent `::` in the papers
def cons: 'a -> List['a] -> List['a]
//│ cons: 'a -> List['a] -> List['a]

// Used to represent `[]` in the papers
def nil: List['a]
//│ nil: List[nothing]

def single: 'a -> List['a]
//│ single: 'a -> List['a]

def head: List['a] -> 'a
//│ head: List['a] -> 'a

def tail: List['a] -> List['a]
//│ tail: List['a] -> List['a]

def append: List['a] -> List['a] -> List['a]
//│ append: List['a] -> List['a] -> List['a]

def runST: (forall 's. ST['s, 'v]) -> 'v
//│ runST: (forall 's. ST['s, 'v]) -> 'v

def argST: ST['s, int]
//│ argST: ST['s, int]


// ============ Raising ML to the power of System F (2003) ============

// This used to be `'a -> (forall 'b. 'b -> 'b | 'a)`, now it's wrong!
// FreezeML A2
choose id
//│ res: 'a -> 'b
//│   where
//│     'c :> 'd -> 'd -> 'd
//│        <: (forall 'e. 'e -> 'e) -> 'f
//│     'f <: 'a -> 'b

fun (g: forall 'a. ('a -> 'a) -> ('a -> 'a)) -> fun (x: forall 'a. 'a -> 'a) -> fun a -> g a (x a)
//│ res: (forall 'a. ('a -> 'a) -> 'a -> 'a) -> (forall 'b, 'c, 'd, 'e. ((forall 'a0. 'a0 -> 'a0) -> (forall 'f, 'b, 'd, 'g, 'h, 'i. ('g -> 'i
//│   where
//│     'b <: 'g -> 'f
//│     'd <: 'g -> 'h
//│     'f <: 'h -> 'i))
//│   where
//│     'b <: nothing -> 'c
//│     'd :> forall 'a0. 'a0 -> 'a0
//│        <: (forall 'a0. 'a0 -> 'a0) & nothing -> 'e
//│     'c <: 'e -> 'f))
//│   where
//│     'j :> forall 'a0. 'a0 -> 'a0
//│        <: (forall 'a0. 'a0 -> 'a0) & nothing -> 'k
//│     'l <: 'k -> 'f
//│     'b :> forall 'a. ('a -> 'a) -> 'a -> 'a
//│        <: (forall 'a. ('a -> 'a) -> 'a -> 'a) & nothing -> 'l

choose id succ
//│ res: int -> int

// FreezeML A7
choose id auto
//│ res: (forall 'a. 'a -> 'a & 'b) -> 'b
//│   where
//│     'c :> forall 'a. 'a -> 'a
//│        <: (forall 'a. 'a -> 'a) & 'c -> 'b

// nope, along with anything with it as a subterm
// i.e. unannotated auto
omega = fun x -> x x
//│ omega: 'a -> 'b
//│   where
//│     'a <: 'a -> 'b

fun (x: forall 'a. 'a) -> x x
//│ res: (forall 'a. 'a) -> 'b
//│   where
//│     'c :> forall 'a. 'a
//│        <: (forall 'a. 'a) & 'c -> 'b

// i.e. auto
omegad = fun (x: forall 'a. 'a -> 'a) -> x x
//│ omegad: (forall 'a. 'a -> 'a) -> 'b
//│   where
//│     'c :> forall 'a. 'a -> 'a
//│        <: (forall 'a. 'a -> 'a) & 'c -> 'b

// FreezeML A5
id auto
//│ res: (forall 'a. 'a -> 'a) -> 'b
//│   where
//│     'c :> forall 'a. 'a -> 'a
//│        <: (forall 'a. 'a -> 'a) & 'c -> 'b

// ~ auto id (FreezeML F5, PolyML 1.1)
(fun x -> x id) auto
//│ res: 'a -> 'a

app auto id
//│ res: 'a -> 'a

// ------------ Sec 5.2 ------------

// Error in the paper (confirmed by Rémy via email).
:e
let f = choose id in (f auto) (f succ)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.158: 	let f = choose id in (f auto) (f succ)
//│ ║         	                     ^^^^^^^^^^^^^^^^^
//│ ╟── type `‘a` is not an instance of type `int`
//│ ║  l.38: 	def auto (x: forall 'a. 'a -> 'a) = x x
//│ ╙──      	                    ^^
//│ res: int -> int | error

// Reproduced with an unnanotated auto:

def auto2 x = x x
//│ auto2: 'a -> 'b
//│   where
//│     'a <: 'a -> 'b

choose id auto2
//│ res: ('a & 'b) -> 'a
//│   where
//│     'b <: 'b -> 'a

:e // FIXME? succeeds with genLamBodies
res (choose id succ)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.180: 	res (choose id succ)
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ╟── reference of type `int -> int` is not an instance of type `int`
//│ ║  l.180: 	res (choose id succ)
//│ ║         	               ^^^^
//│ ╟── but it flows into application with expected type `int`
//│ ║  l.180: 	res (choose id succ)
//│ ╙──       	     ^^^^^^^^^^^^^^
//│ res: int -> int | error | int

// Didier Le Botlan suggested this fix by email:

let f = choose id in (f auto, f succ)
//│ res: (forall 'b, 'c, 'd. ((forall 'a. 'a -> 'a & 'd) -> ('d | 'c)
//│   where
//│     'b :> forall 'a. 'a -> 'a
//│        <: (forall 'a. 'a -> 'a) & 'b -> 'c), forall 'd. (int & 'd) -> (int | 'd),)

let f = choose id in (f auto2, f succ)
//│ res: (forall 'a, 'b, 'c. (('c & 'a) -> ('b | 'c)
//│   where
//│     'a <: 'a -> 'b), forall 'c. (int & 'c) -> (int | 'c),)

// ------------ Sec 6 ------------

// (λ(y) y I ; y K) (λ(x) x x)
// "typable in Fω but not in F [9]"
// [9] P. Giannini and S. R. D. Rocca. Characterization of typings in polymorphic type discipline. In Third annual Symposium on Logic in Computer Science, pages 61–70. IEEE, 1988.

// I := λx.x
I x = x
//│ I: 'a -> 'a

// K := λx.λy.x
K x y = x
//│ K: 'a -> anything -> 'a

(fun y -> let tmp = y I in y K) (fun x -> x x)
//│ res: anything -> (forall 'a. 'a -> anything -> 'a)

// Note: reduces to
let tmp = (fun x -> x x) I in (fun x -> x x) K
//│ res: anything -> (forall 'a. 'a -> anything -> 'a)

// to
let tmp = I I in K K
//│ res: anything -> (forall 'a. 'a -> anything -> 'a)


// ============ Recasting MLF (2009) ============

// ------------ Sec 1.3 ------------

// ~ FreezeML B1
(fun f -> (f 42, f "foo")) (fun x -> x)
//│ res: (42, "foo",)

(fun f -> (f succ, choose f auto)) (choose id)
//│ res: (forall 'b. (int & 'b) -> (int | 'b), forall 'c, 'd, 'e, 'f, 'g. ((forall 'h, 'a. 'a -> 'a & 'h) -> ('i | 'g)
//│   where
//│     'c :> 'd -> 'd -> 'd
//│        <: (forall 'b. 'b -> 'b) -> 'e
//│     'e <: 'h -> 'i
//│     'f :> forall 'a. 'a -> 'a
//│        <: (forall 'a. 'a -> 'a) & 'f -> 'g),)

// ------------ Sec 2.3.1 ------------

// i.e. id auto (FreezeML A5)
(fun z -> z) omegad
(fun z -> z) omega
//│ res: (forall 'a. 'a -> 'a) -> 'b
//│   where
//│     'c :> forall 'a. 'a -> 'a
//│        <: (forall 'a. 'a -> 'a) & 'c -> 'b
//│ res: 'a -> 'b
//│   where
//│     'a <: 'a -> 'b

// i.e. auto id (FreezeML F5)
(fun x -> x x) id
//│ res: 'a -> 'a

fun z -> (z omegad)
fun z -> (z omega)
//│ res: 'b -> 'c
//│   where
//│     'b <: (forall 'd, 'e. ((forall 'a. 'a -> 'a) -> 'e
//│   where
//│     'd :> forall 'a. 'a -> 'a
//│        <: (forall 'a. 'a -> 'a) & 'd -> 'e)) -> 'c
//│ res: 'a -> 'b
//│   where
//│     'a <: (forall 'c, 'd. ('c -> 'd
//│   where
//│     'c <: 'c -> 'd)) -> 'b

(fun y -> fun z -> z y) omegad
(fun y -> fun z -> z y) omega
//│ res: 'b -> 'c
//│   where
//│     'b <: (forall 'd, 'e. ((forall 'a. 'a -> 'a) -> 'e
//│   where
//│     'd :> forall 'a. 'a -> 'a
//│        <: (forall 'a. 'a -> 'a) & 'd -> 'e)) -> 'c
//│ res: 'a -> 'b
//│   where
//│     'a <: (forall 'c, 'd. ('c -> 'd
//│   where
//│     'c <: 'c -> 'd)) -> 'b

fun z -> omegad z
fun z -> omega z
//│ res: 'b -> 'c
//│   where
//│     'b <: forall 'a. 'a -> 'a
//│     'd :> forall 'a. 'a -> 'a
//│        <: (forall 'a. 'a -> 'a) & 'd -> 'e
//│     'e <: 'c
//│ res: 'a -> 'b
//│   where
//│     'a <: 'c
//│     'c <: 'c -> 'd
//│     'd <: 'b

(fun x -> fun y -> x y) omegad
(fun x -> fun y -> x y) omega
//│ res: 'a -> 'b
//│   where
//│     'c <: 'a -> 'b
//│ res: 'a -> 'b
//│   where
//│     'c <: 'a -> 'b

// ------------ Sec 4.3 ------------
// affects the order of bindings in the result type in MLF, not very interesting otherwise

fun (x: forall 'a. 'a -> 'b -> 'a) -> x
//│ res: (forall 'a. 'a -> 'b -> 'a) -> 'c
//│   where
//│     'c := forall 'a. 'a -> 'b -> 'a

fun (x: forall 'b 'a. 'a -> 'b -> 'a) -> x
//│ res: (forall 'a, 'b. 'a -> 'b -> 'a) -> 'c
//│   where
//│     'c := forall 'a, 'b. 'a -> 'b -> 'a

// ============ Leijen 2007 ============

// ------------ Sec 2 ------------

// FreezeML B1
// nope
poly = fun f -> (f 1, f true)
//│ poly: 'a -> ('b, 'c,)
//│   where
//│     'a <: 1 -> 'b & true -> 'c

// FreezeML B2
polyL = fun xs -> poly (head xs)
//│ polyL: 'b -> 'c
//│   where
//│     'd <: 1 -> 'e & true -> 'f
//│     'b <: List['a]
//│     'g <: 'd
//│     'a <: 'g
//│     'c :> ('e, 'f,)

let ids = single id in (polyL ids, append ids (single inc))
//│ res: ((1, true,), List[int -> int],)

// ------------ Sec 5 ------------

// FreezeML C5
ids = single id
//│ ids: List[forall 'a. 'a -> 'a]

// Let-bound version of FreezeML A3
let f = choose nil in f ids
//│ res: List[forall 'a. 'a -> 'a]

// FreezeML A3
choose nil ids
//│ res: List[forall 'a. 'a -> 'a]

def g: (int -> (forall 'a. 'a -> 'a)) -> int
//│ g: (int -> (forall 'a. 'a -> 'a)) -> int

g (fun x -> id)
//│ res: int

let f = fun x -> id in g f
//│ res: int

// FreezeML D4
app runST argST
//│ res: int

