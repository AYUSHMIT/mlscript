
// --- Lit, Add ---


class Lit: { val: int }
class Add[E]: { lhs: E; rhs: E }
def lit val = Lit { val }
def add lhs rhs = Add { lhs; rhs }
//│ Defined class Lit
//│ Defined class Add[+E]
//│ lit: (int & 'val) -> (Lit with {val: 'val})
//│    = [Function: lit]
//│ add: ('lhs & 'E) -> ('E & 'rhs) -> (Add['E] with {lhs: 'lhs, rhs: 'rhs})
//│    = [Function: add]


:stats
def eval1 eval1 e = case e of {
  | Lit -> e.val
  | Add -> eval1 eval1 e.lhs + eval1 eval1 e.rhs
  }
//│ eval1: ('a -> 'rhs -> int & 'a -> 'lhs -> int & 'a) -> ((Add[?] with {lhs: 'lhs, rhs: 'rhs}) | (Lit with {val: 'val})) -> (int | 'val)
//│      = [Function: eval1]
//│ constrain calls  : 36
//│ annoying  calls  : 0
//│ subtyping calls  : 55

:stats
def eval1f eval1 e = case e of {
  | Lit -> e.val
  | Add -> eval1 e.lhs + eval1 e.rhs
  }
//│ eval1f: ('rhs -> int & 'lhs -> int) -> ((Add[?] with {lhs: 'lhs, rhs: 'rhs}) | (Lit with {val: 'val})) -> (int | 'val)
//│       = [Function: eval1f]
//│ constrain calls  : 32
//│ annoying  calls  : 0
//│ subtyping calls  : 52


e1 = add (lit 1) (add (lit 2) (lit 3))
//│ e1: Add[Add[Lit & {val: 2 | 3}] & {lhs: Lit & {val: 2}, rhs: Lit & {val: 3}} | Lit & {val: 1}] with {lhs: Lit & {val: 1}, rhs: Add[Lit & {val: 2 | 3}] & {lhs: Lit & {val: 2}, rhs: Lit & {val: 3}}}
//│   = Add {
//│       lhs: Lit { val: 1 },
//│       rhs: Add { lhs: Lit { val: 2 }, rhs: Lit { val: 3 } }
//│     }


:e
eval1 eval1 e1
//│ ╔══[ERROR] Cyclic-looking constraint while typing application
//│ ║  l.49: 	eval1 eval1 e1
//│ ║        	^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ∀ 0. (α53' -> (α54' -> (val56' | α65')))  <:  ((α164,) -> α165)    PolymorphicType  FunctionType
//│ ╙──  ... looks like:  ∀ 0. (α53' -> (α54' -> (val56' | α65')))  <:  ((α53',) -> α62')
//│ res: error
//│    = 6

:e
def eval1_fixed_1 = eval1 eval1
//│ ╔══[ERROR] Cyclic-looking constraint while typing application
//│ ║  l.60: 	def eval1_fixed_1 = eval1 eval1
//│ ║        	                    ^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ∀ 0. (α53' -> (α54' -> (val56' | α65')))  <:  ((α227',) -> α228')    PolymorphicType  FunctionType
//│ ╙──  ... looks like:  ∀ 0. (α53' -> (α54' -> (val56' | α65')))  <:  ((α53',) -> α62')
//│ eval1_fixed_1: error
//│              = [Function (anonymous)]

eval1_fixed_1 e1
//│ res: error
//│    = 6


rec def eval1_fixed_2 = eval1f (fun x -> eval1f eval1_fixed_2 x)
//│ eval1_fixed_2: 'a -> int
//│   where
//│     'a <: Add[?] & {lhs: Add[?] & {lhs: 'a, rhs: 'a} | Lit, rhs: Add[?] & {lhs: 'a, rhs: 'a} | Lit} | Lit
//│              = [Function (anonymous)]

eval1_fixed_2 e1
//│ res: int
//│    = 6


:e
// Tying the know without a recursive def:
def eval1_fixed_3 =
  let fixed fixed = eval1f (fun x -> eval1f (fixed fixed) x)
  in fixed fixed
//│ ╔══[ERROR] Cyclic-looking constraint while typing application
//│ ║  l.90: 	  in fixed fixed
//│ ║        	     ^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ∀ 1. (α394'' -> α414'')  <:  ((α472',) -> α473')    PolymorphicType  FunctionType
//│ ╙──  ... looks like:  ∀ 1. (α394'' -> α414'')  <:  ((α394'',) -> α397'')
//│ eval1_fixed_3: (Add[?] & {lhs: Add[?] & {lhs: Add[?] & {lhs: Add[?] | Lit, rhs: Add[?] | Lit} | Lit, rhs: Add[?] & {lhs: Add[?] | Lit, rhs: Add[?] | Lit} | Lit} | Lit, rhs: Add[?] & {lhs: Add[?] & {lhs: Add[?] | Lit, rhs: Add[?] | Lit} | Lit, rhs: Add[?] & {lhs: Add[?] | Lit, rhs: Add[?] | Lit} | Lit} | Lit} | (Lit with {val: 'val})) -> (int | 'val) | error
//│              = [Function (anonymous)]

eval1_fixed_3 e1
//│ res: error | int
//│    = 6



// --- Nega ---


class Nega[E]: { arg: E }
def nega arg = Nega { arg }
//│ Defined class Nega[+E]
//│ nega: 'arg -> Nega['arg]
//│     = [Function: nega]


def eval2 eval2 e = case e of {
  | Nega -> 0 - (eval2 eval2 e.arg)
  | _ -> eval1 eval2 e
  }
//│ eval2: ('a -> 'arg -> int & 'a -> 'rhs -> int & 'a -> 'lhs -> int & 'a) -> ((Add[?] with {lhs: 'lhs, rhs: 'rhs}) | (Lit with {val: 'val}) | (Nega[?] with {arg: 'arg})) -> (int | 'val)
//│      = [Function: eval2]

def eval2f eval2 e = case e of {
  | Nega -> 0 - (eval2 e.arg)
  | _ -> eval1f eval2 e
  }
//│ eval2f: ('arg -> int & 'rhs -> int & 'lhs -> int) -> ((Add[?] with {lhs: 'lhs, rhs: 'rhs}) | (Lit with {val: 'val}) | (Nega[?] with {arg: 'arg})) -> (int | 'val)
//│       = [Function: eval2f]


e2 = add (lit 1) (nega e1)
//│ e2: Add[Lit & {val: 1} | Nega[Add[Add[Lit & {val: 2 | 3}] & {lhs: Lit & {val: 2}, rhs: Lit & {val: 3}} | Lit & {val: 1}] with {lhs: Lit & {val: 1}, rhs: Add[Lit & {val: 2 | 3}] & {lhs: Lit & {val: 2}, rhs: Lit & {val: 3}}}]] with {lhs: Lit & {val: 1}, rhs: Nega[Add[Add[Lit & {val: 2 | 3}] & {lhs: Lit & {val: 2}, rhs: Lit & {val: 3}} | Lit & {val: 1}] with {lhs: Lit & {val: 1}, rhs: Add[Lit & {val: 2 | 3}] & {lhs: Lit & {val: 2}, rhs: Lit & {val: 3}}}]}
//│   = Add {
//│       lhs: Lit { val: 1 },
//│       rhs: Nega { arg: Add { lhs: [Lit], rhs: [Add] } }
//│     }


:e
def eval2_fixed_1 = eval2 eval2
//│ ╔══[ERROR] Cyclic-looking constraint while typing application
//│ ║  l.140: 	def eval2_fixed_1 = eval2 eval2
//│ ║         	                    ^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ∀ 0. (α621' -> (α622' -> (α628' | α643')))  <:  ((α778',) -> α779')    PolymorphicType  FunctionType
//│ ╙──  ... looks like:  ∀ 0. (α621' -> (α622' -> (α628' | α643')))  <:  ((α631',) -> α632')
//│ eval2_fixed_1: error
//│              = [Function (anonymous)]

eval2_fixed_1 e1
eval2_fixed_1 e2
//│ res: error
//│    = 6
//│ res: error
//│    = -5

:e
def fix f = let fixed = fun x -> f (fun v -> (x x) v) in fixed fixed
//│ ╔══[ERROR] Cyclic-looking constraint while typing application
//│ ║  l.158: 	def fix f = let fixed = fun x -> f (fun v -> (x x) v) in fixed fixed
//│ ║         	                                                         ^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ∀ 1. (α869'' -> α876'')  <:  ((α888',) -> α889')    PolymorphicType  FunctionType
//│ ╙──  ... looks like:  ∀ 1. (α869'' -> α876'')  <:  ((α869'',) -> α872'')
//│ fix: (('a -> 'b) -> ('a -> 'b & 'c)) -> (error | 'c)
//│    = [Function: fix]

def eval2_fixed_2 = fix eval2f
//│ eval2_fixed_2: 'a -> int | error
//│   where
//│     'a <: Add[?] & {lhs: 'a, rhs: 'a} | Lit | Nega[?] & {arg: 'a}
//│              = [Function (anonymous)]

eval2_fixed_2 e1
eval2_fixed_2 e2
//│ ╔══[ERROR] Subtyping constraint of the form `forall ?a, ?b, ?c, ?arg, ?d, ?e, ?f, ?g, ?h, ?val, ?i, ?rhs, ?lhs, ?j, ?k. ?a <: (forall ?l, ?lhs0, ?val0, ?E, ?lhs1, ?val1, ?E0, ?val2, ?rhs0, ?rhs1. ?l) -> ?m` exceeded recursion depth limit (100)
//│ ║  l.174: 	eval2_fixed_2 e1
//│ ║         	^^^^^^^^^^^^^^^^
//│ ╟── while constraining:  (lit<> & {val: val982})  <!<  α966
//│ ╟── while constraining:  (lit<> & {val: val982})  <!<  α965
//│ ╟── while constraining:  (lit<> & {val: val982})  <!<  ((nega<> & α961) | (α965 & ~(nega<>)))
//│ ╟── while constraining:  (lit<> & {val: val982})  <!<  α960
//│ ╟── while constraining:  (lit<> & {val: val982})  <!<  α964
//│ ╟── while constraining:  (lit<> & {val: val982})  <!<  α963
//│ ╟── while constraining:  (lit<> & {val: val982})  <!<  rhs970
//│ ╟── while constraining:  rhs983  <!<  rhs970
//│ ╟── while constraining:  (add<> & {Add#E: mut E981..E981, lhs: lhs979, rhs: rhs983})  <!<  {rhs: rhs970}
//│ ╟── while constraining:  (add<> & {Add#E: mut E981..E981, lhs: lhs979, rhs: rhs983})  <!<  α969
//│ ╟── while constraining:  (add<> & {Add#E: mut E981..E981, lhs: lhs979, rhs: rhs983})  <!<  ((lit<> & α967) | ((add<> & α969) & ~(lit<>)))
//│ ╟── while constraining:  (add<> & {Add#E: mut E981..E981, lhs: lhs979, rhs: rhs983})  <!<  α966
//│ ╟── while constraining:  (add<> & {Add#E: mut E981..E981, lhs: lhs979, rhs: rhs983})  <!<  α965
//│ ╟── while constraining:  (add<> & {lhs: lhs979, rhs: rhs983, Add#E: mut E981..E981})  <!<  ((nega<> & α961) | (α965 & ~(nega<>)))
//│ ╟── while constraining:  (add<> & {lhs: lhs979, rhs: rhs983, Add#E: mut E981..E981})  <!<  α960
//│ ╟── while constraining:  (add<> & {lhs: lhs979, rhs: rhs983, Add#E: mut E981..E981})  <!<  α964
//│ ╟── while constraining:  (add<> & {lhs: lhs979, rhs: rhs983, Add#E: mut E981..E981})  <!<  α963
//│ ╟── while constraining:  (add<> & {lhs: lhs979, rhs: rhs983, Add#E: mut E981..E981})  <!<  rhs970
//│ ╟── while constraining:  rhs984  <!<  rhs970
//│ ╟── while constraining:  (add<> & {Add#E: mut E978..E978, lhs: lhs976, rhs: rhs984})  <!<  {rhs: rhs970}
//│ ╟── while constraining:  (add<> & {Add#E: mut E978..E978, lhs: lhs976, rhs: rhs984})  <!<  α969
//│ ╟── while constraining:  (add<> & {Add#E: mut E978..E978, lhs: lhs976, rhs: rhs984})  <!<  ((lit<> & α967) | ((add<> & α969) & ~(lit<>)))
//│ ╟── while constraining:  (add<> & {Add#E: mut E978..E978, lhs: lhs976, rhs: rhs984})  <!<  α966
//│ ╟── while constraining:  (add<> & {Add#E: mut E978..E978, lhs: lhs976, rhs: rhs984})  <!<  α965
//│ ╟── while constraining:  (add<> & {lhs: lhs976, rhs: rhs984, Add#E: mut E978..E978})  <!<  ((nega<> & α961) | (α965 & ~(nega<>)))
//│ ╟── while constraining:  α975  <!<  ((nega<> & α961) | (α965 & ~(nega<>)))
//│ ╟── while constraining:  ∀ 0. α140'  <!<  ((nega<> & α961) | (α965 & ~(nega<>)))
//│ ╟── while constraining:  ∀ 0. α140'  <!<  α960
//│ ╟── while constraining:  (∀ 0. α140',)  <!<  (α960,)
//│ ╟── while constraining:  (α960 -> (α972 | α973))  <!<  ((∀ 0. α140',) -> α958)
//│ ╟── while constraining:  α959  <!<  ((∀ 0. α140',) -> α958)
//│ ╙── while constraining:  ∀ 0. α909'  <!<  ((∀ 0. α140',) -> α958)
//│ res: error
//│    = 6
//│ ╔══[ERROR] Subtyping constraint of the form `forall ?a, ?b, ?c, ?arg, ?d, ?e, ?f, ?g, ?h, ?val, ?i, ?rhs, ?lhs, ?j, ?k. ?a <: (forall ?l, ?E, ?E0. ?l) -> ?m` exceeded recursion depth limit (100)
//│ ║  l.175: 	eval2_fixed_2 e2
//│ ║         	^^^^^^^^^^^^^^^^
//│ ╟── while constraining:  (add<> & {Add#E: mut E1040..E1040, lhs: lhs1038, rhs: rhs1046})  <!<  {rhs: rhs1025}
//│ ╟── while constraining:  (add<> & {Add#E: mut E1040..E1040, lhs: lhs1038, rhs: rhs1046})  <!<  α1024
//│ ╟── while constraining:  (add<> & {Add#E: mut E1040..E1040, lhs: lhs1038, rhs: rhs1046})  <!<  ((lit<> & α1022) | ((add<> & α1024) & ~(lit<>)))
//│ ╟── while constraining:  (add<> & {Add#E: mut E1040..E1040, lhs: lhs1038, rhs: rhs1046})  <!<  α1021
//│ ╟── while constraining:  (add<> & {Add#E: mut E1040..E1040, lhs: lhs1038, rhs: rhs1046})  <!<  α1020
//│ ╟── while constraining:  (add<> & {lhs: lhs1038, rhs: rhs1046, Add#E: mut E1040..E1040})  <!<  ((nega<> & α1016) | (α1020 & ~(nega<>)))
//│ ╟── while constraining:  α1037  <!<  ((nega<> & α1016) | (α1020 & ~(nega<>)))
//│ ╟── while constraining:  ∀ 0. α140'  <!<  ((nega<> & α1016) | (α1020 & ~(nega<>)))
//│ ╟── while constraining:  ∀ 0. α140'  <!<  α1015
//│ ╟── while constraining:  ∀ 0. α140'  <!<  α1019
//│ ╟── while constraining:  ∀ 0. α140'  <!<  α1018
//│ ╟── while constraining:  ∀ 0. α140'  <!<  arg1017
//│ ╟── while constraining:  arg1034  <!<  arg1017
//│ ╟── while constraining:  (nega<> & {arg: arg1034, Nega#E: mut E1035..E1035})  <!<  {arg: arg1017}
//│ ╟── while constraining:  (nega<> & {arg: arg1034, Nega#E: mut E1035..E1035})  <!<  α1016
//│ ╟── while constraining:  (nega<> & {arg: arg1034, Nega#E: mut E1035..E1035})  <!<  ((nega<> & α1016) | (α1020 & ~(nega<>)))
//│ ╟── while constraining:  (nega<> & {arg: arg1034, Nega#E: mut E1035..E1035})  <!<  α1015
//│ ╟── while constraining:  (nega<> & {arg: arg1034, Nega#E: mut E1035..E1035})  <!<  α1019
//│ ╟── while constraining:  (nega<> & {arg: arg1034, Nega#E: mut E1035..E1035})  <!<  α1018
//│ ╟── while constraining:  (nega<> & {arg: arg1034, Nega#E: mut E1035..E1035})  <!<  rhs1025
//│ ╟── while constraining:  rhs1036  <!<  rhs1025
//│ ╟── while constraining:  (add<> & {Add#E: mut E1033..E1033, lhs: lhs1031, rhs: rhs1036})  <!<  {rhs: rhs1025}
//│ ╟── while constraining:  (add<> & {Add#E: mut E1033..E1033, lhs: lhs1031, rhs: rhs1036})  <!<  α1024
//│ ╟── while constraining:  (add<> & {Add#E: mut E1033..E1033, lhs: lhs1031, rhs: rhs1036})  <!<  ((lit<> & α1022) | ((add<> & α1024) & ~(lit<>)))
//│ ╟── while constraining:  (add<> & {Add#E: mut E1033..E1033, lhs: lhs1031, rhs: rhs1036})  <!<  α1021
//│ ╟── while constraining:  (add<> & {Add#E: mut E1033..E1033, lhs: lhs1031, rhs: rhs1036})  <!<  α1020
//│ ╟── while constraining:  (add<> & {lhs: lhs1031, rhs: rhs1036, Add#E: mut E1033..E1033})  <!<  ((nega<> & α1016) | (α1020 & ~(nega<>)))
//│ ╟── while constraining:  α1030  <!<  ((nega<> & α1016) | (α1020 & ~(nega<>)))
//│ ╟── while constraining:  ∀ 0. α737'  <!<  ((nega<> & α1016) | (α1020 & ~(nega<>)))
//│ ╟── while constraining:  ∀ 0. α737'  <!<  α1015
//│ ╟── while constraining:  (∀ 0. α737',)  <!<  (α1015,)
//│ ╟── while constraining:  (α1015 -> (α1027 | α1028))  <!<  ((∀ 0. α737',) -> α1013)
//│ ╟── while constraining:  α1014  <!<  ((∀ 0. α737',) -> α1013)
//│ ╙── while constraining:  ∀ 0. α909'  <!<  ((∀ 0. α737',) -> α1013)
//│ res: error
//│    = -5




// === === === ERROR CASES === === === //



// FIXME should be a code-gen error
:re
rec def eval1_fixed = eval1f (eval1f eval1_fixed)
//│ eval1_fixed: 'a -> int
//│   where
//│     'a <: Add[?] & {lhs: 'a, rhs: 'a} | Lit
//│ Runtime error:
//│   ReferenceError: eval1_fixed is not defined

rec def eval1_fixed() = eval1f (eval1f (eval1_fixed()))
//│ eval1_fixed: () -> 'a -> int
//│   where
//│     'a <: Add[?] & {lhs: 'a, rhs: 'a} | Lit
//│            = [Function: eval1_fixed1]

:re
eval1_fixed() e1
//│ res: int
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded



:ShowRelativeLineNums
:AllowTypeErrors



def eval1_fixed = eval1f (fun x -> eval1f eval1f x)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	def eval1_fixed = eval1f (fun x -> eval1f eval1f x)
//│ ║        	                                   ^^^^^^^^^^^^^
//│ ╟── function of type `?a -> (?val | ?b)` is not an instance of type `int`
//│ ║  l.29: 	def eval1f eval1 e = case e of {
//│ ║        	                 ^^^^^^^^^^^^^^^
//│ ║  l.30: 	  | Lit -> e.val
//│ ║        	^^^^^^^^^^^^^^^^
//│ ║  l.31: 	  | Add -> eval1 e.lhs + eval1 e.rhs
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.32: 	  }
//│ ║        	^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.31: 	  | Add -> eval1 e.lhs + eval1 e.rhs
//│ ╙──      	                         ^^^^^^^^^^^
//│ eval1_fixed: (Add[?] & {lhs: Add[?] & {lhs: nothing -> int, rhs: nothing -> int} | Lit, rhs: Add[?] & {lhs: nothing -> int, rhs: nothing -> int} | Lit} | (Lit with {val: 'val})) -> (int | 'val)

rec def eval1_fixed = eval1f (fun x -> eval1_fixed eval1_fixed x)
//│ ╔══[ERROR] Type mismatch in binding of application:
//│ ║  l.+1: 	rec def eval1_fixed = eval1f (fun x -> eval1_fixed eval1_fixed x)
//│ ║        	                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> (?val | ?b)` does not match type `Add[?] & ?c | Lit & ?d`
//│ ║  l.29: 	def eval1f eval1 e = case e of {
//│ ║        	                 ^^^^^^^^^^^^^^^
//│ ║  l.30: 	  | Lit -> e.val
//│ ║        	^^^^^^^^^^^^^^^^
//│ ║  l.31: 	  | Add -> eval1 e.lhs + eval1 e.rhs
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.32: 	  }
//│ ║        	^^^
//│ ╟── but it flows into application with expected type `Add[?] & ?e | Lit & ?f`
//│ ║  l.+1: 	rec def eval1_fixed = eval1f (fun x -> eval1_fixed eval1_fixed x)
//│ ║        	                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.29: 	def eval1f eval1 e = case e of {
//│ ╙──      	                          ^
//│ ╔══[ERROR] Type mismatch in binding of application:
//│ ║  l.+1: 	rec def eval1_fixed = eval1f (fun x -> eval1_fixed eval1_fixed x)
//│ ║        	                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── operator application of type `int` is not a function
//│ ║  l.31: 	  | Add -> eval1 e.lhs + eval1 e.rhs
//│ ║        	           ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.+1: 	rec def eval1_fixed = eval1f (fun x -> eval1_fixed eval1_fixed x)
//│ ║        	                                       ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from application:
//│ ║  l.+1: 	rec def eval1_fixed = eval1f (fun x -> eval1_fixed eval1_fixed x)
//│ ╙──      	                                       ^^^^^^^^^^^^^^^^^^^^^^^
//│ eval1_fixed: ((Add[?] with {lhs: 'a, rhs: 'a}) | (Lit with {val: 'a -> int & 'val})) -> (int | 'val)

:e
rec def eval1_fixed = eval1f eval1_fixed e1
//│ ╔══[ERROR] Type mismatch in binding of application:
//│ ║  l.+1: 	rec def eval1_fixed = eval1f eval1_fixed e1
//│ ║        	                      ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── operator application of type `int` is not a function
//│ ║  l.31: 	  | Add -> eval1 e.lhs + eval1 e.rhs
//│ ║        	           ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into application with expected type `?rhs -> ?a`
//│ ║  l.+1: 	rec def eval1_fixed = eval1f eval1_fixed e1
//│ ║        	                      ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.31: 	  | Add -> eval1 e.lhs + eval1 e.rhs
//│ ║        	                         ^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.+1: 	rec def eval1_fixed = eval1f eval1_fixed e1
//│ ╙──      	                             ^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of application:
//│ ║  l.+1: 	rec def eval1_fixed = eval1f eval1_fixed e1
//│ ║        	                      ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── operator application of type `int` is not a function
//│ ║  l.31: 	  | Add -> eval1 e.lhs + eval1 e.rhs
//│ ║        	           ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into application with expected type `?lhs -> ?a`
//│ ║  l.+1: 	rec def eval1_fixed = eval1f eval1_fixed e1
//│ ║        	                      ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.31: 	  | Add -> eval1 e.lhs + eval1 e.rhs
//│ ║        	           ^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.+1: 	rec def eval1_fixed = eval1f eval1_fixed e1
//│ ╙──      	                             ^^^^^^^^^^^
//│ eval1_fixed: int


def eval2_broken eval2 e = case e of {
  | Nega -> e.arg
  | _ -> eval1 eval2 e
  }
//│ eval2_broken: ('a -> 'rhs -> int & 'a -> 'lhs -> int & 'a) -> ((Add[?] with {lhs: 'lhs, rhs: 'rhs}) | (Lit with {val: 'arg}) | (Nega[?] with {arg: 'arg})) -> ('arg | int)

:e
eval2_broken eval2_broken e2
//│ ╔══[ERROR] Cyclic-looking constraint while typing application
//│ ║  l.+1: 	eval2_broken eval2_broken e2
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ∀ 0. (α1432' -> (α1433' -> (arg1435' | α1450')))  <:  ((α1497,) -> α1498)    PolymorphicType  FunctionType
//│ ╙──  ... looks like:  ∀ 0. (α1432' -> (α1433' -> (arg1435' | α1450')))  <:  ((α1438',) -> α1439')
//│ res: error


def eval2f_oops eval2 e = case e of {
  | Nega -> 0 - (eval2 e.arg)
  | _ -> eval1 eval2 e // should be: eval1f eval2 e
  }
//│ eval2f_oops: ('arg -> int & 'a -> 'rhs -> int & 'a -> 'lhs -> int & 'a) -> ((Add[?] with {lhs: 'lhs, rhs: 'rhs}) | (Lit with {val: 'val}) | (Nega[?] with {arg: 'arg})) -> (int | 'val)

// :e
fix eval2f_oops e2
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	fix eval2f_oops e2
//│ ║        	^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> ?b` does not match type `Add[?] & ?c | Lit & ?d`
//│ ║  l.158: 	def fix f = let fixed = fun x -> f (fun v -> (x x) v) in fixed fixed
//│ ║         	                                    ^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.18: 	def eval1 eval1 e = case e of {
//│ ║        	                         ^
//│ ╟── from reference:
//│ ║  l.391: 	def eval2f_oops eval2 e = case e of {
//│ ╙──       	                               ^
//│ res: error | int


