

class Ref[A]
  method Get: A
  method Set: A -> unit
  method Swap x = let tmp = this.Get in let _ = this.Set x in tmp
//│ Defined class Ref[=A]
//│ Declared Ref.Get: Ref['A] -> 'A
//│ Declared Ref.Set: Ref['A] -> 'A -> unit
//│ Defined Ref.Swap: Ref['A] -> 'A -> 'A

class RefImpl[A]: Ref[A] & { mut value: A }
  method Get   = this.value
  method Set a = this.value <- a
//│ Defined class RefImpl[=A]
//│ Defined RefImpl.Get: RefImpl['A] -> 'A
//│ Defined RefImpl.Set: RefImpl['A] -> 'A -> unit



def move a b = a.Set b.Get
//│ move: Ref['A] -> Ref['A0] -> unit
//│   where
//│     'A0 <: 'A
//│     = [Function: move]

def move_ty: Ref['a] -> Ref[('a & 'b)..'b] -> unit
//│ move_ty: Ref['a] -> Ref[in 'a & 'b out 'b] -> unit
//│        = <missing implementation>
:e // * Works with existential wildcards
move_ty = move
//│ Ref['A] -> Ref['A0] -> unit
//│   where
//│     'A0 <: 'A
//│   <:  move_ty:
//│ Ref['a] -> Ref[in 'a & 'b out 'b] -> unit
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.31: 	move_ty = move
//│ ║        	^^^^^^^^^^^^^^
//│ ╟── type `'b` does not match type `'a`
//│ ║  l.27: 	def move_ty: Ref['a] -> Ref[('a & 'b)..'b] -> unit
//│ ║        	                                       ^^
//│ ╟── Note: constraint arises from type variable:
//│ ║  l.27: 	def move_ty: Ref['a] -> Ref[('a & 'b)..'b] -> unit
//│ ║        	                 ^^
//│ ╟── from field selection:
//│ ║  l.21: 	def move a b = a.Set b.Get
//│ ║        	                     ^^^^^
//│ ╟── Note: class type parameter A is defined at:
//│ ║  l.3: 	class Ref[A]
//│ ╙──     	          ^
//│        = [Function: move]

def move_approx: Ref['a] -> Ref['a] -> unit
move_approx = move
//│ move_approx: Ref['a] -> Ref['a] -> unit
//│            = <missing implementation>
//│ Ref['A] -> Ref['A0] -> unit
//│   where
//│     'A0 <: 'A
//│   <:  move_approx:
//│ Ref['a] -> Ref['a] -> unit
//│            = [Function: move]

def move_bad: Ref['a] -> Ref['a..('a & 'b)] -> unit
//│ move_bad: Ref['a] -> Ref['a] -> unit
//│         = <missing implementation>
// :e // * Doesn't work with existential wildcards
move_bad = move
//│ Ref['A] -> Ref['A0] -> unit
//│   where
//│     'A0 <: 'A
//│   <:  move_bad:
//│ Ref['a] -> Ref['a] -> unit
//│         = [Function: move]


r = RefImpl{mut value = 1}
//│ r: RefImpl['A] with {mut value: 'value}
//│   where
//│     'value :> 1
//│            <: 'A
//│     'A :> 1
//│  = RefImpl { value: 1 }

ri = r : Ref[int]
rn = r : Ref[number]
//│ ri: Ref[int]
//│   = RefImpl { value: 1 }
//│ rn: Ref[number]
//│   = RefImpl { value: 1 }

(r.Get, r.Set, r.Swap)
//│ res: (1, anything -> unit, 'A -> (1 | 'A),)
//│    = [ 1, [Function: Set], [Function: Swap] ]

move r
move_ty r
move_approx r
//│ res: Ref['A] -> unit
//│    = [Function (anonymous)]
//│ res: Ref[in 1 & 'b out 'b] -> unit
//│    = [Function (anonymous)]
//│ res: Ref['a] -> unit
//│   where
//│     'a :> 1
//│    = [Function (anonymous)]

move ri
move_ty ri
move_approx ri
//│ res: Ref['A] -> unit
//│   where
//│     'A <: int
//│    = [Function (anonymous)]
//│ res: Ref[in int & 'b out 'b] -> unit
//│    = [Function (anonymous)]
//│ res: Ref[int] -> unit
//│    = [Function (anonymous)]

fun x -> move x r
fun x -> move_ty x r
fun x -> move_approx x r
//│ res: Ref['A] -> unit
//│   where
//│     'A :> 1
//│    = [Function: res]
//│ res: Ref['a] -> unit
//│   where
//│     'a :> 1
//│    = [Function: res]
//│ res: Ref['a] -> unit
//│   where
//│     'a :> 1
//│    = [Function: res]

fun x -> move x ri
fun x -> move_ty x ri
fun x -> move_approx x ri
//│ res: Ref['A] -> unit
//│   where
//│     'A :> int
//│    = [Function: res]
//│ res: Ref['a] -> unit
//│   where
//│     'a :> int
//│    = [Function: res]
//│ res: Ref[int] -> unit
//│    = [Function: res]

move r ri
move rn r
move rn ri
//│ = []
//│ = []
//│ = []

:e
move ri rn
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.159: 	move ri rn
//│ ║         	^^^^^^^^^^
//│ ╟── type `number` is not an instance of `int`
//│ ║  l.87: 	rn = r : Ref[number]
//│ ║        	             ^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.86: 	ri = r : Ref[int]
//│ ║        	             ^^^
//│ ╟── from field selection:
//│ ║  l.21: 	def move a b = a.Set b.Get
//│ ║        	                     ^^^^^
//│ ╟── Note: class type parameter A is defined at:
//│ ║  l.3: 	class Ref[A]
//│ ╙──     	          ^
//│ res: error | unit
//│    = []


:d
def swap a b = let tmp = a.Get in (a.Set b.Get, b.Set tmp)
//│ 1. Typing term (a,) => (b,) => let tmp = (a).Get in (a).Set ((b).Get,), (b).Set (tmp,),
//│ | TYPING POLY LAM
//│ | 2. Typing pattern a,
//│ | | 2. Typing pattern a
//│ | | 2. : a644''
//│ | 2. : (a644'',)
//│ | 2. Typing term (b,) => let tmp = (a).Get in (a).Set ((b).Get,), (b).Set (tmp,),
//│ | | 2. Typing pattern b,
//│ | | | 2. Typing pattern b
//│ | | | 2. : b645''
//│ | | 2. : (b645'',)
//│ | | 2. Typing term let tmp = (a).Get in (a).Set ((b).Get,), (b).Set (tmp,),
//│ | | | 3. Typing term (a).Get
//│ | | | | 3. Typing term a
//│ | | | | 3. : a644''
//│ | | | | INST [0]   ‹∀ 0. (this23' -> A22')›
//│ | | | |   where  
//│ 		this23' <: Ref[A22']
//│ | | | | TO [3] ~>  (this23_647''' -> A22_648''')
//│ | | | |   where  
//│ 		this23_647''' <: Ref[A22_648''']
//│ | | | | CONSTRAIN (this23_647''' -> A22_648''') <! (a644'' -> α646''')
//│ | | | |   where 
//│ 		this23_647''' <: Ref[A22_648''']
//│ | | | | 3. C (this23_647''' -> A22_648''') <! (a644'' -> α646''')    (0)
//│ | | | | | 3. C (a644'',) <! (this23_647''',)    (1)
//│ | | | | | | 3. C a644'' <! this23_647'''    (2)
//│ | | | | | | | NEW this23_647''' LB (2)
//│ | | | | | | | 3. C a644'' <! Ref[A22_648''']    (4)
//│ | | | | | | | | wrong level: 3
//│ | | | | | | | | RECONSTRAINING TVs
//│ | | | | | | | | EXTR RHS  ~>  Ref[A22_649''..A22_650'']  to 2
//│ | | | | | | | |  where 
//│ 		A22_650'' :> A22_649''
//│ | | | | | | | | 3. C a644'' <! Ref[A22_649''..A22_650'']    (6)
//│ | | | | | | | | | NEW a644'' UB (2)
//│ | | | | | 3. C A22_648''' <! α646'''    (1)
//│ | | | | | | NEW A22_648''' UB (3)
//│ | | | | | | 3. C A22_649'' <! α646'''    (3)
//│ | | | | | | | NEW α646''' LB (2)
//│ | | | 3. : α646'''
//│ | | | UNSTASHING... (out)
//│ | | | 2. Typing term (a).Set ((b).Get,), (b).Set (tmp,),
//│ | | | | 2. Typing term (a).Set ((b).Get,)
//│ | | | | | 2. Typing term (a).Set
//│ | | | | | | 2. Typing term a
//│ | | | | | | 2. : a644''
//│ | | | | | | INST [0]   ‹∀ 0. (this23' -> (A22' -> Unit))›
//│ | | | | | |   where  
//│ 		this23' <: Ref[A22']
//│ | | | | | | TO [2] ~>  (this23_652'' -> (A22_653'' -> Unit))
//│ | | | | | |   where  
//│ 		this23_652'' <: Ref[A22_653'']
//│ | | | | | | CONSTRAIN (this23_652'' -> (A22_653'' -> Unit)) <! (a644'' -> α651'')
//│ | | | | | |   where 
//│ 		a644'' <: Ref[A22_649''..A22_650'']
//│ 		A22_650'' :> A22_649''
//│ 		this23_652'' <: Ref[A22_653'']
//│ | | | | | | 2. C (this23_652'' -> (A22_653'' -> Unit)) <! (a644'' -> α651'')    (0)
//│ | | | | | | | 2. C (a644'',) <! (this23_652'',)    (1)
//│ | | | | | | | | 2. C a644'' <! this23_652''    (2)
//│ | | | | | | | | | NEW a644'' UB (2)
//│ | | | | | | | 2. C (A22_653'' -> Unit) <! α651''    (1)
//│ | | | | | | | | NEW α651'' LB (2)
//│ | | | | | 2. : α651''
//│ | | | | | 2. Typing term (b).Get
//│ | | | | | | 2. Typing term b
//│ | | | | | | 2. : b645''
//│ | | | | | | INST [0]   ‹∀ 0. (this23' -> A22')›
//│ | | | | | |   where  
//│ 		this23' <: Ref[A22']
//│ | | | | | | TO [2] ~>  (this23_655'' -> A22_656'')
//│ | | | | | |   where  
//│ 		this23_655'' <: Ref[A22_656'']
//│ | | | | | | CONSTRAIN (this23_655'' -> A22_656'') <! (b645'' -> α654'')
//│ | | | | | |   where 
//│ 		this23_655'' <: Ref[A22_656'']
//│ | | | | | | 2. C (this23_655'' -> A22_656'') <! (b645'' -> α654'')    (0)
//│ | | | | | | | 2. C (b645'',) <! (this23_655'',)    (1)
//│ | | | | | | | | 2. C b645'' <! this23_655''    (2)
//│ | | | | | | | | | NEW b645'' UB (2)
//│ | | | | | | | 2. C A22_656'' <! α654''    (1)
//│ | | | | | | | | NEW A22_656'' UB (2)
//│ | | | | | 2. : α654''
//│ | | | | | CONSTRAIN α651'' <! (α654'' -> α657'')
//│ | | | | |   where 
//│ 		α651'' :> (A22_653'' -> Unit)
//│ | | | | | 2. C α651'' <! (α654'' -> α657'')    (0)
//│ | | | | | | NEW α651'' UB (2)
//│ | | | | | | 2. C (A22_653'' -> Unit) <! (α654'' -> α657'')    (2)
//│ | | | | | | | 2. C (α654'',) <! (A22_653'',)    (2)
//│ | | | | | | | | 2. C α654'' <! A22_653''    (3)
//│ | | | | | | | | | NEW α654'' UB (2)
//│ | | | | | | | 2. C Unit <! α657''    (2)
//│ | | | | | | | | NEW α657'' LB (0)
//│ | | | | 2. : α657''
//│ | | | | 2. Typing term (b).Set (tmp,)
//│ | | | | | 2. Typing term (b).Set
//│ | | | | | | 2. Typing term b
//│ | | | | | | 2. : b645''
//│ | | | | | | INST [0]   ‹∀ 0. (this23' -> (A22' -> Unit))›
//│ | | | | | |   where  
//│ 		this23' <: Ref[A22']
//│ | | | | | | TO [2] ~>  (this23_659'' -> (A22_660'' -> Unit))
//│ | | | | | |   where  
//│ 		this23_659'' <: Ref[A22_660'']
//│ | | | | | | CONSTRAIN (this23_659'' -> (A22_660'' -> Unit)) <! (b645'' -> α658'')
//│ | | | | | |   where 
//│ 		b645'' <: this23_655''
//│ 		α654'' <: A22_653''
//│ 		this23_655'' <: Ref[A22_656'']
//│ 		A22_656'' <: α654''
//│ 		this23_659'' <: Ref[A22_660'']
//│ | | | | | | 2. C (this23_659'' -> (A22_660'' -> Unit)) <! (b645'' -> α658'')    (0)
//│ | | | | | | | 2. C (b645'',) <! (this23_659'',)    (1)
//│ | | | | | | | | 2. C b645'' <! this23_659''    (2)
//│ | | | | | | | | | NEW b645'' UB (2)
//│ | | | | | | | 2. C (A22_660'' -> Unit) <! α658''    (1)
//│ | | | | | | | | NEW α658'' LB (2)
//│ | | | | | 2. : α658''
//│ | | | | | 2. Typing term tmp
//│ | | | | | 2. : ‹∀ 2. α646'''›
//│ | | | | | CONSTRAIN α658'' <! (‹∀ 2. α646'''› -> α661'')
//│ | | | | |   where 
//│ 		α646''' :> A22_649''
//│ 		α658'' :> (A22_660'' -> Unit)
//│ | | | | | 2. C α658'' <! (‹∀ 2. α646'''› -> α661'')    (0)
//│ | | | | | | NEW α658'' UB (2)
//│ | | | | | | 2. C (A22_660'' -> Unit) <! (‹∀ 2. α646'''› -> α661'')    (2)
//│ | | | | | | | 2. C (‹∀ 2. α646'''›,) <! (A22_660'',)    (2)
//│ | | | | | | | | 2. C ‹∀ 2. α646'''› <! A22_660''    (3)
//│ | | | | | | | | | NEW A22_660'' LB (2)
//│ | | | | | | | 2. C Unit <! α661''    (2)
//│ | | | | | | | | NEW α661'' LB (0)
//│ | | | | 2. : α661''
//│ | | | 2. : (α657'', α661'',)
//│ | | 2. : (α657'', α661'',)
//│ | 2. : (b645'' -> (α657'', α661'',))
//│ | Inferred poly constr: (a644'' -> (b645'' -> (α657'', α661'',)))  —— where 
//│ 		a644'' <: this23_652'' & Ref[A22_649''..A22_650'']
//│ 		b645'' <: this23_659'' & this23_655''
//│ 		α646''' :> A22_649''
//│ 		A22_650'' :> A22_649''
//│ 		this23_652'' <: Ref[A22_653'']
//│ 		α654'' <: A22_653''
//│ 		this23_655'' <: Ref[A22_656'']
//│ 		A22_656'' <: α654''
//│ 		α657'' :> Unit
//│ 		this23_659'' <: Ref[A22_660'']
//│ 		A22_660'' :> ‹∀ 2. α646'''›
//│ 		α661'' :> Unit
//│ | UNSTASHING... (out)
//│ 1. : ‹∀ 1. (a644'' -> (b645'' -> (α657'', α661'',)))›
//│ UNSTASHING... (out)
//│ ⬤ Typed as: ‹∀ 1. (a644'' -> (b645'' -> (α657'', α661'',)))›
//│  where: 
//│ 		a644'' <: this23_652'' & Ref[A22_649''..A22_650'']
//│ 		b645'' <: this23_659'' & this23_655''
//│ 		α646''' :> A22_649''
//│ 		A22_650'' :> A22_649''
//│ 		this23_652'' <: Ref[A22_653'']
//│ 		α654'' <: A22_653''
//│ 		this23_655'' <: Ref[A22_656'']
//│ 		A22_656'' <: α654''
//│ 		α657'' :> Unit
//│ 		this23_659'' <: Ref[A22_660'']
//│ 		A22_660'' :> ‹∀ 2. α646'''›
//│ 		α661'' :> Unit
//│ swap: Ref[in 'A | 'A0 out 'A & 'A0] -> Ref[in 'A0 & 'A1 | 'A2 out 'A1 & ('A | 'A2)] -> (unit, unit,)
//│     = [Function: swap]

swap r
swap ri
swap rn
//│ res: Ref[in 'A out 'A0 & (1 | 'A)] -> (unit, unit,)
//│    = [Function (anonymous)]
//│ res: Ref[in 'A out nothing] -> (unit, unit,)
//│    = [Function (anonymous)]
//│ res: Ref[in 'A out nothing] -> (unit, unit,)
//│    = [Function (anonymous)]

swap r ri
swap ri r
//│ res: (unit, unit,)
//│    = [ [], [] ]
//│ res: (unit, unit,)
//│    = [ [], [] ]

:e
swap rn ri
swap ri rn
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.370: 	swap rn ri
//│ ║         	^^^^^^^^^^
//│ ╟── type `number` is not an instance of type `int`
//│ ║  l.87: 	rn = r : Ref[number]
//│ ║        	             ^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.86: 	ri = r : Ref[int]
//│ ╙──      	             ^^^
//│ res: (unit, unit,) | error
//│    = [ [], [] ]
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.371: 	swap ri rn
//│ ║         	^^^^^^^^^^
//│ ╟── type `number` is not an instance of `int`
//│ ║  l.87: 	rn = r : Ref[number]
//│ ║        	             ^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.86: 	ri = r : Ref[int]
//│ ║        	             ^^^
//│ ╟── from field selection:
//│ ║  l.180: 	def swap a b = let tmp = a.Get in (a.Set b.Get, b.Set tmp)
//│ ║         	                                         ^^^^^
//│ ╟── Note: class type parameter A is defined at:
//│ ║  l.3: 	class Ref[A]
//│ ╙──     	          ^
//│ res: (unit, unit,) | error
//│    = [ [], [] ]



def refin: Ref[int] & Ref[string]
//│ refin: Ref[in int | string out nothing]
//│      = <missing implementation>

refin.Get
//│ res: nothing
//│    = <no result>
//│      refin is not implemented

fun x -> refin.Set x
//│ res: (int | string) -> unit
//│    = <no result>
//│      refin is not implemented

refin.Swap
//│ res: ('A & (int | string)) -> 'A
//│    = <no result>
//│      refin is not implemented

refin: Ref['a..'b]
//│ res: Ref['b]
//│    = <no result>
//│      refin is not implemented

res.Swap
//│ res: ((int | string) & 'A) -> 'A
//│    = undefined

refin: Ref['a..'b] & Ref['c..'d]
//│ res: Ref[in 'b | 'd out 'b & 'd]
//│    = <no result>
//│      refin is not implemented

:ng
res.Swap
//│ res: ('A & ((int | string) & 'b | 'd & (int | string))) -> ('b & 'd | 'A)

refin: Ref['a..'b] | Ref['c..'d]
//│ res: Ref['d]
//│    = <no result>
//│      refin is not implemented

:ng
res.Swap
//│ res: 'A -> 'A



def refun: Ref[int] | Ref[string]
//│ refun: Ref[out int | string]
//│      = <missing implementation>

// * A bit odd
:e
refun.Get
fun x -> refun.Set x
refun.Swap
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.457: 	refun.Get
//│ ║         	^^^^^^^^^
//│ ╟── type `string` is not an instance of `int`
//│ ║  l.451: 	def refun: Ref[int] | Ref[string]
//│ ║         	                          ^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.451: 	def refun: Ref[int] | Ref[string]
//│ ║         	               ^^^
//│ ╟── Note: class type parameter A is defined at:
//│ ║  l.3: 	class Ref[A]
//│ ╙──     	          ^
//│ res: error | int | string
//│    = <no result>
//│      refun is not implemented
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.458: 	fun x -> refun.Set x
//│ ║         	         ^^^^^^^^^
//│ ╟── type `string` is not an instance of `int`
//│ ║  l.451: 	def refun: Ref[int] | Ref[string]
//│ ║         	                          ^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.451: 	def refun: Ref[int] | Ref[string]
//│ ║         	               ^^^
//│ ╟── Note: class type parameter A is defined at:
//│ ║  l.3: 	class Ref[A]
//│ ╙──     	          ^
//│ res: nothing -> (error | unit)
//│    = <no result>
//│      refun is not implemented
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.459: 	refun.Swap
//│ ║         	^^^^^^^^^^
//│ ╟── type `string` is not an instance of `int`
//│ ║  l.451: 	def refun: Ref[int] | Ref[string]
//│ ║         	                          ^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.451: 	def refun: Ref[int] | Ref[string]
//│ ║         	               ^^^
//│ ╟── Note: class type parameter A is defined at:
//│ ║  l.3: 	class Ref[A]
//│ ╙──     	          ^
//│ res: nothing -> (int | string) | error
//│    = <no result>
//│      refun is not implemented



:e
def bar x = RefImpl { mut value = x } : Ref[int] & Ref[string]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.509: 	def bar x = RefImpl { mut value = x } : Ref[int] & Ref[string]
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `string` is not an instance of type `int`
//│ ║  l.509: 	def bar x = RefImpl { mut value = x } : Ref[int] & Ref[string]
//│ ║         	                                                       ^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.509: 	def bar x = RefImpl { mut value = x } : Ref[int] & Ref[string]
//│ ║         	                                            ^^^
//│ ╟── Note: class type parameter A is defined at:
//│ ║  l.12: 	class RefImpl[A]: Ref[A] & { mut value: A }
//│ ╙──      	              ^
//│ bar: nothing -> Ref[in int | string out nothing]
//│    = [Function: bar]

// * Note that this now signature-checks because it instantiates the inferred polymorphic type
// * later (once for each intersection component)
// :e
rec def refin = RefImpl { mut value = refin.Get }
//│ RefImpl['A]
//│   <:  refin:
//│ Ref[in int | string out nothing]
//│      = [Function: refin]



