
(mut 1, mut 2): MutArray['a]
//│ res: MutArray['a]
//│   where
//│     'a :> 1 | 2
//│    = [ 1, 2 ]

((fun t -> let tmp = t._1 <- 3 in t) ((mut 1, mut 2))): MutArray['a]
//│ ╔══[ERROR] Cyclic-looking constraint while typing assignment
//│ ║  l.8: 	((fun t -> let tmp = t._1 <- 3 in t) ((mut 1, mut 2))): MutArray['a]
//│ ║       	                     ^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  α29  <:  {_1: mut α31..⊤}    TypeVariable  RecordType
//│ ╙──  ... looks like:  α29  <:  {_1: mut α30'..⊤}
//│ ╔══[ERROR] Cyclic-looking constraint while typing assignment
//│ ║  l.8: 	((fun t -> let tmp = t._1 <- 3 in t) ((mut 1, mut 2))): MutArray['a]
//│ ║       	                     ^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  3<TypeName(int),TypeName(number)>  <:  α31    ClassTag  TypeVariable
//│ ╙──  ... looks like:  3<TypeName(int),TypeName(number)>  <:  α30'
//│ res: MutArray['a]
//│   where
//│     'a :> 1 | 2
//│    = [ 1, 2, _1: 3 ]

((fun t -> let tmp = t._1 + 1 in t) ((mut 1, mut 2))): MutArray['a]
//│ ╔══[ERROR] Cyclic-looking constraint while typing field selection
//│ ║  l.26: 	((fun t -> let tmp = t._1 + 1 in t) ((mut 1, mut 2))): MutArray['a]
//│ ║        	                     ^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  α41  <:  {_1: α43}    TypeVariable  RecordType
//│ ╙──  ... looks like:  α41  <:  {_1: α42'}
//│ ╔══[ERROR] Cyclic-looking constraint while typing operator application
//│ ║  l.26: 	((fun t -> let tmp = t._1 + 1 in t) ((mut 1, mut 2))): MutArray['a]
//│ ║        	                     ^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  α43  <:  int<TypeName(number)>    TypeVariable  ClassTag
//│ ╙──  ... looks like:  α42'  <:  int<TypeName(number)>
//│ res: MutArray['a]
//│   where
//│     'a :> 1 | 2
//│    = [ 1, 2 ]

if true then (mut 1, mut 2) else (mut 3, mut 4)
//│ res: (mut in 'a out 1 | 3 | 'a, mut in 'b out 2 | 4 | 'b,)
//│    = [ 1, 2 ]

def t1: (mut 1, mut 2)
def t2: (mut 3, mut 4)
//│ t1: (mut 1, mut 2,)
//│   = <missing implementation>
//│ t2: (mut 3, mut 4,)
//│   = <missing implementation>

r = if true then t1 else t2
//│ r: (mut out 1 | 3, mut out 2 | 4,)
//│  = <no result>
//│    t1 is not implemented

:e
r._1 <- 1
//│ ╔══[ERROR] Type mismatch in assignment:
//│ ║  l.61: 	r._1 <- 1
//│ ║        	^^^^^^^^^
//│ ╟── integer literal of type `1` does not match type `3`
//│ ║  l.61: 	r._1 <- 1
//│ ║        	        ^
//│ ╟── Note: constraint arises from literal type:
//│ ║  l.49: 	def t2: (mut 3, mut 4)
//│ ║        	             ^
//│ ╟── from assigned selection:
//│ ║  l.61: 	r._1 <- 1
//│ ╙──      	^^^^
//│ = <no result>
//│   r and t1 are not implemented


def t1: (mut 1 | 2 | 3)
def t2: (mut 2 | 3 | 4)
//│ t1: (mut 1 | 2 | 3,)
//│   = <missing implementation>
//│ t2: (mut 2 | 3 | 4,)
//│   = <missing implementation>

r = if true then t1 else t2
//│ r: (mut in 2 | 3 out 1 | 2 | 3 | 4,)
//│  = <no result>
//│    t1 is not implemented

r._1 <- if true then 2 else 3
//│ = <no result>
//│   r and t1 are not implemented

:e
r._1 <- if true then 2 else 1
//│ ╔══[ERROR] Type mismatch in assignment:
//│ ║  l.95: 	r._1 <- if true then 2 else 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `1` does not match type `2 | 3 | 4`
//│ ║  l.95: 	r._1 <- if true then 2 else 1
//│ ║        	                            ^
//│ ╟── but it flows into application with expected type `2 | 3 | 4`
//│ ║  l.95: 	r._1 <- if true then 2 else 1
//│ ║        	           ^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.79: 	def t2: (mut 2 | 3 | 4)
//│ ║        	             ^^^^^^^^^
//│ ╟── from assigned selection:
//│ ║  l.95: 	r._1 <- if true then 2 else 1
//│ ╙──      	^^^^
//│ = <no result>
//│   r and t1 are not implemented
