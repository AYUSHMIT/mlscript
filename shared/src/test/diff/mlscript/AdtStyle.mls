:NoJS

datatype Either[A, B] = Left[A](A,) || Right[B](B,)
//│ Defined type alias Either[+A, +B]
//│ Defined class Left[+A]
//│ Defined class Right[+B]
//│ Left: 'a -> Either['a, nothing]
//│ Right: 'a -> Either[nothing, 'a]


datatype List[A] = Cons[A](A, List[A]) || Nil[A]
//│ Defined type alias List[+A]
//│ Defined class Cons[+A]
//│ Defined class Nil
//│ Cons: ('a, List['a],) -> List['a]
//│ Nil: List[nothing]

type Heap = List[(string, int)]
datatype HeapVar = HeapInt(int,) || HeapV(Heap,)
datatype Exp = EInt(int,) || Var(string,) || Plus(Exp, Exp) || Times(Exp, Exp)
datatype Stmt = Skip || Assign(string, Exp)
//│ Defined type alias Heap
//│ Defined type alias HeapVar
//│ Defined class HeapInt
//│ Defined class HeapV
//│ Defined type alias Exp
//│ Defined class EInt
//│ Defined class Var
//│ Defined class Plus
//│ Defined class Times
//│ Defined type alias Stmt
//│ Defined class Skip
//│ Defined class Assign
//│ HeapInt: int -> HeapVar
//│ HeapV: Heap -> HeapVar
//│ EInt: int -> Exp
//│ Var: string -> Exp
//│ Plus: (Exp, Exp,) -> Exp
//│ Times: (Exp, Exp,) -> Exp
//│ Skip: Stmt
//│ Assign: (string, Exp,) -> Stmt

datatype Poly[A] = PolyList[A](List[A -> A],)
//│ Defined type alias Poly[=A]
//│ Defined class PolyList[=A]
//│ PolyList: List['a -> 'a] -> Poly['a]

datatype FCPoly = FCPolyList(List[forall 'a. 'a -> 'a],)
//│ Defined type alias FCPoly
//│ Defined class FCPolyList
//│ FCPolyList: List[forall 'a. 'a -> 'a] -> FCPoly


fun x ->
  match x with
   | Cons(a, b) -> b
   | Nil -> Nil
//│ res: List['A] -> List['A]

fun x ->
  match x with
   | Cons(1, b) -> Cons(0, b)
   | Cons(a, b) -> b
   | Nil -> Nil
//│ res: List[1 & 'a] -> List[0 | 'a]

fun x ->
  match x with
   | EInt(v,) -> v
   | _ -> 0
//│ res: Exp -> int

fun x ->
  match x with
   | (1, 2, 3) -> 6
   | (x, y, 3,) -> x + y
   | _ -> 0
//│ res: (1, 2, 3,) -> int

fun (x, y) ->
  match (x, y) with
   | (1, 2) -> 3
   | _ -> 0
//│ res: (1, 2,) -> (0 | 3)


foo x = match x with
  | 0 -> 0
  | 1 -> 1
//│ foo: int -> (0 | 1)

foo 0
//│ res: 0 | 1

:e // allow ascriptions
foo x = match x with
  | (0 : int) -> 0
  | (1 : int) -> 1
//│ /!!!\ Uncaught error: java.lang.Exception: Internal Error: Cannot handle pattern ('(' 0 : int ')') then 0
//│ 	at: mlscript.utils.package$.lastWords(package.scala:197)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$33(Typer.scala:1123)
//│ 	at: scala.collection.immutable.List.foreach(List.scala:333)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:986)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:32)
//│ 	at: mlscript.Typer.typeTerm(Typer.scala:1160)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$20(Typer.scala:822)
//│ 	at: mlscript.Typer$Ctx.$anonfun$poly$1(Typer.scala:104)
//│ 	at: mlscript.Typer$Ctx.nextLevel(Typer.scala:88)
//│ 	at: mlscript.Typer$Ctx.poly(Typer.scala:102)

foo 0
//│ res: 0 | 1


:e // such patterns are not allowed
foo x = match x with
  | (id 0) -> 0
//│ /!!!\ Uncaught error: java.lang.Exception: Internal Error: Cannot handle pattern ('(' id (0,) ')') then 0
//│ 	at: mlscript.utils.package$.lastWords(package.scala:197)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$33(Typer.scala:1123)
//│ 	at: scala.collection.immutable.List.foreach(List.scala:333)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:986)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:32)
//│ 	at: mlscript.Typer.typeTerm(Typer.scala:1160)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$20(Typer.scala:822)
//│ 	at: mlscript.Typer$Ctx.$anonfun$poly$1(Typer.scala:104)
//│ 	at: mlscript.Typer$Ctx.nextLevel(Typer.scala:88)
//│ 	at: mlscript.Typer$Ctx.poly(Typer.scala:102)


match Cons(0, Nil) with Cons(0, Nil) -> 0
//│ res: 0

match Cons(false, Nil) with Cons(true, Nil) -> 0
//│ res: 0

:e
match Cons(0, Nil) with Cons(1, Nil) -> 0
//│ ╔══[ERROR] Type mismatch in adt match expression:
//│ ║  l.138: 	match Cons(0, Nil) with Cons(1, Nil) -> 0
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `0` does not match type `1`
//│ ║  l.138: 	match Cons(0, Nil) with Cons(1, Nil) -> 0
//│ ║         	           ^
//│ ╟── Note: constraint arises from integer literal:
//│ ║  l.138: 	match Cons(0, Nil) with Cons(1, Nil) -> 0
//│ ╙──       	                             ^
//│ res: 0


