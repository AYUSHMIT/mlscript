:NoJS

datatype Either[A, B] = Left[A](A,) || Right[B](B,)
//│ Defined type alias Either[+A, +B]
//│ Left: 'a -> Either['a, nothing]
//│ Right: 'a -> Either[nothing, 'a]

datatype List[A] = Cons[A](A, List[A]) || Nil
//│ Defined type alias List[+A]
//│ Cons: ('a, List['a],) -> List['a]
//│ Nil: List[nothing]

type Heap = List[(string, int)]
datatype HeapVar = HeapInt(int,) || HeapV(Heap,)
datatype Exp = EInt(int,) || Var(string,) || Plus(Exp, Exp) || Times(Exp, Exp)
datatype Stmt = Skip || Assign(string, Exp)
//│ Defined type alias Heap
//│ Defined type alias HeapVar
//│ Defined type alias Exp
//│ Defined type alias Stmt
//│ HeapInt: int -> HeapVar
//│ HeapV: Heap -> HeapVar
//│ EInt: int -> Exp
//│ Var: string -> Exp
//│ Plus: (Exp, Exp,) -> Exp
//│ Times: (Exp, Exp,) -> Exp
//│ Skip: Stmt
//│ Assign: (string, Exp,) -> Stmt

datatype Poly[A] = PolyList[A](List[A -> A],)
//│ Defined type alias Poly[=A]
//│ PolyList: List['a -> 'a] -> Poly['a]

datatype FCPoly = FCPolyList(List[forall 'a. 'a -> 'a],)
//│ Defined type alias FCPoly
//│ FCPolyList: List[forall 'a. 'a -> 'a] -> FCPoly


fun x ->
  match x with
   | Cons(a, b) -> b
   | Nil -> Nil
//│ res: (List[?] & 'a) -> (List[nothing] | 'a)

:e
fun x ->
  match x with
   | Cons(1, b) -> Cons(0, b)
   | Cons(a, b) -> b
   | Nil -> Nil
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.48: 	   | Cons(1, b) -> Cons(0, b)
//│ ║        	                   ^^^^^^^^^^
//│ ╟── integer literal of type `0` does not match type `1`
//│ ║  l.48: 	   | Cons(1, b) -> Cons(0, b)
//│ ║        	                        ^
//│ ╟── Note: constraint arises from integer literal:
//│ ║  l.48: 	   | Cons(1, b) -> Cons(0, b)
//│ ╙──      	          ^
//│ res: (List[?] & 'a) -> (error | List[0] | 'a)

fun x ->
  match x with
   | EInt(v,) -> v
   | _ -> 0
//│ res: Exp -> int
