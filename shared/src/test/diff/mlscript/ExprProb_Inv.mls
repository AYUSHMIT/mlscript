
def intToString: int -> string
def intToString x = toString x
def done x = case x of {}
//│ intToString: int -> string
//│            = <missing implementation>
//│ anything -> string
//│   <:  intToString:
//│ int -> string
//│            = [Function: intToString]
//│ done: nothing -> nothing
//│     = [Function: done]



class Lit: { val: int }
class Add[E]: { lhs: E; rhs: E }
  method Inv (x: E) = x
def lit val = Lit { val }
def add lhs rhs = Add { lhs; rhs }
//│ Defined class Lit
//│ Defined class Add[=E]
//│ Defined Add.Inv: Add['E] -> 'E -> 'E
//│ lit: (int & 'val) -> (Lit with {val: 'val})
//│    = [Function: lit]
//│ add: ('lhs & 'E) -> ('E & 'rhs) -> (Add['E] with {lhs: 'lhs, rhs: 'rhs})
//│    = [Function: add]



rec def eval1_stub k e = case e of {
  | Add -> eval1_stub k e.lhs
  | _ -> k e
  }
//│ eval1_stub: ('a -> 'b) -> 'c -> 'b
//│   where
//│     'c <: (Add[?]\rhs with {lhs: 'c}) | 'a & ~add
//│           = [Function: eval1_stub]

rec def eval1_stub k e = case e of {
  | Add -> eval1_stub k e.lhs + eval1_stub k e.rhs
  | _ -> k e
  }
//│ eval1_stub: ('a -> int) -> 'b -> int
//│   where
//│     'b <: (Add[?] with {lhs: 'b, rhs: 'b}) | 'a & ~add
//│           = [Function: eval1_stub1]

:ns
rec def eval1_stub e = case e of {
  | Lit -> 1
  | Add -> eval1_stub e.lhs
  | _ -> 0
  }
//│ eval1_stub: forall 'eval1_stub, 'a, 'b, 'c, 'lhs, 'd, 'e. 'eval1_stub
//│   where
//│     'eval1_stub :> 'a -> (1 | 'd | 0)
//│                 <: 'lhs -> 'd
//│     'd :> 1 | 'd | 0
//│     'a <: lit & 'b | (add & 'c | 'e & ~add) & ~lit
//│     'c <: {lhs: 'lhs}
//│     'lhs <: 'a
//│           = [Function: eval1_stub2]

eval1_stub
//│ res: 'a -> (0 | 1)
//│   where
//│     'a <: (Add[?]\rhs with {lhs: 'a}) | Lit | ~Add[?] & ~Lit
//│    = [Function: eval1_stub2]

// def eval1: ('b -> int) -> Expr['b] -> int
:stats
rec def eval1 k e = case e of {
  | Lit -> e.val
  | Add -> eval1 k e.lhs + eval1 k e.rhs
  | _ -> k e
  }
//│ eval1: ('a -> int) -> 'b -> int
//│   where
//│     'b <: (Add[?] with {lhs: 'b, rhs: 'b}) | Lit | 'a & ~add & ~lit
//│      = [Function: eval1]
//│ constrain calls  : 79
//│ annoying  calls  : 0
//│ subtyping calls  : 82

:ns
eval1
//│ res: forall 'eval1, 'a, 'b, 'c, 'val, 'd, 'e, 'lhs, 'f, 'g, 'rhs, 'h, 'i, 'j, 'k. 'eval1
//│   where
//│     'eval1 :> 'a -> 'b -> ('val | 'i | 'k)
//│            <: 'a -> 'g & 'a -> 'e
//│     'e :> 'b -> ('val | 'i | 'k)
//│        <: 'lhs -> 'f
//│     'f :> 'val | 'i | 'k
//│        <: int
//│     'g :> 'b -> ('val | 'i | 'k)
//│        <: 'rhs -> 'h
//│     'h :> 'val | 'i | 'k
//│        <: int
//│     'i := int
//│     'b <: lit & 'c | (add & 'd | 'j & ~add) & ~lit
//│     'd <: {rhs: 'rhs} & {lhs: 'lhs}
//│     'lhs <: 'b
//│     'rhs <: 'b
//│     'c <: {val: 'val}
//│     'val <: int
//│     'a <: 'j -> 'k
//│     'k <: int
//│    = [Function: eval1]

:re
error: ~Add[?]
//│ res: ~Add[?]
//│ Runtime error:
//│   Error: unexpected runtime error

:re
error: ('a & ~Lit) -> 'a
//│ res: ('a & ~Lit) -> 'a
//│ Runtime error:
//│   Error: unexpected runtime error

:re
error: ('a) -> ('a & Add[?])
error: ('a) -> ('a & ~Add[?])
error: ('a & ~Add[?]) -> 'a
//│ res: 'a -> (Add[?] & 'a)
//│ Runtime error:
//│   Error: unexpected runtime error
//│ res: 'a -> ('a & ~Add[?])
//│ Runtime error:
//│   Error: unexpected runtime error
//│ res: ('a & ~Add[?]) -> 'a
//│ Runtime error:
//│   Error: unexpected runtime error

:re
error: ('a & ~add) -> 'a
//│ res: ('a & ~add) -> 'a
//│ Runtime error:
//│   Error: unexpected runtime error

:ns
def eval1_ty_ugly: ('a -> int) -> (Lit | Add['b] | 'a & ~Lit & ~Add[?] as 'b) -> int
//│ eval1_ty_ugly: forall 'a, 'b. ('a -> int) -> 'b -> int
//│   where
//│     'b := Lit | Add['b] | 'a & ~Lit & ~Add[?]
//│              = <missing implementation>

eval1_ty_ugly
//│ res: ('a -> int) -> 'b -> int
//│   where
//│     'b := 'a & ~Add[?] & ~Lit | Add['b] | Lit
//│    = <no result>
//│      eval1_ty_ugly is not implemented

:stats
def eval1_ty_ugly = eval1
//│ ('a -> int) -> 'b -> int
//│   where
//│     'b <: (Add[?] with {lhs: 'b, rhs: 'b}) | Lit | 'a & ~add & ~lit
//│   <:  eval1_ty_ugly:
//│ ('a -> int) -> 'b -> int
//│   where
//│     'b := 'a & ~Add[?] & ~Lit | Add['b] | Lit
//│              = [Function: eval1]
//│ constrain calls  : 79
//│ annoying  calls  : 36
//│ subtyping calls  : 362

:ns
def eval1_ty: ('a -> int) -> (Lit | Add['b] | 'a & ~lit & ~add as 'b) -> int
//│ eval1_ty: forall 'a, 'b. ('a -> int) -> 'b -> int
//│   where
//│     'b := Lit | Add['b] | 'a & ~lit & ~add
//│         = <missing implementation>

eval1_ty
//│ res: ('a -> int) -> 'b -> int
//│   where
//│     'b := 'a & ~add & ~lit | Add['b] | Lit
//│    = <no result>
//│      eval1_ty is not implemented

:stats
def eval1_ty = eval1
//│ ('a -> int) -> 'b -> int
//│   where
//│     'b <: (Add[?] with {lhs: 'b, rhs: 'b}) | Lit | 'a & ~add & ~lit
//│   <:  eval1_ty:
//│ ('a -> int) -> 'b -> int
//│   where
//│     'b := 'a & ~add & ~lit | Add['b] | Lit
//│         = [Function: eval1]
//│ constrain calls  : 79
//│ annoying  calls  : 36
//│ subtyping calls  : 354

:stats
eval1_ty_ugly = eval1_ty
//│ ('a -> int) -> 'b -> int
//│   where
//│     'b := 'a & ~add & ~lit | Add['b] | Lit
//│   <:  eval1_ty_ugly:
//│ ('a -> int) -> 'b -> int
//│   where
//│     'b := 'a & ~Add[?] & ~Lit | Add['b] | Lit
//│              = [Function: eval1]
//│ constrain calls  : 16
//│ annoying  calls  : 1
//│ subtyping calls  : 290

:stats
eval1_ty = eval1_ty_ugly
//│ ('a -> int) -> 'b -> int
//│   where
//│     'b := 'a & ~Add[?] & ~Lit | Add['b] | Lit
//│   <:  eval1_ty:
//│ ('a -> int) -> 'b -> int
//│   where
//│     'b := 'a & ~add & ~lit | Add['b] | Lit
//│         = [Function: eval1]
//│ constrain calls  : 16
//│ annoying  calls  : 1
//│ subtyping calls  : 1072


// Workaround:
:ns
type E1[A] = Lit | Add[E1[A]] | A & ~lit & ~add
def eval1_ty: ('a -> int) -> E1['a] -> int
//│ Defined type alias E1[=A]
//│ eval1_ty: forall 'a. ('a -> int) -> E1['a] -> int
//│         = <missing implementation>

eval1_ty
//│ res: ('a -> int) -> E1['a] -> int
//│    = <no result>
//│      eval1_ty is not implemented

:stats
def eval1_ty = eval1
//│ ('a -> int) -> 'b -> int
//│   where
//│     'b <: (Add[?] with {lhs: 'b, rhs: 'b}) | Lit | 'a & ~add & ~lit
//│   <:  eval1_ty:
//│ ('a -> int) -> E1['a] -> int
//│         = [Function: eval1]
//│ constrain calls  : 83
//│ annoying  calls  : 38
//│ subtyping calls  : 211


:stats
rec def pretty1 k e = case e of {
  | Lit -> intToString e.val
  | Add -> concat (pretty1 k e.lhs) (pretty1 k e.rhs)
  | _ -> k e
  }
//│ pretty1: ('a -> string) -> 'b -> string
//│   where
//│     'b <: (Add[?] with {lhs: 'b, rhs: 'b}) | Lit | 'a & ~add & ~lit
//│        = [Function: pretty1]
//│ constrain calls  : 91
//│ annoying  calls  : 0
//│ subtyping calls  : 86


:stats
rec def prettier1 k ev e = case e of {
  | Lit -> intToString e.val
  | Add ->
      if ev e.lhs == 0 then prettier1 k ev e.rhs
      else if ev e.rhs == 0 then prettier1 k ev e.lhs
      else concat (prettier1 k ev e.lhs) (prettier1 k ev e.rhs)
  | _ -> k e
  }
//│ ╔══[ERROR] Cyclic-looking constraint while typing binding of lambda expression
//│ ║  l.270: 	rec def prettier1 k ev e = case e of {
//│ ║         	                  ^^^^^^^^^^^^^^^^^^^^
//│ ║  l.271: 	  | Lit -> intToString e.val
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.272: 	  | Add ->
//│ ║         	^^^^^^^^^^
//│ ║  l.273: 	      if ev e.lhs == 0 then prettier1 k ev e.rhs
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.274: 	      else if ev e.rhs == 0 then prettier1 k ev e.lhs
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.275: 	      else concat (prettier1 k ev e.lhs) (prettier1 k ev e.rhs)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.276: 	  | _ -> k e
//│ ║         	^^^^^^^^^^^^
//│ ║  l.277: 	  }
//│ ║         	^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  (α383' | (α418' | α420'))  <:  α390'    ComposedType  TypeVariable
//│ ╙──  ... looks like:  (α383' | (α418' | α420'))  <:  α20'
//│ prettier1: ('a -> string) -> ('rhs -> int & 'lhs -> int) -> 'b -> string
//│   where
//│     'b <: (Add[?] with {lhs: 'lhs & 'b, rhs: 'rhs & 'b}) | Lit | 'a & ~add & ~lit
//│          = [Function: prettier1]
//│ constrain calls  : 300
//│ annoying  calls  : 0
//│ subtyping calls  : 110

:stats
rec def prettier11 k ev e = case e of {
  | Lit -> intToString e.val
  | Add ->
      let tmp = pretty1 k e.lhs
      in if ev e.rhs == 0 then tmp else concat tmp (prettier11 k ev e.rhs)
  | _ -> k e
  }
//│ ╔══[ERROR] Cyclic-looking constraint while typing field selection
//│ ║  l.310: 	      let tmp = pretty1 k e.lhs
//│ ║         	                          ^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  α455'  <:  {lhs: lhs476'}    TypeVariable  RecordType
//│ ╙──  ... looks like:  α455'  <:  {lhs: lhs475''}
//│ ╔══[ERROR] Cyclic-looking constraint while typing application
//│ ║  l.310: 	      let tmp = pretty1 k e.lhs
//│ ║         	                ^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  lhs476'  <:  α461''    TypeVariable  TypeVariable
//│ ╙──  ... looks like:  lhs475''  <:  α346'
//│ ╔══[ERROR] Cyclic-looking constraint while typing application
//│ ║  l.311: 	      in if ev e.rhs == 0 then tmp else concat tmp (prettier11 k ev e.rhs)
//│ ║         	                                        ^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  α474'  <:  string<>    TypeVariable  ClassTag
//│ ╙──  ... looks like:  α460''  <:  string<>
//│ ╔══[ERROR] Cyclic-looking constraint while typing binding of lambda expression
//│ ║  l.307: 	rec def prettier11 k ev e = case e of {
//│ ║         	                   ^^^^^^^^^^^^^^^^^^^^
//│ ║  l.308: 	  | Lit -> intToString e.val
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.309: 	  | Add ->
//│ ║         	^^^^^^^^^^
//│ ║  l.310: 	      let tmp = pretty1 k e.lhs
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.311: 	      in if ev e.rhs == 0 then tmp else concat tmp (prettier11 k ev e.rhs)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.312: 	  | _ -> k e
//│ ║         	^^^^^^^^^^^^
//│ ║  l.313: 	  }
//│ ║         	^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  α474'  <:  string<>    TypeVariable  ClassTag
//│ ╙──  ... looks like:  α460''  <:  string<>
//│ prettier11: ('a -> string & nothing -> string) -> ('rhs -> int) -> 'b -> (error | string)
//│   where
//│     'b <: (Add[?]\lhs with {rhs: 'rhs & 'b}) | Lit | 'a & ~add & ~lit
//│           = [Function: prettier11]
//│ constrain calls  : 222
//│ annoying  calls  : 0
//│ subtyping calls  : 122

// Doesn't make much sense, but generates very ugly type unless aggressively simplified:
:stats
rec def prettier12 k ev e = case e of {
  | Lit -> intToString e.val
  | Add ->
      let tmp = pretty1 k e.lhs
      in if ev e == 0 then tmp else concat tmp (pretty1 k e.rhs)
  | _ -> k e
  }
//│ ╔══[ERROR] Cyclic-looking constraint while typing field selection
//│ ║  l.363: 	      let tmp = pretty1 k e.lhs
//│ ║         	                          ^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  α535'  <:  {lhs: lhs556'}    TypeVariable  RecordType
//│ ╙──  ... looks like:  α535'  <:  {lhs: lhs555''}
//│ ╔══[ERROR] Cyclic-looking constraint while typing application
//│ ║  l.363: 	      let tmp = pretty1 k e.lhs
//│ ║         	                ^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  lhs556'  <:  α541''    TypeVariable  TypeVariable
//│ ╙──  ... looks like:  lhs555''  <:  α346'
//│ ╔══[ERROR] Cyclic-looking constraint while typing application
//│ ║  l.364: 	      in if ev e == 0 then tmp else concat tmp (pretty1 k e.rhs)
//│ ║         	                                    ^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  α554'  <:  string<>    TypeVariable  ClassTag
//│ ╙──  ... looks like:  α540''  <:  string<>
//│ prettier12: (nothing -> string & 'a -> 'b & 'c -> string) -> ('d -> int) -> ((Add[?]\lhs with {rhs: 'e}) & 'd | Lit | 'a & ~add & ~lit) -> (error | string | 'b)
//│   where
//│     'e <: (Add[?] with {lhs: 'e, rhs: 'e}) | Lit | 'c & ~add & ~lit
//│           = [Function: prettier12]
//│ constrain calls  : 186
//│ annoying  calls  : 0
//│ subtyping calls  : 196


:stats
e1 = Add{lhs = Lit {val = 1}; rhs = Add{lhs = Lit {val = 2}; rhs = Lit {val = 3}}}
eval1 done e1
pretty1 done e1
prettier1 done (eval1 done) e1
prettier11 done (eval1 done) e1
prettier12 done (eval1 done) e1
//│ e1: Add['E] with {lhs: Lit & {val: 1}, rhs: Add['E0] with {lhs: Lit & {val: 2}, rhs: Lit & {val: 3}}}
//│   where
//│     'E :> (Add['E0] with {lhs: Lit & {val: 2}, rhs: Lit & {val: 3}}) | Lit & {val: 1}
//│     'E0 :> Lit & {val: 2 | 3}
//│   = Add {
//│       lhs: Lit { val: 1 },
//│       rhs: Add { lhs: Lit { val: 2 }, rhs: Lit { val: 3 } }
//│     }
//│ res: int
//│    = 6
//│ res: string
//│    = '123'
//│ res: string
//│    = '123'
//│ res: error | string
//│    = '123'
//│ res: error | string
//│    = '123'
//│ constrain calls  : 1323
//│ annoying  calls  : 445
//│ subtyping calls  : 1777


e1 = add (lit 1) (add (lit 2) (lit 3))
eval1 done e1
pretty1 done e1
prettier1 done (eval1 done) e1
prettier11 done (eval1 done) e1
prettier12 done (eval1 done) e1
//│ e1: Add['E] with {lhs: Lit & {val: 1}, rhs: Add['E0] with {lhs: Lit & {val: 2}, rhs: Lit & {val: 3}}}
//│   where
//│     'E :> (Add['E0] with {lhs: Lit & {val: 2}, rhs: Lit & {val: 3}}) | Lit & {val: 1}
//│     'E0 :> Lit & {val: 2 | 3}
//│   = Add {
//│       lhs: Lit { val: 1 },
//│       rhs: Add { lhs: Lit { val: 2 }, rhs: Lit { val: 3 } }
//│     }
//│ res: int
//│    = 6
//│ res: string
//│    = '123'
//│ res: string
//│    = '123'
//│ res: error | string
//│    = '123'
//│ res: error | string
//│    = '123'



class Nega[E]: { arg: E }
def nega arg = Nega { arg }
//│ Defined class Nega[+E]
//│ nega: 'arg -> Nega['arg]
//│     = [Function: nega]



rec def eval2 k = eval1 (fun x -> case x of {
  | Nega -> 0 - (eval2 k x.arg)
  | _ -> k x
  })
//│ ╔══[ERROR] Cyclic-looking constraint while typing application
//│ ║  l.460: 	  | Nega -> 0 - (eval2 k x.arg)
//│ ║         	                 ^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  eval21249'  <:  ((α1250',) -> α1255')    TypeVariable  FunctionType
//│ ╙──  ... looks like:  eval21249'  <:  ((α1250',) -> α1254'')
//│ ╔══[ERROR] Cyclic-looking constraint while typing application
//│ ║  l.460: 	  | Nega -> 0 - (eval2 k x.arg)
//│ ║         	                 ^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  α1255'  <:  ((arg1256'',) -> α1257'')    TypeVariable  FunctionType
//│ ╙──  ... looks like:  α1254''  <:  ((arg1256'',) -> α1257'')
//│ ╔══[ERROR] Cyclic-looking constraint while typing application
//│ ║  l.461: 	  | _ -> k x
//│ ║         	         ^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  α1250'  <:  ((α1261',) -> α1262')    TypeVariable  FunctionType
//│ ╙──  ... looks like:  α1250'  <:  ((α1259'',) -> α1260'')
//│ ╔══[ERROR] Cyclic-looking constraint while typing application
//│ ║  l.459: 	rec def eval2 k = eval1 (fun x -> case x of {
//│ ║         	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.460: 	  | Nega -> 0 - (eval2 k x.arg)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.461: 	  | _ -> k x
//│ ║         	^^^^^^^^^^^^
//│ ║  l.462: 	  })
//│ ║         	^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  α1262'  <:  int<TypeName(number)>    TypeVariable  ClassTag
//│ ╙──  ... looks like:  α1260''  <:  int<TypeName(number)>
//│ eval2: anything -> ('a -> (error | int) | error)
//│   where
//│     'a <: (Add[?] with {lhs: 'a, rhs: 'a}) | Lit | Nega[?] | ~Add[?] & ~Lit & ~Nega[?]
//│      = [Function: eval2]


:stats
rec def prettier2 k ev = prettier1 (fun x -> case x of {
  | Nega -> concat "-" (prettier2 k ev x.arg)
  | _ -> k x
  }) ev
//│ ╔══[ERROR] Cyclic-looking constraint while typing application
//│ ║  l.501: 	  | Nega -> concat "-" (prettier2 k ev x.arg)
//│ ║         	                        ^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  prettier21307'  <:  ((α1308',) -> α1314')    TypeVariable  FunctionType
//│ ╙──  ... looks like:  prettier21307'  <:  ((α1308',) -> α1313'')
//│ ╔══[ERROR] Cyclic-looking constraint while typing application
//│ ║  l.501: 	  | Nega -> concat "-" (prettier2 k ev x.arg)
//│ ║         	                        ^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  α1314'  <:  ((α1309',) -> α1315'')    TypeVariable  FunctionType
//│ ╙──  ... looks like:  α1313''  <:  ((α1309',) -> α1315'')
//│ ╔══[ERROR] Cyclic-looking constraint while typing application
//│ ║  l.502: 	  | _ -> k x
//│ ║         	         ^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  α1308'  <:  ((α1321',) -> α1322')    TypeVariable  FunctionType
//│ ╙──  ... looks like:  α1308'  <:  ((α1319'',) -> α1320'')
//│ ╔══[ERROR] Cyclic-looking constraint while typing application
//│ ║  l.500: 	rec def prettier2 k ev = prettier1 (fun x -> case x of {
//│ ║         	                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.501: 	  | Nega -> concat "-" (prettier2 k ev x.arg)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.502: 	  | _ -> k x
//│ ║         	^^^^^^^^^^^^
//│ ║  l.503: 	  }) ev
//│ ║         	^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  α1322'  <:  string<>    TypeVariable  ClassTag
//│ ╙──  ... looks like:  α1320''  <:  string<>
//│ prettier2: anything -> ('rhs -> int & 'lhs -> int) -> ('a -> (error | string) | error)
//│   where
//│     'a <: (Add[?] with {lhs: 'lhs & 'a, rhs: 'rhs & 'a}) | Lit | Nega[?] | ~Add[?] & ~Lit & ~Nega[?]
//│          = [Function: prettier2]
//│ constrain calls  : 100
//│ annoying  calls  : 0
//│ subtyping calls  : 257

:stats
rec def prettier22 k ev = prettier12 (fun x -> case x of {
  | Nega -> concat "-" (prettier22 k ev x.arg)
  | _ -> k x
  }) ev
//│ ╔══[ERROR] Cyclic-looking constraint while typing application
//│ ║  l.544: 	  | Nega -> concat "-" (prettier22 k ev x.arg)
//│ ║         	                        ^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  prettier221400'  <:  ((α1401',) -> α1407')    TypeVariable  FunctionType
//│ ╙──  ... looks like:  prettier221400'  <:  ((α1401',) -> α1406'')
//│ ╔══[ERROR] Cyclic-looking constraint while typing application
//│ ║  l.544: 	  | Nega -> concat "-" (prettier22 k ev x.arg)
//│ ║         	                        ^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  α1407'  <:  ((α1402',) -> α1408'')    TypeVariable  FunctionType
//│ ╙──  ... looks like:  α1406''  <:  ((α1402',) -> α1408'')
//│ ╔══[ERROR] Cyclic-looking constraint while typing application
//│ ║  l.545: 	  | _ -> k x
//│ ║         	         ^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  α1401'  <:  ((α1414',) -> α1415')    TypeVariable  FunctionType
//│ ╙──  ... looks like:  α1401'  <:  ((α1412'',) -> α1413'')
//│ ╔══[ERROR] Cyclic-looking constraint while typing application
//│ ║  l.543: 	rec def prettier22 k ev = prettier12 (fun x -> case x of {
//│ ║         	                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.544: 	  | Nega -> concat "-" (prettier22 k ev x.arg)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.545: 	  | _ -> k x
//│ ║         	^^^^^^^^^^^^
//│ ║  l.546: 	  }) ev
//│ ║         	^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  α1415'  <:  string<>    TypeVariable  ClassTag
//│ ╙──  ... looks like:  α1413''  <:  string<>
//│ prettier22: anything -> ('a -> int) -> (((Add[?]\lhs with {rhs: 'b}) & 'a | Lit | Nega[?] | ~Add[?] & ~Lit & ~Nega[?]) -> (error | string) | error)
//│   where
//│     'b <: (Add[?] with {lhs: 'b, rhs: 'b}) | Lit | Nega[?] | ~Add[?] & ~Lit & ~Nega[?]
//│           = [Function: prettier22]
//│ constrain calls  : 148
//│ annoying  calls  : 0
//│ subtyping calls  : 440



:stats
eval2 done e1
//│ res: error | int
//│    = 6
//│ constrain calls  : 180
//│ annoying  calls  : 60
//│ subtyping calls  : 246

e2 = add (lit 1) (nega e1)
//│ e2: Add['E] with {lhs: Lit & {val: 1}, rhs: Nega[forall 'E0, 'E1. Add['E0] with {lhs: Lit & {val: 1}, rhs: Add['E1] with {lhs: Lit & {val: 2}, rhs: Lit & {val: 3}}}]}
//│   where
//│     'E :> Lit & {val: 1} | Nega[forall 'E0, 'E1. Add['E0] with {lhs: Lit & {val: 1}, rhs: Add['E1] with {lhs: Lit & {val: 2}, rhs: Lit & {val: 3}}}]
//│     'E0 :> (Add['E1] with {lhs: Lit & {val: 2}, rhs: Lit & {val: 3}}) | Lit & {val: 1}
//│     'E1 :> Lit & {val: 2 | 3}
//│   = Add {
//│       lhs: Lit { val: 1 },
//│       rhs: Nega { arg: Add { lhs: [Lit], rhs: [Add] } }
//│     }

:e
:stats
eval2 done e2
//│ res: error | int
//│    = -5
//│ constrain calls  : 124
//│ annoying  calls  : 43
//│ subtyping calls  : 134

d2 = nega (add (lit 1) (nega (lit 1)))
//│ d2: Nega[Add['E] with {lhs: Lit & {val: 1}, rhs: Nega[Lit & {val: 1}]}]
//│   where
//│     'E :> Lit & {val: 1} | Nega[Lit & {val: 1}]
//│   = Nega { arg: Add { lhs: Lit { val: 1 }, rhs: Nega { arg: [Lit] } } }

:e
:stats
eval2 done d2
//│ res: error | int
//│    = 0
//│ constrain calls  : 67
//│ annoying  calls  : 18
//│ subtyping calls  : 64


prettier2 done
//│ res: ('rhs -> int & 'lhs -> int) -> ('a -> (error | string) | error)
//│   where
//│     'a <: (Add[?] with {lhs: 'lhs & 'a, rhs: 'rhs & 'a}) | Lit | Nega[?] | ~Add[?] & ~Lit & ~Nega[?]
//│    = [Function (anonymous)]

prettier22 done
//│ res: ('a -> int) -> (((Add[?]\lhs with {rhs: 'b}) & 'a | Lit | Nega[?] | ~Add[?] & ~Lit & ~Nega[?]) -> (error | string) | error)
//│   where
//│     'b <: (Add[?] with {lhs: 'b, rhs: 'b}) | Lit | Nega[?] | ~Add[?] & ~Lit & ~Nega[?]
//│    = [Function (anonymous)]

:stats
prettier2 done (eval1 done)
//│ res: 'a -> (error | string) | error
//│   where
//│     'a <: (Add[?] with {lhs: 'a & 'b, rhs: 'a & 'b}) | Lit | Nega[?] | ~Add[?] & ~Lit & ~Nega[?]
//│     'b <: (Add[?] with {lhs: 'b, rhs: 'b}) | Lit
//│    = [Function (anonymous)]
//│ constrain calls  : 83
//│ annoying  calls  : 0
//│ subtyping calls  : 332


prettier22 done (eval1 done)
//│ res: ((Add[?]\lhs with {rhs: 'a}) & 'b | Lit | Nega[?] | ~Add[?] & ~Lit & ~Nega[?]) -> (error | string) | error
//│   where
//│     'b <: (Add[?] with {lhs: 'b, rhs: 'b}) | Lit
//│     'a <: (Add[?] with {lhs: 'a, rhs: 'a}) | Lit | Nega[?] | ~Add[?] & ~Lit & ~Nega[?]
//│    = [Function (anonymous)]

// TODO could probably merge `a` and `b` here!
:stats
prettier2 done (eval2 done)
//│ res: 'a -> (error | string) | error
//│   where
//│     'a <: (Add[?] with {lhs: 'a & 'b, rhs: 'a & 'b}) | Lit | Nega[?] | ~Add[?] & ~Lit & ~Nega[?]
//│     'b <: (Add[?] with {lhs: 'b, rhs: 'b}) | Lit | Nega[?] | ~Add[?] & ~Lit & ~Nega[?]
//│    = [Function (anonymous)]
//│ constrain calls  : 118
//│ annoying  calls  : 0
//│ subtyping calls  : 450

:e
prettier2 done (eval2 done) e2
prettier2 done (eval2 done) d2
//│ res: error | string
//│    = '1-123'
//│ res: error | string
//│    = '-1-1'

:e
:stats
prettier22 done (eval2 done)
prettier22 done (eval2 done) e2
prettier22 done (eval2 done) d2
//│ res: ((Add[?]\lhs with {rhs: 'a}) & 'a | Lit | Nega[?] | ~Add[?] & ~Lit & ~Nega[?]) -> (error | string) | error
//│   where
//│     'a <: (Add[?] with {lhs: 'a, rhs: 'a}) | Lit | Nega[?] | ~Add[?] & ~Lit & ~Nega[?]
//│    = [Function (anonymous)]
//│ res: error | string
//│    = '1-123'
//│ res: error | string
//│    = '-1'
//│ constrain calls  : 502
//│ annoying  calls  : 89
//│ subtyping calls  : 1007




// === === === ERROR CASES === === === //


:ShowRelativeLineNums


:e
eval1 done e2
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	eval1 done e2
//│ ║        	^^^^^^^^^^^^^
//│ ╟── application of type `Nega[?E] & {Nega#E = ?E, arg: ?arg}` does not match type `nothing`
//│ ║  l.452: 	def nega arg = Nega { arg }
//│ ║         	               ^^^^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.4: 	def done x = case x of {}
//│ ║       	                  ^
//│ ╟── from field selection:
//│ ║  l.75: 	  | Add -> eval1 k e.lhs + eval1 k e.rhs
//│ ╙──      	                                   ^^^^^
//│ res: error | int
//│ Runtime error:
//│   Error: non-exhaustive case expression


:e
prettier2 done eval1 e1
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	prettier2 done eval1 e1
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> (?b | ?c)` is not an instance of type `int`
//│ ║  l.73: 	rec def eval1 k e = case e of {
//│ ║        	                ^^^^^^^^^^^^^^^
//│ ║  l.74: 	  | Lit -> e.val
//│ ║        	^^^^^^^^^^^^^^^^
//│ ║  l.75: 	  | Add -> eval1 k e.lhs + eval1 k e.rhs
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.76: 	  | _ -> k e
//│ ║        	^^^^^^^^^^^^
//│ ║  l.77: 	  }
//│ ║        	^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.274: 	      else if ev e.rhs == 0 then prettier1 k ev e.lhs
//│ ╙──       	              ^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	prettier2 done eval1 e1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Lit & {val: ?val}` is not a function
//│ ║  l.19: 	def lit val = Lit { val }
//│ ║        	              ^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.76: 	  | _ -> k e
//│ ║        	         ^^^
//│ ╟── from field selection:
//│ ║  l.274: 	      else if ev e.rhs == 0 then prettier1 k ev e.lhs
//│ ╙──       	                 ^^^^^
//│ res: error
//│    = '123'


:e
:stats
prettier2 done (eval1 done) e2
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	prettier2 done (eval1 done) e2
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Nega[?E] & {Nega#E = ?E, arg: ?arg}` does not match type `nothing`
//│ ║  l.452: 	def nega arg = Nega { arg }
//│ ║         	               ^^^^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.4: 	def done x = case x of {}
//│ ║       	                  ^
//│ ╟── from field selection:
//│ ║  l.274: 	      else if ev e.rhs == 0 then prettier1 k ev e.lhs
//│ ╙──       	                 ^^^^^
//│ res: error | string
//│ Runtime error:
//│   Error: non-exhaustive case expression
//│ constrain calls  : 297
//│ annoying  calls  : 83
//│ subtyping calls  : 388

:e
:stats
prettier2 done eval2
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	prettier2 done eval2
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> ?b` is not an instance of type `int`
//│ ║  l.73: 	rec def eval1 k e = case e of {
//│ ║        	                ^^^^^^^^^^^^^^^
//│ ║  l.74: 	  | Lit -> e.val
//│ ║        	^^^^^^^^^^^^^^^^
//│ ║  l.75: 	  | Add -> eval1 k e.lhs + eval1 k e.rhs
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.76: 	  | _ -> k e
//│ ║        	^^^^^^^^^^^^
//│ ║  l.77: 	  }
//│ ║        	^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.274: 	      else if ev e.rhs == 0 then prettier1 k ev e.lhs
//│ ╙──       	              ^^^^^^^^
//│ res: 'a -> (error | string) | error
//│   where
//│     'a <: (Add[?] with {lhs: 'a, rhs: 'a}) | Lit | Nega[?] | ~Add[?] & ~Lit & ~Nega[?]
//│    = [Function (anonymous)]
//│ constrain calls  : 77
//│ annoying  calls  : 0
//│ subtyping calls  : 340

:e
:stats
prettier2 done eval2 e1
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	prettier2 done eval2 e1
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> ?b` is not an instance of type `int`
//│ ║  l.73: 	rec def eval1 k e = case e of {
//│ ║        	                ^^^^^^^^^^^^^^^
//│ ║  l.74: 	  | Lit -> e.val
//│ ║        	^^^^^^^^^^^^^^^^
//│ ║  l.75: 	  | Add -> eval1 k e.lhs + eval1 k e.rhs
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.76: 	  | _ -> k e
//│ ║        	^^^^^^^^^^^^
//│ ║  l.77: 	  }
//│ ║        	^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.274: 	      else if ev e.rhs == 0 then prettier1 k ev e.lhs
//│ ╙──       	              ^^^^^^^^
//│ res: error | string
//│    = '123'
//│ constrain calls  : 373
//│ annoying  calls  : 100
//│ subtyping calls  : 532

:e
:stats
prettier2 done eval2 e2
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	prettier2 done eval2 e2
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> ?b` is not an instance of type `int`
//│ ║  l.73: 	rec def eval1 k e = case e of {
//│ ║        	                ^^^^^^^^^^^^^^^
//│ ║  l.74: 	  | Lit -> e.val
//│ ║        	^^^^^^^^^^^^^^^^
//│ ║  l.75: 	  | Add -> eval1 k e.lhs + eval1 k e.rhs
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.76: 	  | _ -> k e
//│ ║        	^^^^^^^^^^^^
//│ ║  l.77: 	  }
//│ ║        	^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.274: 	      else if ev e.rhs == 0 then prettier1 k ev e.lhs
//│ ╙──       	              ^^^^^^^^
//│ res: error | string
//│    = '1-123'
//│ constrain calls  : 253
//│ annoying  calls  : 63
//│ subtyping calls  : 274

:e
:stats
prettier2 done eval2 d2
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	prettier2 done eval2 d2
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> ?b` is not an instance of type `int`
//│ ║  l.73: 	rec def eval1 k e = case e of {
//│ ║        	                ^^^^^^^^^^^^^^^
//│ ║  l.74: 	  | Lit -> e.val
//│ ║        	^^^^^^^^^^^^^^^^
//│ ║  l.75: 	  | Add -> eval1 k e.lhs + eval1 k e.rhs
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.76: 	  | _ -> k e
//│ ║        	^^^^^^^^^^^^
//│ ║  l.77: 	  }
//│ ║        	^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.274: 	      else if ev e.rhs == 0 then prettier1 k ev e.lhs
//│ ╙──       	              ^^^^^^^^
//│ res: error | string
//│    = '-1-1'
//│ constrain calls  : 130
//│ annoying  calls  : 18
//│ subtyping calls  : 182

:e
:stats
prettier2 done eval1 e2
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	prettier2 done eval1 e2
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> (?b | ?c)` is not an instance of type `int`
//│ ║  l.73: 	rec def eval1 k e = case e of {
//│ ║        	                ^^^^^^^^^^^^^^^
//│ ║  l.74: 	  | Lit -> e.val
//│ ║        	^^^^^^^^^^^^^^^^
//│ ║  l.75: 	  | Add -> eval1 k e.lhs + eval1 k e.rhs
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.76: 	  | _ -> k e
//│ ║        	^^^^^^^^^^^^
//│ ║  l.77: 	  }
//│ ║        	^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.274: 	      else if ev e.rhs == 0 then prettier1 k ev e.lhs
//│ ╙──       	              ^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	prettier2 done eval1 e2
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Nega[?E] & {Nega#E = ?E, arg: ?arg}` is not a function
//│ ║  l.452: 	def nega arg = Nega { arg }
//│ ║         	               ^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.76: 	  | _ -> k e
//│ ║        	         ^^^
//│ ╟── from field selection:
//│ ║  l.274: 	      else if ev e.rhs == 0 then prettier1 k ev e.lhs
//│ ╙──       	                 ^^^^^
//│ res: error | string
//│    = '1-123'
//│ constrain calls  : 248
//│ annoying  calls  : 67
//│ subtyping calls  : 415

