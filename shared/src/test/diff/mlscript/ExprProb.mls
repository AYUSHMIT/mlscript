
def intToString: int -> string
def intToString x = toString x
def done x = case x of {}
//│ intToString: int -> string
//│ anything -> string
//│   <:  intToString:
//│ int -> string
//│            = [Function: intToString]
//│ done: nothing -> nothing
//│     = [Function: done]



class Lit: { val: int }
class Add[E]: { lhs: E; rhs: E }
def lit val = Lit { val }
def add lhs rhs = Add { lhs; rhs }
//│ Defined class Lit
//│ Defined class Add
//│ lit: (int & 'val) -> (Lit with {val: 'val})
//│    = [Function: lit]
//│ add: 'a -> (forall 'E, 'rhs. ('E & 'rhs) -> (Add['E .. 'E | 'a] with {lhs: 'a, rhs: 'rhs}))
//│    = [Function: add]



rec def eval1_stub k e = case e of {
  | Add -> eval1_stub k e.lhs
  | _ -> k e
  }
//│ eval1_stub: (('a | 'b) -> ('c & 'd)) -> ((Add[?]\rhs with {lhs: (Add[?]\rhs with {lhs: 'e}) | 'b & ~add as 'e}) | 'a & ~add) -> ('c | 'd)
//│           = [Function: eval1_stub]

rec def eval1_stub k e = case e of {
  | Add -> eval1_stub k e.lhs + eval1_stub k e.rhs
  | _ -> k e
  }
//│ eval1_stub: (('a | 'b) -> int) -> ((Add[?] with {lhs: ((Add[?] with {lhs: 'd, rhs: (Add[?] with {lhs: 'c, rhs: 'e}) | 'b & ~add as 'e}) | 'b & ~add as 'd) as 'c, rhs: (Add[?] with {lhs: (Add[?] with {lhs: ((Add[?] with {lhs: 'f, rhs: (Add[?] with {lhs: 'd, rhs: 'e}) | 'b & ~add as 'e}) | 'b & ~add as 'd) as 'f, rhs: 'g & ((Add[?] with {lhs: ((Add[?] with {lhs: 'd, rhs: 'e}) | 'b & ~add as 'd) as 'c, rhs: 'e}) | 'b & ~add as 'e)}) | 'b & ~add, rhs: ((Add[?] with {lhs: ((Add[?] with {lhs: 'd, rhs: 'e}) | 'b & ~add as 'd) as 'c, rhs: 'h}) | 'b & ~add as 'e) as 'h}) | 'b & ~add}) | 'a & ~add) -> int
//│           = [Function: eval1_stub1]

:ns
rec def eval1_stub e = case e of {
  | Lit -> 1
  | Add -> eval1_stub e.lhs
  | _ -> 0
  }
//│ eval1_stub: forall 'a, 'b, 'c. 'a | (forall 'd, 'e, 'f, 'g, 'h, 'i. ('d & (lit & 'e | (add & 'f & {lhs: 'g & ('k & (lit & 'l | (add & 'm & {lhs: 'j} | 'n & ~add) & ~lit) as 'j)} | 'i & ~add) & ~lit)) -> (1 | 'h | (1 | 'o | 0 as 'o) | 0))
//│           = [Function: eval1_stub2]

eval1_stub
//│ res: ((Add[?]\rhs with {lhs: (Add[?]\rhs with {lhs: 'a}) | Lit | ~add & ~lit as 'a}) | Lit | ~add & ~lit) -> (0 | 1)
//│    = [Function: eval1_stub2]

// def eval1: ('b -> int) -> Expr['b] -> int
:stats
rec def eval1 k e = case e of {
  | Lit -> e.val
  | Add -> eval1 k e.lhs + eval1 k e.rhs
  | _ -> k e
  }
//│ eval1: (('a | 'b) -> int) -> (forall 'c. ((Add[?] with {lhs: ((Add[?] with {lhs: 'e, rhs: (Add[?] with {lhs: 'd, rhs: 'f}) | Lit | 'b & ~add & ~lit as 'f}) | Lit | 'b & ~add & ~lit as 'e) as 'd, rhs: (Add[?] with {lhs: (Add[?] with {lhs: ((Add[?] with {lhs: 'g, rhs: (Add[?] with {lhs: 'e, rhs: 'f}) | Lit | 'b & ~add & ~lit as 'f}) | Lit | 'b & ~add & ~lit as 'e) as 'g, rhs: 'h & ((Add[?] with {lhs: ((Add[?] with {lhs: 'e, rhs: 'f}) | Lit | 'b & ~add & ~lit as 'e) as 'd, rhs: 'f}) | Lit | 'b & ~add & ~lit as 'f)}) | Lit | 'b & ~add & ~lit, rhs: ((Add[?] with {lhs: ((Add[?] with {lhs: 'e, rhs: 'f}) | Lit | 'b & ~add & ~lit as 'e) as 'd, rhs: 'i}) | Lit | 'b & ~add & ~lit as 'f) as 'i}) | Lit | 'b & ~add & ~lit}) | (Lit with {val: 'c}) | 'a & ~add & ~lit) -> (int | 'c))
//│      = [Function: eval1]
//│ constrain calls  : 113
//│ annoying  calls  : 0
//│ subtyping calls  : 6437

:ns
eval1
//│ res: forall 'a, 'b, 'c, 'd, 'e, 'f, 'g, 'h, 'i, 'j, 'k, 'l. forall 'm, 'a, 'b, 'c, 'd, 'e, 'f, 'g, 'h, 'i, 'j, 'k, 'l. 'm | (forall 'n, 'o, 'p. ('n & ('o | 'k | 'i) -> ('p & 'l & int & 'j & int) & ('r & 's -> 't & 'q & ('v & ('w | 'i) -> ('x & 'j & int) & 'q & 'u as 'u) as 'q) & ('v & ('w | 'i) -> ('x & 'j & int) & ('r & 's -> 't & 'q & 'u as 'q) & 'u as 'u)) -> (forall 'y, 'J, 'K, 'L, 'M, 'N, 'O, 'P, 'Q. ('y & (lit & 'J & {val: 'K} | (add & 'L & {rhs: 'N & ('S & (lit & 'T & {val: 'U & int} | (add & 'V & {rhs: 'R} & {lhs: 'W & ('Y & (lit & 'Z & {val: '[ & int} | (add & '\ & {rhs: 'R} & {lhs: 'X} | '] & 'k & ~add) & ~lit) as 'X)} | '^ & 'i & ~add) & ~lit) as 'R)} & {lhs: 'M & ('Y & (lit & 'Z & {val: '[ & int} | (add & '\ & {rhs: '_ & ('S & (lit & 'T & {val: 'U & int} | (add & 'V & {rhs: 'R} & {lhs: 'X} | '^ & 'i & ~add) & ~lit) as 'R)} & {lhs: 'X} | '] & 'k & ~add) & ~lit) as 'X)} | 'P & 'o & ~add) & ~lit)) -> ('K | 'O | int | 'Q | 'p)))
//│    = [Function: eval1]

:re
error: ~Add[?]
//│ res: ~Add[?]
//│ Runtime error:
//│   Error: unexpected runtime error

:re
error: ('a & ~Lit) -> 'a
//│ res: ('a & ~{val: int} | 'a & ~lit) -> 'a
//│ Runtime error:
//│   Error: unexpected runtime error

:re
error: ('a & ~Add[?]) -> 'a
//│ res: ('a & ~{Add#E} | 'a & ~{lhs: anything} | 'a & ~{rhs: anything} | 'a & ~add) -> 'a
//│ Runtime error:
//│   Error: unexpected runtime error

:re
error: ('a & ~add) -> 'a
//│ res: ('a & ~add) -> 'a
//│ Runtime error:
//│   Error: unexpected runtime error

:ns
def eval1_ty_ugly: ('a -> int) -> (Lit | Add['b] | 'a & ~Lit & ~Add[?] as 'b) -> int
//│ eval1_ty_ugly: forall 'a, 'b. ('a -> int) -> (Lit | Add['b0 .. Lit | Add['b0 .. 'b1] | 'a & ~Lit & ~Add[?] as 'b1] | 'a & ~Lit & ~Add[?] as 'b0) -> int

:re
eval1_ty_ugly // TODO simplify positive record negatins to bottom!
//│ res: ('a -> int) -> ('a & 'b & ~{val: int} & ~add | 'a & 'b & ~add & ~lit | 'a & 'b & ~{Add#E} & ~lit | 'a & 'b & ~{lhs: anything} & ~lit | 'a & 'b & ~{rhs: anything} & ~lit | (Add['d .. 'e] with {lhs: 'c, rhs: 'c}) & 'b | Lit & 'b as 'c) -> int
//│ Runtime error:
//│   ReferenceError: eval1_ty_ugly is not defined

:stats
def eval1_ty_ugly = eval1
//│ (('a | 'b) -> int) -> (forall 'c. ((Add[?] with {lhs: ((Add[?] with {lhs: 'e, rhs: (Add[?] with {lhs: 'd, rhs: 'f}) | Lit | 'b & ~add & ~lit as 'f}) | Lit | 'b & ~add & ~lit as 'e) as 'd, rhs: (Add[?] with {lhs: (Add[?] with {lhs: ((Add[?] with {lhs: 'g, rhs: (Add[?] with {lhs: 'e, rhs: 'f}) | Lit | 'b & ~add & ~lit as 'f}) | Lit | 'b & ~add & ~lit as 'e) as 'g, rhs: 'h & ((Add[?] with {lhs: ((Add[?] with {lhs: 'e, rhs: 'f}) | Lit | 'b & ~add & ~lit as 'e) as 'd, rhs: 'f}) | Lit | 'b & ~add & ~lit as 'f)}) | Lit | 'b & ~add & ~lit, rhs: ((Add[?] with {lhs: ((Add[?] with {lhs: 'e, rhs: 'f}) | Lit | 'b & ~add & ~lit as 'e) as 'd, rhs: 'i}) | Lit | 'b & ~add & ~lit as 'f) as 'i}) | Lit | 'b & ~add & ~lit}) | (Lit with {val: 'c}) | 'a & ~add & ~lit) -> (int | 'c))
//│   <:  eval1_ty_ugly:
//│ ('a -> int) -> ('a & 'b & ~{val: int} & ~add | 'a & 'b & ~add & ~lit | 'a & 'b & ~{Add#E} & ~lit | 'a & 'b & ~{lhs: anything} & ~lit | 'a & 'b & ~{rhs: anything} & ~lit | (Add['d .. 'e] with {lhs: 'c, rhs: 'c}) & 'b | Lit & 'b as 'c) -> int
//│              = [Function: eval1]
//│ constrain calls  : 205
//│ annoying  calls  : 107
//│ subtyping calls  : 18180

:ns
def eval1_ty: ('a -> int) -> (Lit | Add['b] | 'a & ~lit & ~add as 'b) -> int
//│ eval1_ty: forall 'a, 'b. ('a -> int) -> (Lit | Add['b0 .. Lit | Add['b0 .. 'b1] | 'a & ~lit & ~add as 'b1] | 'a & ~lit & ~add as 'b0) -> int

:re
eval1_ty
//│ res: ('a -> int) -> ('a & 'b & ~add & ~lit | (Add['d .. 'e] with {lhs: 'c, rhs: 'c}) & 'b | Lit & 'b as 'c) -> int
//│ Runtime error:
//│   ReferenceError: eval1_ty is not defined

:stats
def eval1_ty = eval1
//│ (('a & 'b & ~add & ~lit | 'a | 'b) -> int) -> (forall 'c. ((Add[?] with {lhs: ((Add[?] with {lhs: 'e, rhs: (Add[?] with {lhs: 'd, rhs: 'f}) | Lit | 'a & 'b & ~add & ~lit as 'f}) | Lit | 'a & 'b & ~add & ~lit as 'e) as 'd, rhs: (Add[?] with {lhs: (Add[?] with {lhs: ((Add[?] with {lhs: 'g, rhs: (Add[?] with {lhs: 'e, rhs: 'f}) | Lit | 'a & 'b & ~add & ~lit as 'f}) | Lit | 'a & 'b & ~add & ~lit as 'e) as 'g, rhs: 'h & ((Add[?] with {lhs: ((Add[?] with {lhs: 'e, rhs: 'f}) | Lit | 'a & 'b & ~add & ~lit as 'e) as 'd, rhs: 'f}) | Lit | 'a & 'b & ~add & ~lit as 'f)}) | Lit | 'a & 'b & ~add & ~lit, rhs: ((Add[?] with {lhs: ((Add[?] with {lhs: 'e, rhs: 'f}) | Lit | 'a & 'b & ~add & ~lit as 'e) as 'd, rhs: 'i}) | Lit | 'a & 'b & ~add & ~lit as 'f) as 'i}) | Lit | 'a & 'b & ~add & ~lit}) | (Lit with {val: 'c}) | 'a & ~add & ~lit) -> (int | 'c))
//│   <:  eval1_ty:
//│ ('a -> int) -> ('a & 'b & ~add & ~lit | (Add['d .. 'e] with {lhs: 'c, rhs: 'c}) & 'b | Lit & 'b as 'c) -> int
//│         = [Function: eval1]
//│ constrain calls  : 213
//│ annoying  calls  : 104
//│ subtyping calls  : 8778

:stats
eval1_ty_ugly = eval1_ty
//│ ('a -> int) -> ('a & 'b & ~add & ~lit | (Add['d .. 'e] with {lhs: 'c, rhs: 'c}) & 'b | Lit & 'b as 'c) -> int
//│   <:  eval1_ty_ugly:
//│ ('a -> int) -> ('a & 'b & ~{val: int} & ~add | 'a & 'b & ~add & ~lit | 'a & 'b & ~{Add#E} & ~lit | 'a & 'b & ~{lhs: anything} & ~lit | 'a & 'b & ~{rhs: anything} & ~lit | (Add['d .. 'e] with {lhs: 'c, rhs: 'c}) & 'b | Lit & 'b as 'c) -> int
//│              = [Function: eval1]
//│ constrain calls  : 16
//│ annoying  calls  : 1
//│ subtyping calls  : 12797

:stats
eval1_ty = eval1_ty_ugly
//│ ('a -> int) -> ('a & 'b & ~{val: int} & ~add | 'a & 'b & ~add & ~lit | 'a & 'b & ~{Add#E} & ~lit | 'a & 'b & ~{lhs: anything} & ~lit | 'a & 'b & ~{rhs: anything} & ~lit | (Add['d .. 'e] with {lhs: 'c, rhs: 'c}) & 'b | Lit & 'b as 'c) -> int
//│   <:  eval1_ty:
//│ ('a -> int) -> ('a & 'b & ~add & ~lit | (Add['d .. 'e] with {lhs: 'c, rhs: 'c}) & 'b | Lit & 'b as 'c) -> int
//│         = [Function: eval1]
//│ constrain calls  : 16
//│ annoying  calls  : 1
//│ subtyping calls  : 12973


// Workaround:
:ns
type E1[A] = Lit | Add[E1[A]] | A & ~lit & ~add
def eval1_ty: ('a -> int) -> E1['a] -> int
//│ Defined type alias E1
//│ eval1_ty: forall 'a. ('a -> int) -> E1['a] -> int

eval1_ty
//│ res: ('a -> int) -> ('a & ~add & ~lit | (Add['c .. 'd] with {lhs: 'b, rhs: 'b}) | Lit as 'b) -> int
//│    = [Function: eval1]

:stats
def eval1_ty = eval1
//│ (('a & 'b & ~add & ~lit | 'a | 'b) -> int) -> (forall 'c. ((Add[?] with {lhs: ((Add[?] with {lhs: 'e, rhs: (Add[?] with {lhs: 'd, rhs: 'f}) | Lit | 'a & 'b & ~add & ~lit as 'f}) | Lit | 'a & 'b & ~add & ~lit as 'e) as 'd, rhs: (Add[?] with {lhs: (Add[?] with {lhs: ((Add[?] with {lhs: 'g, rhs: (Add[?] with {lhs: 'e, rhs: 'f}) | Lit | 'a & 'b & ~add & ~lit as 'f}) | Lit | 'a & 'b & ~add & ~lit as 'e) as 'g, rhs: 'h & ((Add[?] with {lhs: ((Add[?] with {lhs: 'e, rhs: 'f}) | Lit | 'a & 'b & ~add & ~lit as 'e) as 'd, rhs: 'f}) | Lit | 'a & 'b & ~add & ~lit as 'f)}) | Lit | 'a & 'b & ~add & ~lit, rhs: ((Add[?] with {lhs: ((Add[?] with {lhs: 'e, rhs: 'f}) | Lit | 'a & 'b & ~add & ~lit as 'e) as 'd, rhs: 'i}) | Lit | 'a & 'b & ~add & ~lit as 'f) as 'i}) | Lit | 'a & 'b & ~add & ~lit}) | (Lit with {val: 'c}) | 'a & ~add & ~lit) -> (int | 'c))
//│   <:  eval1_ty:
//│ ('a -> int) -> ('a & ~add & ~lit | (Add['c .. 'd] with {lhs: 'b, rhs: 'b}) | Lit as 'b) -> int
//│         = [Function: eval1]
//│ constrain calls  : 247
//│ annoying  calls  : 115
//│ subtyping calls  : 8349


rec def pretty1 k e = case e of {
  | Lit -> intToString e.val
  | Add -> concat (pretty1 k e.lhs) (pretty1 k e.rhs)
  | _ -> k e
  }
//│ pretty1: (('a | 'b) -> string) -> ((Add[?] with {lhs: ((Add[?] with {lhs: 'd, rhs: (Add[?] with {lhs: 'c, rhs: 'e}) | Lit | 'b & ~add & ~lit as 'e}) | Lit | 'b & ~add & ~lit as 'd) as 'c, rhs: (Add[?] with {lhs: (Add[?] with {lhs: ((Add[?] with {lhs: 'f, rhs: (Add[?] with {lhs: 'd, rhs: 'e}) | Lit | 'b & ~add & ~lit as 'e}) | Lit | 'b & ~add & ~lit as 'd) as 'f, rhs: 'g & ((Add[?] with {lhs: ((Add[?] with {lhs: 'd, rhs: 'e}) | Lit | 'b & ~add & ~lit as 'd) as 'c, rhs: 'e}) | Lit | 'b & ~add & ~lit as 'e)}) | Lit | 'b & ~add & ~lit, rhs: ((Add[?] with {lhs: ((Add[?] with {lhs: 'd, rhs: 'e}) | Lit | 'b & ~add & ~lit as 'd) as 'c, rhs: 'h}) | Lit | 'b & ~add & ~lit as 'e) as 'h}) | Lit | 'b & ~add & ~lit}) | Lit | 'a & ~add & ~lit) -> string
//│        = [Function: pretty1]

// TODO find out why the `prettier` types are not simplified more

:stats
rec def prettier1 k ev e = case e of {
  | Lit -> intToString e.val
  | Add ->
      let tmp = pretty1 k e.lhs
      in if ev e == 0 then tmp else concat tmp (pretty1 k e.rhs)
  | _ -> k e
  }
//│ prettier1: (('a | 'b) -> string) -> (forall 'c. ('c -> int) -> ((Add[?] with {lhs: (Add[?] with {lhs: ((Add[?] with {lhs: 'e, rhs: (Add[?] with {lhs: 'd, rhs: 'f}) | Lit | 'b & ~add & ~lit as 'f}) | Lit | 'b & ~add & ~lit as 'e) as 'd, rhs: (Add[?] with {lhs: (Add[?] with {lhs: ((Add[?] with {lhs: 'g, rhs: (Add[?] with {lhs: 'e, rhs: 'f}) | Lit | 'b & ~add & ~lit as 'f}) | Lit | 'b & ~add & ~lit as 'e) as 'g, rhs: 'h & ((Add[?] with {lhs: ((Add[?] with {lhs: 'e, rhs: 'f}) | Lit | 'b & ~add & ~lit as 'e) as 'd, rhs: 'f}) | Lit | 'b & ~add & ~lit as 'f)}) | Lit | 'b & ~add & ~lit, rhs: ((Add[?] with {lhs: ((Add[?] with {lhs: 'e, rhs: 'f}) | Lit | 'b & ~add & ~lit as 'e) as 'd, rhs: 'i}) | Lit | 'b & ~add & ~lit as 'f) as 'i}) | Lit | 'b & ~add & ~lit}) | Lit | ~add & ~lit, rhs: (Add[?] with {lhs: ((Add[?] with {lhs: 'e, rhs: (Add[?] with {lhs: 'd, rhs: 'f}) | Lit | 'b & ~add & ~lit as 'f}) | Lit | 'b & ~add & ~lit as 'e) as 'd, rhs: (Add[?] with {lhs: (Add[?] with {lhs: ((Add[?] with {lhs: 'g, rhs: (Add[?] with {lhs: 'e, rhs: 'f}) | Lit | 'b & ~add & ~lit as 'f}) | Lit | 'b & ~add & ~lit as 'e) as 'g, rhs: 'h & ((Add[?] with {lhs: ((Add[?] with {lhs: 'e, rhs: 'f}) | Lit | 'b & ~add & ~lit as 'e) as 'd, rhs: 'f}) | Lit | 'b & ~add & ~lit as 'f)}) | Lit | 'b & ~add & ~lit, rhs: ((Add[?] with {lhs: ((Add[?] with {lhs: 'e, rhs: 'f}) | Lit | 'b & ~add & ~lit as 'e) as 'd, rhs: 'i}) | Lit | 'b & ~add & ~lit as 'f) as 'i}) | Lit | 'b & ~add & ~lit}) | Lit | ~add & ~lit}) & 'c | Lit | 'a & ~add & ~lit) -> string)
//│          = [Function: prettier1]
//│ constrain calls  : 186
//│ annoying  calls  : 0
//│ subtyping calls  : 12854

:stats
e1 = Add{lhs = Lit {val = 1}; rhs = Add{lhs = Lit {val = 2}; rhs = Lit {val = 3}}}
eval1 done e1
pretty1 done e1
prettier1 done (eval1 done) e1
//│ e1: Add['E .. 'E | (Add['E0 .. 'E0 | Lit & {val: 2} | Lit & {val: 3}] with {lhs: Lit & {val: 2}, rhs: Lit & {val: 3}}) | Lit & {val: 1}] with {lhs: Lit & {val: 1}, rhs: Add['E0 .. 'E0 | Lit & {val: 2} | Lit & {val: 3}] with {lhs: Lit & {val: 2}, rhs: Lit & {val: 3}}}
//│   = Add {
//│       lhs: Lit { val: 1 },
//│       rhs: Add { lhs: Lit { val: 2 }, rhs: Lit { val: 3 } }
//│     }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.206: 	eval1 done e1
//│ ║         	^^^^^^^^^^
//│ ╟── wildcard pattern of type `'a & ~add & ~lit` does not match type `nothing`
//│ ║  l.60: 	  | _ -> k e
//│ ║        	         ^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.4: 	def done x = case x of {}
//│ ╙──     	                  ^
//│ res: error
//│    = 6
//│ res: string
//│    = '123'
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.208: 	prettier1 done (eval1 done) e1
//│ ║         	                ^^^^^^^^^^
//│ ╟── wildcard pattern of type `'a & ~add & ~lit` does not match type `nothing`
//│ ║  l.60: 	  | _ -> k e
//│ ║        	         ^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.4: 	def done x = case x of {}
//│ ╙──     	                  ^
//│ res: string
//│    = '123'
//│ constrain calls  : 754
//│ annoying  calls  : 152
//│ subtyping calls  : 699

e1 = add (lit 1) (add (lit 2) (lit 3))
eval1 done e1
pretty1 done e1
prettier1 done (eval1 done) e1
//│ e1: Add['E .. 'E | (Add['E0 .. 'E0 | Lit & {val: 3}] with {lhs: nothing, rhs: Lit & {val: 3}}) | Lit & {val: 2}] with {lhs: Lit & {val: 2}, rhs: Add['E0 .. 'E0 | Lit & {val: 3}] with {lhs: nothing, rhs: Lit & {val: 3}}}
//│   = Add {
//│       lhs: Lit { val: 1 },
//│       rhs: Add { lhs: Lit { val: 2 }, rhs: Lit { val: 3 } }
//│     }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.225: 	eval1 done e1
//│ ║         	^^^^^^^^^^
//│ ╟── wildcard pattern of type `'a & ~add & ~lit` does not match type `nothing`
//│ ║  l.60: 	  | _ -> k e
//│ ║        	         ^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.4: 	def done x = case x of {}
//│ ╙──     	                  ^
//│ res: error
//│    = 6
//│ res: string
//│    = '123'
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.227: 	prettier1 done (eval1 done) e1
//│ ║         	                ^^^^^^^^^^
//│ ╟── wildcard pattern of type `'a & ~add & ~lit` does not match type `nothing`
//│ ║  l.60: 	  | _ -> k e
//│ ║        	         ^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.4: 	def done x = case x of {}
//│ ╙──     	                  ^
//│ res: string
//│    = '123'



class Nega[E]: { arg: E }
def nega arg = Nega { arg }
//│ Defined class Nega
//│ nega: ('arg & 'E) -> (Nega['E] with {arg: 'arg})
//│     = [Function: nega]



rec def eval2 k = eval1 (fun x -> case x of {
  | Nega -> 0 - (eval2 k x.arg)
  | _ -> k x
  })
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.250: 	rec def eval2 k = eval1 (fun x -> case x of {
//│ ║         	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.251: 	  | Nega -> 0 - (eval2 k x.arg)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.252: 	  | _ -> k x
//│ ║         	^^^^^^^^^^^^
//│ ║  l.253: 	  })
//│ ║         	^^^^
//│ ╟── expression of type `Nega[?] & 'a | 'a & ~add & ~lit & ~?a` does not have field 'arg'
//│ ╟── Note: constraint arises from field selection:
//│ ║  l.251: 	  | Nega -> 0 - (eval2 k x.arg)
//│ ║         	                         ^^^^^
//│ ╟── from refined scrutinee:
//│ ║  l.250: 	rec def eval2 k = eval1 (fun x -> case x of {
//│ ╙──       	                                       ^
//│ /!!!\ Uncaught error: java.lang.StackOverflowError


// FIXME particularly egregious type!
:stats
rec def prettier2 k ev = prettier1 (fun x -> case x of {
  | Nega -> concat "-" (prettier2 k ev x.arg)
  | _ -> k x
  }) ev
//│ /!!!\ Uncaught error: java.lang.StackOverflowError



:stats
eval2 done e1
//│ /!!!\ Uncaught error: java.lang.StackOverflowError

e2 = add (lit 1) (nega e1)
//│ e2: Add['E .. 'E | (Nega['E0 .. 'E0 | (Add['E1 .. 'E1 | (Add['E2 .. 'E2 | Lit & {val: 1} | Lit & {val: 3}] with {lhs: Lit & {val: 1}, rhs: Lit & {val: 3}}) | Lit & {val: 1} | Lit & {val: 2}] with {lhs: Lit & {val: 1} | Lit & {val: 2}, rhs: Add['E2 .. 'E2 | Lit & {val: 1} | Lit & {val: 3}] with {lhs: Lit & {val: 1}, rhs: Lit & {val: 3}}})] with {arg: Add['E1 .. 'E1 | (Add['E2 .. 'E2 | Lit & {val: 1} | Lit & {val: 3}] with {lhs: Lit & {val: 1}, rhs: Lit & {val: 3}}) | Lit & {val: 1} | Lit & {val: 2}] with {lhs: Lit & {val: 1} | Lit & {val: 2}, rhs: Add['E2 .. 'E2 | Lit & {val: 1} | Lit & {val: 3}] with {lhs: Lit & {val: 1}, rhs: Lit & {val: 3}}}})] with {lhs: nothing, rhs: Nega['E0 .. 'E0 | (Add['E1 .. 'E1 | (Add['E2 .. 'E2 | Lit & {val: 1} | Lit & {val: 3}] with {lhs: Lit & {val: 1}, rhs: Lit & {val: 3}}) | Lit & {val: 1} | Lit & {val: 2}] with {lhs: Lit & {val: 1} | Lit & {val: 2}, rhs: Add['E2 .. 'E2 | Lit & {val: 1} | Lit & {val: 3}] with {lhs: Lit & {val: 1}, rhs: Lit & {val: 3}}})] with {arg: Add['E1 .. 'E1 | (Add['E2 .. 'E2 | Lit & {val: 1} | Lit & {val: 3}] with {lhs: Lit & {val: 1}, rhs: Lit & {val: 3}}) | Lit & {val: 1} | Lit & {val: 2}] with {lhs: Lit & {val: 1} | Lit & {val: 2}, rhs: Add['E2 .. 'E2 | Lit & {val: 1} | Lit & {val: 3}] with {lhs: Lit & {val: 1}, rhs: Lit & {val: 3}}}}}
//│   = Add {
//│       lhs: Lit { val: 1 },
//│       rhs: Nega { arg: Add { lhs: [Lit], rhs: [Add] } }
//│     }

:stats
eval2 done e2
//│ /!!!\ Uncaught error: java.lang.StackOverflowError

d2 = nega (add (lit 1) (nega (lit 1)))
//│ d2: Nega['E .. 'E | (Add['E0 .. 'E0 | (Nega['E1 .. 'E1 | Lit & {val: 1}] with {arg: Lit & {val: 1}})] with {lhs: nothing, rhs: Nega['E1 .. 'E1 | Lit & {val: 1}] with {arg: Lit & {val: 1}}})] with {arg: Add['E0 .. 'E0 | (Nega['E1 .. 'E1 | Lit & {val: 1}] with {arg: Lit & {val: 1}})] with {lhs: nothing, rhs: Nega['E1 .. 'E1 | Lit & {val: 1}] with {arg: Lit & {val: 1}}}}
//│   = Nega { arg: Add { lhs: Lit { val: 1 }, rhs: Nega { arg: [Lit] } } }

:stats
eval2 done d2
//│ /!!!\ Uncaught error: java.lang.StackOverflowError


prettier2 done
//│ res: (((Add['E .. 'E | (Add['E0 .. 'E0 | Lit & {val: 3}] with {lhs: nothing, rhs: Lit & {val: 3}}) | Lit & {val: 2}] with {lhs: Lit & {val: 2}, rhs: Add['E0 .. 'E0 | Lit & {val: 3}] with {lhs: nothing, rhs: Lit & {val: 3}}}) | (Add['E1 .. 'E1 | (Add['E2 .. 'E2 | Lit & {val: 2} | Lit & {val: 3}] with {lhs: Lit & {val: 2}, rhs: Lit & {val: 3}}) | Lit & {val: 1}] with {lhs: Lit & {val: 1}, rhs: Add['E2 .. 'E2 | Lit & {val: 2} | Lit & {val: 3}] with {lhs: Lit & {val: 2}, rhs: Lit & {val: 3}}})) -> int) -> ((Add[?] with {lhs: (Add[?] with {lhs: ((Add[?] with {lhs: 'b, rhs: (Add[?] with {lhs: 'a, rhs: 'c}) | Lit as 'c}) | Lit as 'b) as 'a, rhs: (Add[?] with {lhs: (Add[?] with {lhs: ((Add[?] with {lhs: 'd, rhs: (Add[?] with {lhs: 'b, rhs: 'c}) | Lit as 'c}) | Lit as 'b) as 'd, rhs: 'e & ((Add[?] with {lhs: ((Add[?] with {lhs: 'b, rhs: 'c}) | Lit as 'b) as 'a, rhs: 'c}) | Lit as 'c)}) | Lit, rhs: ((Add[?] with {lhs: ((Add[?] with {lhs: 'b, rhs: 'c}) | Lit as 'b) as 'a, rhs: 'f}) | Lit as 'c) as 'f}) | Lit}) | Lit | ~add & ~lit, rhs: (Add[?] with {lhs: ((Add[?] with {lhs: 'b, rhs: (Add[?] with {lhs: 'a, rhs: 'c}) | Lit as 'c}) | Lit as 'b) as 'a, rhs: (Add[?] with {lhs: (Add[?] with {lhs: ((Add[?] with {lhs: 'd, rhs: (Add[?] with {lhs: 'b, rhs: 'c}) | Lit as 'c}) | Lit as 'b) as 'd, rhs: 'e & ((Add[?] with {lhs: ((Add[?] with {lhs: 'b, rhs: 'c}) | Lit as 'b) as 'a, rhs: 'c}) | Lit as 'c)}) | Lit, rhs: ((Add[?] with {lhs: ((Add[?] with {lhs: 'b, rhs: 'c}) | Lit as 'b) as 'a, rhs: 'f}) | Lit as 'c) as 'f}) | Lit}) | Lit | ~add & ~lit}) | Lit | ~add & ~lit) -> string
//│    = [Function (anonymous)]

:stats
prettier2 done (eval1 done)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.313: 	prettier2 done (eval1 done)
//│ ║         	                ^^^^^^^^^^
//│ ╟── wildcard pattern of type `'a & ~add & ~lit` does not match type `nothing`
//│ ║  l.60: 	  | _ -> k e
//│ ║        	         ^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.4: 	def done x = case x of {}
//│ ╙──     	                  ^
//│ res: ((Add[?] with {lhs: (Add[?] with {lhs: ((Add[?] with {lhs: 'b, rhs: (Add[?] with {lhs: 'a, rhs: 'c}) | Lit as 'c}) | Lit as 'b) as 'a, rhs: (Add[?] with {lhs: (Add[?] with {lhs: ((Add[?] with {lhs: 'd, rhs: (Add[?] with {lhs: 'b, rhs: 'c}) | Lit as 'c}) | Lit as 'b) as 'd, rhs: 'e & ((Add[?] with {lhs: ((Add[?] with {lhs: 'b, rhs: 'c}) | Lit as 'b) as 'a, rhs: 'c}) | Lit as 'c)}) | Lit, rhs: ((Add[?] with {lhs: ((Add[?] with {lhs: 'b, rhs: 'c}) | Lit as 'b) as 'a, rhs: 'f}) | Lit as 'c) as 'f}) | Lit}) | Lit | ~add & ~lit, rhs: (Add[?] with {lhs: ((Add[?] with {lhs: 'b, rhs: (Add[?] with {lhs: 'a, rhs: 'c}) | Lit as 'c}) | Lit as 'b) as 'a, rhs: (Add[?] with {lhs: (Add[?] with {lhs: ((Add[?] with {lhs: 'd, rhs: (Add[?] with {lhs: 'b, rhs: 'c}) | Lit as 'c}) | Lit as 'b) as 'd, rhs: 'e & ((Add[?] with {lhs: ((Add[?] with {lhs: 'b, rhs: 'c}) | Lit as 'b) as 'a, rhs: 'c}) | Lit as 'c)}) | Lit, rhs: ((Add[?] with {lhs: ((Add[?] with {lhs: 'b, rhs: 'c}) | Lit as 'b) as 'a, rhs: 'f}) | Lit as 'c) as 'f}) | Lit}) | Lit | ~add & ~lit}) | Lit | ~add & ~lit) -> string
//│    = [Function (anonymous)]
//│ constrain calls  : 231
//│ annoying  calls  : 16
//│ subtyping calls  : 26832

:stats
prettier2 done (eval2 done)
prettier2 done (eval2 done) e2
prettier2 done (eval2 done) d2
//│ /!!!\ Uncaught error: java.lang.StackOverflowError




// === === === ERROR CASES === === === //


:ShowRelativeLineNums


:e
eval1 done e2
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	eval1 done e2
//│ ║        	^^^^^^^^^^
//│ ╟── wildcard pattern of type `'a & ~add & ~lit` does not match type `nothing`
//│ ║  l.60: 	  | _ -> k e
//│ ║        	         ^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.4: 	def done x = case x of {}
//│ ╙──     	                  ^
//│ res: error
//│ Runtime error:
//│   Error: non-exhaustive case expression


:e
prettier2 done eval1 e1
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	prettier2 done eval1 e1
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Add[?E] & {lhs: ?lhs, rhs: ?rhs}` is not a function
//│ ║  l.18: 	def add lhs rhs = Add { lhs; rhs }
//│ ║        	                  ^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.60: 	  | _ -> k e
//│ ║        	         ^^^
//│ ╟── from reference:
//│ ║  l.60: 	  | _ -> k e
//│ ╙──      	         ^
//│ res: error
//│    = '123'


:e
:stats
prettier2 done (eval1 done) e2
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	prettier2 done (eval1 done) e2
//│ ║        	                ^^^^^^^^^^
//│ ╟── wildcard pattern of type `'a & ~add & ~lit` does not match type `nothing`
//│ ║  l.60: 	  | _ -> k e
//│ ║        	         ^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.4: 	def done x = case x of {}
//│ ╙──     	                  ^
//│ res: string
//│ Runtime error:
//│   Error: non-exhaustive case expression
//│ constrain calls  : 316
//│ annoying  calls  : 49
//│ subtyping calls  : 143

:e
:stats
prettier2 done eval2
//│ /!!!\ Uncaught error: java.lang.StackOverflowError

:e
:stats
prettier2 done eval2 e1
//│ /!!!\ Uncaught error: java.lang.StackOverflowError

:e
:stats
prettier2 done eval2 e2
//│ /!!!\ Uncaught error: java.lang.StackOverflowError

:e
:stats
prettier2 done eval2 d2
//│ /!!!\ Uncaught error: java.lang.StackOverflowError

:e
:stats
prettier2 done eval1 e2
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	prettier2 done eval1 e2
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Add[?E] & {lhs: ?lhs, rhs: ?rhs}` is not a function
//│ ║  l.18: 	def add lhs rhs = Add { lhs; rhs }
//│ ║        	                  ^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.60: 	  | _ -> k e
//│ ║        	         ^^^
//│ ╟── from reference:
//│ ║  l.60: 	  | _ -> k e
//│ ╙──      	         ^
//│ res: error
//│    = '1-123'
//│ constrain calls  : 163
//│ annoying  calls  : 8
//│ subtyping calls  : 7698

