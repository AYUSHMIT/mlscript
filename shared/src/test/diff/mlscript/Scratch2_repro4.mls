:GeneralizeCurriedFunctions
:NoRecursiveTypes

// type ChurchInt = forall 'N. ('N -> 'N) -> ('N -> 'N)

// :ArgGen

// :d
// :ns
def s n = fun f -> fun x -> f (n f x)
// def s n = fun f -> fun x -> (n f x)
// def s n = fun f -> n f
// def s n = n
//│ s: ('a -> 'b -> 'c & 'd) -> (forall 'e, 'f, 'g. (('c | 'e) -> 'f & 'a & 'g) -> (forall 'b, 'c, 'd, 'e, 'f, 'g, 'h, 'i, 'j. (('b & 'h) -> ('j | 'f)
//│   where
//│     'd <: 'g -> 'h -> ('e & 'i)
//│     'g <: ('i | 'c) -> 'j)))
//│  = [Function: s]

def succ: (forall 'N. ('N -> 'N) -> ('N -> 'N)) -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ succ: (forall 'N. ('N -> 'N) -> 'N -> 'N) -> (forall 'M. ('M -> 'M) -> 'M -> 'M)
//│     = <missing implementation>

// :DistributeForalls

// :ns
// :e // * Used to need distrib (see below)
// :d
:e // skolem extrusion?
succ = s
//│ ('a -> 'b -> 'c & 'd) -> (forall 'e, 'f, 'g. (('c | 'e) -> 'f & 'a & 'g) -> (forall 'b, 'c, 'd, 'e, 'f, 'g, 'h, 'i, 'j. (('b & 'h) -> ('j | 'f)
//│   where
//│     'd <: 'g -> 'h -> ('e & 'i)
//│     'g <: ('i | 'c) -> 'j)))
//│   <:  succ:
//│ (forall 'N. ('N -> 'N) -> 'N -> 'N) -> (forall 'M. ('M -> 'M) -> 'M -> 'M)
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.30: 	succ = s
//│ ║        	^^^^^^^^
//│ ╟── type `‘M_136` is not an instance of type `'M_135`
//│ ║  l.20: 	def succ: (forall 'N. ('N -> 'N) -> ('N -> 'N)) -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ║        	                                                           ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.20: 	def succ: (forall 'N. ('N -> 'N) -> ('N -> 'N)) -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ║        	                                                           ^^
//│ ╟── from reference:
//│ ║  l.10: 	def s n = fun f -> fun x -> f (n f x)
//│ ╙──      	                                   ^
//│     = [Function: s]

def s n = fun f -> fun x -> (n f x)
//│ s: ('a -> 'b -> 'c & 'd) -> (forall 'e. ('a & 'e) -> (forall 'b, 'c, 'd, 'e, 'f, 'g. (('b & 'f) -> ('g | 'c)
//│   where
//│     'd <: 'e -> 'f -> 'g)))
//│  = [Function: s1]

:e // skolem extrusion?
succ = s
//│ ('a -> 'b -> 'c & 'd) -> (forall 'e. ('a & 'e) -> (forall 'b, 'c, 'd, 'e, 'f, 'g. (('b & 'f) -> ('g | 'c)
//│   where
//│     'd <: 'e -> 'f -> 'g)))
//│   <:  succ:
//│ (forall 'N. ('N -> 'N) -> 'N -> 'N) -> (forall 'M. ('M -> 'M) -> 'M -> 'M)
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.58: 	succ = s
//│ ║        	^^^^^^^^
//│ ╟── type `‘M_226` is not an instance of type `'M_225`
//│ ║  l.20: 	def succ: (forall 'N. ('N -> 'N) -> ('N -> 'N)) -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ║        	                                                           ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.20: 	def succ: (forall 'N. ('N -> 'N) -> ('N -> 'N)) -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ║        	                                                           ^^
//│ ╟── from reference:
//│ ║  l.51: 	def s n = fun f -> fun x -> (n f x)
//│ ╙──      	                                 ^
//│     = [Function: s1]

:e // skolem extrusion?
def s n = fun f -> n f
succ = s
//│ s: ('a -> 'b & 'c) -> (forall 'a, 'b, 'c, 'd, 'e. (('a & 'd) -> ('e | 'b)
//│   where
//│     'c <: 'd -> 'e))
//│  = [Function: s2]
//│ ('a -> 'b & 'c) -> (forall 'a, 'b, 'c, 'd, 'e. (('a & 'd) -> ('e | 'b)
//│   where
//│     'c <: 'd -> 'e))
//│   <:  succ:
//│ (forall 'N. ('N -> 'N) -> 'N -> 'N) -> (forall 'M. ('M -> 'M) -> 'M -> 'M)
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.80: 	succ = s
//│ ║        	^^^^^^^^
//│ ╟── type `‘M_288` is not an instance of type `'M_285`
//│ ║  l.20: 	def succ: (forall 'N. ('N -> 'N) -> ('N -> 'N)) -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ║        	                                                           ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.20: 	def succ: (forall 'N. ('N -> 'N) -> ('N -> 'N)) -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ║        	                                                           ^^
//│ ╟── from quantified type variable:
//│ ║  l.20: 	def succ: (forall 'N. ('N -> 'N) -> ('N -> 'N)) -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ╙──      	                  ^^
//│     = [Function: s2]

def s n = n
//│ s: 'a -> 'a
//│  = [Function: s3]

succ = s
//│ 'a -> 'a
//│   <:  succ:
//│ (forall 'N. ('N -> 'N) -> 'N -> 'N) -> (forall 'M. ('M -> 'M) -> 'M -> 'M)
//│     = [Function: s3]


// ==========================================================================


// :d
def s n = fun f -> n f
//│ s: ('a -> 'b & 'c) -> (forall 'a, 'b, 'c, 'd, 'e. (('a & 'd) -> ('e | 'b)
//│   where
//│     'c <: 'd -> 'e))
//│  = [Function: s4]

// def succ: (forall 'N. ('N -> 'N) -> ('N -> 'N)) -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
def succ_min : (forall 'N. ('N -> 'N)) -> (forall 'M. ('M -> 'M))
//│ succ_min: (forall 'N. 'N -> 'N) -> (forall 'M. 'M -> 'M)
//│         = <missing implementation>

// :DistributeForalls

// :ns
// :e // * Needs distrib (see below)
// :d
:e // skolem extrusion?
succ_min = s
// succ n = s n
// s id : (forall 'M. ('M -> 'M))
//│ ('a -> 'b & 'c) -> (forall 'a, 'b, 'c, 'd, 'e. (('a & 'd) -> ('e | 'b)
//│   where
//│     'c <: 'd -> 'e))
//│   <:  succ_min:
//│ (forall 'N. 'N -> 'N) -> (forall 'M. 'M -> 'M)
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.136: 	succ_min = s
//│ ║         	^^^^^^^^^^^^
//│ ╟── type `‘M_366` is not an instance of type `'M`
//│ ║  l.126: 	def succ_min : (forall 'N. ('N -> 'N)) -> (forall 'M. ('M -> 'M))
//│ ║         	                                                  ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.126: 	def succ_min : (forall 'N. ('N -> 'N)) -> (forall 'M. ('M -> 'M))
//│ ╙──       	                                                  ^^
//│         = [Function: s4]





