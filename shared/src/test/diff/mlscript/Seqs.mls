
class Seq[A]: { size: int }
//│ Defined class Seq

class ListBase[A]: Seq[A]
//│ Defined class ListBase

class Nil: ListBase[nothing] & {}
class Cons[A]: ListBase[A] & { head: A; tail: List[A] }
type List[A] = Nil | Cons[A]
//│ Defined class Nil
//│ Defined class Cons
//│ Defined type List

:e
Nil{}
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.16: 	Nil{}
//│ ║        	^^^^^
//│ ╟── expression of type `anything` does not have field 'size'
//│ ║  l.16: 	Nil{}
//│ ╙──      	   ^^
//│ res: ((nil & ListBase[nothing]) & {size: nothing}) | error

def Nil = Nil { size = 0 }
//│ Nil: (nil & ListBase[nothing]) & {size: 0}

// FIXME
Cons 1 Nil
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.29: 	Cons 1 Nil
//│ ║        	^^^^^^
//│ ╟── expression of type `1` does not match type `{head: ?a & ?b, size: ?c & int, tail: ?d & List[?b]}`
//│ ║  l.29: 	Cons 1 Nil
//│ ╙──      	     ^
//│ /!!!\ Uncaught error: scala.MatchError: ({head: (α20 & α19), size: (int & α21), tail: (List[α20] & α22)},|Some(([[α24]] -> α26))|None) (of class scala.Tuple2)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrain$5(ConstraintSolver.scala:179)
//│ 	at: scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:17)
//│ 	at: mlscript.ConstraintSolver.annoyingImpl$1(ConstraintSolver.scala:124)
//│ 	at: mlscript.ConstraintSolver.annoying$1(ConstraintSolver.scala:121)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrain$5(ConstraintSolver.scala:192)
//│ 	at: scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:17)
//│ 	at: mlscript.ConstraintSolver.annoyingImpl$1(ConstraintSolver.scala:124)
//│ 	at: mlscript.ConstraintSolver.annoying$1(ConstraintSolver.scala:121)

// In the old inheritance semantics, this used to be required:
def Cons_old head tail =
  Cons (ListBase (Seq { size = succ tail.size }) with { head; tail })
//│ Cons_old: 'a -> 'b & List['c] & {size: int} -> (cons & (ListBase['c | 'a] & {head: 'c | 'a, tail: List['c | 'a]})) & {head: 'a, size: int & (int & int), tail: 'b}

def Cons head tail =
  Cons { size = succ tail.size; head; tail }
//│ Cons: 'a -> 'b & List['c] & {size: int} -> (cons & (ListBase['c | 'a] & {head: 'c | 'a, tail: List['c | 'a]})) & {head: 'a, size: int, tail: 'b}

Nil: ListBase[anything]
//│ res: ListBase[anything]

def c = Cons 1 Nil
//│ c: (cons & (ListBase[1] & {head: 1, tail: List[1]})) & {head: 1, size: int, tail: (nil & ListBase[nothing]) & {size: 0}}

c: ListBase[int]
//│ res: ListBase[int]

c.head
//│ res: 1 & 1

c.tail
//│ res: List[1] & ((nil & ListBase[nothing]) & {size: 0})

c.size
//│ res: int & int

def d = Cons 2 c
//│ d: (cons & (ListBase[(1 & 1) | 2] & {head: (1 & 1) | 2, tail: List[(1 & 1) | 2]})) & {head: 2, size: int, tail: (cons & (ListBase[1] & {head: 1, tail: List[1]})) & {head: 1, size: int, tail: (nil & ListBase[nothing]) & {size: 0}}}

d.head
//│ res: (1 & 1) | 2 & 2

d.size
//│ res: int & int

d.tail
//│ res: List[(1 & 1) | 2] & ((cons & (ListBase[1] & {head: 1, tail: List[1]})) & {head: 1, size: int, tail: (nil & ListBase[nothing]) & {size: 0}})

d.tail.size
//│ res: int & int

d.tail.head
d.tail.tail
//│ res: ((1 & 1) | 2 & 1) & 1
//│ res: (List[(1 & 1) | 2] & List[1]) & ((nil & ListBase[nothing]) & {size: 0})

