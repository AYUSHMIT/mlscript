
class Seq[A]: { size: int }
//│ Defined class Seq

class ListBase[A]: Seq[A]
//│ Defined class ListBase

class Nil: ListBase[nothing] & {}
class Cons[A]: ListBase[A] & { head: A; tail: List[A] }
type List[A] = Nil | Cons[A]
//│ Defined class Nil
//│ Defined class Cons
//│ Defined type alias List

:e
Nil{}
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.16: 	Nil{}
//│ ║        	^^^^^
//│ ╟── record literal of type `anything` does not have field 'size'
//│ ║  l.16: 	Nil{}
//│ ╙──      	   ^^
//│ res: error | Nil & {size: nothing}
//│    = Nil { size: undefined }

def Nil = Nil { size = 0 }
//│ Nil: Nil & {size: 0}
//│    = Nil { size: 0 }

:e
:re
Cons 1 Nil
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.32: 	Cons 1 Nil
//│ ║        	^^^^^^
//│ ╟── integer literal of type `1` is not a record (expected a record with fields: size, tail, head)
//│ ║  l.32: 	Cons 1 Nil
//│ ╙──      	     ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.32: 	Cons 1 Nil
//│ ║        	^^^^^^^^^^
//│ ╟── application of type `Cons[?A] & {head: ?head, size: ?size, tail: ?tail}` is not a function
//│ ║  l.32: 	Cons 1 Nil
//│ ╙──      	^^^^^^
//│ res: error
//│ Runtime error:
//│   TypeError: (intermediate value) is not a function

Cons
//│ res: {head: 'A & 'head, size: int & 'size, tail: ((Cons['A] with {tail: 'b & ('a | Nil)}) as 'a) & 'tail | Nil & 'tail} -> (Cons['A] with {head: 'head, size: 'size, tail: 'tail})
//│    = [Function: res]

// In the old inheritance semantics, this used to be required:
def Cons_old head tail =
  Cons (ListBase (Seq { size = succ tail.size }) with { head; tail })
//│ Cons_old: 'a -> (forall 'A, 'tail, 'b. (((Cons['A | 'a .. 'A] with {tail: 'b & ('c | Nil)}) as 'c) & 'tail | Nil & 'tail) -> (Cons['A .. 'A | 'a] with {head: 'a, tail: 'tail}))
//│         = [Function: Cons_old]

def Cons head tail =
  Cons { size = succ tail.size; head; tail }
//│ Cons: 'a -> (forall 'A, 'tail, 'b. (((Cons['A | 'a .. 'A] with {tail: 'b & ('c | Nil)}) as 'c) & 'tail | Nil & 'tail) -> (Cons['A .. 'A | 'a] with {head: 'a, tail: 'tail}))
//│     = [Function: Cons1]

// We do not yet perform variance analysis
:e
Nil: ListBase[anything]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.66: 	Nil: ListBase[anything]
//│ ║        	^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.66: 	Nil: ListBase[anything]
//│ ║        	              ^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.8: 	class Nil: ListBase[nothing] & {}
//│ ╙──     	                    ^^^^^^^
//│ res: ListBase[anything]
//│    = Nil { size: 0 }

def c = Cons 1 Nil
//│ /!!!\ Uncaught error: java.lang.StackOverflowError

c: ListBase[int]
//│ ╔══[ERROR] identifier not found: c
//│ ║  l.83: 	c: ListBase[int]
//│ ╙──      	^
//│ res: ListBase[int]
//│    = Cons { size: 1, head: 1, tail: Nil { size: 0 } }

c.head
//│ ╔══[ERROR] identifier not found: c
//│ ║  l.87: 	c.head
//│ ╙──      	^
//│ res: error
//│    = 1

c.tail
//│ ╔══[ERROR] identifier not found: c
//│ ║  l.91: 	c.tail
//│ ╙──      	^
//│ res: error
//│    = Nil { size: 0 }

c.size
//│ ╔══[ERROR] identifier not found: c
//│ ║  l.95: 	c.size
//│ ╙──      	^
//│ res: error
//│    = 1

def d = Cons 2 c
//│ /!!!\ Uncaught error: java.lang.StackOverflowError

d.head
//│ ╔══[ERROR] identifier not found: d
//│ ║  l.107: 	d.head
//│ ╙──       	^
//│ res: error
//│    = 2

d.size
//│ ╔══[ERROR] identifier not found: d
//│ ║  l.111: 	d.size
//│ ╙──       	^
//│ res: error
//│    = 2

d.tail
//│ ╔══[ERROR] identifier not found: d
//│ ║  l.115: 	d.tail
//│ ╙──       	^
//│ res: error
//│    = Cons { size: 1, head: 1, tail: Nil { size: 0 } }

d.tail.size
//│ ╔══[ERROR] identifier not found: d
//│ ║  l.119: 	d.tail.size
//│ ╙──       	^
//│ res: error
//│    = 1

d.tail.head
d.tail.tail
//│ ╔══[ERROR] identifier not found: d
//│ ║  l.123: 	d.tail.head
//│ ╙──       	^
//│ res: error
//│    = 1
//│ ╔══[ERROR] identifier not found: d
//│ ║  l.124: 	d.tail.tail
//│ ╙──       	^
//│ res: error
//│    = Nil { size: 0 }

