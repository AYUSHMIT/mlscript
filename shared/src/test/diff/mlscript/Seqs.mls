
class Seq[A]: { size: int }
//│ Defined class Seq

class ListBase[A]: Seq[A]
//│ Defined class ListBase

class Nil: ListBase[nothing] & {}
class Cons[A]: ListBase[A] & { head: A; tail: List[A] }
type List[A] = Nil | Cons[A]
//│ Defined class Nil
//│ Defined class Cons
//│ Defined type alias List

:e
Nil{}
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.16: 	Nil{}
//│ ║        	^^^^^
//│ ╟── expression of type `anything` does not have field 'size'
//│ ║  l.16: 	Nil{}
//│ ╙──      	   ^^
//│ res: nil & {size: nothing, Seq#A = nothing, ListBase#A = nothing} | error

def Nil = Nil { size = 0 }
//│ Nil: nil & {size: 0, Seq#A = nothing, ListBase#A = nothing}

// FIXME
Cons 1 Nil
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.29: 	Cons 1 Nil
//│ ║        	^^^^^^
//│ ╟── expression of type `1` does not match type `{head: ?head, size: ?size, tail: ?tail}`
//│ ║  l.29: 	Cons 1 Nil
//│ ╙──      	     ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.29: 	Cons 1 Nil
//│ ║        	^^^^^^^^^^
//│ ╟── expression of type `cons & {ListBase#A = ?A, Seq#A = ?A, head: ?head, size: ?size, tail: ?tail, Cons#A = ?A}` does not match type `?a -> ?b`
//│ ║  l.29: 	Cons 1 Nil
//│ ╙──      	^^^^^^
//│ res: error

Cons
//│ res: {head: 'head & 'A, size: int & 'size, tail: nil & {size: int, Seq#A = nothing, ListBase#A = nothing} & 'tail | (cons & {size: int, Cons#A = 'A, ListBase#A = 'A, tail: 'b & (nil & {size: int, Seq#A = nothing, ListBase#A = nothing} | 'a), Seq#A = 'A, head: 'A} as 'a) & 'tail} -> (cons & {size: 'size, Cons#A = 'A, ListBase#A = 'A, tail: 'tail, Seq#A = 'A, head: 'head})

// In the old inheritance semantics, this used to be required:
def Cons_old head tail =
  Cons (ListBase (Seq { size = succ tail.size }) with { head; tail })
//│ Cons_old: 'a -> (nil & {size: int, Seq#A = nothing, ListBase#A = nothing} & 'b | (cons & {size: int, Cons#A :> 'A <: 'A | 'a, ListBase#A :> 'A <: 'A | 'a, tail: 'd & (nil & {size: int, Seq#A = nothing, ListBase#A = nothing} | 'c), Seq#A :> 'A <: 'A | 'a, head: 'A} as 'c) & 'b) -> (cons & {size: int, Cons#A :> 'A | 'a <: 'A, ListBase#A :> 'A | 'a <: 'A, tail: 'b, Seq#A :> 'A | 'a <: 'A, head: 'a})

def Cons head tail =
  Cons { size = succ tail.size; head; tail }
//│ Cons: 'a -> (nil & {size: int, Seq#A = nothing, ListBase#A = nothing} & 'b | (cons & {size: int, Cons#A :> 'A <: 'A | 'a, ListBase#A :> 'A <: 'A | 'a, tail: 'd & (nil & {size: int, Seq#A = nothing, ListBase#A = nothing} | 'c), Seq#A :> 'A <: 'A | 'a, head: 'A} as 'c) & 'b) -> (cons & {size: int, Cons#A :> 'A | 'a <: 'A, ListBase#A :> 'A | 'a <: 'A, tail: 'b, Seq#A :> 'A | 'a <: 'A, head: 'a})

// We do not yet perform variance analysis
:e
Nil: ListBase[anything]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.58: 	Nil: ListBase[anything]
//│ ║        	^^^
//│ ╟── expression of type `anything` does not match type `nothing`
//│ ║  l.58: 	Nil: ListBase[anything]
//│ ║        	              ^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.8: 	class Nil: ListBase[nothing] & {}
//│ ╙──     	                    ^^^^^^^
//│ res: listBase & {size: int, Seq#A = anything, ListBase#A = anything}

def c = Cons 1 Nil
//│ c: cons & {size: int, Cons#A :> 'A | 1 <: 'A, ListBase#A :> 'A | 1 <: 'A, tail: nil & {size: 0, Seq#A = nothing, ListBase#A = nothing}, Seq#A :> 'A | 1 <: 'A, head: 1}

c: ListBase[int]
//│ res: listBase & {size: int, Seq#A = int, ListBase#A = int}

c.head
//│ res: 1

c.tail
//│ res: nil & {size: 0, Seq#A = nothing, ListBase#A = nothing}

c.size
//│ res: int

def d = Cons 2 c
//│ d: cons & {size: int, Cons#A :> 'A | 2 | 1 <: 'A, ListBase#A :> 'A | 2 | 1 <: 'A, tail: cons & {size: int, Cons#A :> 'A | 2 | 1 <: 'A, ListBase#A :> 'A | 2 | 1 <: 'A, tail: nil & {size: 0, Seq#A = nothing, ListBase#A = nothing}, Seq#A :> 'A | 2 | 1 <: 'A, head: 1}, Seq#A :> 'A | 2 | 1 <: 'A, head: 2}

d.head
//│ res: 2

d.size
//│ res: int

d.tail
//│ res: cons & {size: int, Cons#A :> 'A | 2 | 1 <: 'A, ListBase#A :> 'A | 2 | 1 <: 'A, tail: nil & {size: 0, Seq#A = nothing, ListBase#A = nothing}, Seq#A :> 'A | 2 | 1 <: 'A, head: 1}

d.tail.size
//│ res: int

d.tail.head
d.tail.tail
//│ res: 1
//│ res: nil & {size: 0, Seq#A = nothing, ListBase#A = nothing}

