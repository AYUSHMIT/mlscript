// :GeneralizeCurriedFunctions // TODO try out

// ============ Sec 1.1 ============

// i.e. auto
g = fun (f: forall 'a. 'a -> 'a) -> f f
//│ g: (forall 'a. 'a -> 'a) -> (forall 'a. 'a -> 'a)
//│  = [Function: g]

// i.e. auto id (FreezeML F5)
(fun (f: forall 'a. 'a -> 'a) -> f f) (fun x -> x)
//│ res: 'a -> 'a
//│    = [Function (anonymous)]

// i.e. (fun auto -> auto id) auto
(fun g -> g (fun x -> x)) (fun (f: forall 'a. 'a -> 'a) -> f f)
//│ res: 'a -> 'a
//│    = [Function (anonymous)]

// ============ Sec 1.2 ============

fun f -> f (g f)
//│ res: ((forall 'a. 'a -> 'a) -> 'b & 'a -> 'a) -> 'b
//│    = [Function: res]

// ============ Sec 4.1 ============

let f = fun x -> x in 
  let g = (fun x -> x) f in
    g g
//│ res: 'a -> 'a
//│    = [Function (anonymous)]

:NoJS

// ============ Sec 4.2 ============
// using FCP to solve method typing issues,
// which is overkill since it can be solved with subtyping and two levels of polymorphism...
// all of the following are typable in the main branch

// ------------ Dummy classes to represent the types in the examples ------------

class List[a]
  method Get: a
//│ Defined class List[+a]
//│ Declared List.Get: List['a] -> 'a

// Used to represent `::` in the papers
def cons[a]: a -> List[a] -> List[a]
//│ cons: 'a -> List['a] -> List['a]

// Used to represent `[]` in the papers
def nil: List['a]
//│ nil: List[nothing]

// ------------ Type signatures for functions used in the examples ------------
// (I guess)

def mem[a]: List[a] -> a -> bool
//│ mem: List[?] -> anything -> bool

def fold_left[a, b]: (a -> b -> a) -> a -> List[b] -> a
//│ fold_left: ('a -> 'b -> 'a) -> 'a -> List['b] -> 'a

// ------------ polymorphic methods ------------

class Collection[a]: { l: List[a] }
  method Mem x = mem x this.l
  method Fold f x = fold_left f x this.l
//│ Defined class Collection[+a]
//│ Defined Collection.Mem: Collection[?] -> List[?] -> bool
//│ Defined Collection.Fold: Collection['a] -> ('b -> 'a -> 'b) -> 'b -> 'b

def coll_mem c x = c.Mem x
//│ coll_mem: Collection[?] -> List[?] -> bool

// typo in the paper? it was `fun x -> fun y -> ...`
def simple_and_double c =
  let l1 = c.Fold (fun y -> fun x -> cons x y) nil in
  let l2 = c.Fold (fun y -> fun x -> cons ((x, x),) y) nil in
  (l1, l2)
//│ simple_and_double: Collection['a | 'a0] -> (List['a0], List[('a, 'a,)],)

// ------------ subtyping & methods ------------

class Float
class Color
class Point: { x: Float; y: Float }
class ColorPoint: Point & { c: Color }
class Circle: { x: Float; y: Float; r: Float }
  method Distance: Point -> Float
//│ Defined class Float
//│ Defined class Color
//│ Defined class Point
//│ Defined class ColorPoint
//│ Defined class Circle
//│ Declared Circle.Distance: Circle -> Point -> Float

c = error : Circle
cp = error : ColorPoint
c.Distance cp
//│ c: Circle
//│ cp: ColorPoint
//│ res: Float
