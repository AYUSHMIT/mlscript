:GeneralizeCurriedFunctions

// ============ Sec 1.1 ============

// i.e. auto
g = fun (f: forall 'a. 'a -> 'a) -> f f
g' = fun f -> f f
//│ g: (forall 'a. 'a -> 'a) -> (forall 'a. 'a -> 'a)
//│  = [Function: g]
//│ g': ('a -> 'b & 'a) -> 'b
//│   = [Function: g]

// i.e. auto id (FreezeML F5)
(fun (f: forall 'a. 'a -> 'a) -> f f) (fun x -> x)
(fun f -> f f) (fun x -> x)
//│ res: 'a -> 'a
//│    = [Function (anonymous)]
//│ res: 'a -> 'a
//│    = [Function (anonymous)]

// i.e. (fun auto -> auto id) auto
(fun g -> g (fun x -> x)) (fun f -> f f)
(fun g -> g (fun x -> x)) (fun (f: forall 'a. 'a -> 'a) -> f f)
//│ res: 'a -> 'a
//│    = [Function (anonymous)]
//│ res: 'a -> 'a
//│    = [Function (anonymous)]

// ============ Sec 1.2 ============

fun f -> f (g f)
fun f -> f (g' f)
//│ res: ((forall 'a. 'a -> 'a) -> 'b & 'a -> 'a) -> 'b
//│    = [Function: res]
//│ res: ('a -> 'b & 'c -> 'a & 'c) -> 'b
//│    = [Function: res]

// ============ Sec 4.1 ============

let f = fun x -> x in 
  let g = (fun x -> x) f in
    g g
//│ res: 'a -> 'a
//│    = [Function (anonymous)]

:NoJS

// ============ Sec 4.2 ============
// using FCP to solve method typing issues,
// which is overkill since it can be solved with subtyping and two levels of polymorphism...
// all of the following are typable in the main branch

// ------------ Dummy classes to represent the types in the examples ------------

class List[a]
  method Get: a
//│ Defined class List[+a]
//│ Declared List.Get: List['a] -> 'a

// Used to represent `::` in the papers
def cons[a]: a -> List[a] -> List[a]
//│ cons: 'a -> List['a] -> List['a]

// Used to represent `[]` in the papers
def nil: List['a]
//│ nil: List[nothing]

def match_list: forall 'a 'b. List['a] -> 'b -> ('a -> List['a] -> 'b) -> 'b
//│ match_list: List['a] -> 'b -> ('a -> List['a] -> 'b) -> 'b

// ------------ Type signatures for functions used in the examples ------------
// (I guess)

def mem[a]: a -> List[a] -> bool
//│ mem: anything -> List[?] -> bool

// FIXME
rec def mem x l = match_list l false (fun head -> fun tail -> if eq head x then true else mem x tail)
//│ 'b -> (forall 'b, 'mem, 'a, 'c. (List['a] -> (false | true | 'c)
//│   where
//│     'mem <: 'b -> List['a] -> 'c)) | 'mem
//│   <:  mem:
//│ anything -> List[?] -> bool
//│ ╔══[ERROR] Subtyping constraint of the form `forall ?mem, ?mem0. ?mem0 <: forall ?a. ?a -> List[?a] -> bool` exceeded recursion depth limit (400)
//│ ║  l.78: 	rec def mem x l = match_list l false (fun head -> fun tail -> if eq head x then true else mem x tail)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── while constraining:  _α199''  <!<  α863'
//│ ╟── while constraining:  α842'  <!<  α863'
//│ ╟── while constraining:  (α842',)  <!<  (α863',)
//│ ╟── while constraining:  (α863' -> ‹∀ 2. {(α873''' -> α872''') where: mem200' <: ((α863',) -> α864''')}›)  <!<  ((α842',) -> α853')
//│ ╟── while constraining:  ‹∀ 1. (α201'' -> ‹∀ 2. {(α211''' -> α210''') where: mem200' <: ((α201'',) -> α202''')}›)›  <!<  ((α842',) -> α853')
//│ ╟── while constraining:  mem200'  <!<  ((α842',) -> α853')
//│ ╟── while constraining:  {(α862' -> α861') where: mem200' <: ((α842',) -> α853')}  <!<  ((α833',) -> α836')
//│ ╟── while constraining:  ‹∀ 2. {(α852''' -> α851''') where: mem200' <: ((α842',) -> α843''')}›  <!<  ((α833',) -> α836')
//│ ╟── while constraining:  ‹∀ 2. {(α852''' -> α851''') where: mem200' <: ((α842',) -> α843''')}›  <!<  α832'
//│ ╟── while constraining:  (α842' -> ‹∀ 2. {(α852''' -> α851''') where: mem200' <: ((α842',) -> α843''')}›)  <!<  ((α821',) -> α832')
//│ ╟── while constraining:  ‹∀ 1. (α201'' -> ‹∀ 2. {(α211''' -> α210''') where: mem200' <: ((α201'',) -> α202''')}›)›  <!<  ((α821',) -> α832')
//│ ╟── while constraining:  mem200'  <!<  ((α821',) -> α832')
//│ ╟── while constraining:  {(α841' -> α840') where: mem200' <: ((α821',) -> α832')}  <!<  ((α812',) -> α815')
//│ ╟── while constraining:  ‹∀ 2. {(α831''' -> α830''') where: mem200' <: ((α821',) -> α822''')}›  <!<  ((α812',) -> α815')
//│ ╟── while constraining:  ‹∀ 2. {(α831''' -> α830''') where: mem200' <: ((α821',) -> α822''')}›  <!<  α811'
//│ ╟── ......
//│ ╟── ......
//│ ╟── while constraining:  ‹∀ 1. (α201'' -> ‹∀ 2. {(α211''' -> α210''') where: mem200' <: ((α201'',) -> α202''')}›)›  <!<  ((α233',) -> α244')
//│ ╟── while constraining:  mem200'  <!<  ((α233',) -> α244')
//│ ╟── while constraining:  {(α253' -> α252') where: mem200' <: ((α233',) -> α244')}  <!<  ((α224',) -> α227')
//│ ╟── while constraining:  ‹∀ 2. {(α243''' -> α242''') where: mem200' <: ((α233',) -> α234''')}›  <!<  ((α224',) -> α227')
//│ ╟── while constraining:  ‹∀ 2. {(α243''' -> α242''') where: mem200' <: ((α233',) -> α234''')}›  <!<  α223'
//│ ╟── while constraining:  (α233' -> ‹∀ 2. {(α243''' -> α242''') where: mem200' <: ((α233',) -> α234''')}›)  <!<  ((α212',) -> α223')
//│ ╟── while constraining:  ‹∀ 1. (α201'' -> ‹∀ 2. {(α211''' -> α210''') where: mem200' <: ((α201'',) -> α202''')}›)›  <!<  ((α212',) -> α223')
//│ ╟── while constraining:  mem200'  <!<  ((α212',) -> α223')
//│ ╟── while constraining:  {(α232' -> α231') where: mem200' <: ((α212',) -> α223')}  <!<  (List[_α199''] -> Bool)
//│ ╟── while constraining:  ‹∀ 2. {(α222''' -> α221''') where: mem200' <: ((α212',) -> α213''')}›  <!<  (List[_α199''] -> Bool)
//│ ╟── while constraining:  (α212' -> ‹∀ 2. {(α222''' -> α221''') where: mem200' <: ((α212',) -> α213''')}›)  <!<  (_α199'' -> (List[_α199''] -> Bool))
//│ ╟── while constraining:  ‹∀ 1. (α201'' -> ‹∀ 2. {(α211''' -> α210''') where: mem200' <: ((α201'',) -> α202''')}›)›  <!<  (_α199'' -> (List[_α199''] -> Bool))
//│ ╟── while constraining:  mem200'  <!<  (_α199'' -> (List[_α199''] -> Bool))
//│ ╟── while constraining:  ‹∀ 0. mem153'›  <!<  (_α199'' -> (List[_α199''] -> Bool))
//│ ╙── while constraining:  ‹∀ 0. mem153'›  <!<  ‹∀ 0. (α151' -> (List[α151'] -> Bool))›




// def fold_left[a, b]: (a -> b -> a) -> a -> List[b] -> a
def fold_left: forall 'a 'b. ('a -> 'b -> 'a) -> 'a -> List['b] -> 'a
//│ fold_left: ('a -> 'b -> 'a) -> 'a -> List['b] -> 'a

rec def fl f x l = match_list l x (fun head -> fun tail -> fl f (f x head) tail)
//│ fl: 'b -> (forall 'c. 'c -> (forall 'b, 'c, 'fl, 'd, 'a, 'e. (List['a] -> ('c | 'e)
//│   where
//│     'fl <: 'b -> 'd -> List['a] -> 'e
//│     'b <: 'c -> 'a -> 'd))) | 'fl

rec def fl2 f x l = match_list l x (fun head -> fun tail -> fold_left f (f x head) tail)
//│ fl2: 'c -> (forall 'd. 'd -> (forall 'c, 'd, 'a, 'b. (List['b] -> ('a | 'd)
//│   where
//│     'c <: ('a | 'd) -> 'b -> 'a & 'd -> 'b -> 'a)))

// :d
// FIXME
def fold_left = fl
//│ 'b -> (forall 'c. 'c -> (forall 'b, 'c, 'fl, 'd, 'a, 'e. (List['a] -> ('c | 'e)
//│   where
//│     'fl <: 'b -> 'd -> List['a] -> 'e
//│     'b <: 'c -> 'a -> 'd))) | 'fl
//│   <:  fold_left:
//│ ('a -> 'b -> 'a) -> 'a -> List['b] -> 'a
//│ ╔══[ERROR] Subtyping constraint of the form `forall ?fl, ?fl0. ?fl0 <: forall ?a, ?b. (?a -> ?b -> ?a) -> ?a -> List[?b] -> ?a` exceeded recursion depth limit (400)
//│ ║  l.140: 	def fold_left = fl
//│ ║         	^^^^^^^^^^^^^^^^^^
//│ ╟── while constraining:  (‘a'' -> (‘b'' -> ‘a''))  <!<  α1785''
//│ ╟── while constraining:  α1748''  <!<  α1785''
//│ ╟── while constraining:  (α1748'',)  <!<  (α1785'',)
//│ ╟── while constraining:  (α1785'' -> ‹∀ 2. (α1786''' -> ‹∀ 3. {(α1798'''' -> α1796'''') where: fl1787'' <: ((α1785'',) -> α1788''''), α1785'' <: ((α1786''',) -> α1797'''')}›)›)  <!<  ((α1748'',) -> α1774'')
//│ ╟── while constraining:  ‹∀ 1. (α1032'' -> ‹∀ 2. (α1033''' -> ‹∀ 3. {(α1044'''' -> α1042'''') where: fl1031'' <: ((α1032'',) -> α1034''''), α1032'' <: ((α1033''',) -> α1043'''')}›)›)›  <!<  ((α1748'',) -> α1774'')
//│ ╟── while constraining:  fl1750''  <!<  ((α1748'',) -> α1774'')
//│ ╟── while constraining:  {(α1784'' -> α1782'') where: fl1750'' <: ((α1748'',) -> α1774''), α1748'' <: ((α1762'',) -> α1783'')}  <!<  ((α1740'',) -> α1743'')
//│ ╟── while constraining:  ‹∀ 3. {(α1773'''' -> α1771'''') where: fl1750'' <: ((α1748'',) -> α1763''''), α1748'' <: ((α1762'',) -> α1772'''')}›  <!<  ((α1740'',) -> α1743'')
//│ ╟── while constraining:  ‹∀ 3. {(α1773'''' -> α1771'''') where: fl1750'' <: ((α1748'',) -> α1763''''), α1748'' <: ((α1762'',) -> α1772'''')}›  <!<  α1739''
//│ ╟── while constraining:  (α1762'' -> ‹∀ 3. {(α1773'''' -> α1771'''') where: fl1750'' <: ((α1748'',) -> α1763''''), α1748'' <: ((α1762'',) -> α1772'''')}›)  <!<  ((α1738'',) -> α1739'')
//│ ╟── while constraining:  ‹∀ 2. (α1749''' -> ‹∀ 3. {(α1761'''' -> α1759'''') where: fl1750'' <: ((α1748'',) -> α1751''''), α1748'' <: ((α1749''',) -> α1760'''')}›)›  <!<  ((α1738'',) -> α1739'')
//│ ╟── while constraining:  ‹∀ 2. (α1749''' -> ‹∀ 3. {(α1761'''' -> α1759'''') where: fl1750'' <: ((α1748'',) -> α1751''''), α1748'' <: ((α1749''',) -> α1760'''')}›)›  <!<  α1737''
//│ ╟── while constraining:  (α1748'' -> ‹∀ 2. (α1749''' -> ‹∀ 3. {(α1761'''' -> α1759'''') where: fl1750'' <: ((α1748'',) -> α1751''''), α1748'' <: ((α1749''',) -> α1760'''')}›)›)  <!<  ((α1711'',) -> α1737'')
//│ ╟── while constraining:  ‹∀ 1. (α1032'' -> ‹∀ 2. (α1033''' -> ‹∀ 3. {(α1044'''' -> α1042'''') where: fl1031'' <: ((α1032'',) -> α1034''''), α1032'' <: ((α1033''',) -> α1043'''')}›)›)›  <!<  ((α1711'',) -> α1737'')
//│ ╟── while constraining:  fl1713''  <!<  ((α1711'',) -> α1737'')
//│ ╟── ......
//│ ╟── ......
//│ ╟── while constraining:  ‹∀ 2. (α1083''' -> ‹∀ 3. {(α1095'''' -> α1093'''') where: fl1084'' <: ((α1082'',) -> α1085''''), α1082'' <: ((α1083''',) -> α1094'''')}›)›  <!<  α1071''
//│ ╟── while constraining:  (α1082'' -> ‹∀ 2. (α1083''' -> ‹∀ 3. {(α1095'''' -> α1093'''') where: fl1084'' <: ((α1082'',) -> α1085''''), α1082'' <: ((α1083''',) -> α1094'''')}›)›)  <!<  ((α1045'',) -> α1071'')
//│ ╟── while constraining:  ‹∀ 1. (α1032'' -> ‹∀ 2. (α1033''' -> ‹∀ 3. {(α1044'''' -> α1042'''') where: fl1031'' <: ((α1032'',) -> α1034''''), α1032'' <: ((α1033''',) -> α1043'''')}›)›)›  <!<  ((α1045'',) -> α1071'')
//│ ╟── while constraining:  fl1047''  <!<  ((α1045'',) -> α1071'')
//│ ╟── while constraining:  {(α1081'' -> α1079'') where: fl1047'' <: ((α1045'',) -> α1071''), α1045'' <: ((α1059'',) -> α1080'')}  <!<  (List[‘b''] -> ‘a'')
//│ ╟── while constraining:  ‹∀ 3. {(α1070'''' -> α1068'''') where: fl1047'' <: ((α1045'',) -> α1060''''), α1045'' <: ((α1059'',) -> α1069'''')}›  <!<  (List[‘b''] -> ‘a'')
//│ ╟── while constraining:  (α1059'' -> ‹∀ 3. {(α1070'''' -> α1068'''') where: fl1047'' <: ((α1045'',) -> α1060''''), α1045'' <: ((α1059'',) -> α1069'''')}›)  <!<  (‘a'' -> (List[‘b''] -> ‘a''))
//│ ╟── while constraining:  ‹∀ 2. (α1046''' -> ‹∀ 3. {(α1058'''' -> α1056'''') where: fl1047'' <: ((α1045'',) -> α1048''''), α1045'' <: ((α1046''',) -> α1057'''')}›)›  <!<  (‘a'' -> (List[‘b''] -> ‘a''))
//│ ╟── while constraining:  (α1045'' -> ‹∀ 2. (α1046''' -> ‹∀ 3. {(α1058'''' -> α1056'''') where: fl1047'' <: ((α1045'',) -> α1048''''), α1045'' <: ((α1046''',) -> α1057'''')}›)›)  <!<  ((‘a'' -> (‘b'' -> ‘a'')) -> (‘a'' -> (List[‘b''] -> ‘a'')))
//│ ╟── while constraining:  ‹∀ 1. (α1032'' -> ‹∀ 2. (α1033''' -> ‹∀ 3. {(α1044'''' -> α1042'''') where: fl1031'' <: ((α1032'',) -> α1034''''), α1032'' <: ((α1033''',) -> α1043'''')}›)›)›  <!<  ((‘a'' -> (‘b'' -> ‘a'')) -> (‘a'' -> (List[‘b''] -> ‘a'')))
//│ ╟── while constraining:  fl1031''  <!<  ((‘a'' -> (‘b'' -> ‘a'')) -> (‘a'' -> (List[‘b''] -> ‘a'')))
//│ ╟── while constraining:  ‹∀ 0. fl892'›  <!<  ((‘a'' -> (‘b'' -> ‘a'')) -> (‘a'' -> (List[‘b''] -> ‘a'')))
//│ ╟── while constraining:  ‹∀ 0. ‹∀ 0. fl892'››  <!<  ((‘a'' -> (‘b'' -> ‘a'')) -> (‘a'' -> (List[‘b''] -> ‘a'')))
//│ ╟── while constraining:  ‹∀ 0. ‹∀ 0. fl892'››  <!<  ‹∀ 1. (('a884'' -> ('b885'' -> 'a884'')) -> ('a884'' -> (List['b885''] -> 'a884'')))›
//│ ╙── while constraining:  ‹∀ 0. ‹∀ 0. fl892'››  <!<  ‹∀ 0. ‹∀ 1. (('a884'' -> ('b885'' -> 'a884'')) -> ('a884'' -> (List['b885''] -> 'a884'')))››

def fold_left = fl2
//│ 'c -> (forall 'd. 'd -> (forall 'c, 'd, 'a, 'b. (List['b] -> ('a | 'd)
//│   where
//│     'c <: ('a | 'd) -> 'b -> 'a & 'd -> 'b -> 'a)))
//│   <:  fold_left:
//│ ('a -> 'b -> 'a) -> 'a -> List['b] -> 'a

// :d
// rec def fold_left f x l = match_list l x (fun head -> fun tail -> fold_left f (f x head) tail)

// ------------ polymorphic methods ------------

class Collection[a]: { l: List[a] }
  method Mem x = mem x this.l
  method Fold f x = fold_left f x this.l
//│ Defined class Collection[+a]
//│ Defined Collection.Mem: Collection[?] -> anything -> bool
//│ Defined Collection.Fold: Collection['a] -> (forall 'b. 'b -> (forall 'a, 'b, 'a0. ('a0 -> 'a0
//│   where
//│     'b <: 'a0 -> 'a -> 'a0)))

def coll_mem c x = c.Mem x
//│ coll_mem: 'a -> (forall 'a. ('a -> bool
//│   where
//│     'a <: Collection['a]))

// typo in the paper? it was `fun x -> fun y -> ...`
def simple_and_double c =
  let l1 = c.Fold (fun y -> fun x -> cons x y) nil in
  let l2 = c.Fold (fun y -> fun x -> cons ((x, x),) y) nil in
  (l1, l2)
//│ simple_and_double: Collection[?] -> (List[nothing], List[(nothing, nothing,)],)

simple_and_double (Collection{l = cons 1 nil})
//│ res: (List[nothing], List[(nothing, nothing,)],)

// ------------ subtyping & methods ------------

class Float
class Color
class Point: { x: Float; y: Float }
class ColorPoint: Point & { c: Color }
class Circle: { x: Float; y: Float; r: Float }
  method Distance: Point -> Float
//│ Defined class Float
//│ Defined class Color
//│ Defined class Point
//│ Defined class ColorPoint
//│ Defined class Circle
//│ Declared Circle.Distance: Circle -> Point -> Float

c = error : Circle
cp = error : ColorPoint
c.Distance cp
//│ c: Circle
//│ cp: ColorPoint
//│ res: Float
