:GeneralizeCurriedFunctions
:NoRecursiveTypes

// ============ Sec 1.1 ============

// i.e. auto
g = fun (f: forall 'a. 'a -> 'a) -> f f
g' = fun f -> f f
//│ g: (forall 'a. 'a -> 'a) -> 'b
//│   where
//│     'c :> forall 'a. 'a -> 'a
//│        <: (forall 'a. 'a -> 'a) & 'c -> 'b
//│  = [Function: g]
//│ g': 'a -> 'b
//│   where
//│     'a <: 'a -> 'b
//│   = [Function: g]

// i.e. auto id (FreezeML F5)
(fun (f: forall 'a. 'a -> 'a) -> f f) (fun x -> x)
(fun f -> f f) (fun x -> x)
//│ res: 'a -> 'a
//│    = [Function (anonymous)]
//│ res: 'a -> 'a
//│    = [Function (anonymous)]

// i.e. (fun auto -> auto id) auto
(fun g -> g (fun x -> x)) (fun f -> f f)
(fun g -> g (fun x -> x)) (fun (f: forall 'a. 'a -> 'a) -> f f)
//│ res: 'a -> 'a
//│    = [Function (anonymous)]
//│ res: 'a -> 'a
//│    = [Function (anonymous)]

// ============ Sec 1.2 ============

fun f -> f (g f)
fun f -> f (g' f)
//│ res: 'b -> 'c
//│   where
//│     'b <: (forall 'a. 'a -> 'a) & 'd -> 'c
//│     'e :> forall 'a. 'a -> 'a
//│        <: (forall 'a. 'a -> 'a) & 'e -> 'f
//│     'f <: 'd
//│    = [Function: res]
//│ res: 'a -> 'b
//│   where
//│     'a <: 'c & 'd -> 'b
//│     'c <: 'c -> 'e
//│     'e <: 'd
//│    = [Function: res]

// ============ Sec 4.1 ============

let f = fun x -> x in 
  let g = (fun x -> x) f in
    g g
//│ res: 'a -> 'a
//│    = [Function (anonymous)]

:NoJS

// ============ Sec 4.2 ============
// using FCP to solve method typing issues,
// which is overkill since it can be solved with subtyping and two levels of polymorphism...
// all of the following are typable in the main branch

// ------------ Dummy classes to represent the types in the examples ------------

class List[a]
  method Get: a
//│ Defined class List[+a]
//│ Declared List.Get: List['a] -> 'a

// Used to represent `::` in the papers
def cons[a]: a -> List[a] -> List[a]
//│ cons: 'a -> List['a] -> List['a]

// Used to represent `[]` in the papers
def nil: List['a]
//│ nil: List[nothing]

def match_list: forall 'a 'b. List['a] -> 'b -> ('a -> List['a] -> 'b) -> 'b
//│ match_list: List['a] -> 'b -> ('a -> List['a] -> 'b) -> 'b

// ------------ Type signatures for functions used in the examples ------------
// (I guess)

def mem[a]: a -> List[a] -> bool
//│ mem: anything -> List[?] -> bool

:RecursiveTypes // needed for this recursive def
rec def mem x l = match_list l false (fun head -> fun tail -> if eq head x then true else mem x tail)
//│ anything -> List[?] -> bool
//│   <:  mem:
//│ anything -> List[?] -> bool
:NoRecursiveTypes




// def fold_left[a, b]: (a -> b -> a) -> a -> List[b] -> a
def fold_left: forall 'a 'b. ('a -> 'b -> 'a) -> 'a -> List['b] -> 'a
//│ fold_left: ('a -> 'b -> 'a) -> 'a -> List['b] -> 'a

rec def fl f x l = match_list l x (fun head -> fun tail -> fl f (f x head) tail)
//│ fl: ('b -> 'a -> 'b) -> 'b -> List['a] -> 'b

rec def fl2 f x l = match_list l x (fun head -> fun tail -> fold_left f (f x head) tail)
//│ fl2: ('a -> nothing -> 'a & nothing -> nothing -> 'a & 'a0 -> nothing -> 'a0 & nothing -> nothing -> 'a0 & nothing -> nothing -> 'a1 & 'a1 -> nothing -> 'a1 & 'c) -> (forall 'c, 'd, 'b, 'a2, 'e, 'f, 'g, 'h, 'i, 'j. ('e -> (forall 'c, 'e, 'k, 'l, 'b0, 'a3, 'm, 'n, 'o, 'p. ('k -> 'q
//│   where
//│     'l :> 'b0 -> ('a3 -> List['a3] -> 'b0) -> 'b0
//│        <: 'e -> 'm
//│     'm <: (forall 'c, 'e, 'a4, 'b1, 'r, 's, 't, 'u, 'v, 'k. ('v -> (forall 'c, 'e, 'v, 'w, 'a5, 'b2, 'x, 'y, 'z, 'a1, 'b1. ('a1 -> 'b1
//│   where
//│     'w :> 'a5 -> List['b2] -> 'a5
//│        <: 'x -> 'y
//│     'z <: 'v -> 'x
//│     'y <: 'a1 -> 'b1
//│     'c <: 'a5 -> 'b2 -> 'a5 & 'e -> 'z))
//│   where
//│     'c <: 'a4 -> 'b1 -> 'a4 & 'e -> 'r
//│     's :> 'a4 -> List['b1] -> 'a4
//│        <: 't -> 'u
//│     'r <: 'v -> 't
//│     'u <: nothing -> 'k)) -> 'q
//│     'n :> 'a6 -> List['b3] -> 'a6
//│        <: 'c1 -> 'o
//│     'p <: nothing -> 'c1
//│     'o <: nothing -> 'k
//│     'c <: 'a6 -> 'b3 -> 'a6 & 'e -> 'p
//│     'k <: List['a3]))
//│   where
//│     'd :> 'b -> ('a2 -> List['a2] -> 'b) -> 'b
//│        <: 'e -> 'f
//│     'f <: (forall 'c, 'e, 'a4, 'b1, 'r, 's, 't, 'u, 'v, 'k. ('v -> (forall 'c, 'e, 'v, 'w, 'a5, 'b2, 'x, 'y, 'z, 'a1, 'b1. ('a1 -> 'b1
//│   where
//│     'w :> 'a5 -> List['b2] -> 'a5
//│        <: 'x -> 'y
//│     'z <: 'v -> 'x
//│     'y <: 'a1 -> 'b1
//│     'c <: 'a5 -> 'b2 -> 'a5 & 'e -> 'z))
//│   where
//│     'c <: 'a4 -> 'b1 -> 'a4 & 'e -> 'r
//│     's :> 'a4 -> List['b1] -> 'a4
//│        <: 't -> 'u
//│     'r <: 'v -> 't
//│     'u <: nothing -> 'k)) -> 'k
//│     'g :> 'a7 -> List['b4] -> 'a7
//│        <: 'd1 -> 'h
//│     'i <: nothing -> 'd1
//│     'h <: nothing -> 'k
//│     'j <: List['a2]
//│     'c <: 'a7 -> 'b4 -> 'a7 & 'e -> 'i))

:RecursiveTypes // needed for this recursive def
def fold_left = fl
//│ ('b -> 'a -> 'b) -> 'b -> List['a] -> 'b
//│   <:  fold_left:
//│ ('a -> 'b -> 'a) -> 'a -> List['b] -> 'a
:NoRecursiveTypes

def fold_left = fl2
//│ ('a -> nothing -> 'a & nothing -> nothing -> 'a & 'a0 -> nothing -> 'a0 & nothing -> nothing -> 'a0 & nothing -> nothing -> 'a1 & 'a1 -> nothing -> 'a1 & 'c) -> (forall 'c, 'd, 'b, 'a2, 'e, 'f, 'g, 'h, 'i, 'j. ('e -> (forall 'c, 'e, 'k, 'l, 'b0, 'a3, 'm, 'n, 'o, 'p. ('k -> 'q
//│   where
//│     'l :> 'b0 -> ('a3 -> List['a3] -> 'b0) -> 'b0
//│        <: 'e -> 'm
//│     'm <: (forall 'c, 'e, 'a4, 'b1, 'r, 's, 't, 'u, 'v, 'k. ('v -> (forall 'c, 'e, 'v, 'w, 'a5, 'b2, 'x, 'y, 'z, 'a1, 'b1. ('a1 -> 'b1
//│   where
//│     'w :> 'a5 -> List['b2] -> 'a5
//│        <: 'x -> 'y
//│     'z <: 'v -> 'x
//│     'y <: 'a1 -> 'b1
//│     'c <: 'a5 -> 'b2 -> 'a5 & 'e -> 'z))
//│   where
//│     'c <: 'a4 -> 'b1 -> 'a4 & 'e -> 'r
//│     's :> 'a4 -> List['b1] -> 'a4
//│        <: 't -> 'u
//│     'r <: 'v -> 't
//│     'u <: nothing -> 'k)) -> 'q
//│     'n :> 'a6 -> List['b3] -> 'a6
//│        <: 'c1 -> 'o
//│     'p <: nothing -> 'c1
//│     'o <: nothing -> 'k
//│     'c <: 'a6 -> 'b3 -> 'a6 & 'e -> 'p
//│     'k <: List['a3]))
//│   where
//│     'd :> 'b -> ('a2 -> List['a2] -> 'b) -> 'b
//│        <: 'e -> 'f
//│     'f <: (forall 'c, 'e, 'a4, 'b1, 'r, 's, 't, 'u, 'v, 'k. ('v -> (forall 'c, 'e, 'v, 'w, 'a5, 'b2, 'x, 'y, 'z, 'a1, 'b1. ('a1 -> 'b1
//│   where
//│     'w :> 'a5 -> List['b2] -> 'a5
//│        <: 'x -> 'y
//│     'z <: 'v -> 'x
//│     'y <: 'a1 -> 'b1
//│     'c <: 'a5 -> 'b2 -> 'a5 & 'e -> 'z))
//│   where
//│     'c <: 'a4 -> 'b1 -> 'a4 & 'e -> 'r
//│     's :> 'a4 -> List['b1] -> 'a4
//│        <: 't -> 'u
//│     'r <: 'v -> 't
//│     'u <: nothing -> 'k)) -> 'k
//│     'g :> 'a7 -> List['b4] -> 'a7
//│        <: 'd1 -> 'h
//│     'i <: nothing -> 'd1
//│     'h <: nothing -> 'k
//│     'j <: List['a2]
//│     'c <: 'a7 -> 'b4 -> 'a7 & 'e -> 'i))
//│   <:  fold_left:
//│ ('a -> 'b -> 'a) -> 'a -> List['b] -> 'a

// :d
// rec def fold_left f x l = match_list l x (fun head -> fun tail -> fold_left f (f x head) tail)

// ------------ polymorphic methods ------------

class Collection[a]: { l: List[a] }
  method Mem x = mem x this.l
  method Fold f x = fold_left f x this.l
//│ Defined class Collection[+a]
//│ Defined Collection.Mem: Collection['a] -> (forall 'a, 'b, 'c, 'l, 'd. ('b -> 'd
//│   where
//│     'b <: 'b
//│     'c :> List['b] -> bool
//│        <: 'l -> 'd
//│     'l :> List['a]))
//│ Defined Collection.Fold: Collection['a] -> (forall 'a, 'c, 'a0, 'b, 'd, 'l, 'e, 'l0, 'f. ('c -> (forall 'a, 'c, 'l, 'f, 'a1, 'b0, 'g, 'h, 'i. ('h -> 'i
//│   where
//│     'c <: 'a1 -> 'b0 -> 'a1
//│     'g :> 'a1 -> List['b0] -> 'a1
//│        <: 'h -> 'f
//│     'f <: 'l -> 'i
//│     'l :> List['a]))
//│   where
//│     'c <: 'a0 -> 'b -> 'a0
//│     'd :> 'a0 -> List['b] -> 'a0
//│        <: 'l -> 'e
//│     'e <: 'l0 -> 'f
//│     'l0 :> List['a]))

def coll_mem c x = c.Mem x
//│ coll_mem: 'b -> (forall 'b, 'a, 'c. ('d -> 'e
//│   where
//│     'b <: Collection['a]
//│     'c :> forall 'f, 'b, 'g, 'l, 'h, 'a. ('f -> 'h
//│   where
//│     'f <: 'b
//│     'g :> List['b] -> bool
//│        <: 'l -> 'h
//│     'l :> List['a])
//│        <: 'd -> 'e))
//│   where
//│     'i :> forall 'f, 'b, 'g, 'l, 'h, 'a. ('f -> 'h
//│   where
//│     'f <: 'b
//│     'g :> List['b] -> bool
//│        <: 'l -> 'h
//│     'l :> List['a])
//│        <: 'l -> 'b
//│     'b <: Collection['b]

// typo in the paper? it was `fun x -> fun y -> ...`
def simple_and_double c =
  let l1 = c.Fold (fun y -> fun x -> cons x y) nil in
  let l2 = c.Fold (fun y -> fun x -> cons ((x, x),) y) nil in
  (l1, l2)
//│ simple_and_double: Collection[?] -> (List[nothing], List[(nothing, nothing,)],)

simple_and_double (Collection{l = cons 1 nil})
//│ res: (List[nothing], List[(nothing, nothing,)],)

// ------------ subtyping & methods ------------

class Float
class Color
class Point: { x: Float; y: Float }
class ColorPoint: Point & { c: Color }
class Circle: { x: Float; y: Float; r: Float }
  method Distance: Point -> Float
//│ Defined class Float
//│ Defined class Color
//│ Defined class Point
//│ Defined class ColorPoint
//│ Defined class Circle
//│ Declared Circle.Distance: Circle -> Point -> Float

c = error : Circle
cp = error : ColorPoint
c.Distance cp
//│ c: Circle
//│ cp: ColorPoint
//│ res: Float
