:GeneralizeCurriedFunctions

// ============ Sec 1.1 ============

// i.e. auto
g = fun (f: forall 'a. 'a -> 'a) -> f f
g' = fun f -> f f
//│ g: (forall 'a. 'a -> 'a) -> (forall 'a. 'a -> 'a)
//│  = [Function: g]
//│ g': ('a -> 'b & 'a) -> 'b
//│   = [Function: g]

// i.e. auto id (FreezeML F5)
(fun (f: forall 'a. 'a -> 'a) -> f f) (fun x -> x)
(fun f -> f f) (fun x -> x)
//│ res: 'a -> 'a
//│    = [Function (anonymous)]
//│ res: 'a -> 'a
//│    = [Function (anonymous)]

// i.e. (fun auto -> auto id) auto
(fun g -> g (fun x -> x)) (fun f -> f f)
(fun g -> g (fun x -> x)) (fun (f: forall 'a. 'a -> 'a) -> f f)
//│ res: 'a -> 'a
//│    = [Function (anonymous)]
//│ res: 'a -> 'a
//│    = [Function (anonymous)]

// ============ Sec 1.2 ============

fun f -> f (g f)
fun f -> f (g' f)
//│ res: ((forall 'a. 'a -> 'a) -> 'b & 'a -> 'a) -> 'b
//│    = [Function: res]
//│ res: ('a -> 'b & 'c -> 'a & 'c) -> 'b
//│    = [Function: res]

// ============ Sec 4.1 ============

let f = fun x -> x in 
  let g = (fun x -> x) f in
    g g
//│ res: 'a -> 'a
//│    = [Function (anonymous)]

:NoJS

// ============ Sec 4.2 ============
// using FCP to solve method typing issues,
// which is overkill since it can be solved with subtyping and two levels of polymorphism...
// all of the following are typable in the main branch

// ------------ Dummy classes to represent the types in the examples ------------

class List[a]
  method Get: a
//│ Defined class List[+a]
//│ Declared List.Get: List['a] -> 'a

// Used to represent `::` in the papers
def cons[a]: a -> List[a] -> List[a]
//│ cons: 'a -> List['a] -> List['a]

// Used to represent `[]` in the papers
def nil: List['a]
//│ nil: List[nothing]

def match_list: forall 'a 'b. List['a] -> 'b -> ('a -> List['a] -> 'b) -> 'b
//│ match_list: List['a] -> 'b -> ('a -> List['a] -> 'b) -> 'b

// ------------ Type signatures for functions used in the examples ------------
// (I guess)

def mem[a]: a -> List[a] -> bool
//│ mem: anything -> List[?] -> bool

// FIXME
rec def mem x l = match_list l false (fun head -> fun tail -> if eq head x then true else mem x tail)
//│ anything -> (forall 'b, 'a, 'c. (List['a] -> (false | true | 'c)
//│   where
//│     'b <: List['a] -> 'c))
//│   <:  mem:
//│ anything -> List[?] -> bool
//│ ╔══[ERROR] Subtyping constraint of the form `forall ?a, ?mem, ?b, ?c, ?d. ?mem <: forall ?e. ?e -> List[?e] -> bool` exceeded recursion depth limit (400)
//│ ║  l.78: 	rec def mem x l = match_list l false (fun head -> fun tail -> if eq head x then true else mem x tail)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── while constraining:  ‹∀ 2. {(α216''' -> α215''') where: α207' <: ((α208''',) -> α211''')}›  <!<  ((α920',) -> α923')
//│ ╟── while constraining:  α207'  <!<  ((α920',) -> α923')
//│ ╟── while constraining:  {(α928' -> α927') where: α207' <: ((α920',) -> α923')}  <!<  ((α911',) -> α914')
//│ ╟── while constraining:  ‹∀ 2. {(α216''' -> α215''') where: α207' <: ((α208''',) -> α211''')}›  <!<  ((α911',) -> α914')
//│ ╟── while constraining:  α207'  <!<  ((α911',) -> α914')
//│ ╟── while constraining:  {(α919' -> α918') where: α207' <: ((α911',) -> α914')}  <!<  ((α902',) -> α905')
//│ ╟── while constraining:  ‹∀ 2. {(α216''' -> α215''') where: α207' <: ((α208''',) -> α211''')}›  <!<  ((α902',) -> α905')
//│ ╟── while constraining:  α207'  <!<  ((α902',) -> α905')
//│ ╟── while constraining:  {(α910' -> α909') where: α207' <: ((α902',) -> α905')}  <!<  ((α893',) -> α896')
//│ ╟── while constraining:  ‹∀ 2. {(α216''' -> α215''') where: α207' <: ((α208''',) -> α211''')}›  <!<  ((α893',) -> α896')
//│ ╟── while constraining:  α207'  <!<  ((α893',) -> α896')
//│ ╟── while constraining:  {(α901' -> α900') where: α207' <: ((α893',) -> α896')}  <!<  ((α884',) -> α887')
//│ ╟── while constraining:  ‹∀ 2. {(α216''' -> α215''') where: α207' <: ((α208''',) -> α211''')}›  <!<  ((α884',) -> α887')
//│ ╟── while constraining:  α207'  <!<  ((α884',) -> α887')
//│ ╟── while constraining:  {(α892' -> α891') where: α207' <: ((α884',) -> α887')}  <!<  ((α875',) -> α878')
//│ ╟── ......
//│ ╟── ......
//│ ╟── while constraining:  ‹∀ 2. {(α216''' -> α215''') where: α207' <: ((α208''',) -> α211''')}›  <!<  ((α236',) -> α239')
//│ ╟── while constraining:  α207'  <!<  ((α236',) -> α239')
//│ ╟── while constraining:  {(α244' -> α243') where: α207' <: ((α236',) -> α239')}  <!<  ((α227',) -> α230')
//│ ╟── while constraining:  ‹∀ 2. {(α216''' -> α215''') where: α207' <: ((α208''',) -> α211''')}›  <!<  ((α227',) -> α230')
//│ ╟── while constraining:  α207'  <!<  ((α227',) -> α230')
//│ ╟── while constraining:  {(α235' -> α234') where: α207' <: ((α227',) -> α230')}  <!<  ((α218',) -> α221')
//│ ╟── while constraining:  ‹∀ 2. {(α216''' -> α215''') where: α207' <: ((α208''',) -> α211''')}›  <!<  ((α218',) -> α221')
//│ ╟── while constraining:  α207'  <!<  ((α218',) -> α221')
//│ ╟── while constraining:  {(α226' -> α225') where: α207' <: ((α218',) -> α221')}  <!<  (List[_α202''] -> Bool)
//│ ╟── while constraining:  ‹∀ 2. {(α216''' -> α215''') where: α207' <: ((α208''',) -> α211''')}›  <!<  (List[_α202''] -> Bool)
//│ ╟── while constraining:  (α217' -> ‹∀ 2. {(α216''' -> α215''') where: α207' <: ((α208''',) -> α211''')}›)  <!<  (_α202'' -> (List[_α202''] -> Bool))
//│ ╟── while constraining:  ‹∀ 1. (α204'' -> ‹∀ 2. {(α216''' -> α215''') where: α207' <: ((α208''',) -> α211''')}›)›  <!<  (_α202'' -> (List[_α202''] -> Bool))
//│ ╟── while constraining:  mem203'  <!<  (_α202'' -> (List[_α202''] -> Bool))
//│ ╟── while constraining:  ‹∀ 0. mem153'›  <!<  (_α202'' -> (List[_α202''] -> Bool))
//│ ╙── while constraining:  ‹∀ 0. mem153'›  <!<  ‹∀ 0. (α151' -> (List[α151'] -> Bool))›




// def fold_left[a, b]: (a -> b -> a) -> a -> List[b] -> a
def fold_left: forall 'a 'b. ('a -> 'b -> 'a) -> 'a -> List['b] -> 'a
//│ fold_left: ('a -> 'b -> 'a) -> 'a -> List['b] -> 'a

rec def fl f x l = match_list l x (fun head -> fun tail -> fl f (f x head) tail)
//│ fl: 'b -> (forall 'c. 'c -> (forall 'b, 'c, 'd, 'e, 'a, 'f. (List['a] -> ('c | 'f)
//│   where
//│     'd <: 'e -> List['a] -> 'f
//│     'b <: 'c -> 'a -> 'e)))

rec def fl2 f x l = match_list l x (fun head -> fun tail -> fold_left f (f x head) tail)
//│ fl2: 'c -> (forall 'd. 'd -> (forall 'c, 'd, 'a, 'b. (List['b] -> ('a | 'd)
//│   where
//│     'c <: ('a | 'd) -> 'b -> 'a & 'd -> 'b -> 'a)))

// :d
// FIXME
def fold_left = fl
//│ 'b -> (forall 'c. 'c -> (forall 'b, 'c, 'd, 'e, 'a, 'f. (List['a] -> ('c | 'f)
//│   where
//│     'd <: 'e -> List['a] -> 'f
//│     'b <: 'c -> 'a -> 'e)))
//│   <:  fold_left:
//│ ('a -> 'b -> 'a) -> 'a -> List['b] -> 'a
//│ ╔══[ERROR] Subtyping constraint of the form `forall ?c, ?d, ?e, ?f, ?fl, ?g, ?h, ?i. ?fl <: forall ?a, ?b. (?a -> ?b -> ?a) -> ?a -> List[?b] -> ?a` exceeded recursion depth limit (400)
//│ ║  l.140: 	def fold_left = fl
//│ ║         	^^^^^^^^^^^^^^^^^^
//│ ╟── while constraining:  ‹∀ 2. (α1139''' -> ‹∀ 3. {(α1149'''' -> α1147'''') where: α1138'' <: ((α1140'''',) -> α1141''''), α1136'' <: ((α1139''',) -> α1148'''')}›)›  <!<  ((α1906'',) -> α1907'')
//│ ╟── while constraining:  α1138''  <!<  ((α1906'',) -> α1907'')
//│ ╟── while constraining:  {(α1915'' -> α1913'') where: α1138'' <: ((α1906'',) -> α1907''), α1136'' <: ((α1895'',) -> α1914'')}  <!<  ((α1887'',) -> α1890'')
//│ ╟── while constraining:  ‹∀ 3. {(α1905'''' -> α1903'''') where: α1138'' <: ((α1896'''',) -> α1897''''), α1136'' <: ((α1895'',) -> α1904'''')}›  <!<  ((α1887'',) -> α1890'')
//│ ╟── while constraining:  ‹∀ 3. {(α1905'''' -> α1903'''') where: α1138'' <: ((α1896'''',) -> α1897''''), α1136'' <: ((α1895'',) -> α1904'''')}›  <!<  α1886''
//│ ╟── while constraining:  (α1895'' -> ‹∀ 3. {(α1905'''' -> α1903'''') where: α1138'' <: ((α1896'''',) -> α1897''''), α1136'' <: ((α1895'',) -> α1904'''')}›)  <!<  ((α1885'',) -> α1886'')
//│ ╟── while constraining:  ‹∀ 2. (α1139''' -> ‹∀ 3. {(α1149'''' -> α1147'''') where: α1138'' <: ((α1140'''',) -> α1141''''), α1136'' <: ((α1139''',) -> α1148'''')}›)›  <!<  ((α1885'',) -> α1886'')
//│ ╟── while constraining:  α1138''  <!<  ((α1885'',) -> α1886'')
//│ ╟── while constraining:  {(α1894'' -> α1892'') where: α1138'' <: ((α1885'',) -> α1886''), α1136'' <: ((α1874'',) -> α1893'')}  <!<  ((α1866'',) -> α1869'')
//│ ╟── while constraining:  ‹∀ 3. {(α1884'''' -> α1882'''') where: α1138'' <: ((α1875'''',) -> α1876''''), α1136'' <: ((α1874'',) -> α1883'''')}›  <!<  ((α1866'',) -> α1869'')
//│ ╟── while constraining:  ‹∀ 3. {(α1884'''' -> α1882'''') where: α1138'' <: ((α1875'''',) -> α1876''''), α1136'' <: ((α1874'',) -> α1883'''')}›  <!<  α1865''
//│ ╟── while constraining:  (α1874'' -> ‹∀ 3. {(α1884'''' -> α1882'''') where: α1138'' <: ((α1875'''',) -> α1876''''), α1136'' <: ((α1874'',) -> α1883'''')}›)  <!<  ((α1864'',) -> α1865'')
//│ ╟── while constraining:  ‹∀ 2. (α1139''' -> ‹∀ 3. {(α1149'''' -> α1147'''') where: α1138'' <: ((α1140'''',) -> α1141''''), α1136'' <: ((α1139''',) -> α1148'''')}›)›  <!<  ((α1864'',) -> α1865'')
//│ ╟── while constraining:  α1138''  <!<  ((α1864'',) -> α1865'')
//│ ╟── while constraining:  {(α1873'' -> α1871'') where: α1138'' <: ((α1864'',) -> α1865''), α1136'' <: ((α1853'',) -> α1872'')}  <!<  ((α1845'',) -> α1848'')
//│ ╟── ......
//│ ╟── ......
//│ ╟── while constraining:  ‹∀ 3. {(α1191'''' -> α1189'''') where: α1138'' <: ((α1182'''',) -> α1183''''), α1136'' <: ((α1181'',) -> α1190'''')}›  <!<  α1172''
//│ ╟── while constraining:  (α1181'' -> ‹∀ 3. {(α1191'''' -> α1189'''') where: α1138'' <: ((α1182'''',) -> α1183''''), α1136'' <: ((α1181'',) -> α1190'''')}›)  <!<  ((α1171'',) -> α1172'')
//│ ╟── while constraining:  ‹∀ 2. (α1139''' -> ‹∀ 3. {(α1149'''' -> α1147'''') where: α1138'' <: ((α1140'''',) -> α1141''''), α1136'' <: ((α1139''',) -> α1148'''')}›)›  <!<  ((α1171'',) -> α1172'')
//│ ╟── while constraining:  α1138''  <!<  ((α1171'',) -> α1172'')
//│ ╟── while constraining:  {(α1180'' -> α1178'') where: α1138'' <: ((α1171'',) -> α1172''), α1134'' <: ((α1160'',) -> α1179'')}  <!<  (List[‘b''] -> ‘a'')
//│ ╟── while constraining:  ‹∀ 3. {(α1170'''' -> α1168'''') where: α1138'' <: ((α1161'''',) -> α1162''''), α1134'' <: ((α1160'',) -> α1169'''')}›  <!<  (List[‘b''] -> ‘a'')
//│ ╟── while constraining:  (α1160'' -> ‹∀ 3. {(α1170'''' -> α1168'''') where: α1138'' <: ((α1161'''',) -> α1162''''), α1134'' <: ((α1160'',) -> α1169'''')}›)  <!<  (‘a'' -> (List[‘b''] -> ‘a''))
//│ ╟── while constraining:  ‹∀ 2. (α1137''' -> ‹∀ 3. {(α1159'''' -> α1157'''') where: α1138'' <: ((α1150'''',) -> α1151''''), α1134'' <: ((α1137''',) -> α1158'''')}›)›  <!<  (‘a'' -> (List[‘b''] -> ‘a''))
//│ ╟── while constraining:  (α1134'' -> ‹∀ 2. (α1137''' -> ‹∀ 3. {(α1159'''' -> α1157'''') where: α1138'' <: ((α1150'''',) -> α1151''''), α1134'' <: ((α1137''',) -> α1158'''')}›)›)  <!<  ((‘a'' -> (‘b'' -> ‘a'')) -> (‘a'' -> (List[‘b''] -> ‘a'')))
//│ ╟── while constraining:  ‹∀ 1. (α1108'' -> ‹∀ 2. (α1111''' -> ‹∀ 3. {(α1133'''' -> α1131'''') where: α1112'' <: ((α1124'''',) -> α1125''''), α1108'' <: ((α1111''',) -> α1132'''')}›)›)›  <!<  ((‘a'' -> (‘b'' -> ‘a'')) -> (‘a'' -> (List[‘b''] -> ‘a'')))
//│ ╟── while constraining:  fl1107''  <!<  ((‘a'' -> (‘b'' -> ‘a'')) -> (‘a'' -> (List[‘b''] -> ‘a'')))
//│ ╟── while constraining:  ‹∀ 0. fl950'›  <!<  ((‘a'' -> (‘b'' -> ‘a'')) -> (‘a'' -> (List[‘b''] -> ‘a'')))
//│ ╟── while constraining:  ‹∀ 0. ‹∀ 0. fl950'››  <!<  ((‘a'' -> (‘b'' -> ‘a'')) -> (‘a'' -> (List[‘b''] -> ‘a'')))
//│ ╟── while constraining:  ‹∀ 0. ‹∀ 0. fl950'››  <!<  ‹∀ 1. (('a942'' -> ('b943'' -> 'a942'')) -> ('a942'' -> (List['b943''] -> 'a942'')))›
//│ ╙── while constraining:  ‹∀ 0. ‹∀ 0. fl950'››  <!<  ‹∀ 0. ‹∀ 1. (('a942'' -> ('b943'' -> 'a942'')) -> ('a942'' -> (List['b943''] -> 'a942'')))››

def fold_left = fl2
//│ 'c -> (forall 'd. 'd -> (forall 'c, 'd, 'a, 'b. (List['b] -> ('a | 'd)
//│   where
//│     'c <: ('a | 'd) -> 'b -> 'a & 'd -> 'b -> 'a)))
//│   <:  fold_left:
//│ ('a -> 'b -> 'a) -> 'a -> List['b] -> 'a

// :d
// rec def fold_left f x l = match_list l x (fun head -> fun tail -> fold_left f (f x head) tail)

// ------------ polymorphic methods ------------

class Collection[a]: { l: List[a] }
  method Mem x = mem x this.l
  method Fold f x = fold_left f x this.l
//│ Defined class Collection[+a]
//│ Defined Collection.Mem: Collection[?] -> anything -> bool
//│ Defined Collection.Fold: Collection['a] -> (forall 'b. 'b -> (forall 'a, 'b, 'a0. ('a0 -> 'a0
//│   where
//│     'b <: 'a0 -> 'a -> 'a0)))

def coll_mem c x = c.Mem x
//│ coll_mem: 'a -> (forall 'a. ('a -> bool
//│   where
//│     'a <: Collection['a]))

// typo in the paper? it was `fun x -> fun y -> ...`
def simple_and_double c =
  let l1 = c.Fold (fun y -> fun x -> cons x y) nil in
  let l2 = c.Fold (fun y -> fun x -> cons ((x, x),) y) nil in
  (l1, l2)
//│ simple_and_double: Collection[?] -> (List[nothing], List[(nothing, nothing,)],)

simple_and_double (Collection{l = cons 1 nil})
//│ res: (List[nothing], List[(nothing, nothing,)],)

// ------------ subtyping & methods ------------

class Float
class Color
class Point: { x: Float; y: Float }
class ColorPoint: Point & { c: Color }
class Circle: { x: Float; y: Float; r: Float }
  method Distance: Point -> Float
//│ Defined class Float
//│ Defined class Color
//│ Defined class Point
//│ Defined class ColorPoint
//│ Defined class Circle
//│ Declared Circle.Distance: Circle -> Point -> Float

c = error : Circle
cp = error : ColorPoint
c.Distance cp
//│ c: Circle
//│ cp: ColorPoint
//│ res: Float
