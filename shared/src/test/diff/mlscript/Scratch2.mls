
:GeneralizeCurriedFunctions

test1 f =
  (f 0, f true)
//│ test1: (true -> 'a & 0 -> 'b) -> ('b, 'a,)
//│      = [Function: test1]

test1 (fun value -> { value })
//│ res: ({value: 0}, {value: true},)
//│    = [ undefined, undefined ]

// :ns
// :d
test2 f =
  let r x = f x
  in (r 0, r true)
//│ test2: (true -> 'a & 0 -> 'b) -> ('b, 'a,)
//│      = [Function: test2]

test2 (fun value -> { value })
//│ res: ({value: 0}, {value: true},)
//│    = [ undefined, undefined ]


type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ Defined type alias ChurchInt

// :ns
// def s (n: ChurchInt) = fun f -> fun x -> f (n f x)

:ns
def s n = fun f -> fun x -> f (n f x)
//│ s: forall 'a. 'a -> (forall 'b. 'b -> (forall 'c, 'd, 'e, 'f. ('c -> 'f
//│   where
//│     'a <: 'b -> 'd
//│     'b <: 'e -> 'f)))
//│   where
//│     'd <: 'c -> 'e
//│  = [Function: s]

def succ: ChurchInt -> ChurchInt
//│ succ: ChurchInt -> ChurchInt
//│     = <missing implementation>

:ns
succ = s
//│ forall 'a. 'a -> (forall 'b. 'b -> (forall 'c, 'd, 'e, 'f. ('c -> 'f
//│   where
//│     'a <: 'b -> 'd
//│     'b <: 'e -> 'f)))
//│   where
//│     'd <: 'c -> 'e
//│   <:  succ:
//│ ChurchInt -> ChurchInt
//│     = [Function: s]

def z f x = x
//│ z: anything -> (forall 'a. 'a -> 'a)
//│  = [Function: z]

def zero: ChurchInt
//│ zero: ChurchInt
//│     = <missing implementation>

def zero = z
//│ anything -> (forall 'a. 'a -> 'a)
//│   <:  zero:
//│ ChurchInt
//│     = [Function: z]

// :ns
// :d
// rec def to_ch n =
//   if n == 0 then zero
//   else to_ch n

// [fixed] Seems to run out of depth:
:ns
rec def to_ch n =
  if n == 0 then zero
  else succ (to_ch (n - 1))
//│ to_ch: forall 'to_ch. 'to_ch
//│   where
//│     'to_ch :> forall 'a, 'b, 'c, 'd. ('a -> 'd
//│   where
//│     'to_ch <: 'b -> 'c)
//│     'c <: ChurchInt
//│     'b :> int
//│     'd :> ChurchInt
//│     'a <: int
//│      = [Function: to_ch]

// rec def to_ch n =
//   (if n == 0 then zero
//   else succ (to_ch (n - 1) : ChurchInt)): ChurchInt

def to_church: int -> ChurchInt
//│ to_church: int -> ChurchInt
//│          = <missing implementation>

def to_church n =
  if n == 0 then zero
  else succ (to_church (n - 1))
//│ int -> ChurchInt
//│   <:  to_church:
//│ int -> ChurchInt
//│          = <no result>
//│            to_church is not implemented

// :s
:ns
to_church = to_ch
//│ forall 'to_ch. 'to_ch
//│   where
//│     'to_ch :> forall 'a, 'b, 'c, 'd. ('a -> 'd
//│   where
//│     'to_ch <: 'b -> 'c)
//│     'c <: ChurchInt
//│     'b :> int
//│     'd :> ChurchInt
//│     'a <: int
//│   <:  to_church:
//│ int -> ChurchInt
//│ /!!!\ Uncaught error: scala.MatchError: (to_ch109' <: ((α535'',) -> α536'') => (α537'' -> α538'')) (of class mlscript.TyperDatatypes$ConstrainedType)
//│ 	at: mlscript.NormalForms$DNF$.mk(NormalForms.scala:549)
//│ 	at: mlscript.TypeSimplifier.$anonfun$normalizeTypes_$bang$75(TypeSimplifier.scala:282)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:30)
//│ 	at: mlscript.TypeSimplifier.go$1(TypeSimplifier.scala:288)
//│ 	at: mlscript.TypeSimplifier.$anonfun$normalizeTypes_$bang$78(TypeSimplifier.scala:292)
//│ 	at: scala.collection.immutable.List.map(List.scala:246)
//│ 	at: mlscript.TypeSimplifier.$anonfun$normalizeTypes_$bang$77(TypeSimplifier.scala:292)
//│ 	at: mlscript.utils.package$MutSetHelpers.setAndIfUnset(package.scala:158)
//│ 	at: mlscript.TypeSimplifier.processVar$1(TypeSimplifier.scala:291)
//│ 	at: mlscript.TypeSimplifier.$anonfun$normalizeTypes_$bang$8(TypeSimplifier.scala:123)


