
:GeneralizeCurriedFunctions
// :DistributeForalls

def s n = fun f -> fun x -> f (n f x)
// def s n = fun f -> fun x -> (n f x)
// def s n = fun f -> n f
// def s n = n
//│ s: (nothing -> nothing -> 'a & 'a) -> (forall 'b. (nothing -> 'a & 'b) -> (forall 'c. 'c -> (forall 'a, 'b, 'c, 'd, 'e. ('e
//│   where
//│     'a <: 'b -> 'c -> 'd
//│     'b <: 'd -> 'e))))
//│  = [Function: s]

// type ChurchInt = forall 'N. ('N -> 'N) -> ('N -> 'N)

def zero: ('N -> 'N) -> ('N -> 'N)
// def zero: 'N -> 'N
//│ zero: ('N -> 'N) -> 'N -> 'N
//│     = <missing implementation>

type ChI = (forall 'M. ('M -> 'M) -> ('M -> 'M))
// type ChI = (forall 'M. 'M -> 'M)
//│ Defined type alias ChI

:ns
sz = s zero
//│ sz: forall 'a, 'b. 'a
//│   where
//│     'a :> forall 'c, 'd, 'e, 'f, 'g. 'c -> (forall 'h. 'h -> ('i
//│   where
//│     'b <: 'c -> 'j
//│     'c <: 'k -> 'i))
//│     'j <: 'h -> 'k
//│     'c <: 'f -> 'g & 'd -> 'e
//│   = <no result>
//│     zero is not implemented

// Note: the error is delayed...
// :e // due to tapping
sz1 = sz 1
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.41: 	sz1 = sz 1
//│ ║        	      ^^^^
//│ ╟── integer literal of type `1` is not a function
//│ ║  l.41: 	sz1 = sz 1
//│ ║        	         ^
//│ ╟── Note: constraint arises from application:
//│ ║  l.5: 	def s n = fun f -> fun x -> f (n f x)
//│ ╙──     	                            ^^^^^^^^^
//│ sz1: error
//│    = <no result>
//│      sz and zero are not implemented

// :e // FIXME? succeeds with genLamBodies
sz1 2
//│ res: error
//│    = <no result>
//│      sz1, sz and zero are not implemented

// :e // due to tapping
sz true
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.62: 	sz true
//│ ║        	^^^^^^^
//│ ╟── reference of type `true` is not a function
//│ ║  l.62: 	sz true
//│ ║        	   ^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.5: 	def s n = fun f -> fun x -> f (n f x)
//│ ╙──     	                            ^^^^^^^^^
//│ res: error
//│    = <no result>
//│      sz and zero are not implemented

sz: ChI
//│ /!!!\ Uncaught error: mlscript.TypeError: Type mismatch in expression:
//│ 	at: mlscript.TypeError$.apply(Diagnostic.scala:14)
//│ 	at: mlscript.ConstraintSolver.reportError$1(ConstraintSolver.scala:881)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrain$65(ConstraintSolver.scala:748)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrain$65$adapted(ConstraintSolver.scala:432)
//│ 	at: mlscript.utils.package$GenHelper$.$bar$greater$extension(package.scala:101)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrain$62(ConstraintSolver.scala:432)
//│ 	at: scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:30)
//│ 	at: mlscript.ConstraintSolver.recImpl$1(ConstraintSolver.scala:390)
//│ 	at: mlscript.ConstraintSolver.rec$1(ConstraintSolver.scala:375)

s zero
//│ res: (nothing -> anything & 'a) -> (forall 'b. 'b -> (forall 'a, 'b, 'c, 'd. ('d
//│   where
//│     'e <: 'a -> 'b -> 'c
//│     'a <: 'c -> 'd)))
//│    = <no result>
//│      zero is not implemented

// :e // works with quantif extrus
// :e // due to tapping
res: ChI
//│ res: ChI
//│    = [Function: s]

let tmp = s zero in tmp: ChI
//│ /!!!\ Uncaught error: mlscript.TypeError: Type mismatch in expression:
//│ 	at: mlscript.TypeError$.apply(Diagnostic.scala:14)
//│ 	at: mlscript.ConstraintSolver.reportError$1(ConstraintSolver.scala:881)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrain$65(ConstraintSolver.scala:748)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrain$65$adapted(ConstraintSolver.scala:432)
//│ 	at: mlscript.utils.package$GenHelper$.$bar$greater$extension(package.scala:101)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrain$62(ConstraintSolver.scala:432)
//│ 	at: scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:30)
//│ 	at: mlscript.ConstraintSolver.recImpl$1(ConstraintSolver.scala:390)
//│ 	at: mlscript.ConstraintSolver.rec$1(ConstraintSolver.scala:375)

// FIXedME:
// :d
s zero : ChI
//│ /!!!\ Uncaught error: mlscript.TypeError: Type mismatch in expression:
//│ 	at: mlscript.TypeError$.apply(Diagnostic.scala:14)
//│ 	at: mlscript.ConstraintSolver.reportError$1(ConstraintSolver.scala:881)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrain$65(ConstraintSolver.scala:748)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrain$65$adapted(ConstraintSolver.scala:432)
//│ 	at: mlscript.utils.package$GenHelper$.$bar$greater$extension(package.scala:101)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrain$62(ConstraintSolver.scala:432)
//│ 	at: scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:30)
//│ 	at: mlscript.ConstraintSolver.recImpl$1(ConstraintSolver.scala:390)
//│ 	at: mlscript.ConstraintSolver.rec$1(ConstraintSolver.scala:375)




// def example f = (f: forall 'a. 'a -> int -> 'b) f
// :ns
// :d
def example f = (f: forall 'a. 'a -> 'a)
//│ example: (forall 'a. 'a -> 'a) -> (forall 'a. 'a -> 'a)
//│        = [Function: example]

:e
example 1
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.142: 	example 1
//│ ║         	^^^^^^^^^
//│ ╟── integer literal of type `1` is not a function
//│ ║  l.142: 	example 1
//│ ║         	        ^
//│ ╟── Note: constraint arises from function type:
//│ ║  l.137: 	def example f = (f: forall 'a. 'a -> 'a)
//│ ║         	                               ^^^^^^^^
//│ ╟── from reference:
//│ ║  l.137: 	def example f = (f: forall 'a. 'a -> 'a)
//│ ╙──       	                 ^
//│ res: 'a -> 'a | error
//│    = 1

:e
example succ
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.159: 	example succ
//│ ║         	^^^^^^^^^^^^
//│ ╟── type `‘a` is not an instance of type `int`
//│ ║  l.137: 	def example f = (f: forall 'a. 'a -> 'a)
//│ ╙──       	                           ^^
//│ res: 'a -> 'a | error
//│    = [Function: succ]

example id
//│ res: 'a -> 'a
//│    = [Function: id]


// def example f = ((fun x -> x, f) : forall 'a. ('a -> 'a, 'a -> 'a))

// FIXME: Rigid variable extrusion here! We should clean extr contexts of local rigids before returning them....
def example f = ((0, f) : forall 'a. (0, 'a))
//│ example: ‘a -> (0, nothing,)
//│        = [Function: example1]

// FIXME same
def example f = ((0, f) : forall 'a. (0, 'a -> 'a))
//│ example: (‘a -> ‘a) -> (forall 'a. (0, 'a -> 'a,))
//│        = [Function: example2]



def id_ty: forall 'a. 'a -> 'a
//│ id_ty: 'a -> 'a
//│      = <missing implementation>

// rec def id x = if true then x else id id x
rec def id x = let tmp = id id x in x
//│ id: 'id
//│   where
//│     'id :> 'a -> 'a
//│     'a :> 'id
//│        <: 'a -> anything
//│   = [Function: id1]

// FIXME
id_ty = id
//│ 'id
//│   where
//│     'id :> 'a -> 'a
//│     'a :> 'id
//│        <: 'a -> anything
//│   <:  id_ty:
//│ 'a -> 'a
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.202: 	id_ty = id
//│ ║         	^^^^^^^^^^
//│ ╟── type `‘a` is not a function
//│ ║  l.188: 	def id_ty: forall 'a. 'a -> 'a
//│ ║         	                  ^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.193: 	rec def id x = let tmp = id id x in x
//│ ║         	                         ^^^^^^^
//│ ╟── from reference:
//│ ║  l.193: 	rec def id x = let tmp = id id x in x
//│ ╙──       	                                    ^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.202: 	id_ty = id
//│ ║         	^^^^^^^^^^
//│ ╟── function of type `?a -> ?a` is not an instance of type `'a`
//│ ║  l.193: 	rec def id x = let tmp = id id x in x
//│ ║         	           ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.188: 	def id_ty: forall 'a. 'a -> 'a
//│ ╙──       	                  ^^
//│      = [Function: id1]


