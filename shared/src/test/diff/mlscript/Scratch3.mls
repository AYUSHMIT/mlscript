
:GeneralizeCurriedFunctions

// def foo f x = f x


// def s n = fun f -> fun x -> f (n f x)



def z f x = x
//│ z: anything -> (forall 'a. 'a -> 'a)
//│  = [Function: z]

def s n f x = f (n f x)
//│ s: (nothing -> nothing -> 'a & 'a) -> (forall 'a, 'b, 'c. (('c -> 'a & 'b) -> (forall 'a, 'b, 'd, 'e. ('d -> (forall 'a, 'b, 'd, 'f, 'g. ('g
//│   where
//│     'a <: 'b -> 'd -> 'f
//│     'b <: 'f -> 'g))
//│   where
//│     'a <: 'b -> 'd -> 'e
//│     'b <: 'e -> 'a))
//│   where
//│     'a <: 'b -> nothing -> 'c))
//│  = [Function: s]


def succ: (forall 'N. ('N -> 'N) -> ('N -> 'N)) -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ succ: (forall 'N. ('N -> 'N) -> 'N -> 'N) -> (forall 'M. ('M -> 'M) -> 'M -> 'M)
//│     = <missing implementation>


// * This one requires distributing the RHS forall to rigidify it earlier:

// * Failure comes from:
// | | | C ‹∀ 1. (α27'' -> ‹∀ 2. (α28''' -> ‹∀ 3. {(α29'''' -> α32'''') where: α27'' <: ((α28''',) -> α30''''), α28''' <: ((α31'''',) -> α32'''')}›)›)› <! (‹∀ 1. (('N95'' -> 'N95'') -> ('N95'' -> 'N95''))› -> ‹∀ 1. (('M96'' -> 'M96'') -> ('M96'' -> 'M96''))›)  PolymorphicType  FunctionType
// :d
// :e // works with quantif extrus
succ = s
//│ (nothing -> nothing -> 'a & 'a) -> (forall 'a, 'b, 'c. (('c -> 'a & 'b) -> (forall 'a, 'b, 'd, 'e. ('d -> (forall 'a, 'b, 'd, 'f, 'g. ('g
//│   where
//│     'a <: 'b -> 'd -> 'f
//│     'b <: 'f -> 'g))
//│   where
//│     'a <: 'b -> 'd -> 'e
//│     'b <: 'e -> 'a))
//│   where
//│     'a <: 'b -> nothing -> 'c))
//│   <:  succ:
//│ (forall 'N. ('N -> 'N) -> 'N -> 'N) -> (forall 'M. ('M -> 'M) -> 'M -> 'M)
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.39: 	succ = s
//│ ║        	^^^^^^^^
//│ ╟── type `‘M171` is not an instance of type `'M`
//│ ║  l.28: 	def succ: (forall 'N. ('N -> 'N) -> ('N -> 'N)) -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ║        	                                                           ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.28: 	def succ: (forall 'N. ('N -> 'N) -> ('N -> 'N)) -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ╙──      	                                                           ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.39: 	succ = s
//│ ║        	^^^^^^^^
//│ ╟── type `‘M192` is not an instance of type `'M`
//│ ║  l.28: 	def succ: (forall 'N. ('N -> 'N) -> ('N -> 'N)) -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ║        	                                                           ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.28: 	def succ: (forall 'N. ('N -> 'N) -> ('N -> 'N)) -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ║        	                                                           ^^
//│ ╟── from reference:
//│ ║  l.15: 	def s n f x = f (n f x)
//│ ╙──      	                     ^
//│     = [Function: s]


// * Manually distributing fixes the error:

def succ0: forall 'M. (forall 'N. ('N -> 'N) -> ('N -> 'N)) -> (('M -> 'M) -> ('M -> 'M))
//│ succ0: (forall 'N. ('N -> 'N) -> 'N -> 'N) -> ('M -> 'M) -> 'M -> 'M
//│      = <missing implementation>

succ0 = s
//│ (nothing -> nothing -> 'a & 'a) -> (forall 'a, 'b, 'c. (('c -> 'a & 'b) -> (forall 'a, 'b, 'd, 'e. ('d -> (forall 'a, 'b, 'd, 'f, 'g. ('g
//│   where
//│     'a <: 'b -> 'd -> 'f
//│     'b <: 'f -> 'g))
//│   where
//│     'a <: 'b -> 'd -> 'e
//│     'b <: 'e -> 'a))
//│   where
//│     'a <: 'b -> nothing -> 'c))
//│   <:  succ0:
//│ (forall 'N. ('N -> 'N) -> 'N -> 'N) -> ('M -> 'M) -> 'M -> 'M
//│      = [Function: s]



// * This does not help; we still need distrib. It works in MLF – do they have distrib?!
// :e // works with quantif extrus
def succ (n: (forall 'N. ('N -> 'N) -> ('N -> 'N))) = fun f -> fun x -> f (n f x)
//│ (forall 'N. ('N -> 'N) -> 'N -> 'N) -> (forall 'a, 'b, 'c. (('c -> anything & 'b) -> (forall 'a, 'b, 'd, 'e. ('d -> (forall 'a, 'b, 'd, 'f, 'g. ('g
//│   where
//│     'a <: 'b -> 'd -> 'f
//│     'b <: 'f -> 'g))
//│   where
//│     'a <: 'b -> 'd -> 'e
//│     'b <: 'e -> anything))
//│   where
//│     'a <: 'b -> nothing -> 'c))
//│   <:  succ:
//│ (forall 'N. ('N -> 'N) -> 'N -> 'N) -> (forall 'M. ('M -> 'M) -> 'M -> 'M)
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.99: 	def succ (n: (forall 'N. ('N -> 'N) -> ('N -> 'N))) = fun f -> fun x -> f (n f x)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘M405` is not an instance of type `'M`
//│ ║  l.28: 	def succ: (forall 'N. ('N -> 'N) -> ('N -> 'N)) -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ║        	                                                           ^^
//│ ╟── but it flows into quantified type variable with expected type `‘M`
//│ ║  l.99: 	def succ (n: (forall 'N. ('N -> 'N) -> ('N -> 'N))) = fun f -> fun x -> f (n f x)
//│ ║        	                     ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.28: 	def succ: (forall 'N. ('N -> 'N) -> ('N -> 'N)) -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ╙──      	                                                           ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.99: 	def succ (n: (forall 'N. ('N -> 'N) -> ('N -> 'N))) = fun f -> fun x -> f (n f x)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘M426` is not an instance of type `'M`
//│ ║  l.28: 	def succ: (forall 'N. ('N -> 'N) -> ('N -> 'N)) -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ║        	                                                           ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.28: 	def succ: (forall 'N. ('N -> 'N) -> ('N -> 'N)) -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ║        	                                                           ^^
//│ ╟── from reference:
//│ ║  l.99: 	def succ (n: (forall 'N. ('N -> 'N) -> ('N -> 'N))) = fun f -> fun x -> f (n f x)
//│ ╙──      	                                                                               ^
//│     = [Function: succ2]



// :d
n1 = s z
//│ n1: ('a -> anything & 'b) -> (forall 'c, 'b, 'd, 'e. ('d -> (forall 'c, 'b, 'd, 'f, 'g. ('g
//│   where
//│     'c <: 'b -> 'd -> 'f
//│     'b <: 'f -> 'g))
//│   where
//│     'c <: 'b -> 'd -> 'e
//│     'b <: 'e -> anything))
//│   where
//│     'c <: 'b -> nothing -> 'a
//│   = [Function (anonymous)]

n2 = s (s z)
//│ n2: ('a -> anything & 'b) -> (forall 'c, 'b, 'd, 'e. ('d -> (forall 'c, 'b, 'd, 'f, 'g. ('g
//│   where
//│     'c <: 'b -> 'd -> 'f
//│     'b <: 'f -> 'g))
//│   where
//│     'c <: 'b -> 'd -> 'e
//│     'b <: 'e -> anything))
//│   where
//│     'c <: 'b -> nothing -> 'a
//│   = [Function (anonymous)]

n3 = s (s (s z))
//│ n3: ('a -> anything & 'b) -> (forall 'c, 'b, 'd, 'e. ('d -> (forall 'c, 'b, 'd, 'f, 'g. ('g
//│   where
//│     'c <: 'b -> 'd -> 'f
//│     'b <: 'f -> 'g))
//│   where
//│     'c <: 'b -> 'd -> 'e
//│     'b <: 'e -> anything))
//│   where
//│     'c <: 'b -> nothing -> 'a
//│   = [Function (anonymous)]

// def wrap: 'WRA -> 'WRA
// def wrap: int -> {x:int}

// def wrap: 'a -> {x: 'a}
wrap x = { x }
//│ wrap: 'a -> {x: 'a}
//│     = [Function: wrap]

// :d
n1w = n1 wrap
//│ n1w: 'a -> (forall 'b, 'c, 'a, 'd, 'e. ('e
//│   where
//│     'b <: 'c -> 'a -> 'd
//│     'c <: 'd -> 'e))
//│   where
//│     'b <: 'c -> 'a -> 'f
//│     'c <: 'f -> anything
//│    = [Function (anonymous)]

// :d
n1w 0
//│ res: 'a
//│   where
//│     'b <: 'c -> 0 -> 'd
//│     'c <: 'd -> 'a
//│    = { x: 0 }

n1 wrap 0
//│ res: 'a
//│   where
//│     'b <: 'c -> 0 -> 'd
//│     'c <: 'd -> 'a
//│    = { x: 0 }

res.x + 1
//│ res: int
//│    = 1

n2 wrap 0
//│ res: 'a
//│   where
//│     'b <: 'c -> 0 -> 'd
//│     'c <: 'd -> 'a
//│    = { x: { x: 0 } }

res.x.x + 1
//│ res: int
//│    = 1

n3 wrap 0
//│ res: 'a
//│   where
//│     'b <: 'c -> 0 -> 'd
//│     'c <: 'd -> 'a
//│    = { x: { x: { x: 0 } } }

res.x.x.x + 1
//│ res: int
//│    = 1


// * With distributivity, it works!:
:DistributeForalls

succ = s
//│ (nothing -> nothing -> 'a & 'a) -> (forall 'a, 'b, 'c. (('c -> 'a & 'b) -> (forall 'a, 'b, 'd, 'e. ('d -> (forall 'a, 'b, 'd, 'f, 'g. ('g
//│   where
//│     'a <: 'b -> 'd -> 'f
//│     'b <: 'f -> 'g))
//│   where
//│     'a <: 'b -> 'd -> 'e
//│     'b <: 'e -> 'a))
//│   where
//│     'a <: 'b -> nothing -> 'c))
//│   <:  succ:
//│ (forall 'N. ('N -> 'N) -> 'N -> 'N) -> (forall 'M. ('M -> 'M) -> 'M -> 'M)
//│     = [Function: s]


type ChurchInt = forall 'N. ('N -> 'N) -> ('N -> 'N)
//│ Defined type alias ChurchInt

:stats
z: ChurchInt
//│ res: ChurchInt
//│    = [Function: z]
//│ constrain calls  : 15
//│ annoying  calls  : 0
//│ subtyping calls  : 0

:stats
s: ChurchInt -> ChurchInt
//│ res: ChurchInt -> ChurchInt
//│    = [Function: s]
//│ constrain calls  : 165
//│ annoying  calls  : 0
//│ subtyping calls  : 0





