:GeneralizeCurriedFunctions
:NoRecursiveTypes
:DontDistributeForalls
// :ArgGen


// =============== Sec 2 ===============
let id x = x in id
(id 3, id false)
//│ res: 'a -> 'a
//│    = [Function (anonymous)]
//│ res: (3, false,)
//│    = [ 3, false ]

let poly f = (f 1, f true) in poly
//│ res: (true -> 'a & 1 -> 'b & 'c) -> ('b, 'a,)
//│    = [Function (anonymous)]
let poly f = let y = f in (y 1, y true) in poly
//│ res: (true -> 'a & 1 -> 'b & 'c) -> ('b, 'a,)
//│    = [Function (anonymous)]

// Altered from
// let poly f = let y = f {forall 'a. 'a -> 'a} in (y 1, y true)
def poly = fun (f : (forall 'a. 'a -> 'a)) -> (f 1, f true)
//│ poly: (forall 'a. 'a -> 'a) -> (1 | 'b, true | 'c,)
//│     = [Function: poly]

def app : ('a -> 'b) -> 'a -> 'b
//│ app: ('a -> 'b) -> 'a -> 'b
//│    = <missing implementation>

def revapp : 'a -> ('a -> 'b) -> 'b
//│ revapp: 'a -> ('a -> 'b) -> 'b
//│       = <missing implementation>

app poly (fun x -> x)
//│ res: (1, true,)
//│    = <no result>
//│      app is not implemented

revapp (fun x -> x) poly
//│ res: (1, true,)
//│    = <no result>
//│      revapp is not implemented

class List[A]
  method Get: A
//│ Defined class List[+A]
//│ Declared List.Get: List['A] -> 'A

def single : 'a -> List['a]
//│ single: 'a -> List['a]
//│       = <missing implementation>

def ids = single (fun x -> x)
//│ ids: List[forall 'a. 'a -> 'a]
//│    = <no result>
//│      single is not implemented

single ids
//│ res: List[List[forall 'a. 'a -> 'a]]
//│    = <no result>
//│      single is not implemented

def map: ('a -> 'b) -> List['a] -> List['b]
def head: List['a] -> 'a
//│ map: ('a -> 'b) -> List['a] -> List['b]
//│    = <missing implementation>
//│ head: List['a] -> 'a
//│     = <missing implementation>

map head (single ids)
//│ res: List[forall 'a. 'a -> 'a]
//│    = <no result>
//│      map is not implemented
app (map head) (single ids)
//│ res: List[forall 'a. 'a -> 'a]
//│    = <no result>
//│      app is not implemented

def fst: forall 'a 'b. (('a, 'b),) -> 'a
def fst ((x, _),) = x
def snd: forall 'a 'b. (('a, 'b),) -> 'b
def snd ((_, x),) = x
//│ fst: ('a, 'b,) -> 'a
//│    = <missing implementation>
//│ ('a, 'b,) -> 'a
//│   <:  fst:
//│ ('a, 'b,) -> 'a
//│    = [Function: fst]
//│ snd: ('a, 'b,) -> 'b
//│    = <missing implementation>
//│ ('a, 'b,) -> 'b
//│   <:  snd:
//│ ('a, 'b,) -> 'b
//│    = [Function: snd]

// def pack : 
def pack t = fun f -> f t
//│ pack: 'a -> (forall 'b, 'c. ('a -> 'b & 'c) -> 'b)
//│     = [Function: pack]

def open p t = p t
//│ open: ('a -> 'b & 'c) -> (forall 'd, 'e. ('a & 'd) -> ('e | 'b))
//│     = [Function: open]

// Altered from
// let f = {exists 'a. 'a * ('a -> 'a) * ('a -> int)} (0, (fun x -> x + 1) , (fun x -> x));
// open {exists 'a. a * ('a -> 'a) * ('a -> int)} g = f in (snd (snd g)) (fst g);;
let f = pack ((0, (fun x -> x + 1, fun x -> x),),) in
  open f (fun x -> (snd (snd x)) (fst x))
//│ res: 0
//│    = 0


// =============== Sec 3 ===============

def run : (forall 'g. 'g -> 'a) -> 'a
//│ run: (forall 'g. 'g -> 'a) -> 'a
//│    = <missing implementation>

def e : 'g -> int
//│ e: anything -> int
//│  = <missing implementation>

// * Notice the effect of distributivity
(fun (f : (forall 'g. int -> 'g)) -> f 1)
//│ res: (forall 'g. int -> 'g) -> nothing
//│    = [Function: res]

run e
//│ res: int
//│    = <no result>
//│      run is not implemented

fun (x : (forall 'a. 'a -> 'a)) -> x
//│ res: (forall 'a. 'a -> 'a) -> (forall 'a. 'a -> 'a)
//│    = [Function: res]


let abstype = pack ((id, id),) in
  let module = pack ((id, app),) in
  open abstype (fun x -> (snd x) (fst x 1))
//│ res: 1
//│    = <no result>
//│      app is not implemented

let abstype = pack ((id, id),) in
  let module = pack ((id, app),) in
  open module (fun x -> (snd x) (fun a -> ((a, a),)) (fst x 1))
//│ res: ((1, 1,),)
//│    = <no result>
//│      app is not implemented

:escape
def Math: nothing
//│ Math: nothing
//│     = <missing implementation>

def div: int -> int -> int
def div a b = Math.trunc(a/b)
//│ div: int -> int -> int
//│    = <missing implementation>
//│ (number & 'a & 'b) -> (forall 'b, 'c. (number & 'b) -> 'c)
//│   <:  div:
//│ int -> int -> int
//│    = [Function: div1]

def mod = let rec mod a b = if a < b then a else mod (a - b) b in mod
//│ mod: (int & 'a & 'b) -> (forall 'c, 'd. ('c & int & 'a) -> (int | 'b | 'e | 'd)) | 'mod
//│    = [Function: mod]


// ********** SMALL ARRAY EXAMPLE **********

// exists r. forall b. Sig[a, r, b]
// (forall r. (forall b. Sig[a, r, b]) -> y) -> y

:GeneralizeCurriedFunctions
:DistributeForalls
// :ArgGen

type ExSmall = (forall 'r. ('a -> 'r, 'r -> int -> 'a) -> 'y) -> 'y
//│ Defined type alias ExSmall

def sbase : ExSmall
def sbase f = f (fun a -> a, fun r -> fun (i : int) -> r)
//│ sbase: ExSmall
//│      = <missing implementation>
//│ ((forall 'a. 'a -> 'a, forall 'b. 'b -> int -> 'b,) -> 'c & 'd) -> 'c
//│   <:  sbase:
//│ ExSmall
//│      = [Function: sbase]

def sstep : ExSmall -> ExSmall
//│ sstep: ExSmall -> ExSmall
//│      = <missing implementation>

:e // * Since "sound extrusion"
def sstep = fun xx -> xx (fun (xinit, xsub) -> 
  let init a = (xinit a, xinit a) in
  let sub ((r1, r2)) i =
    if mod i 2 == 0
    then xsub r1 (div i 2)
    else xsub r2 (div i 2) in
  fun f -> f (init, sub))
//│ ((forall 'a, 'b, 'c, 'd, 'e, 'f, 'g, 'h, 'i, 'j, 'k, 'l, 'm, 'n. ('i -> 'c & 'l -> 'h & 'g, 'd -> ((int | 'n | 'k) -> 'a & 'e) & 'f -> ((int | 'n) -> 'j & 'm) & 'b,) -> (forall 'o, 'p. ((forall 'q, 'r, 's. ('i & 'l & 's) -> ('q | 'h, 'r | 'c,), forall 't, 'u. ('f & 't, 'd & 'u,) -> (forall 'v, 'w, 'x. (int & 'v & 'w) -> ('j | 'a | 'x)),) -> 'o & 'p) -> 'o)) -> 'y & 'z) -> 'y
//│   <:  sstep:
//│ ExSmall -> ExSmall
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.200: 	def sstep = fun xx -> xx (fun (xinit, xsub) -> 
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.201: 	  let init a = (xinit a, xinit a) in
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.202: 	  let sub ((r1, r2)) i =
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.203: 	    if mod i 2 == 0
//│ ║         	^^^^^^^^^^^^^^^^^^^
//│ ║  l.204: 	    then xsub r1 (div i 2)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.205: 	    else xsub r2 (div i 2) in
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.206: 	  fun f -> f (init, sub))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.183: 	type ExSmall = (forall 'r. ('a -> 'r, 'r -> int -> 'a) -> 'y) -> 'y
//│ ║         	                       ^^
//│ ╟── but it flows into application with expected type `nothing`
//│ ║  l.201: 	  let init a = (xinit a, xinit a) in
//│ ║         	                ^^^^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.183: 	type ExSmall = (forall 'r. ('a -> 'r, 'r -> int -> 'a) -> 'y) -> 'y
//│ ║         	                       ^^
//│ ╟── from reference:
//│ ║  l.204: 	    then xsub r1 (div i 2)
//│ ╙──       	              ^^
//│      = [Function: sstep]

// * Alternative, with an annotation on `f`:
def sstep = fun xx -> xx (fun (xinit, xsub) -> 
  let init a = (xinit a, xinit a) in
  let sub ((r1, r2)) i =
    if mod i 2 == 0
    then xsub r1 (div i 2)
    else xsub r2 (div i 2) in
  fun (f : forall 'r. ('a -> 'r, 'r -> int -> 'a) -> 'y) -> f (init, sub))
//│ ((forall 'b, 'c, 'd, 'e, 'f, 'g, 'h, 'i, 'j, 'k, 'l, 'm, 'n, 'o. ((forall 'p. 'o | 'f | 'j | 'p) -> ('k & 'g) & (forall 'p. 'd | 'f | 'j | 'p) -> ('b & 'm) & 'h, 'g -> ((int | 'e | 'n) -> 'j & 'i) & 'm -> ((int | 'e) -> 'f & 'l) & 'c,) -> (forall 'y, 'q, 'a, 's. (forall 'r. (('o & 'd & 'a & 's) -> 'r, 'r -> int -> (forall 'p. 'a | 'f | 'j | 'p),) -> ('y & 'q)) -> 'q)) -> 't & 'u) -> 't
//│   <:  sstep:
//│ ExSmall -> ExSmall
//│      = [Function: sstep1]

let mkSArray n = if n == 0 then sbase else sstep (sstep sbase) in
  mkSArray 1 (fun (xinit, xsub) -> xsub (xinit 2) 2)
//│ res: 2
//│    = 2

def mkSArray : int -> ExSmall
rec def mkSArray n = if n == 0 then sbase else sstep (mkSArray (n - 1))
//│ mkSArray: int -> ExSmall
//│         = <missing implementation>
//│ (int & 'a) -> (ExSmall | 'b)
//│   <:  mkSArray:
//│ int -> ExSmall
//│         = [Function: mkSArray]

mkSArray 2 (fun (xinit, xsub) -> xinit 2)
//│ res: anything
//│    = [ [ 2, 2 ], [ 2, 2 ] ]

ma2 = mkSArray 2
//│ ma2: ExSmall
//│    = [Function (anonymous)]

a2 = ma2 (fun (xinit, xsub) -> xsub (xinit true) 0)
//│ a2: true
//│   = true

not a2
//│ res: bool
//│    = false

a2 = ma2 (fun (xinit, xsub) -> xinit true)
//│ a2: anything
//│   = [ [ true, true ], [ true, true ] ]

:e // This is expected – xinit returns a value of locally-quantified type 'r
a2[0]
//│ ╔══[ERROR] Type mismatch in array access:
//│ ║  l.287: 	a2[0]
//│ ║         	^^^^^
//│ ╟── type `anything` does not match type `Array[?a]`
//│ ║  l.183: 	type ExSmall = (forall 'r. ('a -> 'r, 'r -> int -> 'a) -> 'y) -> 'y
//│ ║         	                       ^^
//│ ╟── but it flows into reference with expected type `Array[?b]`
//│ ║  l.287: 	a2[0]
//│ ╙──       	^^
//│ res: error | undefined
//│    = [ true, true ]

// * Notice the (safely-)extruded skolem for the locally-quantified 'r
ma2 (fun (xinit, xsub) -> let tmp = xinit true in (tmp, tmp))
//│ res: (anything, anything,)
//│    = [
//│        [ [ true, true ], [ true, true ] ],
//│        [ [ true, true ], [ true, true ] ]
//│      ]

ma1 = mkSArray 1
//│ ma1: ExSmall
//│    = [Function (anonymous)]

ma1 (fun (xinit, xsub) -> xinit true)
//│ res: anything
//│    = [ true, true ]

ma1 (fun (xinit, xsub) -> xsub (xinit true) 0)
//│ res: true
//│    = true


// * Trying to do something unsafe now!

:e
ma1 (fun (xinit1, xsub1) -> ma2 (fun (xinit2, xsub2) -> xsub2 (xinit1 true) 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.324: 	ma1 (fun (xinit1, xsub1) -> ma2 (fun (xinit2, xsub2) -> xsub2 (xinit1 true) 0))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘r_1356` does not match type `nothing`
//│ ║  l.183: 	type ExSmall = (forall 'r. ('a -> 'r, 'r -> int -> 'a) -> 'y) -> 'y
//│ ║         	                       ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.183: 	type ExSmall = (forall 'r. ('a -> 'r, 'r -> int -> 'a) -> 'y) -> 'y
//│ ║         	                       ^^
//│ ╟── from application:
//│ ║  l.324: 	ma1 (fun (xinit1, xsub1) -> ma2 (fun (xinit2, xsub2) -> xsub2 (xinit1 true) 0))
//│ ╙──       	                                                               ^^^^^^^^^^^
//│ res: error
//│ Runtime error:
//│   TypeError: boolean true is not iterable (cannot read property Symbol(Symbol.iterator))

:e
ma1 (fun (xinit1, xsub1) -> ma2 (fun (xinit2, xsub2) -> xsub1 (xinit2 true) 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.342: 	ma1 (fun (xinit1, xsub1) -> ma2 (fun (xinit2, xsub2) -> xsub1 (xinit2 true) 0))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` is not an instance of type `'r_1398`
//│ ║  l.183: 	type ExSmall = (forall 'r. ('a -> 'r, 'r -> int -> 'a) -> 'y) -> 'y
//│ ║         	                       ^^
//│ ╟── but it flows into application with expected type `‘r_1398`
//│ ║  l.342: 	ma1 (fun (xinit1, xsub1) -> ma2 (fun (xinit2, xsub2) -> xsub1 (xinit2 true) 0))
//│ ║         	                                                               ^^^^^^^^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.183: 	type ExSmall = (forall 'r. ('a -> 'r, 'r -> int -> 'a) -> 'y) -> 'y
//│ ╙──       	                       ^^
//│ res: error
//│    = [ true, true ]


// ******** ORIGINAL ARRAY EXAMPLE ********

type Sig[a, r, b] = (((a -> r, r -> int -> a), r -> int -> a -> r), (a -> b -> b) -> b -> r -> b)
type ExSig = (forall 'r. (forall 'b. ((('a -> 'r, 'r -> int -> 'a), 'r -> int -> 'a -> 'r), ('a -> 'b -> 'b) -> 'b -> 'r -> 'b)) -> 'y) -> 'y
//│ Defined type alias Sig[=a, =r, =b]
//│ Defined type alias ExSig

// :e // works after fixing freshening levels
def base : ExSig
def base f = f ((((fun a -> a, fun r -> fun (i : int) -> r), fun r -> fun (i : int) -> fun a -> a), fun f -> fun b -> fun r -> f r b),)
//│ base: ExSig
//│     = <missing implementation>
//│ ((((forall 'a. 'a -> 'a, forall 'b. 'b -> int -> 'b,), forall 'c. 'c -> int -> (forall 'd. 'd -> 'd),), forall 'e, 'f, 'g, 'h, 'i. ('i -> ('g -> 'e & 'f) & 'h) -> (forall 'j. ('g & 'j) -> (forall 'k, 'l. ('i & 'k) -> ('l | 'e))),) -> 'm & 'n) -> 'm
//│   <:  base:
//│ ExSig
//│     = [Function: base]

def step : ExSig -> ExSig
//│ step: ExSig -> ExSig
//│     = <missing implementation>

// * The problem here is due to the polymorphism of the `fold` function, which is defined on the outside of the tuple.
// * The reproduction in `QML_exist_Records.mls`, where `fold` is quantified on the inside, does not have this problem.
// * So I suppose we could avoid the problem by pushing (distributing) the quantification inside the tuple, which we do not yet support.
:e
def step = fun xx -> xx (fun ((((xinit, xsub), xupdate), xfold),) ->
  let init a = (xinit a, xinit a) in
  let sub r i =
    if mod i 2 == 0
    then xsub (fst r) (div i 2)
    else xsub (snd r) (div i 2) in
  let update r i a =
    if mod i 2 == 0
    then (xupdate (fst r) (div i 2) a, snd r)
    else (fst r, xupdate (snd r) (div i 2) a) in
  let fold f b r = xfold f (xfold f b (fst r)) (snd r) in
    fun f -> f ((((init, sub), update), fold),) )
//│ ((forall 'c, 'd, 'e, 'f, 'g, 'h, 'i, 'j, 'k, 'l, 'm, 'n, 'o, 'p, 'q, 'r, 's, 't, 'u, 'v, 'b, 'w, 'x, 'y, 'z, 'a1, 'b1, 'c1, 'd1, 'e1, 'f1, 'g1, 'a, 'h1, 'i1, 'a0, 'j1, 'k1, 'l1, 'b0, 'm1, 'n1, 'o1, 'p1. ((('g -> 'm1 & 'i1 -> 'f1 & 'i, ('b | 'n1) -> ((int | 'j1 | 'v) -> 'h & 'o) & ('a | 'd) -> ((int | 'a1 | 'v) -> 'k & 'y) & 'r,), ('b0 | 'u) -> ((int | 'v | 'p1) -> ('n -> 'b1 & 'f) & 'm) & ('a0 | 'w) -> ((int | 'v) -> ('e1 -> 'l & 'q) & 'c) & 'z,), 'd1 -> ('x -> ('s -> 'l1 & 'g1) & 'c1) & 'e -> (('l1 | 'o1) -> ('k1 -> 't & 'j) & 'p) & 'h1,) -> (forall 'q1, 'r1. ((((forall 's1, 't1, 'u1. ('g & 'i1 & 't1) -> ('u1 | 'f1, 's1 | 'm1,), forall 'a1, 'v1, 'b1, 'b2, 'a2. (('a & 'a1 & 'a2, 'b & 'b2 & 'b1,) & 'v1) -> (forall 'w1, 'x1, 'y1. (int & 'w1 & 'x1) -> ('k | 'h | 'y1)),), forall 'b3, 'a3, 'b4, 'a4, 'z1, 'b5, 'a5, 'b6, 'a6. (('a0 & 'a4 & 'a3 & 'a6 & 'a5, 'b0 & 'b4 & 'b3 & 'b6 & 'b5,) & 'z1) -> (forall 'a2. (int & 'a2) -> (forall 'b2, 'c2, 'd2, 'e2, 'f2, 'g2. ('n & 'e1 & 'c2) -> (('a3 | 'd2 | 'l | 'e2, 'b6 | 'g2 | 'f2 | 'b1,) | 'b2))),), forall 'h2. ('d1 & 'e & 'h2) -> (forall 'i2. ('x & 'i2) -> (forall 'j2, 'k2, 'b7, 'a7, 'l2, 'a8, 'b8, 'm2. (('s & 'a8 & 'a7 & 'j2, 'k1 & 'b8 & 'l2 & 'b7,) & 'm2) -> ('k2 | 't))),) -> 'q1 & 'r1) -> 'q1)) -> 'n2 & 'o2) -> 'n2
//│   <:  step:
//│ ExSig -> ExSig
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.384: 	def step = fun xx -> xx (fun ((((xinit, xsub), xupdate), xfold),) ->
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.385: 	  let init a = (xinit a, xinit a) in
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.386: 	  let sub r i =
//│ ║         	^^^^^^^^^^^^^^^
//│ ║  l.387: 	    if mod i 2 == 0
//│ ║         	^^^^^^^^^^^^^^^^^^^
//│ ║  l.388: 	    then xsub (fst r) (div i 2)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.389: 	    else xsub (snd r) (div i 2) in
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.390: 	  let update r i a =
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.391: 	    if mod i 2 == 0
//│ ║         	^^^^^^^^^^^^^^^^^^^
//│ ║  l.392: 	    then (xupdate (fst r) (div i 2) a, snd r)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.393: 	    else (fst r, xupdate (snd r) (div i 2) a) in
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.394: 	  let fold f b r = xfold f (xfold f b (fst r)) (snd r) in
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.395: 	    fun f -> f ((((init, sub), update), fold),) )
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.362: 	type ExSig = (forall 'r. (forall 'b. ((('a -> 'r, 'r -> int -> 'a), 'r -> int -> 'a -> 'r), ('a -> 'b -> 'b) -> 'b -> 'r -> 'b)) -> 'y) -> 'y
//│ ║         	                     ^^
//│ ╟── but it flows into application with expected type `nothing`
//│ ║  l.385: 	  let init a = (xinit a, xinit a) in
//│ ║         	                         ^^^^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.362: 	type ExSig = (forall 'r. (forall 'b. ((('a -> 'r, 'r -> int -> 'a), 'r -> int -> 'a -> 'r), ('a -> 'b -> 'b) -> 'b -> 'r -> 'b)) -> 'y) -> 'y
//│ ║         	                     ^^
//│ ╟── from quantified type variable:
//│ ║  l.83: 	def snd: forall 'a 'b. (('a, 'b),) -> 'b
//│ ╙──      	                   ^^
//│     = [Function: step]

let mkArray n = if n == 0 then base else step base in
  mkArray 1 (fun ((((xinit, xsub), xupdate), xfold),) -> xinit 2)
//│ res: anything
//│    = [ 2, 2 ]

def mkArray : int -> ExSig
//│ mkArray: int -> ExSig
//│        = <missing implementation>

rec def mkArray n = if n == 0 then base else step (mkArray (n - 1))
//│ (int & 'a) -> (ExSig | 'b)
//│   <:  mkArray:
//│ int -> ExSig
//│        = [Function: mkArray]

mkArray 3 (fun ((((xinit, xsub), xupdate), xfold),) -> xinit 2)
//│ res: anything
//│    = [ [ [ 2, 2 ], [ 2, 2 ] ], [ [ 2, 2 ], [ 2, 2 ] ] ]

:e
res 0
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.458: 	res 0
//│ ║         	^^^^^
//│ ╟── type `anything` is not a function
//│ ║  l.362: 	type ExSig = (forall 'r. (forall 'b. ((('a -> 'r, 'r -> int -> 'a), 'r -> int -> 'a -> 'r), ('a -> 'b -> 'b) -> 'b -> 'r -> 'b)) -> 'y) -> 'y
//│ ║         	                     ^^
//│ ╟── but it flows into reference with expected type `0 -> ?a`
//│ ║  l.458: 	res 0
//│ ╙──       	^^^
//│ res: error
//│ Runtime error:
//│   TypeError: res is not a function


// =============== Sec 7 ===============

def choose: 'a -> 'a -> 'a
//│ choose: 'a -> 'a -> 'a
//│       = <missing implementation>

choose (head ids)
//│ res: 'a -> (forall 'b. 'a | 'b -> 'b)
//│    = <no result>
//│      choose is not implemented

