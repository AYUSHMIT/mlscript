:NoJS

// TODO investigate why this makes many tests fail:
:GeneralizeCurriedFunctions
:NoRecursiveTypes


// ------------ Dummy classes to represent the types in the examples ------------

class List[a]
  method Get: a
//│ Defined class List[+a]
//│ Declared List.Get: List['a] -> 'a

// Used to represent `::`
def cons: 'a -> List['a] -> List['a]
//│ cons: 'a -> List['a] -> List['a]

// Used to represent `[]`
def nil: List['a]
//│ nil: List[nothing]

def concat: string -> List[string] -> string
//│ concat: string -> List[string] -> string


// ------------ Examples ------------


// (* s  starts a sequence, cps style *)
def s k = k () nil
//│ s: (() -> (List[nothing] -> 'a & 'b) & 'c) -> 'a

def insert v () acu k = k () (cons v acu)
//│ insert: 'b -> () -> (forall 'c. 'c -> (forall 'b, 'd, 'e, 'f, 'a, 'g, 'c. ((() -> ((List['a | 'b] | 'e) -> 'd & 'f) & 'g) -> 'd
//│   where
//│     'c <: List['a])))

// (* x  inserts "x" in the acu *)
def x () = insert "x" ()
//│ x: () -> (forall 'b. 'b -> (forall 'c, 'b, 'd, 'a, 'e, 'f, 'g. ((() -> ((List["x" | 'a | 'e] | 'g) -> 'd & 'c) & 'f) -> 'd
//│   where
//│     'b <: List['a])) | 'h)

// (* We call x a 'token', in the sequence. *)

// (* e  ends the sequence. It builds a token that can be inserted in another sequence or that can be printed. *)
def e () acu = insert (concat "," acu)
//│ e: () -> (forall 'b, 'c. (List[string] & 'b) -> (() -> (forall 'd. 'd -> (forall 'e, 'f, 'd, 'a, 'g, 'h, 'i. ((() -> ((List['a | string | 'g] | 'i) -> 'f & 'e) & 'h) -> 'f
//│   where
//│     'd <: List['a]))) | 'c))


// (* Prints a token *)
def print t = t () nil (fun () -> fun r -> log (concat "," r))
//│ print: (() -> (List['a] -> ((() -> (forall 'a, 'b. (List[string] & 'b) -> (unit | 'a))) -> 'c & 'd) & 'e) & 'f) -> 'c

// Added by me:
// :e // FIXME? refreshing-extr
s x x (s x x e)
//│ res: (() -> ((List['a | string] | 'b) -> 'c & 'd) & 'e) -> 'c
//│   where
//│     List["x"] <: List['a]


// :e // FIXME? refreshing-extr
def test8  = (s x x (s x x e) x (s x x x e) e)
//│ test8: () -> (forall 'b. 'b -> (forall 'c, 'a, 'd, 'e, 'f, 'b. ((() -> ((List['a | string] | 'd) -> 'e & 'f) & 'c) -> 'e
//│   where
//│     'b <: List['a])))

print test8


// :e // FIXME — works with :RecursiveTypes // Works since inconsistent constrained types...
def test14 = (s x x x x x x x x x x x x x x e)
//│ test14: () -> (forall 'b. 'b -> (forall 'c, 'a, 'd, 'b, 'e, 'f. ((() -> ((List['a | string] | 'd) -> 'e & 'f) & 'c) -> 'e
//│   where
//│     'b <: List['a])))

// :e // FIXME — works with :RecursiveTypes // Works since inconsistent constrained types...
def test16 = (s x x x x x x x x x x x x x x x x e)
//│ test16: () -> (forall 'b. 'b -> (forall 'c, 'a, 'd, 'e, 'f, 'b. ((() -> ((List['a | string] | 'd) -> 'e & 'c) & 'f) -> 'e
//│   where
//│     'b <: List['a])))

// (* This is too much for the type-checker. *)
// :e // FIXME — works with :RecursiveTypes // Works since inconsistent constrained types...
def test18 = (s x x x x x x x x x x x x x x x x x x e)
//│ test18: () -> (forall 'b. 'b -> (forall 'b, 'c, 'a, 'd, 'e, 'f. ((() -> ((List['a | string] | 'e) -> 'f & 'd) & 'c) -> 'f
//│   where
//│     'b <: List['a])))

:RecursiveTypes
def test18 = (s x x x x x x x x x x x x x x x x x x e)
//│ test18: () -> (forall 'b. 'b -> (forall 'a, 'c, 'd, 'e, 'f, 'b. ((() -> ((List['a | string] | 'c) -> 'e & 'd) & 'f) -> 'e
//│   where
//│     'b <: List['a])))
:NoRecursiveTypes


// (* A function that receives a token *)
def f t = (s x x t x x e)
//│ f: (() -> ((List["x" | 'a | 'b | 'c] | 'd) -> ((forall 'e. () -> (forall 'f. 'f -> (forall 'g, 'b, 'f, 'h, 'a0, 'i, 'j. ((() -> ((List["x" | 'a0 | 'b] | 'g) -> 'j & 'h) & 'i) -> 'j
//│   where
//│     'f <: List['a0])) | 'e)) -> ((forall 'e. () -> (forall 'f. 'f -> (forall 'g, 'b, 'f, 'h, 'a0, 'i, 'j. ((() -> ((List["x" | 'a0 | 'b] | 'g) -> 'j & 'h) & 'i) -> 'j
//│   where
//│     'f <: List['a0])) | 'e)) -> ((() -> (forall 'k, 'l. (List[string] & 'k) -> (() -> (forall 'm. 'm -> (forall 'm, 'a1, 'n, 'o, 'p, 'q, 'r. ((() -> ((List['a1 | string | 'r] | 'q) -> 'p & 'o) & 'n) -> 'p
//│   where
//│     'm <: List['a1]))) | 'l))) -> 's & 't) & 'u) & 'v & 'w) & 'x) & 'y & 'z) -> 's

// (* If the token is used twice, we must reveive two arguments *)
def g t1 t2 = (s x x t1 x (s x t2 x e) e)
//│ g: 'b -> (forall 'c, 'd, 'e, 'f, 'g, 'h, 'i, 'a, 'j, 'k, 'l, 'm, 'n, 'o, 'p, 'b, 'q, 'r, 's, 'a0. ((() -> ((List["x" | 'a | 'g] | 'f) -> ((forall 't. () -> (forall 'u. 'u -> (forall 'v, 'w, 'x, 'u, 'g, 'y, 'z, 'a1. ((() -> ((List["x" | 'a1 | 'g | 'z] | 'w) -> 'x & 'v) & 'y) -> 'x
//│   where
//│     'u <: List['a1])) | 't)) -> ((() -> (forall 'a1, 'b1. (List[string] & 'a1) -> (() -> (forall 'c1. 'c1 -> (forall 'd1, 'e1, 'f1, 'a2, 'g1, 'c1, 'h1. ((() -> ((List['a2 | string | 'e1] | 'g1) -> 'h1 & 'd1) & 'f1) -> 'h1
//│   where
//│     'c1 <: List['a2]))) | 'b1))) -> 'p & 'r) & 'n & 's) & 'h) & 'm & 'q) -> 'i
//│   where
//│     'b <: () -> ((List["x" | 'a0 | 'g | 'k] | 'c) -> ((forall 't. () -> (forall 'u. 'u -> (forall 'v, 'w, 'x, 'u, 'g, 'y, 'z, 'a1. ((() -> ((List["x" | 'a1 | 'g | 'z] | 'w) -> 'x & 'v) & 'y) -> 'x
//│   where
//│     'u <: List['a1])) | 't)) -> ('p -> ((() -> (forall 'a1, 'b1. (List[string] & 'a1) -> (() -> (forall 'c1. 'c1 -> (forall 'd1, 'e1, 'f1, 'a2, 'g1, 'c1, 'h1. ((() -> ((List['a2 | string | 'e1] | 'g1) -> 'h1 & 'd1) & 'f1) -> 'h1
//│   where
//│     'c1 <: List['a2]))) | 'b1))) -> 'i & 'l) & 'e) & 'd & 'o) & 'j)))

// (* This does not type. It requires first-class polymorphism. *)
def h t = g t t
//│ h: (() -> ((List["x" | 'a | 'b | 'c] | 'd) -> ((forall 'e. () -> (forall 'f. 'f -> (forall 'g, 'f, 'h, 'i, 'j, 'a0, 'c, 'k. ((() -> ((List["x" | 'a0 | 'c | 'h] | 'k) -> 'j & 'g) & 'i) -> 'j
//│   where
//│     'f <: List['a0])) | 'e)) -> ((() -> (forall 'l, 'm. (List[string] & 'l) -> (() -> (forall 'n. 'n -> (forall 'o, 'n, 'p, 'q, 'a1, 'r, 's. ((() -> ((List['a1 | string | 'p] | 's) -> 'r & 'q) & 'o) -> 'r
//│   where
//│     'n <: List['a1]))) | 'm))) -> 't & 'u) & 'v & 'w) & 'x) & () -> ((List["x" | 'a2 | 'c] | 'y) -> ((forall 'e. () -> (forall 'f. 'f -> (forall 'g, 'f, 'h, 'i, 'j, 'a0, 'c, 'k. ((() -> ((List["x" | 'a0 | 'c | 'h] | 'k) -> 'j & 'g) & 'i) -> 'j
//│   where
//│     'f <: List['a0])) | 'e)) -> ('t -> ((() -> (forall 'l, 'm. (List[string] & 'l) -> (() -> (forall 'n. 'n -> (forall 'o, 'n, 'p, 'q, 'a1, 'r, 's. ((() -> ((List['a1 | string | 'p] | 's) -> 'r & 'q) & 'o) -> 'r
//│   where
//│     'n <: List['a1]))) | 'm))) -> ('z & 'a1) & 'b1) & 'c1) & 'd1 & 'e1) & 'f1) & 'g1 & 'h1 & 'i1 & 'j1) -> 'a1

