:NewParser

:escape
// You can push debug messages to this magic array.
let Array: { from: anything => { push: anything => anything, join: string => string } }
let _Array = Array
let logs: { push: anything => anything, join: string => string } = _Array.from([])
let debug: anything => anything = x => logs.push(x)
fun showDebug = logs.join("\n")
//│ Array: {from: anything -> {join: string -> string, push: anything -> anything}}
//│      = <missing implementation>
//│ _Array: {from: anything -> {join: string -> string, push: anything -> anything}}
//│       = [Function: Array]
//│ logs: {join: string -> string, push: anything -> anything}
//│     = []
//│ debug: anything -> anything
//│      = [Function: debug]
//│ showDebug: string
//│          = [Function: showDebug]

fun concat2(a, b) = concat(a)(b)
fun concat3(a, b, c) = concat2(a, concat2(b, c))
fun concat4(a, b, c, d) = concat2(a, concat3(b, c, d))
fun concat5(a, b, c, d, e) = concat2(a, concat4(b, c, d, e))
fun concat6(a, b, c, d, e, f) = concat2(a, concat5(b, c, d, e, f))
fun concat7(a, b, c, d, e, f, g) = concat2(a, concat6(b, c, d, e, f, g))
fun concat8(a, b, c, d, e, f, g, h) = concat2(a, concat7(b, c, d, e, f, g, h))
fun par(a) = concat3("(", a, ")")
//│ concat2: (string, string,) -> string
//│        = [Function: concat2]
//│ concat3: (string, string, string,) -> string
//│        = [Function: concat3]
//│ concat4: (string, string, string, string,) -> string
//│        = [Function: concat4]
//│ concat5: (string, string, string, string, string,) -> string
//│        = [Function: concat5]
//│ concat6: (string, string, string, string, string, string,) -> string
//│        = [Function: concat6]
//│ concat7: (string, string, string, string, string, string, string,) -> string
//│        = [Function: concat7]
//│ concat8: (string, string, string, string, string, string, string, string,) -> string
//│        = [Function: concat8]
//│ par: string -> string
//│    = [Function: par]

:escape
let String: nothing
let makeString: anything => { length: int, charCodeAt: int => int } = String
let StringInstance: { fromCharCode: int => string } = String
//│ String: nothing
//│       = <missing implementation>
//│ makeString: anything -> {charCodeAt: int -> int, length: int}
//│           = [Function: String]
//│ StringInstance: {fromCharCode: int -> string}
//│               = [Function: String]

fun fromCharCode(n) = StringInstance.fromCharCode(n)
fun stringCharCodeAt(s, i) = makeString(s).charCodeAt(i)
fun stringLength(s) = makeString(s).length
//│ fromCharCode: int -> string
//│             = [Function: fromCharCode]
//│ stringCharCodeAt: (anything, int,) -> int
//│                 = [Function: stringCharCodeAt]
//│ stringLength: anything -> int
//│             = [Function: stringLength]

class Option
class Some(value): Option
class None(): Option
//│ Defined class Option
//│ Defined class Some
//│ Defined class None
//│ Option: () -> Option
//│       = [Function: Option1]
//│ Some: 'value -> (Some with {value: 'value})
//│     = [Function: Some1]
//│ None: () -> None
//│     = [Function: None1]

class List
class Cons(head, tail): List
class Nil(): List
//│ Defined class List
//│ Defined class Cons
//│ Defined class Nil
//│ List: () -> List
//│     = [Function: List1]
//│ Cons: ('head, 'tail,) -> (Cons with {head: 'head, tail: 'tail})
//│     = [Function: Cons1]
//│ Nil: () -> Nil
//│    = [Function: Nil1]

fun list1(x) = Cons(x, Nil())
fun list2(x, y) = Cons(x, list1(y))
fun list3(x, y, z) = Cons(x, list2(y, z))
fun list4(x, y, z, w) = Cons(x, list3(y, z, w))
fun list5(x, y, z, w, v) = Cons(x, list4(y, z, w, v))
fun list6(x, y, z, w, v, u) = Cons(x, list5(y, z, w, v, u))
fun list7(x, y, z, w, v, u, t) = Cons(x, list6(y, z, w, v, u, t))
fun list8(x, y, z, w, v, u, t, s) = Cons(x, list7(y, z, w, v, u, t, s))
//│ list1: 'head -> (Cons with {head: 'head, tail: Nil})
//│      = [Function: list1]
//│ list2: ('head, 'head0,) -> (Cons with {head: 'head, tail: Cons with {head: 'head0, tail: Nil}})
//│      = [Function: list2]
//│ list3: ('head, 'head0, 'head1,) -> (Cons with {head: 'head, tail: Cons with {head: 'head0, tail: Cons with {head: 'head1, tail: Nil}}})
//│      = [Function: list3]
//│ list4: ('head, 'head0, 'head1, 'head2,) -> (Cons with {head: 'head, tail: Cons with {head: 'head0, tail: Cons with {head: 'head1, tail: Cons with {head: 'head2, tail: Nil}}}})
//│      = [Function: list4]
//│ list5: ('head, 'head0, 'head1, 'head2, 'head3,) -> (Cons with {head: 'head, tail: Cons with {head: 'head0, tail: Cons with {head: 'head1, tail: Cons with {head: 'head2, tail: Cons with {head: 'head3, tail: Nil}}}}})
//│      = [Function: list5]
//│ list6: ('head, 'head0, 'head1, 'head2, 'head3, 'head4,) -> (Cons with {head: 'head, tail: Cons with {head: 'head0, tail: Cons with {head: 'head1, tail: Cons with {head: 'head2, tail: Cons with {head: 'head3, tail: Cons with {head: 'head4, tail: Nil}}}}}})
//│      = [Function: list6]
//│ list7: ('head, 'head0, 'head1, 'head2, 'head3, 'head4, 'head5,) -> (Cons with {head: 'head, tail: Cons with {head: 'head0, tail: Cons with {head: 'head1, tail: Cons with {head: 'head2, tail: Cons with {head: 'head3, tail: Cons with {head: 'head4, tail: Cons with {head: 'head5, tail: Nil}}}}}}})
//│      = [Function: list7]
//│ list8: ('head, 'head0, 'head1, 'head2, 'head3, 'head4, 'head5, 'head6,) -> (Cons with {head: 'head, tail: Cons with {head: 'head0, tail: Cons with {head: 'head1, tail: Cons with {head: 'head2, tail: Cons with {head: 'head3, tail: Cons with {head: 'head4, tail: Cons with {head: 'head5, tail: Cons with {head: 'head6, tail: Nil}}}}}}}})
//│      = [Function: list8]

fun listConcat(xs, ys) =
  if xs is
    Nil() then ys
    Cons(x, xs') then Cons(x, listConcat(xs', ys))
//│ listConcat: ('a, 'tail,) -> 'tail
//│   where
//│     'tail :> Cons with {head: 'head, tail: 'tail}
//│     'a <: (Cons with {head: 'head, tail: 'a}) | Nil
//│           = [Function: listConcat]

fun listContains(xs, x) =
  if xs is
    Nil() then false
    Cons(x', xs') and
      eq(x)(x') then true
      _ then listContains(xs', x)
//│ listContains: ('a, anything,) -> bool
//│   where
//│     'a <: Cons & {tail: 'a} | Nil
//│             = [Function: listContains]

// Remove all occurrences of x from xs.
fun listWithout(xs, x) =
  if xs is
    Nil() then Nil()
    Cons(x', xs') and
      eq(x)(x') then listWithout(xs', x)
      _ then Cons(x', listWithout(xs', x))
//│ listWithout: ('a, anything,) -> 'tail
//│   where
//│     'tail :> (Cons with {head: 'head, tail: 'tail}) | Nil
//│     'a <: (Cons with {head: 'head, tail: 'a}) | Nil
//│            = [Function: listWithout]

fun listJoin(xs, sep) =
  if xs is
    Nil() then ""
    Cons(x, Nil()) then toString(x)
    Cons(x, xs') then concat3(toString(x), sep, listJoin(xs', sep))
//│ listJoin: ('a, string,) -> string
//│   where
//│     'a <: Cons & {tail: 'a} | Nil
//│         = [Function: listJoin]

listJoin(list3("x", "y", "z"), ", ")
//│ res: string
//│    = 'x, y, z'

class Term
class Var(name): Term
class Abs(lhs, rhs): Term
class App(lhs, rhs): Term
//│ Defined class Term
//│ Defined class Var
//│ Defined class Abs
//│ Defined class App
//│ Term: () -> Term
//│     = [Function: Term1]
//│ Var: 'name -> (Var with {name: 'name})
//│    = [Function: Var1]
//│ Abs: ('lhs, 'rhs,) -> (Abs with {lhs: 'lhs, rhs: 'rhs})
//│    = [Function: Abs1]
//│ App: ('lhs, 'rhs,) -> (App with {lhs: 'lhs, rhs: 'rhs})
//│    = [Function: App1]

fun showTerm(t) =
  if t is
    Var(name) then toString(name)
    Abs(lhs, rhs) then concat4("&", showTerm(lhs), ". ", showTerm(rhs))
    App(Abs(lhs0, lhs1), rhs) then
      concat8("((", "&", showTerm(lhs0), ". ", showTerm(lhs1), ") ", showTerm(rhs), ")")
    App(lhs, rhs) then par(concat3(showTerm(lhs), " ", showTerm(rhs)))
//│ showTerm: 'a -> string
//│   where
//│     'a <: Abs & {lhs: 'a, rhs: 'a} | App & {lhs: 'a & (Abs & {lhs: 'a, rhs: 'a} | ~#Abs), rhs: 'a} | Var
//│         = [Function: showTerm]

showTerm(Var("x"))
showTerm(Abs(Var("x"), Var("y")))
showTerm(App(Var("x"), Var("y")))
showTerm(App(Abs(Var("x"), Var("y")), Var("z")))
//│ res: string
//│    = 'x'
//│ res: string
//│    = '&x. y'
//│ res: string
//│    = '(x y)'
//│ res: string
//│    = '((&x. y) z)'

fun isValue(t) =
  if t is
    Var then true
    Abs then true
    App then false
//│ isValue: (Abs | App | Var) -> bool
//│        = [Function: isValue]

isValue(Var("x"))
isValue(Abs(Var("x"), Var("y")))
isValue(App(Var("x"), Var("y")))
//│ res: bool
//│    = true
//│ res: bool
//│    = true
//│ res: bool
//│    = false

:w
fun hasFree(t, n) =
  if t is
    // let __ = debug(concat3(showTerm(t), ", ", n))
    Var(na) then eq(n)(na)
    Abs(Var(name), body) and eq(name)(n) then false
    Abs(Var(name), body) then hasFree(body, n)
    App(lhs, rhs) then hasFree(lhs, n) || hasFree(rhs, n)
    _ then false
//│ ╔══[WARNING] Found a duplicated else branch
//│ ║  l.234: 	    _ then false
//│ ║         	           ^^^^^
//│ ╟── The first else branch was declared here.
//│ ║  l.232: 	    Abs(Var(name), body) then hasFree(body, n)
//│ ╙──       	                              ^^^^^^^^^^^^^^^^
//│ hasFree: ('a, anything,) -> bool
//│   where
//│     'a <: Abs & {rhs: 'a} | App & {lhs: 'a, rhs: 'a} | Var | ~Abs & ~App & ~Var
//│        = [Function: hasFree]

fun showHasFree(t, n) =
  concat4(showTerm(t), if hasFree(t, n) then " has " else " DOES NOT have ", "free variable ", n)
//│ showHasFree: ('a & 'b, string,) -> string
//│   where
//│     'b <: Abs & {lhs: 'b, rhs: 'b} | App & {lhs: 'b & (Abs & {lhs: 'b, rhs: 'b} | ~#Abs), rhs: 'b} | Var
//│     'a <: Abs & {rhs: 'a} | App & {lhs: 'a, rhs: 'a} | Var | ~Abs & ~App & ~Var
//│            = [Function: showHasFree]

showHasFree(Var("x"), "x")
showHasFree(Var("x"), "y")
showHasFree(Abs(Var("x"), Var("x")), "x")
showHasFree(Abs(Var("x"), Var("x")), "y")
showHasFree(Abs(Var("x"), Var("y")), "x")
showHasFree(Abs(Var("x"), Var("y")), "y")
showHasFree(App(Var("x"), Var("y")), "x")
showHasFree(App(Var("x"), Var("y")), "y")
showHasFree(App(Abs(Var("x"), Var("x")), Var("x")), "x")
showHasFree(App(Abs(Var("x"), Var("x")), Var("x")), "y")
showHasFree(App(Abs(Var("x"), Var("x")), Var("y")), "y")
showHasFree(App(Abs(Var("x"), Var("x")), Var("x")), "y")
//│ res: string
//│    = 'x has free variable x'
//│ res: string
//│    = 'x DOES NOT have free variable y'
//│ res: string
//│    = '&x. x DOES NOT have free variable x'
//│ res: string
//│    = '&x. x DOES NOT have free variable y'
//│ res: string
//│    = '&x. y DOES NOT have free variable x'
//│ res: string
//│    = '&x. y has free variable y'
//│ res: string
//│    = '(x y) has free variable x'
//│ res: string
//│    = '(x y) has free variable y'
//│ res: string
//│    = '((&x. x) x) has free variable x'
//│ res: string
//│    = '((&x. x) x) DOES NOT have free variable y'
//│ res: string
//│    = '((&x. x) y) has free variable y'
//│ res: string
//│    = '((&x. x) x) DOES NOT have free variable y'

fun fv(t) =
  if t is
    Var(name) then list1(name)
    Abs(Var(name), body) then listWithout(fv(body), name)
    App(lhs, rhs) then listConcat(fv(lhs), fv(rhs))
//│ fv: 'a -> 'tail
//│   where
//│     'tail :> Cons & {head: 'head, tail: Nil} | 'tail0 | (Cons with {head: 'head, tail: 'tail})
//│     'tail0 :> (Cons with {head: 'head, tail: 'tail0}) | Nil
//│     'a <: Abs & {lhs: Var, rhs: 'a} | App & {lhs: 'a, rhs: 'a} | Var & {name: 'head}
//│   = [Function: fv]

fun showFv(t) =
  concat2(showTerm(t), if fv(t) is
    Nil then " DOES NOT have free variables"
    _ then concat2(" has free variables: ", listJoin(fv(t), ", "))
  )
//│ showFv: ('a & 'b) -> string
//│   where
//│     'b <: Abs & {lhs: 'b, rhs: 'b} | App & {lhs: 'b & (Abs & {lhs: 'b, rhs: 'b} | ~#Abs), rhs: 'b} | Var
//│     'a <: Abs & {lhs: Var, rhs: 'a} | App & {lhs: 'a, rhs: 'a} | Var & {name: anything}
//│       = [Function: showFv]

showFv(Var("x"))
showFv(Abs(Var("x"), Var("x")))
showFv(Abs(Var("x"), Var("y")))
showFv(App(Var("x"), Var("y")))
showFv(App(Abs(Var("x"), Var("x")), Var("x")))
//│ res: string
//│    = 'x has free variables: x'
//│ res: string
//│    = '&x. x DOES NOT have free variables'
//│ res: string
//│    = '&x. y has free variables: y'
//│ res: string
//│    = '(x y) has free variables: x, y'
//│ res: string
//│    = '((&x. x) x) has free variables: x'

fun tryNextAlphabet(initialCode, currentCode, freeNames) =
  if
    currentCode
      > 122 then tryNextAlphabet(initialCode, 97, freeNames)
      == initialCode then None()
    let name = fromCharCode(currentCode)
    listContains(freeNames, name) then tryNextAlphabet(initialCode, currentCode + 1, freeNames)
    _ then Some(name)
//│ tryNextAlphabet: (number, int, 'a,) -> (None | Some & {value: string})
//│   where
//│     'a <: Cons & {tail: 'a} | Nil
//│                = [Function: tryNextAlphabet]

tryNextAlphabet(97, 97, list1("a"))
tryNextAlphabet(97, 98, list1("a"))
tryNextAlphabet(97, 98, list2("a", "b"))
tryNextAlphabet(121, 122, list1("y"))
tryNextAlphabet(121, 122, list2("y", "z"))
//│ res: None | Some & {value: string}
//│    = None {}
//│ res: None | Some & {value: string}
//│    = Some { value: 'b' }
//│ res: None | Some & {value: string}
//│    = Some { value: 'c' }
//│ res: None | Some & {value: string}
//│    = Some { value: 'z' }
//│ res: None | Some & {value: string}
//│    = Some { value: 'a' }

fun tryAppendDigits(name, index, freeNames) =
  if
    let currentName = concat2(name, toString(index))
    listContains(freeNames, currentName) then
      tryAppendDigits(name, index + 1, freeNames)
    _ then currentName
//│ tryAppendDigits: (string, int, 'a,) -> string
//│   where
//│     'a <: Cons & {tail: 'a} | Nil
//│                = [Function: tryAppendDigits]

// Note: some weird behavior here... Just try the commented code.
// fun findFreshName(name, freeNames) =
//   if
//     stringLength(name) == 1 and
//       let charCode = stringCharCodeAt(name, 0)
//       tryNextAlphabet(charCode, charCode + 1, freeNames) is
//         Some(newName) then newName
//     _ then tryAppendDigits(name, 0, freeNames)
fun findFreshName(name, freeNames) =
  if
    stringLength(name) == 1 and
      let charCode = stringCharCodeAt(name, 0)
      tryNextAlphabet(charCode, charCode + 1, freeNames) is Some(newName) then newName
    _ then tryAppendDigits(name, 0, freeNames)
//│ findFreshName: (string, 'a,) -> string
//│   where
//│     'a <: Cons & {tail: 'a} | Nil
//│              = [Function: findFreshName]

// Find a fresh name to replace `name` that does not conflict with any bound
// variables in the `body`.
fun freshName(name, body) = findFreshName(name, fv(body))
//│ freshName: (string, 'a,) -> string
//│   where
//│     'a <: Abs & {lhs: Var, rhs: 'a} | App & {lhs: 'a, rhs: 'a} | Var & {name: anything}
//│          = [Function: freshName]

:w
fun subst(t, n, v) =
  if t is
    Var(name) and eq(name)(n) then v
    Abs(Var(name), body) and ne(name)(n) and
      hasFree(v, name) and freshName(name, body) is newName then
        subst(Abs(Var(newName), subst(body, name, Var(newName))), n, v)
      _ then Abs(Var(name), subst(body, n, v))
    App(lhs, rhs) then App(subst(lhs, n, v), subst(rhs, n, v))
    _ then t
//│ ╔══[WARNING] Found a duplicated else branch
//│ ║  l.406: 	    _ then t
//│ ║         	           ^
//│ ╟── The first else branch was declared here.
//│ ║  l.404: 	      _ then Abs(Var(name), subst(body, n, v))
//│ ╙──       	             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ subst: ('a, anything, 'a & 'b & 'rhs & 'c,) -> 'rhs
//│   where
//│     'c <: Abs & {rhs: 'c} | App & {lhs: 'c, rhs: 'c} | Var | ~Abs & ~App & ~Var
//│     'a <: Abs & 'd | App & 'e | Var & 'f | 'g & ~#Abs & ~#App & ~#Var
//│     'd :> (Abs with {lhs: Var & {name: string}, rhs: 'rhs}) | 'rhs
//│        <: 'b & (Abs & {lhs: Var & {name: 'name} | ~Var, rhs: 'a & 'b} | App & {lhs: Var & {name: 'name} | ~Var, rhs: 'a & 'b} & 'e | Var & {lhs: Var & {name: 'name} | ~Var, rhs: 'a & 'b} & 'f | {lhs: Var & {name: 'name} | ~Var, rhs: 'a & 'b} & 'g & ~#Abs & ~#App & ~#Var)
//│     'rhs :> (App with {lhs: 'rhs, rhs: 'rhs}) | (Abs with {lhs: Var & {name: 'name0}, rhs: 'rhs}) | Var & {name: string} | 'f | 'd | 'g
//│     'f :> Var & {name: string}
//│        <: 'b & (Abs & {name: anything} & 'd | App & {name: anything} & 'e | Var | {name: anything} & 'g & ~#Abs & ~#App & ~#Var)
//│     'g <: 'b & (Abs & 'd | App & 'e | Var & 'f | ~#Abs & ~#App & ~#Var)
//│     'e <: {lhs: 'a, rhs: 'a}
//│     'b <: Abs & {lhs: Var, rhs: 'b} | App & {lhs: 'b, rhs: 'b} | Var & {name: anything}
//│     'name0 :> string
//│            <: 'name
//│     'name <: string & 'name0
//│      = [Function: subst]

fun showSubst(t, n, v) =
  concat8(showTerm(t), " [", n, " / ", showTerm(v), "]", " => ", showTerm(subst(t, n, v)))
//│ showSubst: ('a & 'b, string, 'a & 'lhs & 'c & 'd & 'e & 'b,) -> string
//│   where
//│     'e <: Abs & {rhs: 'e} | App & {lhs: 'e, rhs: 'e} | Var | ~Abs & ~App & ~Var
//│     'b <: Abs & {lhs: 'b, rhs: 'b} | App & {lhs: 'b & (Abs & {lhs: 'b, rhs: 'b} | ~#Abs), rhs: 'b} | Var
//│     'a <: Abs & 'f | App & 'g | Var & 'h | 'i & ~#Abs & ~#App & ~#Var
//│     'f <: 'lhs & 'c & 'd & (Abs & {lhs: Var & {name: string} | ~Var, rhs: 'a & 'd} | App & {lhs: Var & {name: string} | ~Var, rhs: 'a & 'd} & 'g | Var & {lhs: Var & {name: string} | ~Var, rhs: 'a & 'd} & 'h | {lhs: Var & {name: string} | ~Var, rhs: 'a & 'd} & 'i & ~#Abs & ~#App & ~#Var)
//│     'h <: 'lhs & 'c & 'd & (Abs & {name: anything} & 'f | App & {name: anything} & 'g | Var | {name: anything} & 'i & ~#Abs & ~#App & ~#Var)
//│     'i <: 'lhs & 'c & 'd & (Abs & 'f | App & 'g | ~#Abs & ~#App & ~#Var | Var & 'h)
//│     'g <: {lhs: 'a, rhs: 'a}
//│     'd <: Abs & {lhs: Var, rhs: 'd} | App & {lhs: 'd, rhs: 'd} | Var & {name: anything}
//│     'lhs <: Abs & {lhs: 'c, rhs: 'c} | ~Abs
//│     'c <: Abs & {lhs: 'c, rhs: 'c} | App & {lhs: 'lhs & 'c, rhs: 'c} | Var
//│          = [Function: showSubst]

showSubst(Var("x"), "x", Var("y"))
showSubst(Abs(Var("x"), Var("x")), "x", Var("z"))
showSubst(App(Var("x"), Var("y")), "x", Abs(Var("x"), Var("x")))
showSubst(App(Abs(Var("x"), Var("x")), Var("x")), "x", Abs(Var("y"), Var("y")))
showSubst(Abs(Var("x"), App(Var("x"), Var("y"))), "y", Var("x"))
//│ res: string
//│    = 'x [x / y] => y'
//│ res: string
//│    = '&x. x [x / z] => &x. x'
//│ res: string
//│    = '(x y) [x / &x. x] => ((&x. x) y)'
//│ res: string
//│    = '((&x. x) x) [x / &y. y] => ((&x. x) &y. y)'
//│ res: string
//│    = '&x. (x y) [y / x] => &z. (z x)'

fun stepByValue(t) =
  if t is
    Var then None()
    Abs then None()
    App(lhs, rhs) and stepByValue(lhs) is
      Some(lhs) then Some(App(lhs, rhs))
      None and stepByValue(rhs) is
        Some(rhs) then Some(App(lhs, rhs))
        None and lhs is
          Abs(Var(name), body) then Some(subst(body, name, rhs))
          _ then None()
//│ stepByValue: 'a -> (None | (Some with {value: 'rhs}))
//│   where
//│     'rhs :> 'value | (App with {lhs: 'rhs, rhs: 'rhs0}) | (App with {lhs: 'lhs, rhs: 'rhs})
//│     'a <: Abs | App & {lhs: 'lhs & 'a & (Abs & {rhs: 'b} | ~#Abs), rhs: 'a & 'b & 'c & 'value & 'd & 'rhs0} | Var
//│     'd <: Abs & {rhs: 'd} | App & {lhs: 'd, rhs: 'd} | Var | ~Abs & ~App & ~Var
//│     'b <: Abs & 'e | App & 'f | Var & 'g | 'h & ~#Abs & ~#App & ~#Var
//│     'e :> (Abs with {lhs: Var & {name: string}, rhs: 'value}) | 'value
//│        <: 'c & (Abs & {lhs: Var & {name: 'name} | ~Var, rhs: 'b & 'c} | App & {lhs: Var & {name: 'name} | ~Var, rhs: 'b & 'c} & 'f | Var & {lhs: Var & {name: 'name} | ~Var, rhs: 'b & 'c} & 'g | {lhs: Var & {name: 'name} | ~Var, rhs: 'b & 'c} & 'h & ~#Abs & ~#App & ~#Var)
//│     'value :> (App with {lhs: 'value, rhs: 'value}) | (Abs with {lhs: Var & {name: 'name0}, rhs: 'value}) | Var & {name: string} | 'g | 'e | 'h
//│     'g :> Var & {name: string}
//│        <: 'c & (Abs & {name: anything} & 'e | App & {name: anything} & 'f | Var | {name: anything} & 'h & ~#Abs & ~#App & ~#Var)
//│     'h <: 'c & (Abs & 'e | App & 'f | Var & 'g | ~#Abs & ~#App & ~#Var)
//│     'f <: {lhs: 'b, rhs: 'b}
//│     'c <: Abs & {lhs: Var, rhs: 'c} | App & {lhs: 'c, rhs: 'c} | Var & {name: anything}
//│     'name0 :> string
//│            <: 'name
//│     'name <: string & 'name0
//│            = [Function: stepByValue]

fun showStepByValue(t) =
  concat3(showTerm(t), " => ", if stepByValue(t) is
    Some(t) then showTerm(t)
    None then "stuck"
  )
//│ showStepByValue: ('a & 'b) -> string
//│   where
//│     'b <: Abs & {lhs: 'b, rhs: 'b} | App & {lhs: 'b & (Abs & {lhs: 'b, rhs: 'b} | ~#Abs), rhs: 'b} | Var
//│     'a <: Abs | App & {lhs: 'a & 'lhs & 'c & (Abs & {rhs: 'd} | ~#Abs), rhs: 'a & 'd & 'lhs & 'c & 'e & 'f} | Var
//│     'f <: Abs & {rhs: 'f} | App & {lhs: 'f, rhs: 'f} | Var | ~Abs & ~App & ~Var
//│     'd <: Abs & 'g | App & 'h | Var & 'i | 'j & ~#Abs & ~#App & ~#Var
//│     'g <: 'lhs & 'c & 'e & (Abs & {lhs: Var & {name: string} | ~Var, rhs: 'd & 'e} | App & {lhs: Var & {name: string} | ~Var, rhs: 'd & 'e} & 'h | Var & {lhs: Var & {name: string} | ~Var, rhs: 'd & 'e} & 'i | {lhs: Var & {name: string} | ~Var, rhs: 'd & 'e} & 'j & ~#Abs & ~#App & ~#Var)
//│     'i <: 'lhs & 'c & 'e & (Abs & {name: anything} & 'g | App & {name: anything} & 'h | Var | {name: anything} & 'j & ~#Abs & ~#App & ~#Var)
//│     'j <: 'lhs & 'c & 'e & (Abs & 'g | App & 'h | ~#Abs & ~#App & ~#Var | Var & 'i)
//│     'h <: {lhs: 'd, rhs: 'd}
//│     'e <: Abs & {lhs: Var, rhs: 'e} | App & {lhs: 'e, rhs: 'e} | Var & {name: anything}
//│     'lhs <: Abs & {lhs: 'c, rhs: 'c} | ~Abs
//│     'c <: Abs & {lhs: 'c, rhs: 'c} | App & {lhs: 'lhs & 'c, rhs: 'c} | Var
//│                = [Function: showStepByValue]

showStepByValue(Var("x"))
showStepByValue(Abs(Var("x"), Var("y")))
showStepByValue(App(Var("x"), Var("y")))
showStepByValue(App(Abs(Var("x"), Var("x")), Var("y")))
//│ res: string
//│    = 'x => stuck'
//│ res: string
//│    = '&x. y => stuck'
//│ res: string
//│    = '(x y) => stuck'
//│ res: string
//│    = '((&x. x) y) => y'

fun equalTerm(a, b) =
  if a is
    Var(na) and b is Var(nb) then eq(na)(nb)
    Abs(la, ra) and b is Abs(lb, rb) then equalTerm(la, lb) && equalTerm(ra, rb)
    App(la, ra) and b is App(lb, rb) then equalTerm(la, lb) && equalTerm(ra, rb)
    _ then false
//│ equalTerm: ('a, 'a,) -> bool
//│   where
//│     'a <: Abs & {lhs: 'a, rhs: 'a} | App & {lhs: 'a, rhs: 'a} | Var | ~Abs & ~App & ~Var
//│          = [Function: equalTerm]
