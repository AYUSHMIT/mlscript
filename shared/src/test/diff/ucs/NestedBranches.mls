:PreTyper


class Some[out A](val value: A)
module None
class Left[out A](val leftValue: A)
class Right[out A](val rightValue: A)
module Nil
class Cons[out A](val head: A, val tail: Cons[A] | Nil)
class Pair[out A, out B](val fst: A, val snd: B)
//│ class Some[A](value: A)
//│ module None
//│ class Left[A](leftValue: A)
//│ class Right[A](rightValue: A)
//│ module Nil
//│ class Cons[A](head: A, tail: Cons[A] | Nil)
//│ class Pair[A, B](fst: A, snd: B)


fun optionApply(x, y, f) =
  if x is
    Some(xv) and y is
      Some(yv) then Some(f(xv, yv))
      None then None
    None then None
//│ fun optionApply: forall 'a 'b 'A. (None | Some['a], None | Some['b], ('a, 'b) -> 'A) -> (None | Some['A])

let zeroToThree = Cons(0, Cons(1, Cons(2, Cons(3, Nil))))
//│ let zeroToThree: Cons[0 | 1 | 2 | 3]
//│ zeroToThree
//│             = Cons {}

fun f(x) = if x % 2 == 0 then Left(x) else Right(x)
//│ fun f: forall 'A. (Int & 'A) -> (Left['A] | Right['A])

// FIXME: Looks like a transformation bug.
fun mapPartition(f, xs) = if xs is
  Nil then Pair(Nil, Nil)
  Cons(x, xs) and mapPartition(f, xs) is Pair(l, r) and f(x) is
    Left(v)  then Pair(Cons(v, l), r)
    Right(v) then Pair(l, Cons(v, r))
//│ ╔══[ERROR] identifier `l` not found
//│ ║  l.40: 	    Left(v)  then Pair(Cons(v, l), r)
//│ ╙──      	                               ^
//│ ╔══[ERROR] identifier `r` not found
//│ ║  l.40: 	    Left(v)  then Pair(Cons(v, l), r)
//│ ╙──      	                                   ^
//│ ╔══[ERROR] identifier `l` not found
//│ ║  l.41: 	    Right(v) then Pair(l, Cons(v, r))
//│ ╙──      	                       ^
//│ ╔══[ERROR] identifier `r` not found
//│ ║  l.41: 	    Right(v) then Pair(l, Cons(v, r))
//│ ╙──      	                                  ^
//│ ╔══[ERROR] identifier not found: l
//│ ║  l.40: 	    Left(v)  then Pair(Cons(v, l), r)
//│ ╙──      	                               ^
//│ ╔══[ERROR] identifier not found: r
//│ ║  l.40: 	    Left(v)  then Pair(Cons(v, l), r)
//│ ╙──      	                                   ^
//│ ╔══[ERROR] identifier not found: l
//│ ║  l.41: 	    Right(v) then Pair(l, Cons(v, r))
//│ ╙──      	                       ^
//│ ╔══[ERROR] identifier not found: r
//│ ║  l.41: 	    Right(v) then Pair(l, Cons(v, r))
//│ ╙──      	                                  ^
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.39: 	  Cons(x, xs) and mapPartition(f, xs) is Pair(l, r) and f(x) is
//│ ║        	                                                        ^^^^^^^
//│ ║  l.40: 	    Left(v)  then Pair(Cons(v, l), r)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.41: 	    Right(v) then Pair(l, Cons(v, r))
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╙── expression of type `Bool` is not an instance of type `true`
//│ fun mapPartition: forall 'a 'A 'A0. ('a -> (Left['A] | Right['A0]), Cons['a] | Nil) -> Pair[Cons['A] | Nil | error, Cons['A0] | Nil | error]
//│ Code generation encountered an error:
//│   unresolved symbol l

:re
mapPartition(x => Left(x + 1), zeroToThree)
//│ Pair[Cons[Int] | Nil | error, Cons[nothing] | Nil | error]
//│ res
//│ Runtime error:
//│   ReferenceError: mapPartition is not defined

:re
mapPartition(f, zeroToThree)
//│ Pair[Cons[0 | 1 | 2 | 3] | Nil | error, Cons[0 | 1 | 2 | 3] | Nil | error]
//│ res
//│ Runtime error:
//│   ReferenceError: mapPartition is not defined


fun mapPartition(f, xs) = if xs is
  Nil then Pair(Nil, Nil)
  Cons(x, xs) and
    mapPartition(f, xs) is Pair(l, r) and f(x) is
      Left(v)  then Pair(Cons(v, l), r)
      Right(v) then Pair(l, Cons(v, r))
//│ fun mapPartition: forall 'a 'A 'A0. ('a -> (Left['A] | Right['A0]), Cons['a] | Nil) -> Pair[Cons['A] | Nil, Cons['A0] | Nil]

mapPartition(f, zeroToThree)
//│ Pair[Cons[0 | 1 | 2 | 3] | Nil, Cons[0 | 1 | 2 | 3] | Nil]
//│ res
//│     = Pair {}


fun mapPartition(f, xs) = if xs is
  Nil then
    Pair(Nil, Nil)
  Cons(x, xs) and
    mapPartition(f, xs) is
      Pair(l, r) and
        f(x) is
          Left(v)  then
            Pair(Cons(v, l), r)
          Right(v) then
            Pair(l, Cons(v, r))
//│ fun mapPartition: forall 'a 'A 'A0. ('a -> (Left['A] | Right['A0]), Cons['a] | Nil) -> Pair[Cons['A] | Nil, Cons['A0] | Nil]

mapPartition(f, zeroToThree)
//│ Pair[Cons[0 | 1 | 2 | 3] | Nil, Cons[0 | 1 | 2 | 3] | Nil]
//│ res
//│     = Pair {}

:e // TODO make this one work (needs tuple support)
fun mapPartition(f, xs) = if xs is
  Nil then [Nil, Nil]
  Cons(x, xs) and mapPartition(f, xs) is [l, r] and f(x) is
    Left(v)  then [Cons(v, l), r]
    Right(v) then [l, Cons(v, r)]
//│ ╔══[ERROR] identifier `l` not found
//│ ║  l.129: 	    Left(v)  then [Cons(v, l), r]
//│ ╙──       	                           ^
//│ ╔══[ERROR] identifier `r` not found
//│ ║  l.129: 	    Left(v)  then [Cons(v, l), r]
//│ ╙──       	                               ^
//│ ╔══[ERROR] identifier `l` not found
//│ ║  l.130: 	    Right(v) then [l, Cons(v, r)]
//│ ╙──       	                   ^
//│ ╔══[ERROR] identifier `r` not found
//│ ║  l.130: 	    Right(v) then [l, Cons(v, r)]
//│ ╙──       	                              ^
//│ ╔══[ERROR] identifier not found: l
//│ ║  l.129: 	    Left(v)  then [Cons(v, l), r]
//│ ╙──       	                           ^
//│ ╔══[ERROR] identifier not found: r
//│ ║  l.129: 	    Left(v)  then [Cons(v, l), r]
//│ ╙──       	                               ^
//│ ╔══[ERROR] identifier not found: l
//│ ║  l.130: 	    Right(v) then [l, Cons(v, r)]
//│ ╙──       	                   ^
//│ ╔══[ERROR] identifier not found: r
//│ ║  l.130: 	    Right(v) then [l, Cons(v, r)]
//│ ╙──       	                              ^
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.128: 	  Cons(x, xs) and mapPartition(f, xs) is [l, r] and f(x) is
//│ ║         	                                                    ^^^^^^^
//│ ║  l.129: 	    Left(v)  then [Cons(v, l), r]
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.130: 	    Right(v) then [l, Cons(v, r)]
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╙── expression of type `Bool` is not an instance of type `true`
//│ fun mapPartition: forall 'a 'A 'A0. ('a -> (Left['A] | Right['A0]), Cons['a] | Nil) -> [Cons['A] | Nil | error, Cons['A0] | Nil | error]
//│ Code generation encountered an error:
//│   unresolved symbol l

:re // TODO
mapPartition(f, zeroToThree)
//│ [Cons[0 | 1 | 2 | 3] | Nil | error, Cons[0 | 1 | 2 | 3] | Nil | error]
//│ res
//│ Runtime error:
//│   ReferenceError: mapPartition3 is not defined


// * Vertical alignment is not allowed! (good)
:pe
:w
:e
fun mapPartition(f, xs) = if xs is
  Nil then [Nil, Nil]
  Cons(x, xs) and mapPartition(f, xs) is [l, r]
          and f(x) is Left(v)  then [Cons(v, l), r]
                      Right(v) then [l, Cons(v, r)]
//│ ╔══[PARSE ERROR] Unexpected 'then' keyword here
//│ ║  l.183: 	                      Right(v) then [l, Cons(v, r)]
//│ ╙──       	                               ^^^^
//│ ╔══[WARNING] Paren-less applications should use the 'of' keyword
//│ ║  l.182: 	          and f(x) is Left(v)  then [Cons(v, l), r]
//│ ║         	                                    ^^^^^^^^^^^^^^^
//│ ║  l.183: 	                      Right(v) then [l, Cons(v, r)]
//│ ╙──       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.182: 	          and f(x) is Left(v)  then [Cons(v, l), r]
//│ ║         	                                    ^^^^^^^^^^^^^^^
//│ ║  l.183: 	                      Right(v) then [l, Cons(v, r)]
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── tuple literal of type `[?a, ?b]` is not a function
//│ ║  l.182: 	          and f(x) is Left(v)  then [Cons(v, l), r]
//│ ╙──       	                                    ^^^^^^^^^^^^^^^
//│ fun mapPartition: forall 'a. ('a -> Left[anything], Cons['a] | Nil) -> (error | [Nil, Nil])

