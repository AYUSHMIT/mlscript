:NewParser


class Option
class Some(value): Option
class None: Option
class Either
class Left(leftValue): Either
class Right(rightValue): Either
class List
class Nil: List
let Nil = Nil()
class Cons(head, tail): List
class Pair(fst, snd)
//│ Defined class Option
//│ Defined class Some
//│ Defined class None
//│ Defined class Either
//│ Defined class Left
//│ Defined class Right
//│ Defined class List
//│ Defined class Nil
//│ Defined class Cons
//│ Defined class Pair
//│ Option: () -> Option
//│       = [Function: Option1]
//│ Some: 'value -> (Some & {value: 'value})
//│     = [Function: Some1]
//│ None: () -> None
//│     = [Function: None1]
//│ Either: () -> Either
//│       = [Function: Either1]
//│ Left: 'leftValue -> (Left & {leftValue: 'leftValue})
//│     = [Function: Left1]
//│ Right: 'rightValue -> (Right & {rightValue: 'rightValue})
//│      = [Function: Right1]
//│ List: () -> List
//│     = [Function: List1]
//│ Nil: () -> Nil
//│    = [Function: Nil1]
//│ Nil: Nil
//│    = Nil {}
//│ Cons: ('head, 'tail,) -> (Cons & {head: 'head, tail: 'tail})
//│     = [Function: Cons1]
//│ Pair: ('fst, 'snd,) -> (Pair & {fst: 'fst, snd: 'snd})
//│     = [Function: Pair1]



fun optionApply(x, y, f) =
  if x is
    Some(xv) and y is
      Some(yv) then Some(f(xv, yv))
      None() then None()
    None() then None()
//│ optionApply: (None | Some & {value: 'value}, None | Some & {value: 'value0}, ('value, 'value0,) -> 'value1,) -> (None | Some & {value: 'value1})
//│            = [Function: optionApply]

let zeroToThree = Cons(0, Cons(1, Cons(2, Cons(3, Nil))))
//│ zeroToThree: Cons & {head: 0, tail: Cons & {head: 1, tail: Cons & {head: 2, tail: Cons & {head: 3, tail: Nil}}}}
//│            = Cons {
//│                head: 0,
//│                tail: Cons { head: 1, tail: Cons { head: 2, tail: [Cons] } }
//│              }

fun f(x) = if x % 2 == 0 then Left(x) else Right(x)
//│ f: (int & 'leftValue) -> (Left & {leftValue: 'leftValue} | Right & {rightValue: 'leftValue})
//│  = [Function: f]


fun mapPartition(f, xs) = if xs is
  Nil then Pair(Nil(), Nil())
  Cons(x, xs) and mapPartition(f, xs) is Pair(l, r) and f(x) is
    Left(v)  then Pair(Cons(v, l), r)
    Right(v) then Pair(l, Cons(v, r))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.72: 	  Nil then Pair(Nil(), Nil())
//│ ║        	                ^^^^^
//│ ╟── application of type `Nil` is not a function
//│ ║  l.11: 	class Nil: List
//│ ║        	      ^^^
//│ ╟── but it flows into reference with expected type `() -> ?a`
//│ ║  l.72: 	  Nil then Pair(Nil(), Nil())
//│ ╙──      	                ^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.72: 	  Nil then Pair(Nil(), Nil())
//│ ║        	                       ^^^^^
//│ ╟── application of type `Nil` is not a function
//│ ║  l.11: 	class Nil: List
//│ ║        	      ^^^
//│ ╟── but it flows into reference with expected type `() -> ?a`
//│ ║  l.72: 	  Nil then Pair(Nil(), Nil())
//│ ╙──      	                       ^^^
//│ mapPartition: ('head -> (Left & {leftValue: 'leftValue} | Right & {rightValue: 'rightValue}), 'tail,) -> (Pair & {fst: 'fst, snd: 'tail0})
//│   where
//│     'tail0 :> Cons & {head: 'rightValue, tail: 'tail0} | error
//│     'fst :> error | Cons & {head: 'leftValue, tail: 'fst}
//│     'tail <: Cons & {head: 'head, tail: 'tail} | Nil
//│             = [Function: mapPartition]

mapPartition(x => Left(x + 1), zeroToThree)
//│ res: Pair & {fst: 'fst, snd: 'snd}
//│   where
//│     'snd :> Cons & {head: nothing, tail: 'snd} | error
//│     'fst :> error | Cons & {head: int, tail: 'fst}
//│ Runtime error:
//│   TypeError: Nil2 is not a function

mapPartition(f, zeroToThree)
//│ res: Pair & {fst: 'fst, snd: 'snd}
//│   where
//│     'snd :> Cons & {head: 0 | 1 | 2 | 3, tail: 'snd} | error
//│     'fst :> error | Cons & {head: 0 | 1 | 2 | 3, tail: 'fst}
//│ Runtime error:
//│   TypeError: Nil2 is not a function


fun mapPartition(f, xs) = if xs is
  Nil then Pair(Nil(), Nil())
  Cons(x, xs) and
    mapPartition(f, xs) is Pair(l, r) and f(x) is
      Left(v)  then Pair(Cons(v, l), r)
      Right(v) then Pair(l, Cons(v, r))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.119: 	  Nil then Pair(Nil(), Nil())
//│ ║         	                ^^^^^
//│ ╟── application of type `Nil` is not a function
//│ ║  l.11: 	class Nil: List
//│ ║        	      ^^^
//│ ╟── but it flows into reference with expected type `() -> ?a`
//│ ║  l.119: 	  Nil then Pair(Nil(), Nil())
//│ ╙──       	                ^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.119: 	  Nil then Pair(Nil(), Nil())
//│ ║         	                       ^^^^^
//│ ╟── application of type `Nil` is not a function
//│ ║  l.11: 	class Nil: List
//│ ║        	      ^^^
//│ ╟── but it flows into reference with expected type `() -> ?a`
//│ ║  l.119: 	  Nil then Pair(Nil(), Nil())
//│ ╙──       	                       ^^^
//│ mapPartition: ('head -> (Left & {leftValue: 'leftValue} | Right & {rightValue: 'rightValue}), 'tail,) -> (Pair & {fst: 'fst, snd: 'tail0})
//│   where
//│     'tail0 :> Cons & {head: 'rightValue, tail: 'tail0} | error
//│     'fst :> error | Cons & {head: 'leftValue, tail: 'fst}
//│     'tail <: Cons & {head: 'head, tail: 'tail} | Nil
//│             = [Function: mapPartition1]

mapPartition(f, zeroToThree)
//│ res: Pair & {fst: 'fst, snd: 'snd}
//│   where
//│     'snd :> Cons & {head: 0 | 1 | 2 | 3, tail: 'snd} | error
//│     'fst :> error | Cons & {head: 0 | 1 | 2 | 3, tail: 'fst}
//│ Runtime error:
//│   TypeError: Nil2 is not a function


fun mapPartition(f, xs) = if xs is
  Nil then
    Pair(Nil(), Nil())
  Cons(x, xs) and
    mapPartition(f, xs) is
      Pair(l, r) and
        f(x) is
          Left(v)  then
            Pair(Cons(v, l), r)
          Right(v) then
            Pair(l, Cons(v, r))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.160: 	    Pair(Nil(), Nil())
//│ ║         	         ^^^^^
//│ ╟── application of type `Nil` is not a function
//│ ║  l.11: 	class Nil: List
//│ ║        	      ^^^
//│ ╟── but it flows into reference with expected type `() -> ?a`
//│ ║  l.160: 	    Pair(Nil(), Nil())
//│ ╙──       	         ^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.160: 	    Pair(Nil(), Nil())
//│ ║         	                ^^^^^
//│ ╟── application of type `Nil` is not a function
//│ ║  l.11: 	class Nil: List
//│ ║        	      ^^^
//│ ╟── but it flows into reference with expected type `() -> ?a`
//│ ║  l.160: 	    Pair(Nil(), Nil())
//│ ╙──       	                ^^^
//│ mapPartition: ('head -> (Left & {leftValue: 'leftValue} | Right & {rightValue: 'rightValue}), 'tail,) -> (Pair & {fst: 'fst, snd: 'tail0})
//│   where
//│     'tail0 :> Cons & {head: 'rightValue, tail: 'tail0} | error
//│     'fst :> error | Cons & {head: 'leftValue, tail: 'fst}
//│     'tail <: Cons & {head: 'head, tail: 'tail} | Nil
//│             = [Function: mapPartition2]

mapPartition(f, zeroToThree)
//│ res: Pair & {fst: 'fst, snd: 'snd}
//│   where
//│     'snd :> Cons & {head: 0 | 1 | 2 | 3, tail: 'snd} | error
//│     'fst :> error | Cons & {head: 0 | 1 | 2 | 3, tail: 'fst}
//│ Runtime error:
//│   TypeError: Nil2 is not a function


// TODO make this one work (needs tuple support)
fun mapPartition(f, xs) = if xs is
  Nil then (Nil(), Nil())
  Cons(x, xs) and mapPartition(f, xs) is (l, r) and f(x) is
    Left(v)  then (Cons(v, l), r)
    Right(v) then (l, Cons(v, r))
//│ ╔══[ERROR] The case when this is false is not handled: is (mapPartition (f, xs,),) (l, r,)
//│ ║  l.206: 	  Cons(x, xs) and mapPartition(f, xs) is (l, r) and f(x) is
//│ ╙──       	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ mapPartition: (anything, anything,) -> error
//│ Code generation encountered an error:
//│   if expression was not desugared

// TODO
mapPartition(f, zeroToThree)
//│ res: error
//│ Runtime error:
//│   ReferenceError: mapPartition3 is not defined


// * Vertical alignment is not allowed! (good)
:pe
:w
:e
:ge
fun mapPartition(f, xs) = if xs is
  Nil then (Nil(), Nil())
  Cons(x, xs) and mapPartition(f, xs) is (l, r)
          and f(x) is Left(v)  then (Cons(v, l), r)
                      Right(v) then (l, Cons(v, r))
//│ ╔══[PARSE ERROR] Unexpected 'then' keyword here
//│ ║  l.232: 	                      Right(v) then (l, Cons(v, r))
//│ ╙──       	                               ^^^^
//│ ╔══[WARNING] Paren-less applications should use the 'of' keyword
//│ ║  l.231: 	          and f(x) is Left(v)  then (Cons(v, l), r)
//│ ║         	                                    ^^^^^^^^^^^^^^^
//│ ║  l.232: 	                      Right(v) then (l, Cons(v, r))
//│ ╙──       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.229: 	  Nil then (Nil(), Nil())
//│ ║         	            ^^^^^
//│ ╟── application of type `Nil` is not a function
//│ ║  l.11: 	class Nil: List
//│ ║        	      ^^^
//│ ╟── but it flows into reference with expected type `() -> ?a`
//│ ║  l.229: 	  Nil then (Nil(), Nil())
//│ ╙──       	            ^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.229: 	  Nil then (Nil(), Nil())
//│ ║         	                   ^^^^^
//│ ╟── application of type `Nil` is not a function
//│ ║  l.11: 	class Nil: List
//│ ║        	      ^^^
//│ ╟── but it flows into reference with expected type `() -> ?a`
//│ ║  l.229: 	  Nil then (Nil(), Nil())
//│ ╙──       	                   ^^^
//│ ╔══[ERROR] type identifier not found: Tuple#2
//│ ╙──
//│ mapPartition: (anything, 'tail,) -> ((error, error,) | error)
//│   where
//│     'tail <: Cons & {tail: 'tail} | Nil
//│ Code generation encountered an error:
//│   unknown match case: Tuple#2


