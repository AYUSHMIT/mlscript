:NewDefs


module A
//│ module A()

// This one is easy to fix but what about the next one?
// The following example can better reveal the essence of the problem.
fun test(x: 0 | A) = if x is
  0 then 0
  A then A
//│ fun test: (x: 0 | A,) -> (0 | A)

// FIXME
fun test(x: 0 | A) =
  if
    x == 0 then 0
    x is A then A
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.17: 	    x == 0 then 0
//│ ║        	    ^^^^
//│ ╟── type `A` is not an instance of type `number`
//│ ║  l.15: 	fun test(x: 0 | A) =
//│ ║        	                ^
//│ ╟── but it flows into reference with expected type `number`
//│ ║  l.17: 	    x == 0 then 0
//│ ╙──      	    ^
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.18: 	    x is A then A
//│ ║        	    ^^^^^^^^^^^^^
//│ ╟── type `0` is not an instance of type `A`
//│ ║  l.15: 	fun test(x: 0 | A) =
//│ ║        	            ^
//│ ╟── but it flows into reference with expected type `A`
//│ ║  l.18: 	    x is A then A
//│ ║        	    ^
//│ ╟── Note: constraint arises from class pattern:
//│ ║  l.18: 	    x is A then A
//│ ╙──      	         ^
//│ fun test: (x: 0 | A,) -> (0 | A)
