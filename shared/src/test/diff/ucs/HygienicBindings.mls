:PreTyper

type Option[out T] = None | Some[T]
module None
class Some[out T](val value: T)
//│ type Option[T] = None | Some[T]
//│ module None
//│ class Some[T](value: T)

type Either[A, B] = Left[A] | Right[B]
class Left[A](val leftValue: A)
class Right[B](val rightValue: B)
//│ type Either[A, B] = Left[A] | Right[B]
//│ class Left[A](leftValue: A)
//│ class Right[B](rightValue: B)

type List[out A] = Nil | Cons[A]
module Nil
class Cons[out A](head: A, tail: List[A])
//│ type List[A] = Cons[A] | Nil
//│ module Nil
//│ class Cons[A](head: A, tail: List[A])

fun h0(a) =
  if
    a is Some(Left(y)) then y
    a is Some(Right(z)) then z
    a is None then 0
//│ fun h0: forall 'a. (None | Some[Left['a] | Right['a]]) -> (0 | 'a)

// Precise scrutinee identification (easy)
// =======================================
// The desugarer should be able to identify pattern matching on the first
// parameter of `Some` even if they are bound to different variables.
:dpt:postprocess.result
fun h1(a) =
  if
    a is Some(x) and x is Left(y) then y
    a is Some(y) and y is Right(z) then z
    a is None then 0
//│ | | | | | | | Post-processed UCS term:
//│ | | | | | | | case a*‡ of
//│ | | | | | | |   Some*◊ ->
//│ | | | | | | |     let ucs$args_a$Some*† = (Some).unapply(a,)
//│ | | | | | | |     let x*‡ = (ucs$args_a$Some).0
//│ | | | | | | |     case x*‡ of
//│ | | | | | | |       Left*◊ ->
//│ | | | | | | |         let ucs$args_x$Left*† = (Left).unapply(x,)
//│ | | | | | | |         let y*‡ = (ucs$args_x$Left).0
//│ | | | | | | |         y
//│ | | | | | | |       Right*◊ ->
//│ | | | | | | |         let y*‡ = (ucs$args_a$Some).0
//│ | | | | | | |         let ucs$args_y$Right*† = (Right).unapply(y,)
//│ | | | | | | |         let z*‡ = (ucs$args_y$Right).0
//│ | | | | | | |         z
//│ | | | | | | |   None*† -> 0
//│ fun h1: forall 'a. (None | Some[Right[anything] & {#rightValue: 'a}]) -> (0 | 'a)

// FIXME
h1(Some(Left(0)))
//│ ╔══[ERROR] Type `Left[?A]` does not contain member `rightValue`
//│ ║  l.12: 	class Right[B](val rightValue: B)
//│ ╙──      	                   ^^^^^^^^^^
//│ 0 | error
//│ res
//│     = 0

// This is the desugared version of the test case above.
fun h1'(a) =
  if a is
    Some then
      let x = a.value
      let y = a.value
      if x is
        Left then
          let y = x.leftValue
          y
        _ then
          if y is
            Right then
              let z = y.rightValue
              z
    None then 0
//│ fun h1': forall 'leftValue. (None | Some[Right['leftValue]]) -> (0 | 'leftValue)

// FIXME
h1'(Some(Left(0)))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.87: 	h1'(Some(Left(0)))
//│ ║        	^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Left[?A]` is not an instance of type `Right`
//│ ║  l.87: 	h1'(Some(Left(0)))
//│ ║        	         ^^^^^^^
//│ ╟── Note: constraint arises from class pattern:
//│ ║  l.80: 	            Right then
//│ ║        	            ^^^^^
//│ ╟── from field selection:
//│ ║  l.73: 	      let y = a.value
//│ ║        	              ^^^^^^^
//│ ╟── Note: type parameter T is defined at:
//│ ║  l.5: 	class Some[out T](val value: T)
//│ ╙──     	               ^
//│ 0 | error
//│ res
//│     = 0

fun h1''(a) =
  if
    a is Some(x) and x is Left(y) then y
    a is Some(x) and x is Right(z) then z
    a is None then 0
//│ fun h1'': forall 'a. (None | Some[Left['a] | Right['a]]) -> (0 | 'a)

h1''(Some(Left(0)))
//│ 0
//│ res
//│     = 0

// FIXME: Precise scrutinee identification (hard)
fun h2(a) =
  if
    a is Some(x) and x is x' and x' is Left(y) then y
    a is Some(y) and
      let y' = y
      y' is Right(z) then z
    a is None then 0
//│ fun h2: forall 'a. (None | Some[Left['a]]) -> (0 | 'a)

// FIXME: Some results are wrong.
fun h3(x, y, f, p) =
  if x is
    _ and f(x) is y and p(x) then y
    None then y
    _ then "anyway"
h3("anything", "not me", _ => "should be me", _ => true)
h3(None, "should be me", _ => "not me", _ => false)
h3("anything", "anything", _ => "not me", _ => false)
//│ fun h3: forall 'a 'b. (Object & 'a, anything, 'a -> 'b, 'a -> Bool) -> ("anyway" | 'b)
//│ "anyway" | "not me"
//│ res
//│     = 'should be me'
//│ res
//│     = 'not me'
//│ res
//│     = 'anyway'


// FIXME: We still haven't fixed all shadowing problems.
:dpt:postprocess.result
fun h4(x, y, p) =
  if x is
    y and p(x) then y
    None then y
    _ then "default"
//│ | | | | | | | Post-processed UCS term:
//│ | | | | | | | let y*‡ = x
//│ | | | | | | | let ucs$test$0*† = p(x,) : Bool
//│ | | | | | | | case ucs$test$0*† of
//│ | | | | | | |   true*† -> y
//│ | | | | | | |   _ ->
//│ | | | | | | |     case x*‡ of
//│ | | | | | | |       None*† -> y
//│ | | | | | | |       _ -> "default"
//│ fun h4: forall 'a. (Object & 'a, anything, 'a -> Bool) -> ("default" | 'a)

h4("should be me", "not me", _ => true)
h4(None, "not me", _ => true)
h4(None, "should be me", _ => false)
h4("anything", "not me", _ => false)
//│ "anything" | "default"
//│ res
//│     = 'should be me'
//│ res
//│     = None { class: [class None] }
//│ res
//│     = None { class: [class None] }
//│ res
//│     = 'default'
