:NewParser


class Foo(x)
//│ Defined class Foo
//│ Foo: 'x -> (Foo with {x: 'x})
//│    = [Function: Foo1]

if 1 is 1 then 1 else 0
//│ res: 0 | 1
//│    = 1

fun test(x) = if x is 1 then 0 else 1
//│ test: number -> (0 | 1)
//│     = [Function: test]

// It should report duplicated branches.
:w
fun testF(x) = if x is
  Foo(a) then a
  Foo(a) then a
//│ ╔══[WARNING] duplicated branch
//│ ╙──
//│ testF: (Foo with {x: 'x}) -> 'x
//│      = [Function: testF]

class Bar(y, z)
//│ Defined class Bar
//│ Bar: ('y, 'z,) -> (Bar with {y: 'y, z: 'z})
//│    = [Function: Bar1]

fun test(f) = if f is
  Foo(a) then a
  Bar(b, c) then b + c
//│ test: (Bar & {y: int, z: int} | (Foo with {x: 'x})) -> (int | 'x)
//│     = [Function: test1]


class Pair(fst, snd)
//│ Defined class Pair
//│ Pair: ('fst, 'snd,) -> (Pair with {fst: 'fst, snd: 'snd})
//│     = [Function: Pair1]

fun f(x) =
  if x is
    Pair(0, 0) then "zeros"
    Pair(1, 1) then "ones"
    Pair(y, 1) then x
    _          then "nah"
//│ f: (Pair & {fst: number, snd: number} & 'a | ~Pair) -> ("nah" | "ones" | "zeros" | 'a)
//│  = [Function: f]

class Z()
class O()
//│ Defined class Z
//│ Defined class O
//│ Z: () -> Z
//│  = [Function: Z1]
//│ O: () -> O
//│  = [Function: O1]

// This is not exhaustive.
:e
:ge
:d
fun foo(x) = if x is
  Pair(Z(), Z()) then "zeros"
  Pair(O(), O()) then "ones"
//│ 1. Typing term x, => if x is ‹(Pair (Z (), Z (),)) then "zeros"; (Pair (O (), O (),)) then "ones"›
//│ | 1. Typing pattern x,
//│ | | 1. Typing pattern x
//│ | | 1. : α160'
//│ | 1. : (α160',)
//│ | 1. Typing term if x is ‹(Pair (Z (), Z (),)) then "zeros"; (Pair (O (), O (),)) then "ones"›
//│ | | If(IfOpApp(Var(x), Var(is), IfBlock(IfThen(App(Var(Pair), Tup(_: App(Var(Z), Tup()), _: App(Var(Z), Tup()))), StrLit(zeros);IfThen(App(Var(Pair), Tup(_: App(Var(O), Tup()), _: App(Var(O), Tup()))), StrLit(ones)), None)
//│ | | Build a Clause.MatchClass from x where pattern is Pair (Z (), Z (),)
//│ | | Fragments: List()
//│ | | The locations of the clause: List(Loc(23,37,ucs/Humiliation:+66))
//│ | | Build a Clause.MatchClass from tmp2 where pattern is Z ()
//│ | | Fragments: List()
//│ | | The locations of the clause: List(Loc(28,31,ucs/Humiliation:+66))
//│ | | Build a Clause.MatchClass from tmp3 where pattern is Z ()
//│ | | Fragments: List()
//│ | | The locations of the clause: List(Loc(33,36,ucs/Humiliation:+66))
//│ | | Build a Clause.MatchClass from x where pattern is Pair (O (), O (),)
//│ | | Fragments: List()
//│ | | The locations of the clause: List(Loc(53,67,ucs/Humiliation:+66))
//│ | | Build a Clause.MatchClass from tmp2 where pattern is O ()
//│ | | Fragments: List()
//│ | | The locations of the clause: List(Loc(58,61,ucs/Humiliation:+66))
//│ | | Build a Clause.MatchClass from tmp3 where pattern is O ()
//│ | | Fragments: List()
//│ | | The locations of the clause: List(Loc(63,66,ucs/Humiliation:+66))
//│ | | Flattened conjunctions
//│ | | + «x is Pair» and «tmp2 is Z» and «tmp3 is Z» => "zeros"
//│ | | + «x is Pair» and «tmp2 is O» and «tmp3 is O» => "ones"
//│ | | The mutable CaseOf tree
//│ | | «x» match
//│ | |   case Pair =>
//│ | |     let tmp2 = .fst
//│ | |     let tmp3 = .snd
//│ | |     «tmp2» match
//│ | |       case Z =>
//│ | |         «tmp3» match
//│ | |           case Z =>
//│ | |             «"zeros"»
//│ | |       case O =>
//│ | |         «tmp3» match
//│ | |           case O =>
//│ | |             «"ones"»
//│ | | Summarize pattern of Match(x, 1 branch, no wildcard)
//│ | | | Summarize pattern of Match(tmp2, 2 branches, no wildcard)
//│ | | | | Summarize pattern of Match(tmp3, 1 branch, no wildcard)
//│ | | | | | Summarize pattern of Consequent("zeros")
//│ | | | | Summarize pattern of Match(tmp3, 1 branch, no wildcard)
//│ | | | | | Summarize pattern of Consequent("ones")
//│ | | Exhaustiveness map
//│ | | - Left(tmp3) => Z, O
//│ | | - Left(tmp2) => Z, O
//│ | | - Right(9) => Pair
//│ | | Check exhaustiveness of Match(x, 1 branch, no wildcard)
//│ | | | The exhaustiveness map is Map(Left(tmp3) -> Map(Z -> MutCase((Z,ArrayBuffer()),Consequent("zeros")), O -> MutCase((O,ArrayBuffer()),Consequent("ones"))), Left(tmp2) -> Map(Z -> MutCase((Z,ArrayBuffer()),Match(tmp3,ArrayBuffer(MutCase((Z,ArrayBuffer()),Consequent("zeros"))),None)), O -> MutCase((O,ArrayBuffer()),Match(tmp3,ArrayBuffer(MutCase((O,ArrayBuffer()),Consequent("ones"))),None))), Right(9) -> Map(Pair -> MutCase((Pair,ArrayBuffer((fst,tmp2), (snd,tmp3))),Match(tmp2,ArrayBuffer(MutCase((Z,ArrayBuffer()),Match(tmp3,ArrayBuffer(MutCase((Z,ArrayBuffer()),Consequent("zeros"))),None)), MutCase((O,ArrayBuffer()),Match(tmp3,ArrayBuffer(MutCase((O,ArrayBuffer()),Consequent("ones"))),None))),None))))
//│ | | | The scrutinee key is Right(9)
//│ | | | Pattern map of the scrutinee:
//│ | | | - Pair => MutCase((Pair,ArrayBuffer((fst,tmp2), (snd,tmp3))),Match(tmp2,ArrayBuffer(MutCase((Z,ArrayBuffer()),Match(tmp3,ArrayBuffer(MutCase((Z,ArrayBuffer()),Consequent("zeros"))),None)), MutCase((O,ArrayBuffer()),Match(tmp3,ArrayBuffer(MutCase((O,ArrayBuffer()),Consequent("ones"))),None))),None))
//│ | | | Number of missing cases: 0
//│ | | | Check exhaustiveness of Match(tmp2, 2 branches, no wildcard)
//│ | | | | The exhaustiveness map is Map(Left(tmp3) -> Map(Z -> MutCase((Z,ArrayBuffer()),Consequent("zeros")), O -> MutCase((O,ArrayBuffer()),Consequent("ones"))), Left(tmp2) -> Map(Z -> MutCase((Z,ArrayBuffer()),Match(tmp3,ArrayBuffer(MutCase((Z,ArrayBuffer()),Consequent("zeros"))),None)), O -> MutCase((O,ArrayBuffer()),Match(tmp3,ArrayBuffer(MutCase((O,ArrayBuffer()),Consequent("ones"))),None))), Right(9) -> Map(Pair -> MutCase((Pair,ArrayBuffer((fst,tmp2), (snd,tmp3))),Match(tmp2,ArrayBuffer(MutCase((Z,ArrayBuffer()),Match(tmp3,ArrayBuffer(MutCase((Z,ArrayBuffer()),Consequent("zeros"))),None)), MutCase((O,ArrayBuffer()),Match(tmp3,ArrayBuffer(MutCase((O,ArrayBuffer()),Consequent("ones"))),None))),None))))
//│ | | | | The scrutinee key is Left(tmp2)
//│ | | | | Pattern map of the scrutinee:
//│ | | | | - Z => MutCase((Z,ArrayBuffer()),Match(tmp3,ArrayBuffer(MutCase((Z,ArrayBuffer()),Consequent("zeros"))),None))
//│ | | | | - O => MutCase((O,ArrayBuffer()),Match(tmp3,ArrayBuffer(MutCase((O,ArrayBuffer()),Consequent("ones"))),None))
//│ | | | | Number of missing cases: 0
//│ | | | | Check exhaustiveness of Match(tmp3, 1 branch, no wildcard)
//│ | | | | | The exhaustiveness map is Map(Left(tmp3) -> Map(Z -> MutCase((Z,ArrayBuffer()),Consequent("zeros")), O -> MutCase((O,ArrayBuffer()),Consequent("ones"))), Left(tmp2) -> Map(Z -> MutCase((Z,ArrayBuffer()),Match(tmp3,ArrayBuffer(MutCase((Z,ArrayBuffer()),Consequent("zeros"))),None)), O -> MutCase((O,ArrayBuffer()),Match(tmp3,ArrayBuffer(MutCase((O,ArrayBuffer()),Consequent("ones"))),None))), Right(9) -> Map(Pair -> MutCase((Pair,ArrayBuffer((fst,tmp2), (snd,tmp3))),Match(tmp2,ArrayBuffer(MutCase((Z,ArrayBuffer()),Match(tmp3,ArrayBuffer(MutCase((Z,ArrayBuffer()),Consequent("zeros"))),None)), MutCase((O,ArrayBuffer()),Match(tmp3,ArrayBuffer(MutCase((O,ArrayBuffer()),Consequent("ones"))),None))),None))))
//│ | | | | | The scrutinee key is Left(tmp3)
//│ | | | | | Pattern map of the scrutinee:
//│ | | | | | - Z => MutCase((Z,ArrayBuffer()),Consequent("zeros"))
//│ | | | | | - O => MutCase((O,ArrayBuffer()),Consequent("ones"))
//│ | | | | | Number of missing cases: 1
//│ | 1. : error<>
//│ 1. : (α160' -> error<>)
//│ CONSTRAIN (α160' -> error<>) <! foo159'
//│   where 
//│ C (α160' -> error<>) <! foo159'    (0)
//│ ⬤ Typed as: foo159'
//│  where: 
//│ 		foo159' :> (α160' -> error<>)
//│ ╔══[ERROR] The match is not exhaustive.
//│ ║  l.66: 	fun foo(x) = if x is
//│ ║        	                ^^^^
//│ ╟── The scrutinee at this position misses 1 case.
//│ ║  l.67: 	  Pair(Z(), Z()) then "zeros"
//│ ║        	            ^^^
//│ ╟── [Missing Case 1/1] `O`
//│ ╟── It first appears here.
//│ ║  l.68: 	  Pair(O(), O()) then "ones"
//│ ╙──      	            ^^^
//│ foo: anything -> error
//│ Code generation encountered an error:
//│   if expression has not been desugared

// Change `Pair` to a real pair.
:e
:ge
fun foo(x) = if x is
  (Z(), Z()) then "zeros"
  (O(), O()) then "ones"
//│ ╔══[ERROR] The match is not exhaustive.
//│ ║  l.166: 	fun foo(x) = if x is
//│ ║         	                ^^^^
//│ ╟── The scrutinee at this position misses 1 case.
//│ ║  l.167: 	  (Z(), Z()) then "zeros"
//│ ║         	        ^^^
//│ ╟── [Missing Case 1/1] `O`
//│ ╟── It first appears here.
//│ ║  l.168: 	  (O(), O()) then "ones"
//│ ╙──       	        ^^^
//│ foo: anything -> error
//│ Code generation encountered an error:
//│   if expression has not been desugared

fun foo(x) = if x is
  Pair(a, b) then if a is
    Z() then if b is
      Z() then "zeros"
    O() then if b is
      O() then "ones"
//│ foo: (Pair & {fst: O | Z, snd: nothing}) -> ("ones" | "zeros")
//│    = [Function: foo2]

fun foo(x) = if x is
  Pair(a, b) then if a is
    Z() then if b is
      Z() then "zeros"
      else "???"
    O() then if b is
      O() then "ones"
//│ foo: (Pair & {fst: O | Z, snd: O}) -> ("???" | "ones" | "zeros")
//│    = [Function: foo3]

fun foo(x) = if x is
  Pair(a, b) then if a is
    Z() then if b is
      Z() then "zeros"
      else "???"
    O() then if b is
      O() then "zeros"
      else "???"
//│ foo: (Pair & {fst: O | Z}) -> ("???" | "zeros")
//│    = [Function: foo4]

class S(pred)
//│ Defined class S
//│ S: 'pred -> (S with {pred: 'pred})
//│  = [Function: S1]

// TODO: Cannot check exhaustiveness of nested UCS yet.
fun foo(x) = if x is
  Pair(a, b) then if a is
    Z() then if b is
      S(x) then x
      else "???"
    O() then if b is
      O() then "zeros"
      else "???"
//│ foo: (Pair & {fst: O | Z, snd: (S with {pred: 'pred}) | ~S}) -> ("???" | "zeros" | 'pred)
//│    = [Function: foo5]

:re
foo(Pair(Z(), Z()))
//│ res: "???" | "zeros"
//│ Runtime error:
//│   Error: non-exhaustive case expression

:e
:ge
fun foo(x) = if x is
  Pair(Z(), Z()) then "zeros"
  Pair(O(), O()) then "ones"
  Pair(y, O()) then x
//│ ╔══[ERROR] The match is not exhaustive.
//│ ║  l.238: 	fun foo(x) = if x is
//│ ║         	                ^^^^
//│ ╟── The scrutinee at this position misses 1 case.
//│ ║  l.239: 	  Pair(Z(), Z()) then "zeros"
//│ ║         	            ^^^
//│ ╟── [Missing Case 1/1] `Z`
//│ ╟── It first appears here.
//│ ║  l.239: 	  Pair(Z(), Z()) then "zeros"
//│ ╙──       	            ^^^
//│ foo: anything -> error
//│ Code generation encountered an error:
//│   if expression has not been desugared

fun foo(x, y) = if x is Z() and y is O() then 0 else 1
//│ foo: (anything, anything,) -> (0 | 1)
//│    = [Function: foo7]

:pe
fun foo(x, y) = if x is
  Z() and y is O() then 0 else 1
//│ ╔══[PARSE ERROR] Unexpected 'else' keyword here
//│ ║  l.262: 	  Z() and y is O() then 0 else 1
//│ ╙──       	                          ^^^^
//│ foo: (Z, O,) -> 0
//│    = [Function: foo8]

fun foo(x, y) =
  if x is
    Z() and y is O() then 0
    else 1
//│ foo: (anything, anything,) -> (0 | 1)
//│    = [Function: foo9]
