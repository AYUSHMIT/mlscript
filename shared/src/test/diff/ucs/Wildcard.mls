:NewParser
:NewDefs

type Option[T] = None | Some[T]
module None
class Some[T](value: T)
//│ type Option[T] = Some[T] | None
//│ module None()
//│ class Some[T](value: T)

type Either[A, B] = Left[A] | Right[B]
class Left[A](leftValue: A)
class Right[B](rightValue: B)
//│ type Either[A, B] = Left[A] | Right[B]
//│ class Left[A](leftValue: A)
//│ class Right[B](rightValue: B)

fun w1(x, e_0, e_1) =
  if x is
    Left(None) then "Left of None"
    Right(None) then "Right of None"
    _ and e_0 is y_0 and x is
      Left(Some(lv)) then concat("Left of Some of ")(toString(lv))
      _ and e_1 is y_1 and x is
        Right(Some(rv)) then concat("Right of Some of ")(toString(rv))
//│ fun w1: (Left[None | Some[anything]] | Right[None | Some[anything]], anything, anything,) -> string

w1(Left(None), "a", "b")
w1(Right(None), "a", "b")
w1(Left(Some(0)), "a", "b")
w1(Right(Some(0)), "a", "b")
//│ string
//│ res
//│     = 'Left of None'
//│ res
//│     = 'Right of None'
//│ res
//│     = 'Left of Some of 0'
//│ res
//│     = 'Right of Some of 0'

fun w2(x, p) =
  if x is
    Some then 1
    _ and p(x) then 2
    None then 3
    _ then 4
//│ fun w2: forall 'a. (None | Some[anything] | 'a & ~#None & ~#Some, (None | 'a) -> anything,) -> (1 | 2 | 3 | 4)

w2(Some(0), x => true)
w2(None, x => true)
w2(None, x => false)
w2(0, x => false)
//│ 1 | 2 | 3 | 4
//│ res
//│     = 1
//│ res
//│     = 2
//│ res
//│     = 3
//│ res
//│     = 4
