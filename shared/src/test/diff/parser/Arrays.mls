:AllowParseErrors
:AllowTypeErrors // TODO rm


[]
//│ |[BEG:||:END]|
//│ Parsed: {'('  ')'}

[1]
//│ |[BEG:|1|:END]|
//│ Parsed: {'(' 1, ')'}

[1,]
//│ |[BEG:|1|,|:END]|
//│ Parsed: {'(' 1, ')'}

[1, 2, 3]
//│ |[BEG:|1|,| |2|,| |3|:END]|
//│ Parsed: {'(' 1, 2, 3, ')'}

()
//│ |(BEG:||:END)|
//│ Parsed: {'('  ')'}

(1)
//│ |(BEG:|1|:END)|
//│ Parsed: {'(' 1, ')'}

(1,)
//│ |(BEG:|1|,|:END)|
//│ Parsed: {'(' 1, ')'}

(1, 2, 3)
//│ |(BEG:|1|,| |2|,| |3|:END)|
//│ Parsed: {'(' 1, 2, 3, ')'}


1
//│ |1|
//│ Parsed: {1}

1,
//│ |1|,|
//│ ╔══[PARSE ERROR] Expected end of input; found comma instead
//│ ║  l.42: 	1,
//│ ╙──      	 ^
//│ Parsed: {1}

1, 2, 3
//│ |1|,| |2|,| |3|
//│ ╔══[PARSE ERROR] Expected end of input; found comma instead
//│ ║  l.49: 	1, 2, 3
//│ ╙──      	 ^
//│ Parsed: {1}

f of 1, 2, 3
//│ |f| |#of| |1|,| |2|,| |3|
//│ Parsed: {f (1, 2, 3,)}

f of
  1, 2, 3
//│ |f| |#of|→|1|,| |2|,| |3|←|
//│ Parsed: {f (1, 2, 3,)}

f of
  1,
  2,
  3
//│ |f| |#of|→|1|,|↵|2|,|↵|3|←|
//│ Parsed: {f (1, 2, 3,)}


let arr = []
//│ |#let| |arr| |#=| |[BEG:||:END]|
//│ Parsed: {let arr = '('  ')' in undefined}

let arr = [
]
//│ |#let| |arr| |#=| |[BEG:|↵|:END]|
//│ Parsed: {let arr = '('  ')' in undefined}

let arr =
[
]
//│ |#let| |arr| |#=|↵|[BEG:|↵|:END]|
//│ ╔══[PARSE ERROR] Unexpected newline in expression position
//│ ║  l.82: 	let arr =
//│ ║        	         ^
//│ ║  l.83: 	[
//│ ╙──      	
//│ Parsed: {let arr = '('  ')' in undefined}

let arr = [
  1
]
//│ |#let| |arr| |#=| |[BEG:|→|1|←|↵|:END]|
//│ Parsed: {let arr = '(' 1, ')' in undefined}

let arr = [
  1, 2
]
//│ |#let| |arr| |#=| |[BEG:|→|1|,| |2|←|↵|:END]|
//│ Parsed: {let arr = '(' 1, 2, ')' in undefined}

let arr = [
  1,
  2
]
//│ |#let| |arr| |#=| |[BEG:|→|1|,|↵|2|←|↵|:END]|
//│ Parsed: {let arr = '(' 1, 2, ')' in undefined}


