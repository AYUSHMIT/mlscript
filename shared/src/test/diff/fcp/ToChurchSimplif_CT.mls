// * This test contains simplifications of the to_church function,
// * used to minimize and reproduce problems with to_church and related definitions.

:NoRecursiveTypes
:GeneralizeCurriedFunctions
:ConstrainedTypes
:DontDistributeForalls



type ChurchInt = forall 'N. ('N -> 'N) -> ('N -> 'N)
//│ Defined type alias ChurchInt

def zero: ChurchInt
def succ: ChurchInt -> ChurchInt
//│ zero: ChurchInt
//│     = <missing implementation>
//│ succ: ChurchInt -> ChurchInt
//│     = <missing implementation>

def to_church: int -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ to_church: int -> (forall 'M. ('M -> 'M) -> 'M -> 'M)
//│          = <missing implementation>



def z f x = x
//│ z: 'a -> (forall 'b. 'b -> 'b)
//│  = [Function: z]

// * Simpler functions that can be used instead of `s` to debug
// def s n f x = f (n f x) // * original succ
// def s n f = f (n f)
def s n f x = (n f x)
// def s n f = n f
//│ s: 'a -> (forall 'b. 'b -> (forall 'c, 'd, 'a, 'b, 'e. ('e -> 'c
//│   where
//│     'a <: 'b -> ('e -> 'c & 'd))))
//│  = [Function: s]

:ns
s
//│ res: forall 'a. 'a -> (forall 'b. 'b -> (forall 'c, 'd, 'e. ('d -> 'e
//│   where
//│     'a <: 'b -> 'c)))
//│   where
//│     'c <: 'd -> 'e
//│    = [Function: s]

:e // * Since "sound extrusion"
succ = s
//│ 'a -> (forall 'b. 'b -> (forall 'c, 'd, 'a, 'b, 'e. ('e -> 'c
//│   where
//│     'a <: 'b -> ('e -> 'c & 'd))))
//│   <:  succ:
//│ ChurchInt -> ChurchInt
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.51: 	succ = s
//│ ║        	^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.11: 	type ChurchInt = forall 'N. ('N -> 'N) -> ('N -> 'N)
//│ ║        	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.11: 	type ChurchInt = forall 'N. ('N -> 'N) -> ('N -> 'N)
//│ ╙──      	                        ^^
//│     = [Function: s]

:e // * Since "sound extrusion"
succ n f = n f
//│ 'a -> (forall 'a, 'b, 'c. ('b -> 'c
//│   where
//│     'a <: 'b -> 'c))
//│   <:  succ:
//│ ChurchInt -> ChurchInt
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.69: 	succ n f = n f
//│ ║        	^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.11: 	type ChurchInt = forall 'N. ('N -> 'N) -> ('N -> 'N)
//│ ║        	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.11: 	type ChurchInt = forall 'N. ('N -> 'N) -> ('N -> 'N)
//│ ╙──      	                        ^^
//│     = [Function: succ2]

succ n = n
//│ 'a -> 'a
//│   <:  succ:
//│ ChurchInt -> ChurchInt
//│     = [Function: succ3]

def succ_min : (forall 'N. ('N -> 'N)) -> (forall 'M. ('M -> 'M))
//│ succ_min: (forall 'N. 'N -> 'N) -> (forall 'M. 'M -> 'M)
//│         = <missing implementation>

:e // * Since "sound extrusion"
succ_min n f = n f
//│ 'a -> (forall 'a, 'b, 'c. ('b -> 'c
//│   where
//│     'a <: 'b -> 'c))
//│   <:  succ_min:
//│ (forall 'N. 'N -> 'N) -> (forall 'M. 'M -> 'M)
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.97: 	succ_min n f = n f
//│ ║        	^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.92: 	def succ_min : (forall 'N. ('N -> 'N)) -> (forall 'M. ('M -> 'M))
//│ ║        	                                                  ^^
//│ ╟── but it flows into reference with expected type `nothing`
//│ ║  l.97: 	succ_min n f = n f
//│ ║        	                 ^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.92: 	def succ_min : (forall 'N. ('N -> 'N)) -> (forall 'M. ('M -> 'M))
//│ ║        	                                                  ^^
//│ ╟── from application:
//│ ║  l.97: 	succ_min n f = n f
//│ ╙──      	               ^^^
//│         = [Function: succ_min]



rec def to_ch n =
  if n == 0 then zero
  else s (to_ch n)
//│ to_ch: 'to_ch
//│   where
//│     'to_ch :> forall 'a, 'b, 'to_ch, 'c, 'd. ((number & 'b) -> (forall 'e. 'e -> (forall 'f, 'g, 'd, 'e, 'h. ('f -> 'g
//│   where
//│     'd <: 'e -> ('f -> 'g & 'h))) | ChurchInt | 'c)
//│   where
//│     'to_ch <: 'b -> ('a & 'd))
//│      = <no result>
//│        zero is not implemented

:e
to_church = to_ch
//│ 'to_ch
//│   where
//│     'to_ch :> forall 'a, 'b, 'c, 'to_ch, 'd. ((number & 'b) -> (forall 'e. 'e -> (forall 'a, 'f, 'g, 'h, 'e. ('h -> 'g
//│   where
//│     'a <: 'e -> ('h -> 'g & 'f))) | ChurchInt | 'd)
//│   where
//│     'to_ch <: 'b -> ('c & 'a))
//│   <:  to_church:
//│ int -> (forall 'M. ('M -> 'M) -> 'M -> 'M)
//│ ╔══[ERROR] Cyclic-looking constraint while typing def definition; a type annotation may be required
//│ ║  l.136: 	to_church = to_ch
//│ ║         	^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  to_ch178_258#  <:  ((α179_275,) -> α185_276)    TypeVariable  FunctionType
//│ ╙──  ... looks like:  to_ch178'#  <:  ((α179_259'',) -> α185_260'')
//│          = <no result>
//│            to_ch and zero are not implemented


rec def to_ch n =
  if true then zero
  else s (to_ch n)
//│ to_ch: 'to_ch
//│   where
//│     'to_ch :> forall 'a, 'b, 'to_ch, 'c, 'd. ('c -> (forall 'e. 'e -> (forall 'a, 'f, 'g, 'h, 'e. ('h -> 'g
//│   where
//│     'a <: 'e -> ('h -> 'g & 'f))) | ChurchInt | 'd)
//│   where
//│     'to_ch <: 'c -> ('b & 'a))
//│      = <no result>
//│        zero is not implemented

:e
to_church = to_ch
//│ 'to_ch
//│   where
//│     'to_ch :> forall 'a, 'b, 'to_ch, 'c, 'd. ('c -> (forall 'e. 'e -> (forall 'a, 'e, 'f, 'g, 'h. ('h -> 'g
//│   where
//│     'a <: 'e -> ('h -> 'g & 'f))) | ChurchInt | 'b)
//│   where
//│     'to_ch <: 'c -> ('d & 'a))
//│   <:  to_church:
//│ int -> (forall 'M. ('M -> 'M) -> 'M -> 'M)
//│ ╔══[ERROR] Cyclic-looking constraint while typing def definition; a type annotation may be required
//│ ║  l.170: 	to_church = to_ch
//│ ║         	^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  to_ch283_361#  <:  ((α284_378,) -> α288_379)    TypeVariable  FunctionType
//│ ╙──  ... looks like:  to_ch283'#  <:  ((α284_362'',) -> α288_363'')
//│          = <no result>
//│            to_ch and zero are not implemented


rec def to_ch n =
  if true then zero
  else s (to_church n)
//│ to_ch: (int & 'a) -> (forall 'b. 'b -> (forall 'b, 'c, 'd, 'e. ('c -> 'd
//│   where
//│     forall 'M, 'f. ('M -> 'M) -> 'M -> 'M | 'f <: 'b -> ('c -> 'd & 'e))) | ChurchInt | 'g)
//│      = <no result>
//│        zero is not implemented

:e
to_church = to_ch
//│ (int & 'a) -> (forall 'b. 'b -> (forall 'b, 'c, 'd, 'e. ('c -> 'd
//│   where
//│     forall 'M, 'f. ('M -> 'M) -> 'M -> 'M | 'f <: 'b -> ('c -> 'd & 'e))) | ChurchInt | 'g)
//│   <:  to_church:
//│ int -> (forall 'M. ('M -> 'M) -> 'M -> 'M)
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.200: 	to_church = to_ch
//│ ║         	^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.21: 	def to_church: int -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ║        	                              ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.21: 	def to_church: int -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ╙──      	                              ^^
//│          = <no result>
//│            to_ch and zero are not implemented


def to_ch n =
  if true then z
  else s (to_church n)
//│ to_ch: (int & 'a) -> (forall 'b, 'c, 'd. ('c & 'd) -> (forall 'd, 'e, 'f, 'g, 'h. (('f & 'g) -> ('f | 'e)
//│   where
//│     forall 'M, 'i. ('M -> 'M) -> 'M -> 'M | 'i <: 'd -> ('g -> 'e & 'h))) | 'b)
//│      = <no result>
//│        to_church, to_ch and zero are not implemented

:e // * Since "sound extrusion"
to_church = to_ch
//│ (int & 'a) -> (forall 'b, 'c, 'd. ('c & 'd) -> (forall 'e, 'f, 'd, 'g, 'h. (('e & 'h) -> ('e | 'g)
//│   where
//│     forall 'M, 'i. ('M -> 'M) -> 'M -> 'M | 'i <: 'd -> ('h -> 'g & 'f))) | 'b)
//│   <:  to_church:
//│ int -> (forall 'M. ('M -> 'M) -> 'M -> 'M)
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.229: 	to_church = to_ch
//│ ║         	^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.21: 	def to_church: int -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ║        	                              ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.21: 	def to_church: int -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ╙──      	                              ^^
//│          = <no result>
//│            to_ch, to_church, to_ch and zero are not implemented


def to_ch n =
  if true then zero
  else s (to_church n)
//│ to_ch: (int & 'a) -> (forall 'b. 'b -> (forall 'c, 'd, 'e, 'b. ('c -> 'd
//│   where
//│     forall 'M, 'f. ('M -> 'M) -> 'M -> 'M | 'f <: 'b -> ('c -> 'd & 'e))) | ChurchInt | 'g)
//│      = <no result>
//│        zero is not implemented

:e // * Since "sound extrusion"
to_church = to_ch
//│ (int & 'a) -> (forall 'b. 'b -> (forall 'b, 'c, 'd, 'e. ('c -> 'd
//│   where
//│     forall 'M, 'f. ('M -> 'M) -> 'M -> 'M | 'f <: 'b -> ('c -> 'd & 'e))) | ChurchInt | 'g)
//│   <:  to_church:
//│ int -> (forall 'M. ('M -> 'M) -> 'M -> 'M)
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.258: 	to_church = to_ch
//│ ║         	^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.21: 	def to_church: int -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ║        	                              ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.21: 	def to_church: int -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ╙──      	                              ^^
//│          = <no result>
//│            to_ch and zero are not implemented


def to_ch n =
  s (to_church n)
//│ to_ch: (int & 'a) -> (forall 'b. 'b -> (forall 'b, 'c, 'd, 'e. ('c -> 'd
//│   where
//│     forall 'M, 'f. ('M -> 'M) -> 'M -> 'M | 'f <: 'b -> ('c -> 'd & 'e))) | 'g)
//│      = <no result>
//│        to_church, to_ch and zero are not implemented

:e // * Since "sound extrusion"
to_church = to_ch
//│ (int & 'a) -> (forall 'b. 'b -> (forall 'c, 'd, 'e, 'b. ('c -> 'd
//│   where
//│     forall 'M, 'f. ('M -> 'M) -> 'M -> 'M | 'f <: 'b -> ('c -> 'd & 'e))) | 'g)
//│   <:  to_church:
//│ int -> (forall 'M. ('M -> 'M) -> 'M -> 'M)
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.286: 	to_church = to_ch
//│ ║         	^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.21: 	def to_church: int -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ║        	                              ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.21: 	def to_church: int -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ╙──      	                              ^^
//│          = <no result>
//│            to_ch, to_church, to_ch and zero are not implemented


rec def to_ch n =
  s (to_church n)
//│ to_ch: (int & 'a) -> (forall 'b. 'b -> (forall 'c, 'd, 'e, 'b. ('c -> 'd
//│   where
//│     forall 'M, 'f. ('M -> 'M) -> 'M -> 'M | 'f <: 'b -> ('c -> 'd & 'e))) | 'g)
//│      = <no result>
//│        to_church, to_ch, to_church, to_ch and zero are not implemented

:e
to_church = to_ch
//│ (int & 'a) -> (forall 'b. 'b -> (forall 'b, 'c, 'd, 'e. ('c -> 'd
//│   where
//│     forall 'M, 'f. ('M -> 'M) -> 'M -> 'M | 'f <: 'b -> ('c -> 'd & 'e))) | 'g)
//│   <:  to_church:
//│ int -> (forall 'M. ('M -> 'M) -> 'M -> 'M)
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.314: 	to_church = to_ch
//│ ║         	^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.21: 	def to_church: int -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ║        	                              ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.21: 	def to_church: int -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ╙──      	                              ^^
//│          = <no result>
//│            to_ch, to_church, to_ch, to_church, to_ch and zero are not implemented


def to_ch (n:int) =
  s (to_church n)
//│ to_ch: int -> (forall 'a. 'a -> (forall 'a, 'b, 'c, 'd. ('b -> 'c
//│   where
//│     forall 'M, 'e. ('M -> 'M) -> 'M -> 'M | 'e <: 'a -> ('b -> 'c & 'd))) | 'f)
//│      = <no result>
//│        to_church, to_ch, to_church, to_ch, to_church, to_ch and zero are not implemented

:e // * Since "sound extrusion"
to_church = to_ch
//│ int -> (forall 'a. 'a -> (forall 'a, 'b, 'c, 'd. ('b -> 'c
//│   where
//│     forall 'M, 'e. ('M -> 'M) -> 'M -> 'M | 'e <: 'a -> ('b -> 'c & 'd))) | 'f)
//│   <:  to_church:
//│ int -> (forall 'M. ('M -> 'M) -> 'M -> 'M)
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.342: 	to_church = to_ch
//│ ║         	^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.21: 	def to_church: int -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ║        	                              ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.21: 	def to_church: int -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ╙──      	                              ^^
//│          = <no result>
//│            to_ch, to_church, to_ch, to_church, to_ch, to_church, to_ch and zero are not implemented

// * Marking it `rec` (on a minimized version) makes it fail
// *  This is because of `destroyConstrainedTypes` which is invoked on rec defs:
// *  (disabling the destruction fixes this problem)

rec def to_ch n =
  s (to_church n)
//│ to_ch: (int & 'a) -> (forall 'b. 'b -> (forall 'b, 'c, 'd, 'e. ('c -> 'd
//│   where
//│     forall 'M, 'f. ('M -> 'M) -> 'M -> 'M | 'f <: 'b -> ('c -> 'd & 'e))) | 'g)
//│      = <no result>
//│        to_church, to_ch, to_church, to_ch, to_church, to_ch, to_church, to_ch and zero are not implemented

:e
to_church = to_ch
//│ (int & 'a) -> (forall 'b. 'b -> (forall 'c, 'd, 'e, 'b. ('c -> 'd
//│   where
//│     forall 'M, 'f. ('M -> 'M) -> 'M -> 'M | 'f <: 'b -> ('c -> 'd & 'e))) | 'g)
//│   <:  to_church:
//│ int -> (forall 'M. ('M -> 'M) -> 'M -> 'M)
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.373: 	to_church = to_ch
//│ ║         	^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.21: 	def to_church: int -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ║        	                              ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.21: 	def to_church: int -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ╙──      	                              ^^
//│          = <no result>
//│            to_ch, to_church, to_ch, to_church, to_ch, to_church, to_ch, to_church, to_ch and zero are not implemented


def to_ch =
  s (to_church 0)
//│ to_ch: 'a -> (forall 'a, 'b, 'c, 'd. ('b -> 'c
//│   where
//│     forall 'M. ('M -> 'M) -> 'M -> 'M <: 'a -> ('b -> 'c & 'd)))
//│      = <no result>
//│        to_church, to_ch, to_church, to_ch, to_church, to_ch, to_church, to_ch, to_church, to_ch and zero are not implemented

:e
to_church = to_ch
//│ 'a -> (forall 'a, 'b, 'c, 'd. ('b -> 'c
//│   where
//│     forall 'M. ('M -> 'M) -> 'M -> 'M <: 'a -> ('b -> 'c & 'd)))
//│   <:  to_church:
//│ int -> (forall 'M. ('M -> 'M) -> 'M -> 'M)
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.401: 	to_church = to_ch
//│ ║         	^^^^^^^^^^^^^^^^^
//│ ╟── type `int` is not a function
//│ ║  l.21: 	def to_church: int -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ║        	               ^^^
//│ ╟── Note: constraint arises from function type:
//│ ║  l.21: 	def to_church: int -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ╙──      	                                  ^^^^^^^^^^
//│          = <no result>
//│            to_ch, to_church, to_ch, to_church, to_ch, to_church, to_ch, to_church, to_ch, to_church, to_ch and zero are not implemented


// * But distributivity allows getting around the recursion limitation by recovering _some_ of the lost expressiveness
:DistributeForalls


rec def to_ch n =
  s (to_church n)
//│ to_ch: (int & 'a) -> (forall 'b. 'b -> (forall 'c, 'd, 'e, 'b. ('c -> 'd
//│   where
//│     forall 'f, 'M. ('M -> 'M) -> 'M -> 'M | 'f <: 'b -> ('c -> 'd & 'e))) | 'g)
//│      = <no result>
//│        to_church, to_ch, to_church, to_ch, to_church, to_ch, to_church, to_ch, to_church, to_ch, to_church, to_ch and zero are not implemented

to_church = to_ch
//│ (int & 'a) -> (forall 'b. 'b -> (forall 'b, 'c, 'd, 'e. ('c -> 'd
//│   where
//│     forall 'M, 'f. ('M -> 'M) -> 'M -> 'M | 'f <: 'b -> ('c -> 'd & 'e))) | 'g)
//│   <:  to_church:
//│ int -> (forall 'M. ('M -> 'M) -> 'M -> 'M)
//│          = <no result>
//│            to_ch, to_church, to_ch, to_church, to_ch, to_church, to_ch, to_church, to_ch, to_church, to_ch, to_church, to_ch and zero are not implemented


rec def to_ch n =
  if n == 0 then zero
  else succ (to_ch (n - 1))
//│ to_ch: 'to_ch
//│   where
//│     'to_ch :> forall 'a, 'b, 'to_ch, 'c, 'd. ((int & 'd) -> (ChurchInt | 'c)
//│   where
//│     'to_ch <: (int | 'b) -> (ChurchInt & 'a))
//│      = <no result>
//│        zero is not implemented

:e // * Since the removal of "recursive definition hacks"
to_church = to_ch
//│ 'to_ch
//│   where
//│     'to_ch :> forall 'a, 'b, 'c, 'to_ch, 'd. ((int & 'b) -> (ChurchInt | 'a)
//│   where
//│     'to_ch <: (int | 'd) -> (ChurchInt & 'c))
//│   <:  to_church:
//│ int -> (forall 'M. ('M -> 'M) -> 'M -> 'M)
//│ ╔══[ERROR] Cyclic-looking constraint while typing def definition; a type annotation may be required
//│ ║  l.454: 	to_church = to_ch
//│ ║         	^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  to_ch1183_1233'#  <:  ((α1191_1242',) -> α1192_1243')    TypeVariable  FunctionType
//│ ╙──  ... looks like:  to_ch1183'#  <:  ((α1191_1234'',) -> α1192_1235'')
//│          = <no result>
//│            to_ch and zero are not implemented


rec def to_ch n =
  if n == 0 then z
  else s (to_ch (n - 1))
//│ to_ch: 'to_ch
//│   where
//│     'to_ch :> forall 'a, 'to_ch, 'b, 'c, 'd. ((int & 'c) -> (forall 'e, 'f, 'g. ('e & 'f) -> (forall 'h, 'f, 'i, 'j, 'k, 'd. (('i & 'k) -> ('i | 'j)
//│   where
//│     'd <: 'f -> ('k -> 'j & 'h))) | 'g)
//│   where
//│     'to_ch <: (int | 'b) -> ('a & 'd))
//│      = [Function: to_ch7]

:e // * Since the removal of "recursive definition hacks"
to_church = to_ch
//│ 'to_ch
//│   where
//│     'to_ch :> forall 'a, 'b, 'to_ch, 'c, 'd. ((int & 'c) -> (forall 'e, 'f, 'g. ('e & 'f) -> (forall 'h, 'f, 'i, 'j, 'k, 'd. (('h & 'i) -> ('h | 'j)
//│   where
//│     'd <: 'f -> ('i -> 'j & 'k))) | 'g)
//│   where
//│     'to_ch <: (int | 'b) -> ('a & 'd))
//│   <:  to_church:
//│ int -> (forall 'M. ('M -> 'M) -> 'M -> 'M)
//│ ╔══[ERROR] Cyclic-looking constraint while typing def definition; a type annotation may be required
//│ ║  l.485: 	to_church = to_ch
//│ ║         	^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  to_ch1246_1348'#  <:  ((α1254_1367',) -> α1255_1368')    TypeVariable  FunctionType
//│ ╙──  ... looks like:  to_ch1246'#  <:  ((α1254_1349'',) -> α1255_1350'')
//│          = [Function: to_ch7]


rec def to_ch_weird n =
  s (to_ch_weird n)
//│ to_ch_weird: 'to_ch_weird
//│   where
//│     'to_ch_weird :> forall 'to_ch_weird, 'a, 'b, 'c, 'd. ('b -> (forall 'e. 'e -> (forall 'c, 'e, 'f, 'g, 'h. ('g -> 'h
//│   where
//│     'c <: 'e -> ('g -> 'h & 'f))) | 'd)
//│   where
//│     'to_ch_weird <: 'b -> ('a & 'c))
//│            = [Function: to_ch_weird]

:e // * Since the removal of "recursive definition hacks"
to_church = to_ch
//│ 'to_ch
//│   where
//│     'to_ch :> forall 'a, 'b, 'c, 'd, 'to_ch. ((int & 'd) -> (forall 'e, 'f, 'g. ('e & 'f) -> (forall 'h, 'f, 'a, 'i, 'j, 'k. (('h & 'i) -> ('h | 'j)
//│   where
//│     'a <: 'f -> ('i -> 'j & 'k))) | 'g)
//│   where
//│     'to_ch <: (int | 'c) -> ('b & 'a))
//│   <:  to_church:
//│ int -> (forall 'M. ('M -> 'M) -> 'M -> 'M)
//│ ╔══[ERROR] Cyclic-looking constraint while typing def definition; a type annotation may be required
//│ ║  l.516: 	to_church = to_ch
//│ ║         	^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  to_ch1246_1460'#  <:  ((α1254_1479',) -> α1255_1480')    TypeVariable  FunctionType
//│ ╙──  ... looks like:  to_ch1246'#  <:  ((α1254_1461'',) -> α1255_1462'')
//│          = [Function: to_ch7]


