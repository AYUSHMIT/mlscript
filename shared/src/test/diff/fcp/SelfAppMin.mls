:NoRecursiveTypes
:GeneralizeCurriedFunctions


class L
class A: { f: anything }
//│ Defined class L
//│ Defined class A



def eval eval x = case x of
  L -> 0,
  A -> eval eval x.f
//│ eval: ('a -> 'f -> 'b & 'a) -> ((A with {f: 'f}) | L) -> (0 | 'b)
//│     = [Function: eval]


:e
e = eval eval
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.20: 	e = eval eval
//│ ║        	    ^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 0. ‹∀ 1. (α9_24'' -> ‹∀ 2. (α10_28''' -> (0<int,number> | α16_32'''))›)››  <:  α9_72'    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 0. ‹∀ 1. (α9_24'' -> ‹∀ 2. (α10_28''' -> (0<int,number> | α16_32'''))›)››  <:  α9_24''
//│ e: (A & {f: A | L} | L) -> 0 | error
//│  = [Function (anonymous)]

e (A{f = L{}})
//│ res: 0 | error
//│    = 0


:e // TODO(oc) improve on `nothing`
e = eval eval!
//│ ╔══[ERROR] Inferred recursive type: nothing
//│ ║  l.14: 	  A -> eval eval x.f
//│ ╙──      	                 ^^^
//│ e: 'f -> 0
//│   where
//│     'f <: A & {f: 'f} | L
//│  = [Function (anonymous)]

:e // TODO(oc) improve on `nothing`
e (A{f = L{}})
//│ ╔══[ERROR] Inferred recursive type: nothing
//│ ║  l.14: 	  A -> eval eval x.f
//│ ╙──      	                 ^^^
//│ res: 0
//│    = 0

:e
// * Note: this computation will diverge
rec def v = A{f = v}
//│ ╔══[ERROR] Inferred recursive type: 'f
//│   where
//│     'f :> A with {f: 'f}
//│ ╙──
//│ v: 'f
//│   where
//│     'f :> A with {f: 'f}
//│  = [Function: v]

:e
e v
//│ ╔══[ERROR] Inferred recursive type: 'f
//│   where
//│     'f :> A with {f: 'f}
//│ ║  l.14: 	  A -> eval eval x.f
//│ ╙──      	                 ^^^
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.66: 	e v
//│ ║        	^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  (a<> & {f: f8_259})  <:  f17_242    ComposedType  TypeVariable
//│ ╙──  ... looks like:  (a<> & {f: f8_222'})  <:  f17_132'
//│ res: error | 0
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded

:RecursiveTypes

// * Note: Expected divergence
:re
e v
//│ res: 0
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded



def eval eval x = case x of
  L -> 0,
  A -> { x = eval eval x.f }
//│ eval: ('a -> 'f -> 'b & 'a) -> ((A with {f: 'f}) | L) -> (0 | {x: 'b})
//│     = [Function: eval1]


:e
e = eval eval
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.101: 	e = eval eval
//│ ║         	    ^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 0. ‹∀ 1. (α307_322'' -> ‹∀ 2. (α308_326''' -> (0<int,number> | {x: α314_330'''}))›)››  <:  α307_370'    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 0. ‹∀ 1. (α307_322'' -> ‹∀ 2. (α308_326''' -> (0<int,number> | {x: α314_330'''}))›)››  <:  α307_322''
//│ e: (A & {f: A | L} | L) -> (0 | {x: 0 | {x: nothing}}) | error
//│  = [Function (anonymous)]

:re
e v
//│ res: 0 | error | {x: 0 | {x: nothing}}
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded


e = eval eval!
//│ e: 'f -> 'a
//│   where
//│     'a :> 0 | {x: 'a}
//│     'f <: A & {f: 'f} | L
//│  = [Function (anonymous)]

:re
e v
//│ res: 'a
//│   where
//│     'a :> 0 | {x: 'a}
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded

