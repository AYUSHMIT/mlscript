:NoRecursiveTypes
:GeneralizeCurriedFunctions


def id_ty: forall 'a. 'a -> 'a
//│ id_ty: 'a -> 'a
//│      = <missing implementation>


rec def id x = let tmp = id x in x
//│ id: 'a -> 'a
//│   = [Function: id]

:re
id 1
//│ res: 1
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded

id_ty = id
//│ 'a -> 'a
//│   <:  id_ty:
//│ 'a -> 'a
//│      = [Function: id]


// * When we had the "recursive definition hacks", and the reason was:
// * "we get `'a <: 'a -> anything` because `id` is passed for `x`
// * and we can't infer polymorphic recursion, so all `x` should have the same type"
rec def id x = let tmp = id id x in x
//│ id: 'a -> 'a
//│   = [Function: id1]

:re
id 1
//│ res: 1
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded

id_ty = id
//│ 'a -> 'a
//│   <:  id_ty:
//│ 'a -> 'a
//│      = [Function: id1]


// * Not sure why we get a cycle in this slight variation!
:e
rec def id x = if true then x else id id x
//│ ╔══[ERROR] Inferred recursive type: 'a
//│   where
//│     'a :> forall 'b, 'c. 'b -> 'c
//│        <: 'd -> 'a
//│     'b <: 'd & 'c
//│     'd :> forall 'b, 'c. 'b -> 'c
//│        <: 'a
//│     'c :> 'a
//│ ║  l.49: 	rec def id x = if true then x else id id x
//│ ╙──      	                                   ^^^^^
//│ ╔══[ERROR] Cyclic-looking constraint while typing binding of lambda expression; a type annotation may be required
//│ ║  l.49: 	rec def id x = if true then x else id id x
//│ ║        	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 1. (α109_119'' -> α118_121'')›  <:  α109_125'    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 1. (α109_119'' -> α118_121'')›  <:  α109_119''
//│ ╔══[ERROR] Cyclic-looking constraint while typing binding of lambda expression; a type annotation may be required
//│ ║  l.49: 	rec def id x = if true then x else id id x
//│ ║        	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 1. (α109_119'' -> α118_121'')›  <:  α109_125'    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 1. (α109_119'' -> α118_121'')›  <:  α109_119''
//│ ╔══[ERROR] Cyclic-looking constraint while typing binding of lambda expression; a type annotation may be required
//│ ║  l.49: 	rec def id x = if true then x else id id x
//│ ║        	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 1. (α109_119'' -> α118_121'')›  <:  α114'    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 1. (α109_119'' -> α118_121'')›  <:  α114'
//│ ╔══[ERROR] Cyclic-looking constraint while typing binding of lambda expression; a type annotation may be required
//│ ║  l.49: 	rec def id x = if true then x else id id x
//│ ║        	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 1. (α109_119'' -> α118_121'')›  <:  α114'    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 1. (α109_119'' -> α118_121'')›  <:  α114'
//│ id: 'id
//│   where
//│     'id :> forall 'a. ('b & 'a) -> 'a
//│     'a :> 'c
//│     'b :> 'id
//│        <: 'c
//│     'c :> 'id
//│        <: 'b -> 'c
//│   = [Function: id2]

:e
id_ty = id
//│ ╔══[ERROR] Inferred recursive type: 'a
//│   where
//│     'a :> 'b
//│     'b :> forall 'a, 'c. 'c -> 'a | ‘a_209
//│        <: 'd -> 'b & ‘a_209
//│     'c <: 'a & 'd
//│     'd :> forall 'a, 'c. 'c -> 'a | ‘a_209
//│        <: 'b
//│ ║  l.49: 	rec def id x = if true then x else id id x
//│ ╙──      	                  ^^^^^^^^^^^^^^^^^^^^^^^^
//│ 'id
//│   where
//│     'id :> forall 'a. ('b & 'a) -> 'a
//│     'a :> 'c
//│     'b :> 'id
//│        <: 'c
//│     'c :> 'id
//│        <: 'b -> 'c
//│   <:  id_ty:
//│ 'a -> 'a
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.95: 	id_ty = id
//│ ║        	^^^^^^^^^^
//│ ╟── type `‘a_209` is not a function
//│ ║  l.5: 	def id_ty: forall 'a. 'a -> 'a
//│ ║       	                  ^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.49: 	rec def id x = if true then x else id id x
//│ ║        	                                   ^^^^^^^
//│ ╟── from reference:
//│ ║  l.49: 	rec def id x = if true then x else id id x
//│ ╙──      	                                         ^
//│      = [Function: id2]


