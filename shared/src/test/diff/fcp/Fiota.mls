
// On the Power of Coercion Abstraction

S x y z = x z (y z)
//│ S: ('a -> 'b -> 'c) -> ('a -> 'b) -> 'a -> 'c
//│  = [Function: S]

type S1 = ('a -> 'b -> 'c) -> ('a -> 'b) -> 'a -> 'c
//│ Defined type alias S1

type S2 = (forall 'a. 'a -> 'a) -> (forall 'a. 'a -> 'a) -> (forall 'a. 'a -> 'a) -> (forall 'a. 'a -> 'a)
//│ Defined type alias S2

s1 = S: S1
//│ s1: S1
//│   = [Function: S]

s1: S2
//│ res: S2
//│    = [Function: S]

s2 = S: S2
//│ s2: S2
//│   = [Function: S]

:e // * S2 is less genetral than S1
s2: S1
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.27: 	s2: S1
//│ ║        	^^
//│ ╟── type `‘a_86` is not an instance of type `'a_83`
//│ ║  l.11: 	type S2 = (forall 'a. 'a -> 'a) -> (forall 'a. 'a -> 'a) -> (forall 'a. 'a -> 'a) -> (forall 'a. 'a -> 'a)
//│ ║        	                  ^^
//│ ╟── Note: constraint arises from type variable:
//│ ║  l.8: 	type S1 = ('a -> 'b -> 'c) -> ('a -> 'b) -> 'a -> 'c
//│ ╙──     	           ^^
//│ res: S1
//│    = [Function: S]


type Id = forall 'a. 'a -> 'a
//│ Defined type alias Id

:e // TODO: could probably use different type var shadows from different type alias occurrences
S: Id -> Id -> Id -> Id
//│ ╔══[ERROR] Cyclic-looking constraint while typing type ascription; a type annotation may be required
//│ ║  l.45: 	S: Id -> Id -> Id -> Id
//│ ║        	^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  Id  <:  'a87_98    TypeRef  TypeVariable
//│ ╙──  ... looks like:  Id  <:  'a87_88''
//│ res: Id -> Id -> Id -> Id
//│    = [Function: S]


