:GeneralizeCurriedFunctions
:NoRecursiveTypes



// On the Power of Coercion Abstraction

S x y z = x z (y z)
//│ S: ('a -> 'b -> 'c) -> (forall 'd. ('d -> 'b) -> ('a & 'd) -> 'c)
//│  = [Function: S]

type S1 = ('a -> 'b -> 'c) -> ('a -> 'b) -> 'a -> 'c
//│ Defined type alias S1

type S2 = (forall 'a. 'a -> 'a) -> (forall 'a. 'a -> 'a) -> (forall 'a. 'a -> 'a) -> (forall 'a. 'a -> 'a)
//│ Defined type alias S2

s1 = S: S1
//│ s1: S1
//│   = [Function: S]

s1: S2
//│ res: S2
//│    = [Function: S]

:e
s2 = S: S2
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.27: 	s2 = S: S2
//│ ║        	     ^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.15: 	type S2 = (forall 'a. 'a -> 'a) -> (forall 'a. 'a -> 'a) -> (forall 'a. 'a -> 'a) -> (forall 'a. 'a -> 'a)
//│ ║        	                                                                                             ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.15: 	type S2 = (forall 'a. 'a -> 'a) -> (forall 'a. 'a -> 'a) -> (forall 'a. 'a -> 'a) -> (forall 'a. 'a -> 'a)
//│ ╙──      	                                                                                             ^^
//│ s2: S2
//│   = [Function: S]

:e // * S2 is less genetral than S1
s2: S1
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.41: 	s2: S1
//│ ║        	^^
//│ ╟── type `‘a_145` is not an instance of type `'a_142`
//│ ║  l.15: 	type S2 = (forall 'a. 'a -> 'a) -> (forall 'a. 'a -> 'a) -> (forall 'a. 'a -> 'a) -> (forall 'a. 'a -> 'a)
//│ ║        	                  ^^
//│ ╟── Note: constraint arises from type variable:
//│ ║  l.12: 	type S1 = ('a -> 'b -> 'c) -> ('a -> 'b) -> 'a -> 'c
//│ ╙──      	           ^^
//│ res: S1
//│    = [Function: S]


type Id = forall 'a. 'a -> 'a
//│ Defined type alias Id

:e // TODO: could probably use different type var shadows from different type alias occurrences
S: Id -> Id -> Id -> Id
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.59: 	S: Id -> Id -> Id -> Id
//│ ║        	^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.55: 	type Id = forall 'a. 'a -> 'a
//│ ║        	                 ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.55: 	type Id = forall 'a. 'a -> 'a
//│ ╙──      	                 ^^
//│ res: Id -> Id -> Id -> Id
//│    = [Function: S]


