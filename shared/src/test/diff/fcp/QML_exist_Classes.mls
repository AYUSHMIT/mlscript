// * Adaptation of QML's original existentials example; using encoded existentials and classes


:NoRecursiveTypes
:GeneralizeCurriedFunctions
// :DistributeForalls
// :ArgGen
// :NoConstrainedTypes

// TODO with :NoRecursiveTypes
// TODO without some signatures



class ArraysRep[A, Rep]
  method Init: A -> Rep
  method Sub: Rep -> int -> A
  method Update: Rep -> int -> A -> Rep
  method Fold: (A -> 'b -> 'b) -> 'b -> Rep -> 'b
//│ Defined class ArraysRep[=A, =Rep]
//│ Declared ArraysRep.Init: ArraysRep['A, 'Rep] -> 'A -> 'Rep
//│ Declared ArraysRep.Sub: ArraysRep['A, 'Rep] -> 'Rep -> int -> 'A
//│ Declared ArraysRep.Update: ArraysRep['A, 'Rep] -> 'Rep -> int -> 'A -> 'Rep
//│ Declared ArraysRep.Fold: ArraysRep['A, 'Rep] -> ('A -> 'b -> 'b) -> 'b -> 'Rep -> 'b

class ArraysImpl[A, Rep]: ArraysRep[A, Rep] & {
    init: A -> Rep;
    sub: Rep -> int -> A;
    update: Rep -> int -> A -> Rep;
    fold: forall 'b. (A -> 'b -> 'b) -> 'b -> Rep -> 'b
  }
  method Init = this.init
  method Sub = this.sub
  method Update = this.update
  method Fold = this.fold
//│ Defined class ArraysImpl[=A, =Rep]
//│ Defined ArraysImpl.Init: ArraysImpl['A, 'Rep] -> 'A -> 'Rep
//│ Defined ArraysImpl.Sub: ArraysImpl['A, 'Rep] -> 'Rep -> int -> 'A
//│ Defined ArraysImpl.Update: ArraysImpl['A, 'Rep] -> 'Rep -> int -> 'A -> 'Rep
//│ Defined ArraysImpl.Fold: ArraysImpl['A, 'Rep] -> (forall 'b. ('A -> 'b -> 'b) -> 'b -> 'Rep -> 'b)

type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ Defined type alias Arrays[=A]



baseImpl = ArraysImpl {
    init   = fun a -> a;
    sub    = fun r -> fun (i : int) -> r;
    update = fun r -> fun (i : int) -> fun a -> a;
    fold   = fun f -> fun b -> fun r -> f r b
  }
//│ baseImpl: ArraysImpl['Rep, 'Rep] with {fold: forall 'a. 'a -> (forall 'b. 'b -> (forall 'a, 'c, 'd, 'e, 'b. ('e -> 'd
//│   where
//│     'a <: 'e -> ('b -> 'd & 'c)))), init: forall 'f. 'f -> 'f, sub: forall 'g. 'g -> int -> 'g, update: forall 'h. 'h -> int -> (forall 'i. 'i -> 'i)}
//│         = ArraysImpl {
//│             init: [Function: init],
//│             sub: [Function: sub],
//│             update: [Function: update],
//│             fold: [Function: fold]
//│           }

def base: Arrays['a]
def base f = f baseImpl
//│ base: Arrays['a]
//│     = <missing implementation>
//│ ((forall 'Rep. ArraysImpl['Rep, 'Rep] with {fold: forall 'a. 'a -> (forall 'b. 'b -> (forall 'a, 'c, 'd, 'e, 'b. ('c -> 'd
//│   where
//│     'a <: 'c -> ('b -> 'd & 'e)))), init: forall 'f. 'f -> 'f, sub: forall 'g. 'g -> int -> 'g, update: forall 'h. 'h -> int -> (forall 'i. 'i -> 'i)}) -> 'j & 'k) -> 'j
//│   <:  base:
//│ Arrays['a]
//│     = [Function: base]



def simpleStepImpl arrImpl = ArraysImpl {
    init   = fun a -> (arrImpl.Init a, "initialized");
    sub    = fun ((r0, r1)) -> fun i -> arrImpl.Sub r0 i;
    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.Update r0 i a, "updated");
    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f b r0
  }
//│ simpleStepImpl: (ArraysRep[in 'A | 'A0 | 'A1 & 'A2 out 'A & 'A0 & 'A3 & ('A2 | 'A4), in 'Rep | 'a & 'c & 'd & 'e & 'Rep0 & 'Rep1 | 'a & 'c & 'e & 'Rep0 & 'f & 'Rep2 | 'Rep3 out 'Rep2 & ('a | 'Rep) & ('c | 'Rep1) & ('Rep0 | 'Rep3 | 'Rep4)] & 'g) -> ((ArraysImpl['A1, 'Rep5] with {fold: forall 'h. 'h -> (forall 'i. 'i -> (forall 'A5, 'j, 'i, 'b, 'g, 'Rep6, 'k, 'h, 'l. (('Rep6 & 'k, 'j,) -> ('i | 'l)
//│   where
//│     'h <: 'A5 -> ('b | 'i) -> ('b & 'l)
//│     'g <: ArraysRep['A5, 'Rep6]))) | 'fold, init: forall 'init, 'm, 'A6, 'n, 'Rep7, 'g. (('A6 & 'm) -> ('n, "initialized",) | 'init
//│   where
//│     'g <: ArraysRep['A6, 'Rep7]), sub: forall 'o, 'p. ('o, 'p,) -> (forall 'q, 'A7, 'r, 'g, 'Rep8, 'o. ((int & 'r) -> 'q
//│   where
//│     'g <: ArraysRep['A7, 'Rep8])) | 'sub, update: forall 's, 't. ('s, 't,) -> (forall 'r, 'u. (int & 'u & 'r) -> (forall 'A8, 'Rep9, 'v, 's, 'w, 'g. (('A8 & 'w) -> ('s | 'v, "updated",)
//│   where
//│     'g <: ArraysRep['A8, 'Rep9]))) | 'update}) | 'x)
//│   where
//│     'Rep9 :> 's
//│           <: 'v
//│     'Rep8 :> 'o
//│     'A7 <: 'q
//│     'Rep7 <: 'n
//│     'Rep5 :> ('f | 'c | 'd, "initialized" | "updated",)
//│           <: ('a & 'c & 'e & 'Rep0, 'y & 'z & 'a1,)
//│     'A1 <: 'b1 & 'A & 'c1 & 'A0
//│               = [Function: simpleStepImpl]

simpleStepImpl : ArraysImpl['a, 'r] -> ArraysImpl['a, ('r, string)]
//│ res: ArraysImpl['a, 'r] -> ArraysImpl['a, ('r, string,)]
//│    = [Function: simpleStepImpl]

// def simpleStepImpl2_ty: Arrays['a] -> ArraysImpl['a, ('_, string)]
// def simpleStepImpl2_ty: Arrays['a] -> ArraysImpl['a, '_]
// def simpleStepImpl2 arr = arr simpleStepImpl

def simpleStepImpl2_ty: (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, string)]
//│ simpleStepImpl2_ty: (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, string,)]
//│                   = <missing implementation>


def simpleStepImpl2 arr = arr simpleStepImpl
//│ simpleStepImpl2: ((forall 'a, 'A, 'c, 'A0, 'Rep, 'd, 'Rep0, 'e, 'A1, 'f, 'A2, 'A3, 'Rep1, 'fold, 'g, 'Rep2, 'h, 'i, 'Rep3, 'Rep4, 'Rep5, 'update, 'A4, 'j, 'sub, 'k, 'l, 'm. (ArraysRep[in 'A0 | 'A2 | 'A4 & 'A1 out 'A0 & 'A2 & 'A3 & ('A1 | 'A), in 'Rep | 'j & 'a & 'f & 'e & 'Rep2 & 'Rep0 | 'j & 'a & 'e & 'Rep2 & 'm & 'Rep1 | 'Rep4 out 'Rep1 & ('j | 'Rep) & ('a | 'Rep0) & ('Rep2 | 'Rep4 | 'Rep3)] & 'i) -> ((ArraysImpl['A4, 'Rep5] with {fold: forall 'n. 'n -> (forall 'o. 'o -> (forall 'b, 'Rep6, 'o, 'p, 'A5, 'q, 'i, 'n, 'r. (('Rep6 & 'r, 'q,) -> ('o | 'p)
//│   where
//│     'n <: 'A5 -> ('b | 'o) -> ('b & 'p)
//│     'i <: ArraysRep['A5, 'Rep6]))) | 'fold, init: forall 's, 'Rep7, 'init, 'A6, 'i, 't. (('A6 & 't) -> ('s, "initialized",) | 'init
//│   where
//│     'i <: ArraysRep['A6, 'Rep7]), sub: forall 'u, 'v. ('u, 'v,) -> (forall 'A7, 'i, 'w, 'Rep8, 'u, 'x. ((int & 'x) -> 'w
//│   where
//│     'i <: ArraysRep['A7, 'Rep8])) | 'sub, update: forall 'y, 'z. ('y, 'z,) -> (forall 'x, 'a1. (int & 'a1 & 'x) -> (forall 'b1, 'c1, 'i, 'y, 'Rep9, 'A8. (('A8 & 'b1) -> ('y | 'c1, "updated",)
//│   where
//│     'i <: ArraysRep['A8, 'Rep9]))) | 'update}) | 'l)) -> 'd1 & 'e1) -> 'd1
//│   where
//│     'Rep9 :> 'y
//│           <: 'c1
//│     'Rep8 :> 'u
//│     'A7 <: 'w
//│     'Rep7 <: 's
//│     'Rep5 :> ('m | 'a | 'f, "initialized" | "updated",)
//│           <: ('j & 'a & 'e & 'Rep2, 'k & 'g & 'h,)
//│     'A4 <: 'c & 'A0 & 'd & 'A2
//│                = [Function: simpleStepImpl2]

simpleStepImpl2_ty = simpleStepImpl2
//│ ((forall 'fold, 'A, 'a, 'Rep, 'c, 'd, 'Rep0, 'e, 'Rep1, 'f, 'Rep2, 'g, 'Rep3, 'Rep4, 'update, 'h, 'i, 'j, 'A0, 'A1, 'Rep5, 'A2, 'A3, 'A4, 'k, 'sub, 'l, 'm. (ArraysRep[in 'A1 | 'A | 'A3 & 'A4 out 'A0 & 'A1 & 'A & ('A4 | 'A2), in 'Rep2 | 'e & 'a & 'h & 'g & 'Rep0 & 'Rep3 | 'e & 'a & 'g & 'Rep0 & 'i & 'Rep5 | 'Rep out ('e | 'Rep2) & ('a | 'Rep3) & 'Rep5 & ('Rep0 | 'Rep | 'Rep1)] & 'd) -> ((ArraysImpl['A3, 'Rep4] with {fold: forall 'n. 'n -> (forall 'o. 'o -> (forall 'b, 'Rep6, 'p, 'A5, 'q, 'o, 'r, 'n, 'd. (('Rep6 & 'q, 'p,) -> ('o | 'r)
//│   where
//│     'd <: ArraysRep['A5, 'Rep6]
//│     'n <: 'A5 -> ('b | 'o) -> ('b & 'r)))) | 'fold, init: forall 'init, 'A6, 'd, 'Rep7, 's, 't. (('A6 & 't) -> ('s, "initialized",) | 'init
//│   where
//│     'd <: ArraysRep['A6, 'Rep7]), sub: forall 'u, 'v. ('u, 'v,) -> (forall 'w, 'u, 'Rep8, 'd, 'x, 'A7. ((int & 'w) -> 'x
//│   where
//│     'd <: ArraysRep['A7, 'Rep8])) | 'sub, update: forall 'y, 'z. ('y, 'z,) -> (forall 'w, 'a1. (int & 'a1 & 'w) -> (forall 'd, 'y, 'b1, 'A8, 'c1, 'Rep9. (('A8 & 'c1) -> ('y | 'b1, "updated",)
//│   where
//│     'd <: ArraysRep['A8, 'Rep9]))) | 'update}) | 'm)) -> 'd1 & 'e1) -> 'd1
//│   where
//│     'Rep9 :> 'y
//│           <: 'b1
//│     'Rep8 :> 'u
//│     'A7 <: 'x
//│     'Rep7 <: 's
//│     'Rep4 :> ('i | 'a | 'h, "initialized" | "updated",)
//│           <: ('e & 'a & 'g & 'Rep0, 'l & 'j & 'c,)
//│     'A3 <: 'f & 'A1 & 'k & 'A
//│   <:  simpleStepImpl2_ty:
//│ (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, string,)]
//│                   = [Function: simpleStepImpl2]

:e // * Annotation is actually counter-productive... probably because the rigid universal in Arrays gets extruded!
def simpleStepImpl2_ty (arr: Arrays['a]) = arr simpleStepImpl
//│ Arrays['a] -> ((ArraysImpl[in 'a0 & 'A & 'c & 'A0 & 'd & 'A1 out 'a0 | 'A | 'A2, in (nothing, 'e & 'f & 'g,) & 'Rep out (anything, "initialized" | "updated",) | 'Rep | 'Rep0] with {fold: forall 'h. 'h -> (forall 'i. 'i -> (forall 'j, 'k, 'a0, 'i, 'A3, 'l, 'b, 'm, 'Rep1, 'h. (('Rep1 & 'k, 'm,) -> ('l | 'i)
//│   where
//│     ArraysRep['a0, ?] | 'j <: ArraysRep['A3, 'Rep1]
//│     'h <: 'A3 -> ('b | 'i) -> ('b & 'l)))) | 'fold, init: forall 'n, 'j, 'a0, 'Rep2, 'o, 'A4, 'init. (('A4 & 'o) -> ('n, "initialized",) | 'init
//│   where
//│     ArraysRep['a0, ?] | 'j <: ArraysRep['A4, in 'Rep2 & 'n out 'Rep2]), sub: forall 'p, 'q. ('p, 'q,) -> (forall 'Rep3, 'j, 'p, 'A5, 'r, 'a0, 's. ((int & 's) -> 'r
//│   where
//│     ArraysRep['a0, ?] | 'j <: ArraysRep[in 'A5 & 'r out 'A5, in 'Rep3 out 'Rep3 | 'p])) | 'sub, update: forall 't, 'u. ('t, 'u,) -> (forall 's, 'v. (int & 'v & 's) -> (forall 'j, 'a0, 'w, 't, 'Rep4, 'x, 'A6. (('A6 & 'x) -> ('w | 't, "updated",)
//│   where
//│     ArraysRep['a0, ?] | 'j <: ArraysRep['A6, in 'Rep4 & 'w out 'Rep4 | 't]))) | 'update}) | 'y)
//│   <:  simpleStepImpl2_ty:
//│ (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, string,)]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.163: 	def simpleStepImpl2_ty (arr: Arrays['a]) = arr simpleStepImpl
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘Rep_1662` does not match type `nothing`
//│ ║  l.111: 	def simpleStepImpl2_ty: (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, string)]
//│ ║         	                                                                                          ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.42: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.78: 	    sub    = fun ((r0, r1)) -> fun i -> arrImpl.Sub r0 i;
//│ ╙──      	                                                    ^^
//│                   = [Function: simpleStepImpl2_ty1]

def simpleStep: Arrays['a] -> Arrays['a]
//│ simpleStep: Arrays['a] -> Arrays['a]
//│           = <missing implementation>

:e // * Since "sound extrusion"
def simpleStep arr f = f (simpleStepImpl2 arr)
//│ 'a -> (forall 'c, 'd, 'e, 'a, 'f. (('d -> 'e & 'f) -> 'e
//│   where
//│     'a <: (forall 'g, 'h, 'sub, 'i, 'j, 'Rep, 'Rep0, 'A, 'k, 'Rep1, 'l, 'A0, 'm, 'Rep2, 'A1, 'n, 'o, 'A2, 'fold, 'Rep3, 'p, 'Rep4, 'Rep5, 'A3, 'q, 'A4, 'update, 'r. (ArraysRep[in 'A2 | 'A0 | 'A3 & 'A out 'A4 & 'A2 & 'A0 & ('A | 'A1), in 'Rep4 | 'r & 'o & 'n & 'k & 'Rep0 & 'Rep1 | 'r & 'o & 'k & 'Rep0 & 'm & 'Rep3 | 'Rep5 out ('r | 'Rep4) & ('o | 'Rep1) & 'Rep3 & ('Rep0 | 'Rep5 | 'Rep)] & 'g) -> ((ArraysImpl['A3, 'Rep2] with {fold: forall 's. 's -> (forall 't. 't -> (forall 'g, 'Rep6, 'u, 'A5, 'b, 'v, 's, 'w, 't. (('Rep6 & 'u, 'w,) -> ('t | 'v)
//│   where
//│     's <: 'A5 -> ('b | 't) -> ('b & 'v)
//│     'g <: ArraysRep['A5, 'Rep6]))) | 'fold, init: forall 'g, 'x, 'y, 'init, 'Rep7, 'A6. (('A6 & 'x) -> ('y, "initialized",) | 'init
//│   where
//│     'g <: ArraysRep['A6, 'Rep7]), sub: forall 'z, 'a1. ('z, 'a1,) -> (forall 'g, 'A7, 'b1, 'z, 'c1, 'Rep8. ((int & 'c1) -> 'b1
//│   where
//│     'g <: ArraysRep['A7, 'Rep8])) | 'sub, update: forall 'd1, 'e1. ('d1, 'e1,) -> (forall 'f1, 'c1. (int & 'f1 & 'c1) -> (forall 'g, 'g1, 'h1, 'Rep9, 'd1, 'A8. (('A8 & 'g1) -> ('d1 | 'h1, "updated",)
//│   where
//│     'g <: ArraysRep['A8, 'Rep9]))) | 'update}) | 'q)) -> ('c & 'd)))
//│   where
//│     'Rep9 :> 'd1
//│           <: 'h1
//│     'Rep8 :> 'z
//│     'A7 <: 'b1
//│     'Rep7 <: 'y
//│     'Rep2 :> ('m | 'o | 'n, "initialized" | "updated",)
//│           <: ('r & 'o & 'k & 'Rep0, 'l & 'h & 'j,)
//│     'A3 <: 'p & 'A2 & 'i & 'A0
//│   <:  simpleStep:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.195: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.42: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.42: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.78: 	    sub    = fun ((r0, r1)) -> fun i -> arrImpl.Sub r0 i;
//│ ╙──      	                                                    ^^
//│           = [Function: simpleStep]

:e // TODO update: seems like the given type for `simpleStepImpl2_ty` is not precise enough
def simpleStep arr f = f (simpleStepImpl2_ty arr)
//│ 'a -> (forall 'b, 'a, 'c, 'A, 'Rep, 'd. (((ArraysImpl['A, ('Rep, string,)] | 'd) -> 'b & 'c) -> 'b
//│   where
//│     'a <: forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r))
//│   <:  simpleStep:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.234: 	def simpleStep arr f = f (simpleStepImpl2_ty arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.42: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.42: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│           = [Function: simpleStep1]

sb = simpleStep base
//│ sb: Arrays['a]
//│   = [Function (anonymous)]

sb (fun arr -> arr.Init true)
//│ res: anything
//│    = [ true, 'initialized' ]

sb (fun arr -> arr.Sub (arr.Init true) 1)
//│ res: true
//│    = true

:e // * Expected – argument order confusion
sb (fun arr -> arr.Sub 0 (arr.Init true))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.264: 	sb (fun arr -> arr.Sub 0 (arr.Init true))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘Rep_2202` is not an instance of type `int`
//│ ║  l.42: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.17: 	  method Sub: Rep -> int -> A
//│ ║        	                     ^^^
//│ ╟── from application:
//│ ║  l.264: 	sb (fun arr -> arr.Sub 0 (arr.Init true))
//│ ║         	                          ^^^^^^^^^^^^^
//│ ╟── Note: class type parameter Rep is defined at:
//│ ║  l.15: 	class ArraysRep[A, Rep]
//│ ╙──      	                   ^^^
//│ res: error
//│ Runtime error:
//│   TypeError: number 0 is not iterable (cannot read property Symbol(Symbol.iterator))

sb (fun arr -> arr.Update (arr.Init true) 1 false)
//│ res: anything
//│    = [ false, 'updated' ]

:e // * Rightly prevent skolem confusion
sb (fun arr1 -> sb (fun arr2 -> arr2.Update (arr1.Init true)))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.289: 	sb (fun arr1 -> sb (fun arr2 -> arr2.Update (arr1.Init true)))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘Rep_2309` does not match type `nothing`
//│ ║  l.42: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.42: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from application:
//│ ║  l.289: 	sb (fun arr1 -> sb (fun arr2 -> arr2.Update (arr1.Init true)))
//│ ╙──       	                                             ^^^^^^^^^^^^^^
//│ res: error
//│    = [Function (anonymous)]

sb (fun arr ->
    let r2 = arr.Update (arr.Init true) 1 false
    in (arr.Sub r2 0, arr.Sub r2 1)
  )
//│ res: (bool, bool,)
//│    = [ false, false ]



:escape
def Math: nothing
//│ Math: nothing
//│     = <missing implementation>

def div: int -> int -> int
def div a b = Math.trunc(a/b)
//│ div: int -> int -> int
//│    = <missing implementation>
//│ (number & 'a & 'b) -> (forall 'b, 'c. (number & 'b) -> 'c)
//│   <:  div:
//│ int -> int -> int
//│    = [Function: div1]

def mod: int -> int -> int
rec def mod a b = if a < b then a else mod (a - b) b
//│ mod: int -> int -> int
//│    = <missing implementation>
//│ int -> int -> int
//│   <:  mod:
//│ int -> int -> int
//│    = [Function: mod]

def stepImpl arrImpl = ArraysImpl {
    init = fun a -> (arrImpl.Init a, arrImpl.Init a);
    sub = fun ((r0, r1)) -> fun i ->
      if mod i 2 == 0
      then arrImpl.Sub r0 (div i 2)
      else arrImpl.Sub r1 (div i 2);
    update = fun ((r0, r1)) -> fun i -> fun a ->
      if mod i 2 == 0
      then (arrImpl.Update r0 (div i 2) a, r1)
      else (r0, arrImpl.Update r1 (div i 2) a);
    fold = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f (arrImpl.Fold f b r0) r1
  }
//│ stepImpl: (ArraysRep[in 'A | 'A0 | 'A1 | 'A2 | 'a & 'c & 'A3 & 'd & 'A4 | 'A3 & ('A5 | 'A6) out 'A & 'A0 & 'A1 & 'A2 & 'A4 & 'A7 & ('A5 & ('A6 | 'A8) | 'A9 & ('A6 | 'A8)), in 'Rep | 'Rep0 | 'e & 'f & 'g & 'h & 'Rep1 & 'Rep2 & 'Rep3 | 'i & 'j & 'k & 'l & 'Rep4 & 'Rep5 & 'Rep6 | 'e & 'f & 'h & 'Rep1 & 'Rep2 & 'm & 'Rep7 | 'i & 'j & 'l & 'Rep4 & 'Rep5 & 'n & 'Rep8 | 'Rep9 | 'Rep10 out ('e | 'Rep) & ('i | 'Rep0) & ('f | 'Rep3) & 'Rep2 & ('j | 'Rep6) & 'Rep5 & 'Rep7 & 'Rep8] & 'o) -> ((ArraysImpl['A3, 'Rep11] with {fold: forall 'p. 'p -> (forall 'q. 'q -> (forall 'Rep12, 'r, 'p, 'Rep13, 'q, 's, 'A10, 'A11, 'b, 't, 'b0, 'u, 'o. (('Rep13 & 'u, 'Rep12 & 's,) -> ('q | 'r)
//│   where
//│     'o <: ArraysRep['A11, 'Rep12] & ArraysRep['A10, 'Rep13]
//│     'p <: 'A11 -> ('b0 | 'q) -> ('b0 & 'r) & 'A10 -> ('b | 'q) -> ('b0 & 'r & 'b & 't)))) | 'fold, init: forall 'A12, 'Rep14, 'A13, 'Rep15, 'v, 'w, 'init, 'x, 'o. (('A13 & 'A12 & 'w) -> ('x, 'v,) | 'init
//│   where
//│     'o <: ArraysRep['A13, 'Rep15] & ArraysRep['A12, 'Rep14]), sub: forall 'y, 'z. ('y, 'z,) -> (forall 'a1, 'b1, 'A14, 'A15, 'c1, 'y, 'd1, 'Rep16, 'e1, 'o, 'z, 'Rep17. ((int & 'b1) -> 'd1
//│   where
//│     'o <: ArraysRep['A15, 'Rep17] & ArraysRep['A14, 'Rep16])) | 'sub, update: forall 'f1, 'g1. ('f1, 'g1,) -> (forall 'h1, 'b1. (int & 'h1 & 'b1) -> (forall 'i1, 'j1, 'Rep18, 'k1, 'f1, 'Rep19, 'A16, 'l1, 'g1, 'A17, 'o. (('A16 & 'A17 & 'k1) -> (('f1 | 'i1, 'g1 | 'j1,) | 'l1)
//│   where
//│     'o <: ArraysRep['A16, 'Rep18] & ArraysRep['A17, 'Rep19]))) | 'update}) | 'm1)
//│   where
//│     'Rep19 :> 'g1
//│            <: 'j1
//│     'Rep18 :> 'f1
//│            <: 'i1
//│     'Rep16 :> 'z
//│     'A14 <: 'e1 & 'd1 & 'c1
//│     'Rep17 :> 'y
//│     'A15 <: 'a1 & 'e1 & 'd1
//│     'Rep14 <: 'v
//│     'Rep15 <: 'x
//│     'Rep11 :> ('n | 'j | 'k, 'm | 'f | 'g,)
//│            <: ('i & 'j & 'l & 'Rep4 & 'Rep5, 'e & 'f & 'h & 'Rep1 & 'Rep2,)
//│     'A3 <: 'n1 & 'A & 'A0 & 'o1 & 'A1 & 'A2
//│         = [Function: stepImpl]

def stepImpl2_ty: (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, 'Rep)]
//│ stepImpl2_ty: (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, 'Rep,)]
//│             = <missing implementation>

def stepImpl2 arr = arr stepImpl
//│ stepImpl2: ((forall 'sub, 'Rep, 'a, 'fold, 'Rep0, 'c, 'd, 'Rep1, 'e, 'Rep2, 'Rep3, 'f, 'g, 'Rep4, 'A, 'update, 'Rep5, 'h, 'A0, 'A1, 'i, 'j, 'Rep6, 'k, 'l, 'm, 'Rep7, 'A2, 'n, 'Rep8, 'A3, 'o, 'A4, 'Rep9, 'p, 'A5, 'A6, 'q, 'A7, 'A8, 'Rep10, 'Rep11, 'r, 'A9. (ArraysRep[in 'A0 | 'A2 | 'A4 | 'A8 | 'a & 'd & 'A7 & 'f & 'A | 'A7 & ('A6 | 'A5) out 'A0 & 'A2 & 'A4 & 'A8 & 'A & 'A3 & ('A1 & ('A6 | 'A9) | 'A5 & ('A6 | 'A9)), in 'Rep7 | 'Rep1 | 'j & 'k & 'p & 'l & 'Rep9 & 'Rep3 & 'Rep11 | 'n & 'h & 'g & 'e & 'Rep8 & 'Rep & 'Rep0 | 'j & 'k & 'l & 'Rep9 & 'Rep3 & 'm & 'Rep5 | 'n & 'h & 'e & 'Rep8 & 'Rep & 'r & 'Rep2 | 'Rep4 | 'Rep6 out ('j | 'Rep7) & ('n | 'Rep1) & ('k | 'Rep11) & 'Rep3 & ('h | 'Rep0) & 'Rep & 'Rep5 & 'Rep2] & 'o) -> ((ArraysImpl['A7, 'Rep10] with {fold: forall 's. 's -> (forall 't. 't -> (forall 'u, 't, 'b, 'Rep12, 's, 'o, 'v, 'A10, 'b0, 'w, 'Rep13, 'x, 'A11. (('Rep12 & 'w, 'Rep13 & 'u,) -> ('t | 'x)
//│   where
//│     'o <: ArraysRep['A11, 'Rep13] & ArraysRep['A10, 'Rep12]
//│     's <: 'A11 -> ('b | 't) -> ('b & 'x) & 'A10 -> ('b0 | 't) -> ('b & 'x & 'b0 & 'v)))) | 'fold, init: forall 'Rep14, 'Rep15, 'y, 'o, 'z, 'A12, 'a1, 'A13, 'init. (('A12 & 'A13 & 'z) -> ('a1, 'y,) | 'init
//│   where
//│     'o <: ArraysRep['A12, 'Rep15] & ArraysRep['A13, 'Rep14]), sub: forall 'b1, 'c1. ('b1, 'c1,) -> (forall 'd1, 'e1, 'b1, 'A14, 'c1, 'o, 'f1, 'Rep16, 'A15, 'g1, 'Rep17, 'h1. ((int & 'f1) -> 'h1
//│   where
//│     'o <: ArraysRep['A15, 'Rep16] & ArraysRep['A14, 'Rep17])) | 'sub, update: forall 'i1, 'j1. ('i1, 'j1,) -> (forall 'f1, 'k1. (int & 'k1 & 'f1) -> (forall 'A16, 'Rep18, 'Rep19, 'o, 'j1, 'l1, 'm1, 'i1, 'n1, 'o1, 'A17. (('A16 & 'A17 & 'l1) -> (('i1 | 'm1, 'j1 | 'o1,) | 'n1)
//│   where
//│     'o <: ArraysRep['A16, 'Rep19] & ArraysRep['A17, 'Rep18]))) | 'update}) | 'q)) -> 'p1 & 'q1) -> 'p1
//│   where
//│     'Rep18 :> 'j1
//│            <: 'o1
//│     'Rep19 :> 'i1
//│            <: 'm1
//│     'Rep17 :> 'c1
//│     'A14 <: 'g1 & 'h1 & 'e1
//│     'Rep16 :> 'b1
//│     'A15 <: 'd1 & 'g1 & 'h1
//│     'Rep14 <: 'y
//│     'Rep15 <: 'a1
//│     'Rep10 :> ('r | 'h | 'g, 'm | 'k | 'p,)
//│            <: ('n & 'h & 'e & 'Rep8 & 'Rep, 'j & 'k & 'l & 'Rep9 & 'Rep3,)
//│     'A7 <: 'c & 'A0 & 'A2 & 'i & 'A4 & 'A8
//│          = [Function: stepImpl2]

stepImpl2_ty = stepImpl2
//│ ((forall 'A, 'a, 'c, 'd, 'A0, 'e, 'Rep, 'A1, 'Rep0, 'Rep1, 'f, 'A2, 'Rep2, 'g, 'h, 'A3, 'i, 'Rep3, 'j, 'k, 'A4, 'fold, 'l, 'sub, 'Rep4, 'update, 'A5, 'Rep5, 'Rep6, 'Rep7, 'm, 'Rep8, 'A6, 'Rep9, 'Rep10, 'Rep11, 'A7, 'n, 'o, 'A8, 'A9, 'p, 'q, 'r. (ArraysRep[in 'A4 | 'A7 | 'A | 'A3 | 'o & 'q & 'A6 & 'c & 'A5 | 'A6 & ('A9 | 'A0) out 'A5 & 'A8 & 'A4 & 'A7 & 'A & 'A3 & ('A1 & ('A9 | 'A2) | 'A0 & ('A9 | 'A2)), in 'Rep | 'Rep9 | 'f & 'h & 'l & 'd & 'Rep0 & 'Rep8 & 'Rep11 | 'k & 'a & 'r & 'm & 'Rep2 & 'Rep3 & 'Rep6 | 'f & 'h & 'd & 'Rep0 & 'Rep8 & 'p & 'Rep4 | 'k & 'a & 'm & 'Rep2 & 'Rep3 & 'g & 'Rep1 | 'Rep7 | 'Rep10 out ('f | 'Rep) & ('k | 'Rep9) & ('h | 'Rep11) & 'Rep8 & ('a | 'Rep6) & 'Rep3 & 'Rep4 & 'Rep1] & 'n) -> ((ArraysImpl['A6, 'Rep5] with {fold: forall 's. 's -> (forall 't. 't -> (forall 'u, 't, 'A10, 'b, 'v, 'Rep12, 'w, 's, 'Rep13, 'A11, 'b0, 'n, 'x. (('Rep13 & 'u, 'Rep12 & 'x,) -> ('t | 'w)
//│   where
//│     'n <: ArraysRep['A11, 'Rep12] & ArraysRep['A10, 'Rep13]
//│     's <: 'A11 -> ('b0 | 't) -> ('b0 & 'w) & 'A10 -> ('b | 't) -> ('b0 & 'w & 'b & 'v)))) | 'fold, init: forall 'y, 'z, 'A12, 'A13, 'init, 'Rep14, 'n, 'Rep15, 'a1. (('A13 & 'A12 & 'z) -> ('y, 'a1,) | 'init
//│   where
//│     'n <: ArraysRep['A13, 'Rep15] & ArraysRep['A12, 'Rep14]), sub: forall 'b1, 'c1. ('b1, 'c1,) -> (forall 'd1, 'A14, 'e1, 'A15, 'f1, 'c1, 'Rep16, 'b1, 'g1, 'n, 'Rep17, 'h1. ((int & 'e1) -> 'g1
//│   where
//│     'n <: ArraysRep['A14, 'Rep16] & ArraysRep['A15, 'Rep17])) | 'sub, update: forall 'i1, 'j1. ('i1, 'j1,) -> (forall 'e1, 'k1. (int & 'k1 & 'e1) -> (forall 'l1, 'j1, 'm1, 'Rep18, 'Rep19, 'A16, 'n1, 'n, 'A17, 'i1, 'o1. (('A16 & 'A17 & 'l1) -> (('i1 | 'o1, 'j1 | 'm1,) | 'n1)
//│   where
//│     'n <: ArraysRep['A16, 'Rep18] & ArraysRep['A17, 'Rep19]))) | 'update}) | 'e)) -> 'p1 & 'q1) -> 'p1
//│   where
//│     'Rep19 :> 'j1
//│            <: 'm1
//│     'Rep18 :> 'i1
//│            <: 'o1
//│     'Rep17 :> 'c1
//│     'A15 <: 'h1 & 'g1 & 'd1
//│     'Rep16 :> 'b1
//│     'A14 <: 'f1 & 'h1 & 'g1
//│     'Rep14 <: 'a1
//│     'Rep15 <: 'y
//│     'Rep5 :> ('g | 'a | 'r, 'p | 'h | 'l,)
//│           <: ('k & 'a & 'm & 'Rep2 & 'Rep3, 'f & 'h & 'd & 'Rep0 & 'Rep8,)
//│     'A6 <: 'j & 'A4 & 'A7 & 'i & 'A & 'A3
//│   <:  stepImpl2_ty:
//│ (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, 'Rep,)]
//│             = [Function: stepImpl2]


def step: Arrays['a] -> Arrays['a]
//│ step: Arrays['a] -> Arrays['a]
//│     = <missing implementation>

:e // * Since "sound extrusion"
def step arr f = f (stepImpl2 arr)
//│ 'a -> (forall 'c, 'a, 'd, 'e, 'f. (('c -> 'd & 'e) -> 'd
//│   where
//│     'a <: (forall 'Rep, 'g, 'A, 'h, 'Rep0, 'i, 'A0, 'Rep1, 'A1, 'update, 'j, 'Rep2, 'k, 'l, 'm, 'n, 'A2, 'Rep3, 'A3, 'o, 'Rep4, 'A4, 'p, 'q, 'r, 's, 'sub, 'Rep5, 'Rep6, 't, 'Rep7, 'Rep8, 'u, 'A5, 'v, 'fold, 'A6, 'A7, 'Rep9, 'A8, 'w, 'A9, 'Rep10, 'Rep11. (ArraysRep[in 'A5 | 'A4 | 'A9 | 'A7 | 'o & 'q & 'A2 & 'n & 'A1 | 'A2 & ('A3 | 'A0) out 'A1 & 'A6 & 'A5 & 'A4 & 'A9 & 'A7 & ('A8 & ('A3 | 'A) | 'A0 & ('A3 | 'A)), in 'Rep1 | 'Rep6 | 'w & 'k & 's & 't & 'Rep4 & 'Rep3 & 'Rep0 | 'g & 'i & 'j & 'm & 'Rep & 'Rep5 & 'Rep9 | 'w & 'k & 't & 'Rep4 & 'Rep3 & 'r & 'Rep2 | 'g & 'i & 'm & 'Rep & 'Rep5 & 'v & 'Rep10 | 'Rep7 | 'Rep8 out ('w | 'Rep1) & ('g | 'Rep6) & ('k | 'Rep0) & 'Rep3 & ('i | 'Rep9) & 'Rep5 & 'Rep2 & 'Rep10] & 'h) -> ((ArraysImpl['A2, 'Rep11] with {fold: forall 'x. 'x -> (forall 'y. 'y -> (forall 'Rep12, 'z, 'h, 'x, 'a1, 'A10, 'b, 'b1, 'Rep13, 'y, 'b0, 'A11, 'c1. (('Rep13 & 'a1, 'Rep12 & 'c1,) -> ('y | 'z)
//│   where
//│     'h <: ArraysRep['A11, 'Rep12] & ArraysRep['A10, 'Rep13]
//│     'x <: 'A11 -> ('b0 | 'y) -> ('b0 & 'z) & 'A10 -> ('b | 'y) -> ('b0 & 'z & 'b & 'b1)))) | 'fold, init: forall 'd1, 'h, 'e1, 'f1, 'Rep14, 'A12, 'init, 'Rep15, 'A13. (('A12 & 'A13 & 'f1) -> ('e1, 'd1,) | 'init
//│   where
//│     'h <: ArraysRep['A12, 'Rep14] & ArraysRep['A13, 'Rep15]), sub: forall 'g1, 'h1. ('g1, 'h1,) -> (forall 'i1, 'h, 'A14, 'A15, 'j1, 'g1, 'Rep16, 'k1, 'h1, 'l1, 'm1, 'Rep17. ((int & 'j1) -> 'k1
//│   where
//│     'h <: ArraysRep['A15, 'Rep17] & ArraysRep['A14, 'Rep16])) | 'sub, update: forall 'n1, 'o1. ('n1, 'o1,) -> (forall 'j1, 'p1. (int & 'p1 & 'j1) -> (forall 'n1, 'q1, 'h, 'r1, 'Rep18, 's1, 't1, 'A16, 'Rep19, 'o1, 'A17. (('A16 & 'A17 & 't1) -> (('n1 | 'q1, 'o1 | 's1,) | 'r1)
//│   where
//│     'h <: ArraysRep['A16, 'Rep19] & ArraysRep['A17, 'Rep18]))) | 'update}) | 'l)) -> ('f & 'c)))
//│   where
//│     'Rep18 :> 'o1
//│            <: 's1
//│     'Rep19 :> 'n1
//│            <: 'q1
//│     'Rep16 :> 'h1
//│     'A14 <: 'i1 & 'k1 & 'l1
//│     'Rep17 :> 'g1
//│     'A15 <: 'm1 & 'i1 & 'k1
//│     'Rep15 <: 'd1
//│     'Rep14 <: 'e1
//│     'Rep11 :> ('v | 'i | 'j, 'r | 'k | 's,)
//│            <: ('g & 'i & 'm & 'Rep & 'Rep5, 'w & 'k & 't & 'Rep4 & 'Rep3,)
//│     'A2 <: 'p & 'A5 & 'A4 & 'u & 'A9 & 'A7
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.441: 	def step arr f = f (stepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.42: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.42: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.341: 	      then arrImpl.Sub r0 (div i 2)
//│ ╙──       	                       ^^
//│     = [Function: step]

// * Now the annotation was okay [until "sound extrusion"] because the result no longer extruded it...
:e // * Since "sound extrusion"
def step (arr: Arrays['a]) f = f (stepImpl2 arr)
//│ Arrays['a] -> (forall 'A, 'c, 'A0, 'A1, 'd, 'e, 'Rep, 'A2, 'Rep0, 'A3, 'A4, 'update, 'a0, 'sub, 'fold, 'f, 'g. (((ArraysImpl[in 'a0 & 'A1 & 'd & 'A2 & 'A4 & 'c & 'A0 & 'A out 'a0 | 'A1 | 'A3, in (nothing, nothing,) & 'Rep0 out (anything, anything,) | 'Rep0 | 'Rep] with {fold: forall 'h. 'h -> (forall 'i. 'i -> (forall 'b, 'A5, 'j, 'Rep1, 'A6, 'b0, 'k, 'Rep2, 'l, 'i, 'm, 'h, 'n, 'a0. (('Rep1 & 'n, 'Rep2 & 'm,) -> ('i | 'l)
//│   where
//│     ArraysRep['a0, ?] | 'k <: ArraysRep['A6, 'Rep2] & ArraysRep['A5, 'Rep1]
//│     'h <: 'A6 -> ('b0 | 'i) -> ('b0 & 'l) & 'A5 -> ('b | 'i) -> ('b0 & 'l & 'b & 'j)))) | 'fold, init: forall 'A7, 'o, 'p, 'q, 'A8, 'init, 'a0, 'Rep3, 'k, 'Rep4. (('A8 & 'A7 & 'q) -> ('p, 'o,) | 'init
//│   where
//│     ArraysRep['a0, ?] | 'k <: ArraysRep['A8, in 'Rep4 & 'p out 'Rep4] & ArraysRep['A7, in 'Rep3 & 'o out 'Rep3]), sub: forall 'r, 's. ('r, 's,) -> (forall 't, 'u, 's, 'Rep5, 'v, 'A9, 'k, 'A10, 'w, 'Rep6, 'a0, 'r, 'x. ((int & 'u) -> 'x
//│   where
//│     ArraysRep['a0, ?] | 'k <: ArraysRep[in 'A9 & 'w & 't & 'x out 'A9, in 'Rep6 out 'Rep6 | 'r] & ArraysRep[in 't & 'x & 'A10 & 'v out 'A10, in 'Rep5 out 'Rep5 | 's])) | 'sub, update: forall 'y, 'z. ('y, 'z,) -> (forall 'a1, 'u. (int & 'a1 & 'u) -> (forall 'Rep7, 'A11, 'b1, 'c1, 'Rep8, 'z, 'd1, 'A12, 'e1, 'a0, 'k, 'y. (('A11 & 'A12 & 'e1) -> (('y | 'd1, 'z | 'c1,) | 'b1)
//│   where
//│     ArraysRep['a0, ?] | 'k <: ArraysRep['A11, in 'Rep8 & 'd1 out 'Rep8 | 'y] & ArraysRep['A12, in 'Rep7 & 'c1 out 'Rep7 | 'z]))) | 'update}) | 'g) -> 'f & 'e) -> 'f)
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.486: 	def step (arr: Arrays['a]) f = f (stepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.42: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.42: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.341: 	      then arrImpl.Sub r0 (div i 2)
//│ ╙──       	                       ^^
//│     = [Function: step1]

// * Don't know why these don't work:
:e
def step arr f = f (stepImpl2_ty arr)
//│ 'a -> (forall 'A, 'b, 'a, 'c, 'Rep, 'd. (((ArraysImpl['A, ('Rep, 'Rep,)] | 'b) -> 'c & 'd) -> 'c
//│   where
//│     'a <: forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r))
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.515: 	def step arr f = f (stepImpl2_ty arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.42: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.42: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│     = [Function: step2]
:e
def step (arr: Arrays['a]) f = f (stepImpl2_ty arr)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.532: 	def step (arr: Arrays['a]) f = f (stepImpl2_ty arr)
//│ ║         	                                  ^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.42: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.42: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ Arrays['a] -> (forall 'b, 'c, 'd. ((error | 'b) -> 'c & 'd) -> 'c)
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│     = [Function: step3]


ssb = step (step base)
//│ ssb: Arrays['a]
//│    = [Function (anonymous)]

ssb (fun arr ->
    let r2 = arr.Update (arr.Init true) 1 false
    in (arr.Sub r2 0, arr.Sub r2 1)
  )
//│ res: (bool, bool,)
//│    = [ true, false ]



rec def mkMonoArray n =
  if n == 0 then base else step (mkMonoArray(n - 1))
//│ mkMonoArray: int -> (forall 'a. Arrays['a])
//│            = [Function: mkMonoArray]

snb = mkMonoArray 5
//│ snb: Arrays['a]
//│    = [Function (anonymous)]

snb (fun arr -> arr.Init true)
//│ res: anything
//│    = [
//│        [ [ [Array], [Array] ], [ [Array], [Array] ] ],
//│        [ [ [Array], [Array] ], [ [Array], [Array] ] ]
//│      ]


// * From the paper:
// let mkPolyArray n = {∀α(∃ρ.∀β.sig(α,ρ,β))} (mkMonoArray n)





