:NoRecursiveTypes
:GeneralizeCurriedFunctions


class Ls[A]
  method Head: A | undefined
  method Tail: Ls[A] | undefined
//│ Defined class Ls[+A]
//│ Declared Ls.Head: Ls['A] -> ('A | undefined)
//│ Declared Ls.Tail: Ls['A] -> (Ls['A] | undefined)

// * Note that a more structural type such as this will raise cycle errors due to `:NoRecursiveTypes`
// class Ls[A]: { head: A | undefined; tail: Ls[A] | undefined }

class Nil: Ls[nothing]
  method Head = undefined
  method Tail = undefined
//│ Defined class Nil
//│ Defined Nil.Head: Nil -> undefined
//│ Defined Nil.Tail: Nil -> undefined

class Cons[A]: Ls[A] & { head: A; tail: Ls[A] }
  method Head = this.head
  method Tail = this.tail
//│ Defined class Cons[+A]
//│ Defined Cons.Head: Cons['A] -> 'A
//│ Defined Cons.Tail: Cons['A] -> Ls['A]

def nil: Ls['a]
def cons: ('a, Ls['a]) -> Ls['a]
def single: 'a -> Ls['a]
//│ nil: Ls[nothing]
//│    = <missing implementation>
//│ cons: ('a, Ls['a],) -> Ls['a]
//│     = <missing implementation>
//│ single: 'a -> Ls['a]
//│       = <missing implementation>

nil = Nil {}
cons (head, tail) = Cons { head; tail }
//│ Nil
//│   <:  nil:
//│ Ls[nothing]
//│    = Nil {}
//│ ('head & 'A, Ls['A] & 'tail,) -> (Cons['A] with {head: 'head, tail: 'tail})
//│   <:  cons:
//│ ('a, Ls['a],) -> Ls['a]
//│     = [Function: cons]



// * Random minimized trials:


def build0 (g: forall 'b. ('a -> 'b) -> 'b) = g single
//│ build0: (forall 'b. ('a -> 'b) -> 'b) -> Ls['a]
//│       = <no result>
//│         single is not implemented

build0 (fun s -> s 1)
//│ res: Ls[1]
//│    = <no result>
//│      build0 and single are not implemented

res: Ls[int]
//│ res: Ls[int]
//│    = [Function: cons]


def build0 (g: forall 'b. ('a -> 'b) -> 'b) = g (fun x -> single ((x, x)))
//│ build0: (forall 'b. ('a -> 'b) -> 'b) -> Ls[('a, 'a,)]
//│       = <no result>
//│         single is not implemented

def build0 (g: forall 'b. ('a -> 'a -> 'b) -> 'b) = g (fun x -> fun y -> single ((x,y)))
//│ build0: (forall 'b. ('a -> 'a -> 'b) -> 'b) -> Ls[('a, 'a,)]
//│       = <no result>
//│         single is not implemented

def build0 (g: forall 'b. ('a -> 'b -> 'b) -> 'b) = g (fun x -> fun y -> single ((x,y)))
//│ build0: (forall 'b. ('a -> 'b -> 'b) -> 'b) -> 'c
//│   where
//│     'c :> Ls[('a, 'c,)]
//│       = <no result>
//│         single is not implemented

def build0 (g: forall 'b. (('a, 'b) -> 'b) -> 'b) = g cons
//│ build0: (forall 'b. (('a, 'b,) -> 'b) -> 'b) -> Ls['a]
//│       = [Function: build01]

def build0 (g: forall 'b. (('a, 'b) -> 'b) -> 'b) = g (fun (x, xs) -> cons (x, xs))
//│ build0: (forall 'b. (('a, 'b,) -> 'b) -> 'b) -> Ls['a]
//│       = [Function: build02]

def g: forall 'b. (('a, 'b) -> 'b) -> 'b
//│ g: ((nothing, 'b,) -> 'b) -> 'b
//│  = <missing implementation>

g (fun (x, xs) -> cons (x, xs))
//│ res: Ls[nothing]
//│    = <no result>
//│      g is not implemented

def g: ((int, 'b) -> 'b) -> 'b
//│ g: ((int, 'b,) -> 'b) -> 'b
//│  = <missing implementation>

g (fun (x, xs) -> cons (x, xs))
//│ res: Ls[int]
//│    = <no result>
//│      g is not implemented

def cons2: ('a, {x:'a}) -> {x:'a}
// def cons2: ('a, 'a) -> 'a
//│ cons2: ('a, {x: 'a},) -> {x: 'a}
//│      = <missing implementation>

f (x, xs) = cons2 (x, xs)
//│ f: ('a, {x: 'a},) -> {x: 'a}
//│  = <no result>
//│    cons2 is not implemented

g f
//│ res: {x: int}
//│    = <no result>
//│      g is not implemented


def build0 (g: forall 'b. ('a -> 'b -> 'b) -> 'b) = g (fun x -> fun xs -> cons (x, xs))
//│ build0: (forall 'b. ('a -> 'b -> 'b) -> 'b) -> Ls['a]
//│       = [Function: build03]

:re
build0 (fun k -> k 1 error)
//│ res: Ls[1]
//│ Runtime error:
//│   Error: unexpected runtime error



// * The Real Deal:


def build = fun (g: forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> g (fun x -> fun xs -> cons (x, xs)) nil
//│ build: (forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> Ls['a]
//│      = [Function: build]

build (fun c -> fun n -> n)
//│ res: Ls[nothing]
//│    = Nil {}

build (fun c -> fun n -> c 1 n)
//│ res: Ls[1]
//│    = Cons { head: 1, tail: Nil {} }

build (fun c -> fun n -> c 1 (c 2 (c 3 n)))
//│ res: Ls[1 | 2 | 3]
//│    = Cons {
//│        head: 1,
//│        tail: Cons { head: 2, tail: Cons { head: 3, tail: Nil {} } }
//│      }



build: (forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> Ls['a]
//│ res: (forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> Ls['a]
//│    = [Function: build]

:e // FIXME why does the above work but not this one?
build: forall 'a. (forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> Ls['a]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.170: 	build: forall 'a. (forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> Ls['a]
//│ ║         	^^^^^
//│ ╟── type `‘b` is not an instance of type `'b`
//│ ║  l.170: 	build: forall 'a. (forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> Ls['a]
//│ ║         	                          ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.144: 	def build = fun (g: forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> g (fun x -> fun xs -> cons (x, xs)) nil
//│ ╙──       	                           ^^
//│ res: (forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> Ls['a]
//│    = [Function: build]


// * This `build` type is _too_ general as it lets the continuation assume it will handle lists instead of some unknown 'b
:e
build: (('a -> Ls['a] -> Ls['a]) -> Ls['a] -> Ls['a]) -> Ls['a]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.186: 	build: (('a -> Ls['a] -> Ls['a]) -> Ls['a] -> Ls['a]) -> Ls['a]
//│ ║         	^^^^^
//│ ╟── type `Ls[?a]` is not an instance of type `'b`
//│ ║  l.186: 	build: (('a -> Ls['a] -> Ls['a]) -> Ls['a] -> Ls['a]) -> Ls['a]
//│ ║         	               ^^^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.144: 	def build = fun (g: forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> g (fun x -> fun xs -> cons (x, xs)) nil
//│ ╙──       	                           ^^
//│ res: (('a -> Ls['a] -> Ls['a | error]) -> Ls['a | error] -> Ls['a]) -> Ls['a | error]
//│    = [Function: build]



// * It also Just Works without type annotations!


def build_ = fun g -> g (fun x -> fun xs -> cons (x, xs)) nil
//│ build_: ((forall 'a. 'a -> (forall 'a, 'a0. (Ls['a0] -> Ls['a | 'a0]
//│   where
//│     'a <: 'a0))) -> Ls[nothing] -> 'b) -> 'b
//│       = [Function: build_]

build_ (fun c -> fun n -> n)
//│ res: Ls[nothing]
//│    = Nil {}

build_ (fun c -> fun n -> c 1 n)
//│ res: Ls[1]
//│    = Cons { head: 1, tail: Nil {} }

build_ (fun c -> fun n -> c 1 (c 2 (c 3 n)))
//│ res: Ls[1 | 2 | 3]
//│    = Cons {
//│        head: 1,
//│        tail: Cons { head: 2, tail: Cons { head: 3, tail: Nil {} } }
//│      }



def g: forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│ g: (nothing -> 'b -> 'b) -> 'b -> 'b
//│  = <missing implementation>

g : ('a -> Ls['a] -> Ls['a]) -> Ls['a] -> Ls['a]
//│ res: ('a -> Ls['a] -> Ls['a]) -> Ls['a] -> Ls['a]
//│    = <no result>
//│      g is not implemented


build_ : (forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> Ls['a]
//│ res: (forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> Ls['a]
//│    = [Function: build_]


def b: (forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> Ls['a]
//│ b: (forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> Ls['a]
//│  = <missing implementation>

:e // FIXME why does the above work but not this one?
b = build_
//│ ((forall 'a. 'a -> (forall 'a, 'a0. (Ls['a0] -> Ls['a | 'a0]
//│   where
//│     'a <: 'a0))) -> Ls[nothing] -> 'b) -> 'b
//│   <:  b:
//│ (forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> Ls['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.247: 	b = build_
//│ ║         	^^^^^^^^^^
//│ ╟── type `‘b` is not an instance of type `Ls`
//│ ║  l.242: 	def b: (forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> Ls['a]
//│ ║         	               ^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.30: 	def cons: ('a, Ls['a]) -> Ls['a]
//│ ║        	               ^^^^^^
//│ ╟── from reference:
//│ ║  l.204: 	def build_ = fun g -> g (fun x -> fun xs -> cons (x, xs)) nil
//│ ╙──       	                                                     ^^
//│  = [Function: build_]




