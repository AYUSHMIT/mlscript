// * Adaptation of QML's original existentials example; using encoded existentials and classes


:NoRecursiveTypes
:GeneralizeCurriedFunctions
:ConstrainedTypes
// :DistributeForalls
// :ArgGen

// TODO try without some signatures



class ArraysRep[A, Rep]
  method Init: A -> Rep
  method Sub: Rep -> int -> A
  method Update: Rep -> int -> A -> Rep
  method Fold: (A -> 'b -> 'b) -> 'b -> Rep -> 'b
//│ Defined class ArraysRep[=A, =Rep]
//│ Declared ArraysRep.Init: ArraysRep['A, 'Rep] -> 'A -> 'Rep
//│ Declared ArraysRep.Sub: ArraysRep['A, 'Rep] -> 'Rep -> int -> 'A
//│ Declared ArraysRep.Update: ArraysRep['A, 'Rep] -> 'Rep -> int -> 'A -> 'Rep
//│ Declared ArraysRep.Fold: ArraysRep['A, 'Rep] -> ('A -> 'b -> 'b) -> 'b -> 'Rep -> 'b

class ArraysImpl[A, Rep]: ArraysRep[A, Rep] & {
    init: A -> Rep;
    sub: Rep -> int -> A;
    update: Rep -> int -> A -> Rep;
    fold: forall 'b. (A -> 'b -> 'b) -> 'b -> Rep -> 'b
  }
  method Init = this.init
  method Sub = this.sub
  method Update = this.update
  method Fold = this.fold
//│ Defined class ArraysImpl[=A, =Rep]
//│ Defined ArraysImpl.Init: ArraysImpl['A, 'Rep] -> 'A -> 'Rep
//│ Defined ArraysImpl.Sub: ArraysImpl['A, 'Rep] -> 'Rep -> int -> 'A
//│ Defined ArraysImpl.Update: ArraysImpl['A, 'Rep] -> 'Rep -> int -> 'A -> 'Rep
//│ Defined ArraysImpl.Fold: ArraysImpl['A, 'Rep] -> (forall 'b. ('A -> 'b -> 'b) -> 'b -> 'Rep -> 'b)

type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ Defined type alias Arrays[=A]



baseImpl = ArraysImpl {
    init   = fun a -> a;
    sub    = fun r -> fun (i : int) -> r;
    update = fun r -> fun (i : int) -> fun a -> a;
    fold   = fun f -> fun b -> fun r -> f r b
  }
//│ baseImpl: ArraysImpl['Rep, 'Rep] with {fold: forall 'a. 'a -> (forall 'b. 'b -> (forall 'c, 'd. ('c -> 'd
//│   where
//│     'a <: 'c -> 'b -> 'd))), init: forall 'e. 'e -> 'e, sub: forall 'f. 'f -> int -> 'f, update: anything -> int -> (forall 'g. 'g -> 'g)}
//│         = ArraysImpl {
//│             init: [Function: init],
//│             sub: [Function: sub],
//│             update: [Function: update],
//│             fold: [Function: fold]
//│           }

def base: Arrays['a]
def base f = f baseImpl
//│ base: Arrays['a]
//│     = <missing implementation>
//│ ((forall 'Rep. ArraysImpl['Rep, 'Rep] with {fold: forall 'a. 'a -> (forall 'b. 'b -> (forall 'c, 'd. ('c -> 'd
//│   where
//│     'a <: 'c -> 'b -> 'd))), init: forall 'e. 'e -> 'e, sub: forall 'f. 'f -> int -> 'f, update: anything -> int -> (forall 'g. 'g -> 'g)}) -> 'h) -> 'h
//│   <:  base:
//│ Arrays['a]
//│     = [Function: base]



def simpleStepImpl arrImpl = ArraysImpl {
    init   = fun a -> (arrImpl.Init a, "initialized");
    sub    = fun ((r0, r1)) -> fun i -> arrImpl.Sub r0 i;
    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.Update r0 i a, "updated");
    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f b r0
  }
//│ simpleStepImpl: (ArraysRep[in 'A | 'A0 | 'A1 & 'A2 out nothing, in 'Rep | 'Rep0 out nothing] & 'a) -> (ArraysImpl['A1, 'Rep1] with {fold: forall 'c. 'c -> (forall 'd. 'd -> (forall 'A3, 'Rep2, 'b. (('Rep2, anything,) -> ('d | 'b)
//│   where
//│     'a <: ArraysRep['A3, 'Rep2]
//│     'c <: 'A3 -> ('d | 'b) -> 'b))), init: forall 'A4, 'Rep3. ('A4 -> ('Rep3, "initialized",)
//│   where
//│     'a <: ArraysRep['A4, 'Rep3]), sub: forall 'e. ('e, anything,) -> (forall 'A5, 'Rep4. (int -> 'A5
//│   where
//│     'a <: ArraysRep['A5, 'Rep4])), update: forall 'f. ('f, anything,) -> int -> (forall 'A6, 'Rep5. ('A6 -> ('Rep5, "updated",)
//│   where
//│     'a <: ArraysRep['A6, 'Rep5]))})
//│   where
//│     'Rep5 :> 'f
//│     'Rep4 :> 'e
//│     'Rep1 :> (nothing, "initialized" | "updated",)
//│           <: (nothing, anything,)
//│     'A1 <: 'A & 'A0
//│               = [Function: simpleStepImpl]

simpleStepImpl : ArraysImpl['a, 'r] -> ArraysImpl['a, ('r, string)]
//│ res: ArraysImpl['a, 'r] -> ArraysImpl['a, ('r, string,)]
//│    = [Function: simpleStepImpl]

// def simpleStepImpl2_ty: Arrays['a] -> ArraysImpl['a, ('_, string)]
// def simpleStepImpl2_ty: Arrays['a] -> ArraysImpl['a, '_]
// def simpleStepImpl2 arr = arr simpleStepImpl

def simpleStepImpl2_ty: (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, string)]
//│ simpleStepImpl2_ty: (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, string,)]
//│                   = <missing implementation>


def simpleStepImpl2 arr = arr simpleStepImpl
//│ simpleStepImpl2: ((forall 'A, 'Rep, 'Rep0, 'Rep1, 'A0, 'A1, 'a, 'A2. (ArraysRep[in 'A2 | 'A0 | 'A & 'A1 out nothing, in 'Rep0 | 'Rep out nothing] & 'a) -> (ArraysImpl['A, 'Rep1] with {fold: forall 'c. 'c -> (forall 'd. 'd -> (forall 'A3, 'Rep2, 'b. (('Rep2, anything,) -> ('d | 'b)
//│   where
//│     'c <: 'A3 -> ('d | 'b) -> 'b
//│     'a <: ArraysRep['A3, 'Rep2]))), init: forall 'A4, 'Rep3. ('A4 -> ('Rep3, "initialized",)
//│   where
//│     'a <: ArraysRep['A4, 'Rep3]), sub: forall 'e. ('e, anything,) -> (forall 'A5, 'Rep4. (int -> 'A5
//│   where
//│     'a <: ArraysRep['A5, 'Rep4])), update: forall 'f. ('f, anything,) -> int -> (forall 'A6, 'Rep5. ('A6 -> ('Rep5, "updated",)
//│   where
//│     'a <: ArraysRep['A6, 'Rep5]))})) -> 'g) -> 'g
//│   where
//│     'Rep5 :> 'f
//│     'Rep4 :> 'e
//│     'Rep1 :> (nothing, "initialized" | "updated",)
//│           <: (nothing, anything,)
//│     'A <: 'A2 & 'A0
//│                = [Function: simpleStepImpl2]

simpleStepImpl2_ty = simpleStepImpl2
//│ ((forall 'Rep, 'A, 'a, 'A0, 'Rep0, 'A1, 'Rep1, 'A2. (ArraysRep[in 'A2 | 'A1 | 'A0 & 'A out nothing, in 'Rep1 | 'Rep0 out nothing] & 'a) -> (ArraysImpl['A0, 'Rep] with {fold: forall 'c. 'c -> (forall 'd. 'd -> (forall 'A3, 'Rep2, 'b. (('Rep2, anything,) -> ('d | 'b)
//│   where
//│     'c <: 'A3 -> ('d | 'b) -> 'b
//│     'a <: ArraysRep['A3, 'Rep2]))), init: forall 'A4, 'Rep3. ('A4 -> ('Rep3, "initialized",)
//│   where
//│     'a <: ArraysRep['A4, 'Rep3]), sub: forall 'e. ('e, anything,) -> (forall 'A5, 'Rep4. (int -> 'A5
//│   where
//│     'a <: ArraysRep['A5, 'Rep4])), update: forall 'f. ('f, anything,) -> int -> (forall 'A6, 'Rep5. ('A6 -> ('Rep5, "updated",)
//│   where
//│     'a <: ArraysRep['A6, 'Rep5]))})) -> 'g) -> 'g
//│   where
//│     'Rep5 :> 'f
//│     'Rep4 :> 'e
//│     'Rep :> (nothing, "initialized" | "updated",)
//│          <: (nothing, anything,)
//│     'A0 <: 'A2 & 'A1
//│   <:  simpleStepImpl2_ty:
//│ (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, string,)]
//│                   = [Function: simpleStepImpl2]

:e // * Annotation is actually counter-productive... probably because the rigid universal in Arrays gets extruded!
def simpleStepImpl2_ty (arr: Arrays['a]) = arr simpleStepImpl
//│ Arrays['a] -> error
//│   <:  simpleStepImpl2_ty:
//│ (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, string,)]
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.153: 	def simpleStepImpl2_ty (arr: Arrays['a]) = arr simpleStepImpl
//│ ║         	                                           ^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│                   = [Function: simpleStepImpl2_ty1]

def simpleStep: Arrays['a] -> Arrays['a]
//│ simpleStep: Arrays['a] -> Arrays['a]
//│           = <missing implementation>

:e // * Since "sound extrusion"
def simpleStep arr f = f (simpleStepImpl2 arr)
//│ 'a -> (forall 'c, 'd. (('c -> 'd) -> 'd
//│   where
//│     'a <: (forall 'A, 'e, 'Rep. (ArraysRep[in anything out nothing, in anything out nothing] & 'e) -> (ArraysImpl['A, 'Rep] with {fold: forall 'f. 'f -> (forall 'g. 'g -> (forall 'A0, 'Rep0, 'b. (('Rep0, anything,) -> ('g | 'b)
//│   where
//│     'e <: ArraysRep['A0, 'Rep0]
//│     'f <: 'A0 -> ('g | 'b) -> 'b))), init: forall 'A1, 'Rep1. ('A1 -> ('Rep1, "initialized",)
//│   where
//│     'e <: ArraysRep['A1, 'Rep1]), sub: forall 'h. ('h, anything,) -> (forall 'A2, 'Rep2. (int -> 'A2
//│   where
//│     'e <: ArraysRep['A2, 'Rep2])), update: forall 'i. ('i, anything,) -> int -> (forall 'A3, 'Rep3. ('A3 -> ('Rep3, "updated",)
//│   where
//│     'e <: ArraysRep['A3, 'Rep3]))})) -> 'c))
//│   where
//│     'Rep3 :> 'i
//│     'Rep2 :> 'h
//│     'Rep :> (nothing, "initialized" | "updated",)
//│          <: (nothing, anything,)
//│     'A <: nothing
//│   <:  simpleStep:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.77: 	    sub    = fun ((r0, r1)) -> fun i -> arrImpl.Sub r0 i;
//│ ╙──      	                                                    ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.78: 	    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.Update r0 i a, "updated");
//│ ╙──      	                                                                 ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.78: 	    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.Update r0 i a, "updated");
//│ ╙──      	                                                                 ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.78: 	    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.Update r0 i a, "updated");
//│ ╙──      	                                                                 ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.77: 	    sub    = fun ((r0, r1)) -> fun i -> arrImpl.Sub r0 i;
//│ ╙──      	                                                    ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.77: 	    sub    = fun ((r0, r1)) -> fun i -> arrImpl.Sub r0 i;
//│ ╙──      	                                                    ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.77: 	    sub    = fun ((r0, r1)) -> fun i -> arrImpl.Sub r0 i;
//│ ╙──      	                                                    ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.77: 	    sub    = fun ((r0, r1)) -> fun i -> arrImpl.Sub r0 i;
//│ ╙──      	                                                    ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.77: 	    sub    = fun ((r0, r1)) -> fun i -> arrImpl.Sub r0 i;
//│ ╙──      	                                                    ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.78: 	    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.Update r0 i a, "updated");
//│ ╙──      	                                                                 ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.77: 	    sub    = fun ((r0, r1)) -> fun i -> arrImpl.Sub r0 i;
//│ ╙──      	                                                    ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.79: 	    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f b r0
//│ ╙──      	                                                                  ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.79: 	    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f b r0
//│ ╙──      	                                                                  ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.79: 	    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f b r0
//│ ╙──      	                                                                  ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.79: 	    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f b r0
//│ ╙──      	                                                                  ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.79: 	    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f b r0
//│ ╙──      	                                                                  ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.79: 	    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f b r0
//│ ╙──      	                                                                  ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.79: 	    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f b r0
//│ ╙──      	                                                                  ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.79: 	    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f b r0
//│ ╙──      	                                                                  ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.78: 	    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.Update r0 i a, "updated");
//│ ╙──      	                                                                 ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.77: 	    sub    = fun ((r0, r1)) -> fun i -> arrImpl.Sub r0 i;
//│ ╙──      	                                                    ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.79: 	    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f b r0
//│ ╙──      	                                                                  ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.79: 	    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f b r0
//│ ╙──      	                                                                  ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.79: 	    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f b r0
//│ ╙──      	                                                                  ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.79: 	    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f b r0
//│ ╙──      	                                                                  ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.79: 	    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f b r0
//│ ╙──      	                                                                  ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.79: 	    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f b r0
//│ ╙──      	                                                                  ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.79: 	    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f b r0
//│ ╙──      	                                                                  ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.79: 	    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f b r0
//│ ╙──      	                                                                  ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.79: 	    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f b r0
//│ ╙──      	                                                                  ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.79: 	    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f b r0
//│ ╙──      	                                                                  ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.79: 	    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f b r0
//│ ╙──      	                                                                  ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.78: 	    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.Update r0 i a, "updated");
//│ ╙──      	                                                                 ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Subtyping constraint of the form `forall ?b. ?b -> (forall ?c, ?d, ?e, ?f. (?e -> ?f
//│   where
//│     ?b <: (forall ?Rep, ?g, ?sub, ?h, ?i, ?j, ?k, ?l, ?A, ?Rep0, ?Rep1, ?A0, ?m, ?Rep2, ?init, ?n, ?Rep3, ?o, ?A1, ?A2, ?p, ?A3, ?q, ?fold, ?r, ?update, ?s, ?A4, ?Rep4, ?Rep5. ?m -> ?j) -> ?c)) <: forall ?a. Arrays[?a] -> Arrays[?a]` took too many steps and ran out of fuel (5000)
//│ ║  l.173: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟──  + ⊤
//│ ║  l.78: 	    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.Update r0 i a, "updated");
//│ ║        	                                                                 ^^
//│ ╟──  + ⊤
//│ ║  l.14: 	class ArraysRep[A, Rep]
//│ ║        	                   ^^^
//│ ╟──  + ⊤
//│ ║  l.14: 	class ArraysRep[A, Rep]
//│ ║        	                   ^^^
//│ ╟──  + ⊤
//│ ║  l.78: 	    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.Update r0 i a, "updated");
//│ ║        	                                                  ^^^^^^^^^^^^^^^^^^^^^
//│ ╟──  + ⊤
//│ ║  l.78: 	    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.Update r0 i a, "updated");
//│ ║        	                                                  ^^^^^^^^^^^^^^^^^^^^^
//│ ╟──  + ⊤
//│ ║  l.78: 	    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.Update r0 i a, "updated");
//│ ║        	                                                  ^^^^^^^^^^^^^^^^^^^^^
//│ ╟──  + ⊤
//│ ╟──  + ⊤
//│ ╟──  + ⊤
//│ ╟──  + ⊤
//│ ╟──  + ⊤
//│ ║  l.78: 	    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.Update r0 i a, "updated");
//│ ║        	                                                                 ^^
//│ ╟──  + ⊤
//│ ║  l.14: 	class ArraysRep[A, Rep]
//│ ║        	                   ^^^
//│ ╟──  + ⊤
//│ ║  l.14: 	class ArraysRep[A, Rep]
//│ ║        	                   ^^^
//│ ╟──  + ⊤
//│ ║  l.78: 	    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.Update r0 i a, "updated");
//│ ║        	                                                  ^^^^^^^^^^^^^^^^^^^^^
//│ ╟──  + ⊤
//│ ║  l.78: 	    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.Update r0 i a, "updated");
//│ ║        	                                                  ^^^^^^^^^^^^^^^^^^^^^
//│ ╟──  + ⊤
//│ ║  l.78: 	    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.Update r0 i a, "updated");
//│ ║        	                                                  ^^^^^^^^^^^^^^^^^^^^^
//│ ╟──  + ⊤
//│ ╟──  + α316_2089''
//│ ╟──  + α316_2089''
//│ ╟──  + α316_2089''
//│ ║  l.77: 	    sub    = fun ((r0, r1)) -> fun i -> arrImpl.Sub r0 i;
//│ ║        	                                                    ^^
//│ ╟──  + α316_2089''
//│ ║  l.14: 	class ArraysRep[A, Rep]
//│ ║        	                   ^^^
//│ ╟──  + Rep1917_2097''
//│ ║  l.14: 	class ArraysRep[A, Rep]
//│ ║        	                   ^^^
//│ ╟──  - ⊥
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╙──  - ⊥..⊤
//│           = [Function: simpleStep]

:e // TODO update: seems like the given type for `simpleStepImpl2_ty` is not precise enough
def simpleStep arr f = f (simpleStepImpl2_ty arr)
//│ 'a -> (forall 'b, 'A, 'Rep. ((ArraysImpl['A, ('Rep, string,)] -> 'b) -> 'b
//│   where
//│     'a <: forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r))
//│   <:  simpleStep:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1491: 	def simpleStep arr f = f (simpleStepImpl2_ty arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│           = [Function: simpleStep1]

sb = simpleStep base
//│ sb: Arrays['a]
//│   = [Function (anonymous)]

sb (fun arr -> arr.Init true)
//│ res: anything
//│    = [ true, 'initialized' ]

sb (fun arr -> arr.Sub (arr.Init true) 1)
//│ res: true
//│    = true

:e // * Expected – argument order confusion
sb (fun arr -> arr.Sub 0 (arr.Init true))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.1521: 	sb (fun arr -> arr.Sub 0 (arr.Init true))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘Rep_2302` is not an instance of type `int`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.16: 	  method Sub: Rep -> int -> A
//│ ║        	                     ^^^
//│ ╟── from application:
//│ ║  l.1521: 	sb (fun arr -> arr.Sub 0 (arr.Init true))
//│ ║          	                          ^^^^^^^^^^^^^
//│ ╟── Note: class type parameter Rep is defined at:
//│ ║  l.14: 	class ArraysRep[A, Rep]
//│ ╙──      	                   ^^^
//│ res: error | true
//│ Runtime error:
//│   TypeError: number 0 is not iterable (cannot read property Symbol(Symbol.iterator))

sb (fun arr -> arr.Update (arr.Init true) 1 false)
//│ res: anything
//│    = [ false, 'updated' ]

:e // * Rightly prevent skolem confusion
sb (fun arr1 -> sb (fun arr2 -> arr2.Update (arr1.Init true)))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.1546: 	sb (fun arr1 -> sb (fun arr2 -> arr2.Update (arr1.Init true)))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘Rep_2409` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from application:
//│ ║  l.1546: 	sb (fun arr1 -> sb (fun arr2 -> arr2.Update (arr1.Init true)))
//│ ╙──        	                                             ^^^^^^^^^^^^^^
//│ res: int -> anything -> anything | error
//│    = [Function (anonymous)]

sb (fun arr ->
    let r2 = arr.Update (arr.Init true) 1 false
    in (arr.Sub r2 0, arr.Sub r2 1)
  )
//│ res: (bool, bool,)
//│    = [ false, false ]



:escape
def Math: nothing
//│ Math: nothing
//│     = <missing implementation>

def div: int -> int -> int
def div a b = Math.trunc(a/b)
//│ div: int -> int -> int
//│    = <missing implementation>
//│ number -> number -> nothing
//│   <:  div:
//│ int -> int -> int
//│    = [Function: div1]

def mod: int -> int -> int
//│ mod: int -> int -> int
//│    = <missing implementation>

:e // * Since the removal of "recursive definition hacks"
rec def mod a b = if a < b then a else mod (a - b) b
//│ 'mod
//│   where
//│     'mod :> forall 'a. (int & 'a) -> (forall 'b, 'c. ((int & 'b) -> ('a | 'c)
//│   where
//│     'mod <: int -> 'b -> 'c))
//│   <:  mod:
//│ int -> int -> int
//│ ╔══[ERROR] Subtyping constraint of the form `forall ?mod. ?mod <: int -> int -> int` exceeded recursion depth limit (250)
//│ ║  l.1590: 	rec def mod a b = if a < b then a else mod (a - b) b
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── while constraining:  ‹∀ 1. (α2544_2586'' -> ‹∀ 2. {(α2545_2589''' -> α2555_2592''') where: mod2543_2585# <: ((α2552_2587''',) -> α2553_2588''')}›)›  <!<  ((α2552_2951,) -> α2553_2952)
//│ ╟── while constraining:  mod2543_2585#  <!<  ((α2552_2951,) -> α2553_2952)
//│ ╟── while constraining:  {(α2545_2953 -> α2555_2956) where: mod2543_2585# <: ((α2552_2951,) -> α2553_2952)}  <!<  ((α2545_2940,) -> α2554_2941)
//│ ╟── while constraining:  ‹∀ 2. {(α2545_2947''' -> α2555_2950''') where: mod2543_2585# <: ((α2552_2945''',) -> α2553_2946''')}›  <!<  ((α2545_2940,) -> α2554_2941)
//│ ╟── while constraining:  ‹∀ 2. {(α2545_2947''' -> α2555_2950''') where: mod2543_2585# <: ((α2552_2945''',) -> α2553_2946''')}›  <!<  α2553_2939
//│ ╟── while constraining:  (α2544_2944 -> ‹∀ 2. {(α2545_2947''' -> α2555_2950''') where: mod2543_2585# <: ((α2552_2945''',) -> α2553_2946''')}›)  <!<  ((α2552_2938,) -> α2553_2939)
//│ ╟── while constraining:  ‹∀ 1. (α2544_2586'' -> ‹∀ 2. {(α2545_2589''' -> α2555_2592''') where: mod2543_2585# <: ((α2552_2587''',) -> α2553_2588''')}›)›  <!<  ((α2552_2938,) -> α2553_2939)
//│ ╟── while constraining:  mod2543_2585#  <!<  ((α2552_2938,) -> α2553_2939)
//│ ╟── while constraining:  {(α2545_2940 -> α2555_2943) where: mod2543_2585# <: ((α2552_2938,) -> α2553_2939)}  <!<  ((α2545_2927,) -> α2554_2928)
//│ ╟── while constraining:  ‹∀ 2. {(α2545_2934''' -> α2555_2937''') where: mod2543_2585# <: ((α2552_2932''',) -> α2553_2933''')}›  <!<  ((α2545_2927,) -> α2554_2928)
//│ ╟── while constraining:  ‹∀ 2. {(α2545_2934''' -> α2555_2937''') where: mod2543_2585# <: ((α2552_2932''',) -> α2553_2933''')}›  <!<  α2553_2926
//│ ╟── while constraining:  (α2544_2931 -> ‹∀ 2. {(α2545_2934''' -> α2555_2937''') where: mod2543_2585# <: ((α2552_2932''',) -> α2553_2933''')}›)  <!<  ((α2552_2925,) -> α2553_2926)
//│ ╟── while constraining:  ‹∀ 1. (α2544_2586'' -> ‹∀ 2. {(α2545_2589''' -> α2555_2592''') where: mod2543_2585# <: ((α2552_2587''',) -> α2553_2588''')}›)›  <!<  ((α2552_2925,) -> α2553_2926)
//│ ╟── while constraining:  mod2543_2585#  <!<  ((α2552_2925,) -> α2553_2926)
//│ ╟── while constraining:  {(α2545_2927 -> α2555_2930) where: mod2543_2585# <: ((α2552_2925,) -> α2553_2926)}  <!<  ((α2545_2914,) -> α2554_2915)
//│ ╟── ......
//│ ╟── ......
//│ ╟── while constraining:  (α2544_2619 -> ‹∀ 2. {(α2545_2622''' -> α2555_2625''') where: mod2543_2585# <: ((α2552_2620''',) -> α2553_2621''')}›)  <!<  ((α2552_2613,) -> α2553_2614)
//│ ╟── while constraining:  ‹∀ 1. (α2544_2586'' -> ‹∀ 2. {(α2545_2589''' -> α2555_2592''') where: mod2543_2585# <: ((α2552_2587''',) -> α2553_2588''')}›)›  <!<  ((α2552_2613,) -> α2553_2614)
//│ ╟── while constraining:  mod2543_2585#  <!<  ((α2552_2613,) -> α2553_2614)
//│ ╟── while constraining:  {(α2545_2615 -> α2555_2618) where: mod2543_2585# <: ((α2552_2613,) -> α2553_2614)}  <!<  ((α2545_2602,) -> α2554_2603)
//│ ╟── while constraining:  ‹∀ 2. {(α2545_2609''' -> α2555_2612''') where: mod2543_2585# <: ((α2552_2607''',) -> α2553_2608''')}›  <!<  ((α2545_2602,) -> α2554_2603)
//│ ╟── while constraining:  ‹∀ 2. {(α2545_2609''' -> α2555_2612''') where: mod2543_2585# <: ((α2552_2607''',) -> α2553_2608''')}›  <!<  α2553_2601
//│ ╟── while constraining:  (α2544_2606 -> ‹∀ 2. {(α2545_2609''' -> α2555_2612''') where: mod2543_2585# <: ((α2552_2607''',) -> α2553_2608''')}›)  <!<  ((α2552_2600,) -> α2553_2601)
//│ ╟── while constraining:  ‹∀ 1. (α2544_2586'' -> ‹∀ 2. {(α2545_2589''' -> α2555_2592''') where: mod2543_2585# <: ((α2552_2587''',) -> α2553_2588''')}›)›  <!<  ((α2552_2600,) -> α2553_2601)
//│ ╟── while constraining:  mod2543_2585#  <!<  ((α2552_2600,) -> α2553_2601)
//│ ╟── while constraining:  {(α2545_2602 -> α2555_2605) where: mod2543_2585# <: ((α2552_2600,) -> α2553_2601)}  <!<  (Int -> Int)
//│ ╟── while constraining:  ‹∀ 2. {(α2545_2596''' -> α2555_2599''') where: mod2543_2585# <: ((α2552_2594''',) -> α2553_2595''')}›  <!<  (Int -> Int)
//│ ╟── while constraining:  (α2544_2593 -> ‹∀ 2. {(α2545_2596''' -> α2555_2599''') where: mod2543_2585# <: ((α2552_2594''',) -> α2553_2595''')}›)  <!<  (Int -> (Int -> Int))
//│ ╟── while constraining:  ‹∀ 1. (α2544_2586'' -> ‹∀ 2. {(α2545_2589''' -> α2555_2592''') where: mod2543_2585# <: ((α2552_2587''',) -> α2553_2588''')}›)›  <!<  (Int -> (Int -> Int))
//│ ╟── while constraining:  mod2543_2585#  <!<  (Int -> (Int -> Int))
//│ ╙── while constraining:  ‹∀ 0. mod2543'#›  <!<  (Int -> (Int -> Int))
//│    = [Function: mod]

def stepImpl arrImpl = ArraysImpl {
    init = fun a -> (arrImpl.Init a, arrImpl.Init a);
    sub = fun ((r0, r1)) -> fun i ->
      if mod i 2 == 0
      then arrImpl.Sub r0 (div i 2)
      else arrImpl.Sub r1 (div i 2);
    update = fun ((r0, r1)) -> fun i -> fun a ->
      if mod i 2 == 0
      then (arrImpl.Update r0 (div i 2) a, r1)
      else (r0, arrImpl.Update r1 (div i 2) a);
    fold = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f (arrImpl.Fold f b r0) r1
  }
//│ stepImpl: (ArraysRep[in 'A | 'A0 | 'A1 | 'A2 | 'A3 & 'A4 | 'A3 & ('A5 | 'A6) out nothing, in anything out nothing] & 'a) -> (ArraysImpl['A3, 'Rep] with {fold: forall 'c. 'c -> (forall 'd. 'd -> (forall 'A7, 'Rep0, 'Rep1, 'A8, 'b, 'b0. (('Rep0, 'Rep1,) -> ('d | 'b0)
//│   where
//│     'a <: ArraysRep['A7, 'Rep1] & ArraysRep['A8, 'Rep0]
//│     'c <: 'A7 -> ('d | 'b0) -> 'b0 & 'A8 -> ('b | 'd) -> ('b0 & 'b)))), init: forall 'A9, 'Rep2, 'A10, 'Rep3. (('A9 & 'A10) -> ('Rep2, 'Rep3,)
//│   where
//│     'a <: ArraysRep['A9, 'Rep2] & ArraysRep['A10, 'Rep3]), sub: forall 'e, 'f. ('e, 'f,) -> (forall 'A11, 'A12, 'Rep4, 'g, 'Rep5. (int -> 'g
//│   where
//│     'a <: ArraysRep['A12, 'Rep5] & ArraysRep['A11, 'Rep4])), update: forall 'h, 'i. ('i, 'h,) -> int -> (forall 'A13, 'Rep6, 'A14, 'Rep7. (('A13 & 'A14) -> ('Rep6 | 'i, 'Rep7 | 'h,)
//│   where
//│     'a <: ArraysRep['A13, 'Rep6] & ArraysRep['A14, 'Rep7]))})
//│   where
//│     'Rep7 :> 'h
//│     'Rep6 :> 'i
//│     'Rep4 :> 'f
//│     'A11 <: 'g
//│     'Rep5 :> 'e
//│     'A12 <: 'g
//│     'Rep :> ('j, 'k,)
//│          <: (nothing, nothing,)
//│     'A3 <: 'A & 'A0 & 'A1 & 'A2
//│         = [Function: stepImpl]

def stepImpl2_ty: (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, 'Rep)]
//│ stepImpl2_ty: (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, 'Rep,)]
//│             = <missing implementation>

def stepImpl2 arr = arr stepImpl
//│ stepImpl2: ((forall 'A, 'a, 'A0, 'A1, 'A2, 'c, 'A3, 'Rep, 'A4, 'd, 'A5, 'A6. (ArraysRep[in 'A0 | 'A5 | 'A6 | 'A1 | 'A4 & 'A3 | 'A4 & ('A | 'A2) out nothing, in anything out nothing] & 'd) -> (ArraysImpl['A4, 'Rep] with {fold: forall 'e. 'e -> (forall 'f. 'f -> (forall 'Rep0, 'Rep1, 'b, 'A7, 'b0, 'A8. (('Rep0, 'Rep1,) -> ('f | 'b)
//│   where
//│     'd <: ArraysRep['A7, 'Rep1] & ArraysRep['A8, 'Rep0]
//│     'e <: 'A7 -> ('f | 'b) -> 'b & 'A8 -> ('b0 | 'f) -> ('b & 'b0)))), init: forall 'A9, 'Rep2, 'A10, 'Rep3. (('A9 & 'A10) -> ('Rep2, 'Rep3,)
//│   where
//│     'd <: ArraysRep['A9, 'Rep2] & ArraysRep['A10, 'Rep3]), sub: forall 'g, 'h. ('g, 'h,) -> (forall 'i, 'Rep4, 'A11, 'A12, 'Rep5. (int -> 'i
//│   where
//│     'd <: ArraysRep['A11, 'Rep5] & ArraysRep['A12, 'Rep4])), update: forall 'j, 'k. ('j, 'k,) -> int -> (forall 'A13, 'Rep6, 'A14, 'Rep7. (('A13 & 'A14) -> ('Rep6 | 'j, 'Rep7 | 'k,)
//│   where
//│     'd <: ArraysRep['A13, 'Rep6] & ArraysRep['A14, 'Rep7]))})) -> 'l) -> 'l
//│   where
//│     'Rep7 :> 'k
//│     'Rep6 :> 'j
//│     'Rep4 :> 'h
//│     'A12 <: 'i
//│     'Rep5 :> 'g
//│     'A11 <: 'i
//│     'Rep :> ('a, 'c,)
//│          <: (nothing, nothing,)
//│     'A4 <: 'A0 & 'A5 & 'A6 & 'A1
//│          = [Function: stepImpl2]

stepImpl2_ty = stepImpl2
//│ ((forall 'A, 'A0, 'A1, 'a, 'c, 'Rep, 'A2, 'A3, 'A4, 'd, 'A5, 'A6. (ArraysRep[in 'A0 | 'A3 | 'A5 | 'A4 | 'A & 'A2 | 'A & ('A1 | 'A6) out nothing, in anything out nothing] & 'c) -> (ArraysImpl['A, 'Rep] with {fold: forall 'e. 'e -> (forall 'f. 'f -> (forall 'Rep0, 'b, 'A7, 'Rep1, 'b0, 'A8. (('Rep0, 'Rep1,) -> ('f | 'b)
//│   where
//│     'c <: ArraysRep['A8, 'Rep1] & ArraysRep['A7, 'Rep0]
//│     'e <: 'A8 -> ('f | 'b) -> 'b & 'A7 -> ('b0 | 'f) -> ('b & 'b0)))), init: forall 'A9, 'Rep2, 'A10, 'Rep3. (('A9 & 'A10) -> ('Rep2, 'Rep3,)
//│   where
//│     'c <: ArraysRep['A9, 'Rep2] & ArraysRep['A10, 'Rep3]), sub: forall 'g, 'h. ('g, 'h,) -> (forall 'Rep4, 'A11, 'A12, 'Rep5, 'i. (int -> 'i
//│   where
//│     'c <: ArraysRep['A12, 'Rep4] & ArraysRep['A11, 'Rep5])), update: forall 'j, 'k. ('j, 'k,) -> int -> (forall 'A13, 'Rep6, 'A14, 'Rep7. (('A13 & 'A14) -> ('Rep6 | 'j, 'Rep7 | 'k,)
//│   where
//│     'c <: ArraysRep['A13, 'Rep6] & ArraysRep['A14, 'Rep7]))})) -> 'l) -> 'l
//│   where
//│     'Rep7 :> 'k
//│     'Rep6 :> 'j
//│     'Rep5 :> 'h
//│     'A11 <: 'i
//│     'Rep4 :> 'g
//│     'A12 <: 'i
//│     'Rep :> ('a, 'd,)
//│          <: (nothing, nothing,)
//│     'A <: 'A0 & 'A3 & 'A5 & 'A4
//│   <:  stepImpl2_ty:
//│ (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, 'Rep,)]
//│             = [Function: stepImpl2]


def step: Arrays['a] -> Arrays['a]
//│ step: Arrays['a] -> Arrays['a]
//│     = <missing implementation>

:e // * Since "sound extrusion"
def step arr f = f (stepImpl2 arr)
//│ 'a -> (forall 'c, 'd. (('c -> 'd) -> 'd
//│   where
//│     'a <: (forall 'Rep, 'A, 'e, 'f, 'g. (ArraysRep[in anything out nothing, in anything out nothing] & 'g) -> (ArraysImpl['A, 'Rep] with {fold: forall 'h. 'h -> (forall 'i. 'i -> (forall 'b, 'Rep0, 'A0, 'Rep1, 'b0, 'A1. (('Rep0, 'Rep1,) -> ('i | 'b)
//│   where
//│     'h <: 'A1 -> ('i | 'b) -> 'b & 'A0 -> ('b0 | 'i) -> ('b & 'b0)
//│     'g <: ArraysRep['A1, 'Rep1] & ArraysRep['A0, 'Rep0]))), init: forall 'A2, 'Rep2, 'A3, 'Rep3. (('A2 & 'A3) -> ('Rep2, 'Rep3,)
//│   where
//│     'g <: ArraysRep['A2, 'Rep2] & ArraysRep['A3, 'Rep3]), sub: forall 'j, 'k. ('j, 'k,) -> (forall 'Rep4, 'l, 'A4, 'Rep5, 'A5. (int -> 'l
//│   where
//│     'g <: ArraysRep['A4, 'Rep4] & ArraysRep['A5, 'Rep5])), update: forall 'm, 'n. ('m, 'n,) -> int -> (forall 'A6, 'Rep6, 'A7, 'Rep7. (('A6 & 'A7) -> ('Rep6 | 'm, 'Rep7 | 'n,)
//│   where
//│     'g <: ArraysRep['A6, 'Rep6] & ArraysRep['A7, 'Rep7]))})) -> 'c))
//│   where
//│     'Rep7 :> 'n
//│     'Rep6 :> 'm
//│     'Rep5 :> 'k
//│     'A5 <: 'l
//│     'Rep4 :> 'j
//│     'A4 <: 'l
//│     'Rep :> ('f, 'e,)
//│          <: (nothing, nothing,)
//│     'A <: nothing
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.1639: 	      then arrImpl.Sub r0 (div i 2)
//│ ╙──        	                       ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.1640: 	      else arrImpl.Sub r1 (div i 2);
//│ ╙──        	                       ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.1643: 	      then (arrImpl.Update r0 (div i 2) a, r1)
//│ ╙──        	                           ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.1644: 	      else (r0, arrImpl.Update r1 (div i 2) a);
//│ ╙──        	            ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.1643: 	      then (arrImpl.Update r0 (div i 2) a, r1)
//│ ╙──        	                           ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.1644: 	      else (r0, arrImpl.Update r1 (div i 2) a);
//│ ╙──        	                               ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.1644: 	      else (r0, arrImpl.Update r1 (div i 2) a);
//│ ╙──        	                               ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.1643: 	      then (arrImpl.Update r0 (div i 2) a, r1)
//│ ╙──        	                                           ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.1639: 	      then arrImpl.Sub r0 (div i 2)
//│ ╙──        	                       ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.1639: 	      then arrImpl.Sub r0 (div i 2)
//│ ╙──        	                       ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.1639: 	      then arrImpl.Sub r0 (div i 2)
//│ ╙──        	                       ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.1640: 	      else arrImpl.Sub r1 (div i 2);
//│ ╙──        	                       ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.1640: 	      else arrImpl.Sub r1 (div i 2);
//│ ╙──        	                       ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.1640: 	      else arrImpl.Sub r1 (div i 2);
//│ ╙──        	                       ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.1640: 	      else arrImpl.Sub r1 (div i 2);
//│ ╙──        	                       ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.1639: 	      then arrImpl.Sub r0 (div i 2)
//│ ╙──        	                       ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.1639: 	      then arrImpl.Sub r0 (div i 2)
//│ ╙──        	                       ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.1640: 	      else arrImpl.Sub r1 (div i 2);
//│ ╙──        	                       ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.1643: 	      then (arrImpl.Update r0 (div i 2) a, r1)
//│ ╙──        	                           ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.1644: 	      else (r0, arrImpl.Update r1 (div i 2) a);
//│ ╙──        	                               ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.1645: 	    fold = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f (arrImpl.Fold f b r0) r1
//│ ╙──        	                                                                                ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.1645: 	    fold = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f (arrImpl.Fold f b r0) r1
//│ ╙──        	                                                                                ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.1645: 	    fold = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f (arrImpl.Fold f b r0) r1
//│ ╙──        	                                                                                ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.1645: 	    fold = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f (arrImpl.Fold f b r0) r1
//│ ╙──        	                                                                                    ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.1645: 	    fold = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f (arrImpl.Fold f b r0) r1
//│ ╙──        	                                                                                    ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.1639: 	      then arrImpl.Sub r0 (div i 2)
//│ ╙──        	                       ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.1640: 	      else arrImpl.Sub r1 (div i 2);
//│ ╙──        	                       ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.1645: 	    fold = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f (arrImpl.Fold f b r0) r1
//│ ╙──        	                                                                                ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.1645: 	    fold = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f (arrImpl.Fold f b r0) r1
//│ ╙──        	                                                                                    ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.1643: 	      then (arrImpl.Update r0 (div i 2) a, r1)
//│ ╙──        	                           ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.1644: 	      else (r0, arrImpl.Update r1 (div i 2) a);
//│ ╙──        	                               ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.1645: 	    fold = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f (arrImpl.Fold f b r0) r1
//│ ╙──        	                                                                                ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.1645: 	    fold = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f (arrImpl.Fold f b r0) r1
//│ ╙──        	                                                                                ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.1645: 	    fold = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f (arrImpl.Fold f b r0) r1
//│ ╙──        	                                                                                ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.1645: 	    fold = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f (arrImpl.Fold f b r0) r1
//│ ╙──        	                                                                                    ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.1645: 	    fold = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f (arrImpl.Fold f b r0) r1
//│ ╙──        	                                                                                    ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.1639: 	      then arrImpl.Sub r0 (div i 2)
//│ ╙──        	                       ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.1640: 	      else arrImpl.Sub r1 (div i 2);
//│ ╙──        	                       ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.1645: 	    fold = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f (arrImpl.Fold f b r0) r1
//│ ╙──        	                                                                                ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.1645: 	    fold = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f (arrImpl.Fold f b r0) r1
//│ ╙──        	                                                                                    ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.1645: 	    fold = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f (arrImpl.Fold f b r0) r1
//│ ╙──        	                                                                                ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.1645: 	    fold = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f (arrImpl.Fold f b r0) r1
//│ ╙──        	                                                                                ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.1645: 	    fold = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f (arrImpl.Fold f b r0) r1
//│ ╙──        	                                                                                ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.1645: 	    fold = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f (arrImpl.Fold f b r0) r1
//│ ╙──        	                                                                                    ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.1645: 	    fold = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f (arrImpl.Fold f b r0) r1
//│ ╙──        	                                                                                    ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Subtyping constraint of the form `forall ?b. ?b -> (forall ?c, ?d, ?e, ?f. (?f -> ?d
//│   where
//│     ?b <: (forall ?A, ?Rep, ?Rep0, ?g, ?Rep1, ?A0, ?A1, ?h, ?Rep2, ?sub, ?A2, ?A3, ?Rep3, ?A4, ?i, ?Rep4, ?A5, ?A6, ?Rep5, ?j, ?Rep6, ?k, ?l, ?Rep7, ?Rep8, ?m, ?Rep9, ?n, ?o, ?p, ?A7, ?Rep10, ?init, ?q, ?A8, ?update, ?r, ?s, ?t, ?u, ?Rep11, ?fold, ?v, ?w, ?x, ?A9. ?w -> ?k) -> ?e)) <: forall ?a. Arrays[?a] -> Arrays[?a]` took too many steps and ran out of fuel (5000)
//│ ║  l.1727: 	def step arr f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟──  + ‘a_4400'
//│ ║  l.25: 	class ArraysImpl[A, Rep]: ArraysRep[A, Rep] & {
//│ ║        	                 ^
//│ ╟──  + ‘a_4400'
//│ ║  l.25: 	class ArraysImpl[A, Rep]: ArraysRep[A, Rep] & {
//│ ║        	                 ^
//│ ╟──  + ‘a_4400'
//│ ║  l.25: 	class ArraysImpl[A, Rep]: ArraysRep[A, Rep] & {
//│ ║        	                 ^
//│ ╟──  + A4638''
//│ ║  l.25: 	class ArraysImpl[A, Rep]: ArraysRep[A, Rep] & {
//│ ║        	                 ^
//│ ╙──  - α4674_4970''
//│     = [Function: step]

// * Now the annotation was okay [until "sound extrusion"] because the result no longer extruded it...
:e // * Since "sound extrusion"
def step (arr: Arrays['a]) f = f (stepImpl2 arr)
//│ Arrays['a] -> (forall 'b. (error -> 'b) -> 'b)
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.2800: 	def step (arr: Arrays['a]) f = f (stepImpl2 arr)
//│ ║          	                                  ^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│     = [Function: step1]

// * Don't know why these don't work:
:e
def step arr f = f (stepImpl2_ty arr)
//│ 'a -> (forall 'A, 'Rep, 'b. ((ArraysImpl['A, ('Rep, 'Rep,)] -> 'b) -> 'b
//│   where
//│     'a <: forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r))
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.2817: 	def step arr f = f (stepImpl2_ty arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│     = [Function: step2]
:e
def step (arr: Arrays['a]) f = f (stepImpl2_ty arr)
//│ Arrays['a] -> (forall 'Rep, 'b, 'A. ((ArraysImpl['A, ('Rep, 'Rep,)] | error) -> 'b) -> 'b)
//│   where
//│     'Rep :> anything
//│          <: nothing
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.2834: 	def step (arr: Arrays['a]) f = f (stepImpl2_ty arr)
//│ ║          	                                  ^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│     = [Function: step3]


ssb = step (step base)
//│ ssb: Arrays['a]
//│    = [Function (anonymous)]

ssb (fun arr ->
    let r2 = arr.Update (arr.Init true) 1 false
    in (arr.Sub r2 0, arr.Sub r2 1)
  )
//│ res: (bool, bool,)
//│    = [ true, false ]



rec def mkMonoArray n =
  if n == 0 then base else step (mkMonoArray(n - 1))
//│ mkMonoArray: 'mkMonoArray
//│   where
//│     'mkMonoArray :> forall 'a. (int -> Arrays['a]
//│   where
//│     'mkMonoArray <: int -> Arrays['a])
//│            = [Function: mkMonoArray]

:e // * Since the removal of "recursive definition hacks"
snb = mkMonoArray 5
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.2876: 	snb = mkMonoArray 5
//│ ║          	      ^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  mkMonoArray5648_5680'#  <:  ((α5656_5691',) -> α5657_5692')    TypeVariable  FunctionType
//│ ╙──  ... looks like:  mkMonoArray5648'#  <:  ((α5656_5681'',) -> α5657_5682'')
//│ snb: error | Arrays['a]
//│    = [Function (anonymous)]

snb (fun arr -> arr.Init true)
//│ res: anything
//│    = [
//│        [ [ [Array], [Array] ], [ [Array], [Array] ] ],
//│        [ [ [Array], [Array] ], [ [Array], [Array] ] ]
//│      ]


// * From the paper:
// let mkPolyArray n = {∀α(∃ρ.∀β.sig(α,ρ,β))} (mkMonoArray n)





