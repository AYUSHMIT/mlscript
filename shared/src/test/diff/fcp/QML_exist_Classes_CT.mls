// * Adaptation of QML's original existentials example; using encoded existentials and classes


:NoRecursiveTypes
:GeneralizeCurriedFunctions
:ConstrainedTypes
// :DistributeForalls
// :ArgGen

// TODO try without some signatures



class ArraysRep[A, Rep]
  method Init: A -> Rep
  method Sub: Rep -> int -> A
  method Update: Rep -> int -> A -> Rep
  method Fold: (A -> 'b -> 'b) -> 'b -> Rep -> 'b
//│ Defined class ArraysRep[=A, =Rep]
//│ Declared ArraysRep.Init: ArraysRep['A, 'Rep] -> 'A -> 'Rep
//│ Declared ArraysRep.Sub: ArraysRep['A, 'Rep] -> 'Rep -> int -> 'A
//│ Declared ArraysRep.Update: ArraysRep['A, 'Rep] -> 'Rep -> int -> 'A -> 'Rep
//│ Declared ArraysRep.Fold: ArraysRep['A, 'Rep] -> ('A -> 'b -> 'b) -> 'b -> 'Rep -> 'b

class ArraysImpl[A, Rep]: ArraysRep[A, Rep] & {
    init: A -> Rep;
    sub: Rep -> int -> A;
    update: Rep -> int -> A -> Rep;
    fold: forall 'b. (A -> 'b -> 'b) -> 'b -> Rep -> 'b
  }
  method Init = this.init
  method Sub = this.sub
  method Update = this.update
  method Fold = this.fold
//│ Defined class ArraysImpl[=A, =Rep]
//│ Defined ArraysImpl.Init: ArraysImpl['A, 'Rep] -> 'A -> 'Rep
//│ Defined ArraysImpl.Sub: ArraysImpl['A, 'Rep] -> 'Rep -> int -> 'A
//│ Defined ArraysImpl.Update: ArraysImpl['A, 'Rep] -> 'Rep -> int -> 'A -> 'Rep
//│ Defined ArraysImpl.Fold: ArraysImpl['A, 'Rep] -> (forall 'b. ('A -> 'b -> 'b) -> 'b -> 'Rep -> 'b)

type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ Defined type alias Arrays[=A]



baseImpl = ArraysImpl {
    init   = fun a -> a;
    sub    = fun r -> fun (i : int) -> r;
    update = fun r -> fun (i : int) -> fun a -> a;
    fold   = fun f -> fun b -> fun r -> f r b
  }
//│ baseImpl: ArraysImpl['Rep, 'Rep] with {fold: forall 'a. 'a -> (forall 'b. 'b -> (forall 'a, 'c, 'd, 'e, 'b. ('e -> 'd
//│   where
//│     'a <: 'e -> ('b -> 'd & 'c)))), init: forall 'f. 'f -> 'f, sub: forall 'g. 'g -> int -> 'g, update: forall 'h. 'h -> int -> (forall 'i. 'i -> 'i)}
//│         = ArraysImpl {
//│             init: [Function: init],
//│             sub: [Function: sub],
//│             update: [Function: update],
//│             fold: [Function: fold]
//│           }

def base: Arrays['a]
def base f = f baseImpl
//│ base: Arrays['a]
//│     = <missing implementation>
//│ ((forall 'Rep. ArraysImpl['Rep, 'Rep] with {fold: forall 'a. 'a -> (forall 'b. 'b -> (forall 'a, 'c, 'd, 'e, 'b. ('c -> 'd
//│   where
//│     'a <: 'c -> ('b -> 'd & 'e)))), init: forall 'f. 'f -> 'f, sub: forall 'g. 'g -> int -> 'g, update: forall 'h. 'h -> int -> (forall 'i. 'i -> 'i)}) -> 'j & 'k) -> 'j
//│   <:  base:
//│ Arrays['a]
//│     = [Function: base]



def simpleStepImpl arrImpl = ArraysImpl {
    init   = fun a -> (arrImpl.Init a, "initialized");
    sub    = fun ((r0, r1)) -> fun i -> arrImpl.Sub r0 i;
    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.Update r0 i a, "updated");
    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f b r0
  }
//│ simpleStepImpl: (ArraysRep[in 'A | 'A0 | 'A1 & 'A2 out 'A & 'A0 & 'A3 & ('A2 | 'A4), in 'Rep | 'a & 'c & 'd & 'e & 'Rep0 & 'Rep1 | 'a & 'c & 'e & 'Rep0 & 'f & 'Rep2 | 'Rep3 out 'Rep2 & ('a | 'Rep) & ('c | 'Rep1) & ('Rep0 | 'Rep3 | 'Rep4)] & 'g) -> ((ArraysImpl['A1, 'Rep5] with {fold: forall 'h. 'h -> (forall 'i. 'i -> (forall 'A5, 'j, 'i, 'b, 'g, 'Rep6, 'k, 'h, 'l. (('Rep6 & 'k, 'j,) -> ('i | 'l)
//│   where
//│     'h <: 'A5 -> ('b | 'i) -> ('b & 'l)
//│     'g <: ArraysRep['A5, 'Rep6]))) | 'fold, init: forall 'init, 'm, 'A6, 'n, 'Rep7, 'g. (('A6 & 'm) -> ('n, "initialized",) | 'init
//│   where
//│     'g <: ArraysRep['A6, 'Rep7]), sub: forall 'o, 'p. ('o, 'p,) -> (forall 'q, 'A7, 'r, 'g, 'Rep8, 'o. ((int & 'r) -> 'q
//│   where
//│     'g <: ArraysRep['A7, 'Rep8])) | 'sub, update: forall 's, 't. ('s, 't,) -> (forall 'r, 'u. (int & 'u & 'r) -> (forall 'A8, 'Rep9, 'v, 's, 'w, 'g. (('A8 & 'w) -> ('s | 'v, "updated",)
//│   where
//│     'g <: ArraysRep['A8, 'Rep9]))) | 'update}) | 'x)
//│   where
//│     'Rep9 :> 's
//│           <: 'v
//│     'Rep8 :> 'o
//│     'A7 <: 'q
//│     'Rep7 <: 'n
//│     'Rep5 :> ('f | 'c | 'd, "initialized" | "updated",)
//│           <: ('a & 'c & 'e & 'Rep0, 'y & 'z & 'a1,)
//│     'A1 <: 'b1 & 'A & 'c1 & 'A0
//│               = [Function: simpleStepImpl]

simpleStepImpl : ArraysImpl['a, 'r] -> ArraysImpl['a, ('r, string)]
//│ res: ArraysImpl['a, 'r] -> ArraysImpl['a, ('r, string,)]
//│    = [Function: simpleStepImpl]

// def simpleStepImpl2_ty: Arrays['a] -> ArraysImpl['a, ('_, string)]
// def simpleStepImpl2_ty: Arrays['a] -> ArraysImpl['a, '_]
// def simpleStepImpl2 arr = arr simpleStepImpl

def simpleStepImpl2_ty: (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, string)]
//│ simpleStepImpl2_ty: (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, string,)]
//│                   = <missing implementation>


def simpleStepImpl2 arr = arr simpleStepImpl
//│ simpleStepImpl2: ((forall 'a, 'A, 'c, 'A0, 'Rep, 'd, 'Rep0, 'e, 'A1, 'f, 'A2, 'A3, 'Rep1, 'fold, 'g, 'Rep2, 'h, 'i, 'Rep3, 'Rep4, 'Rep5, 'update, 'A4, 'j, 'sub, 'k, 'l, 'm. (ArraysRep[in 'A0 | 'A2 | 'A4 & 'A1 out 'A0 & 'A2 & 'A3 & ('A1 | 'A), in 'Rep | 'j & 'a & 'f & 'e & 'Rep2 & 'Rep0 | 'j & 'a & 'e & 'Rep2 & 'm & 'Rep1 | 'Rep4 out 'Rep1 & ('j | 'Rep) & ('a | 'Rep0) & ('Rep2 | 'Rep4 | 'Rep3)] & 'i) -> ((ArraysImpl['A4, 'Rep5] with {fold: forall 'n. 'n -> (forall 'o. 'o -> (forall 'b, 'Rep6, 'o, 'p, 'A5, 'q, 'i, 'n, 'r. (('Rep6 & 'r, 'q,) -> ('o | 'p)
//│   where
//│     'n <: 'A5 -> ('b | 'o) -> ('b & 'p)
//│     'i <: ArraysRep['A5, 'Rep6]))) | 'fold, init: forall 's, 'Rep7, 'init, 'A6, 'i, 't. (('A6 & 't) -> ('s, "initialized",) | 'init
//│   where
//│     'i <: ArraysRep['A6, 'Rep7]), sub: forall 'u, 'v. ('u, 'v,) -> (forall 'A7, 'i, 'w, 'Rep8, 'u, 'x. ((int & 'x) -> 'w
//│   where
//│     'i <: ArraysRep['A7, 'Rep8])) | 'sub, update: forall 'y, 'z. ('y, 'z,) -> (forall 'x, 'a1. (int & 'a1 & 'x) -> (forall 'b1, 'c1, 'i, 'y, 'Rep9, 'A8. (('A8 & 'b1) -> ('y | 'c1, "updated",)
//│   where
//│     'i <: ArraysRep['A8, 'Rep9]))) | 'update}) | 'l)) -> 'd1 & 'e1) -> 'd1
//│   where
//│     'Rep9 :> 'y
//│           <: 'c1
//│     'Rep8 :> 'u
//│     'A7 <: 'w
//│     'Rep7 <: 's
//│     'Rep5 :> ('m | 'a | 'f, "initialized" | "updated",)
//│           <: ('j & 'a & 'e & 'Rep2, 'k & 'g & 'h,)
//│     'A4 <: 'c & 'A0 & 'd & 'A2
//│                = [Function: simpleStepImpl2]

simpleStepImpl2_ty = simpleStepImpl2
//│ ((forall 'fold, 'A, 'a, 'Rep, 'c, 'd, 'Rep0, 'e, 'Rep1, 'f, 'Rep2, 'g, 'Rep3, 'Rep4, 'update, 'h, 'i, 'j, 'A0, 'A1, 'Rep5, 'A2, 'A3, 'A4, 'k, 'sub, 'l, 'm. (ArraysRep[in 'A1 | 'A | 'A3 & 'A4 out 'A0 & 'A1 & 'A & ('A4 | 'A2), in 'Rep2 | 'e & 'a & 'h & 'g & 'Rep0 & 'Rep3 | 'e & 'a & 'g & 'Rep0 & 'i & 'Rep5 | 'Rep out ('e | 'Rep2) & ('a | 'Rep3) & 'Rep5 & ('Rep0 | 'Rep | 'Rep1)] & 'd) -> ((ArraysImpl['A3, 'Rep4] with {fold: forall 'n. 'n -> (forall 'o. 'o -> (forall 'b, 'Rep6, 'p, 'A5, 'q, 'o, 'r, 'n, 'd. (('Rep6 & 'q, 'p,) -> ('o | 'r)
//│   where
//│     'd <: ArraysRep['A5, 'Rep6]
//│     'n <: 'A5 -> ('b | 'o) -> ('b & 'r)))) | 'fold, init: forall 'init, 'A6, 'd, 'Rep7, 's, 't. (('A6 & 't) -> ('s, "initialized",) | 'init
//│   where
//│     'd <: ArraysRep['A6, 'Rep7]), sub: forall 'u, 'v. ('u, 'v,) -> (forall 'w, 'u, 'Rep8, 'd, 'x, 'A7. ((int & 'w) -> 'x
//│   where
//│     'd <: ArraysRep['A7, 'Rep8])) | 'sub, update: forall 'y, 'z. ('y, 'z,) -> (forall 'w, 'a1. (int & 'a1 & 'w) -> (forall 'd, 'y, 'b1, 'A8, 'c1, 'Rep9. (('A8 & 'c1) -> ('y | 'b1, "updated",)
//│   where
//│     'd <: ArraysRep['A8, 'Rep9]))) | 'update}) | 'm)) -> 'd1 & 'e1) -> 'd1
//│   where
//│     'Rep9 :> 'y
//│           <: 'b1
//│     'Rep8 :> 'u
//│     'A7 <: 'x
//│     'Rep7 <: 's
//│     'Rep4 :> ('i | 'a | 'h, "initialized" | "updated",)
//│           <: ('e & 'a & 'g & 'Rep0, 'l & 'j & 'c,)
//│     'A3 <: 'f & 'A1 & 'k & 'A
//│   <:  simpleStepImpl2_ty:
//│ (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, string,)]
//│                   = [Function: simpleStepImpl2]

:e // * Annotation is actually counter-productive... probably because the rigid universal in Arrays gets extruded!
def simpleStepImpl2_ty (arr: Arrays['a]) = arr simpleStepImpl
//│ Arrays['a] -> ((ArraysImpl[in 'a0 & 'A & 'c & 'A0 & 'd & 'A1 out 'a0 | 'A | 'A2, in (nothing, 'e & 'f & 'g,) & 'Rep out (anything, "initialized" | "updated",) | 'Rep | 'Rep0] with {fold: forall 'h. 'h -> (forall 'i. 'i -> (forall 'j, 'k, 'a0, 'i, 'A3, 'l, 'b, 'm, 'Rep1, 'h. (('Rep1 & 'k, 'm,) -> ('l | 'i)
//│   where
//│     ArraysRep['a0, ?] | 'j <: ArraysRep['A3, 'Rep1]
//│     'h <: 'A3 -> ('b | 'i) -> ('b & 'l)))) | 'fold, init: forall 'n, 'j, 'a0, 'Rep2, 'o, 'A4, 'init. (('A4 & 'o) -> ('n, "initialized",) | 'init
//│   where
//│     ArraysRep['a0, ?] | 'j <: ArraysRep['A4, in 'Rep2 & 'n out 'Rep2]), sub: forall 'p, 'q. ('p, 'q,) -> (forall 'Rep3, 'j, 'p, 'A5, 'r, 'a0, 's. ((int & 's) -> 'r
//│   where
//│     ArraysRep['a0, ?] | 'j <: ArraysRep[in 'A5 & 'r out 'A5, in 'Rep3 out 'Rep3 | 'p])) | 'sub, update: forall 't, 'u. ('t, 'u,) -> (forall 's, 'v. (int & 'v & 's) -> (forall 'j, 'a0, 'w, 't, 'Rep4, 'x, 'A6. (('A6 & 'x) -> ('w | 't, "updated",)
//│   where
//│     ArraysRep['a0, ?] | 'j <: ArraysRep['A6, in 'Rep4 & 'w out 'Rep4 | 't]))) | 'update}) | 'y)
//│   <:  simpleStepImpl2_ty:
//│ (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, string,)]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.162: 	def simpleStepImpl2_ty (arr: Arrays['a]) = arr simpleStepImpl
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘Rep_1662` does not match type `nothing`
//│ ║  l.110: 	def simpleStepImpl2_ty: (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, string)]
//│ ║         	                                                                                          ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.77: 	    sub    = fun ((r0, r1)) -> fun i -> arrImpl.Sub r0 i;
//│ ╙──      	                                                    ^^
//│                   = [Function: simpleStepImpl2_ty1]

def simpleStep: Arrays['a] -> Arrays['a]
//│ simpleStep: Arrays['a] -> Arrays['a]
//│           = <missing implementation>

:e // * Since "sound extrusion"
def simpleStep arr f = f (simpleStepImpl2 arr)
//│ 'a -> (forall 'c, 'd, 'e, 'a, 'f. (('d -> 'e & 'f) -> 'e
//│   where
//│     'a <: (forall 'g, 'h, 'sub, 'i, 'j, 'Rep, 'Rep0, 'A, 'k, 'Rep1, 'l, 'A0, 'm, 'Rep2, 'A1, 'n, 'o, 'A2, 'fold, 'Rep3, 'p, 'Rep4, 'Rep5, 'A3, 'q, 'A4, 'update, 'r. (ArraysRep[in 'A2 | 'A0 | 'A3 & 'A out 'A4 & 'A2 & 'A0 & ('A | 'A1), in 'Rep4 | 'r & 'o & 'n & 'k & 'Rep0 & 'Rep1 | 'r & 'o & 'k & 'Rep0 & 'm & 'Rep3 | 'Rep5 out ('r | 'Rep4) & ('o | 'Rep1) & 'Rep3 & ('Rep0 | 'Rep5 | 'Rep)] & 'g) -> ((ArraysImpl['A3, 'Rep2] with {fold: forall 's. 's -> (forall 't. 't -> (forall 'g, 'Rep6, 'u, 'A5, 'b, 'v, 's, 'w, 't. (('Rep6 & 'u, 'w,) -> ('t | 'v)
//│   where
//│     's <: 'A5 -> ('b | 't) -> ('b & 'v)
//│     'g <: ArraysRep['A5, 'Rep6]))) | 'fold, init: forall 'g, 'x, 'y, 'init, 'Rep7, 'A6. (('A6 & 'x) -> ('y, "initialized",) | 'init
//│   where
//│     'g <: ArraysRep['A6, 'Rep7]), sub: forall 'z, 'a1. ('z, 'a1,) -> (forall 'g, 'A7, 'b1, 'z, 'c1, 'Rep8. ((int & 'c1) -> 'b1
//│   where
//│     'g <: ArraysRep['A7, 'Rep8])) | 'sub, update: forall 'd1, 'e1. ('d1, 'e1,) -> (forall 'f1, 'c1. (int & 'f1 & 'c1) -> (forall 'g, 'g1, 'h1, 'Rep9, 'd1, 'A8. (('A8 & 'g1) -> ('d1 | 'h1, "updated",)
//│   where
//│     'g <: ArraysRep['A8, 'Rep9]))) | 'update}) | 'q)) -> ('c & 'd)))
//│   where
//│     'Rep9 :> 'd1
//│           <: 'h1
//│     'Rep8 :> 'z
//│     'A7 <: 'b1
//│     'Rep7 <: 'y
//│     'Rep2 :> ('m | 'o | 'n, "initialized" | "updated",)
//│           <: ('r & 'o & 'k & 'Rep0, 'l & 'h & 'j,)
//│     'A3 <: 'p & 'A2 & 'i & 'A0
//│   <:  simpleStep:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.194: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.77: 	    sub    = fun ((r0, r1)) -> fun i -> arrImpl.Sub r0 i;
//│ ╙──      	                                                    ^^
//│           = [Function: simpleStep]

:e // TODO update: seems like the given type for `simpleStepImpl2_ty` is not precise enough
def simpleStep arr f = f (simpleStepImpl2_ty arr)
//│ 'a -> (forall 'b, 'a, 'c, 'A, 'Rep, 'd. (((ArraysImpl['A, ('Rep, string,)] | 'd) -> 'b & 'c) -> 'b
//│   where
//│     'a <: forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r))
//│   <:  simpleStep:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.233: 	def simpleStep arr f = f (simpleStepImpl2_ty arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│           = [Function: simpleStep1]

sb = simpleStep base
//│ sb: Arrays['a]
//│   = [Function (anonymous)]

sb (fun arr -> arr.Init true)
//│ res: anything
//│    = [ true, 'initialized' ]

sb (fun arr -> arr.Sub (arr.Init true) 1)
//│ res: true
//│    = true

:e // * Expected – argument order confusion
sb (fun arr -> arr.Sub 0 (arr.Init true))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.263: 	sb (fun arr -> arr.Sub 0 (arr.Init true))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘Rep_2202` is not an instance of type `int`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.16: 	  method Sub: Rep -> int -> A
//│ ║        	                     ^^^
//│ ╟── from application:
//│ ║  l.263: 	sb (fun arr -> arr.Sub 0 (arr.Init true))
//│ ║         	                          ^^^^^^^^^^^^^
//│ ╟── Note: class type parameter Rep is defined at:
//│ ║  l.14: 	class ArraysRep[A, Rep]
//│ ╙──      	                   ^^^
//│ res: error
//│ Runtime error:
//│   TypeError: number 0 is not iterable (cannot read property Symbol(Symbol.iterator))

sb (fun arr -> arr.Update (arr.Init true) 1 false)
//│ res: anything
//│    = [ false, 'updated' ]

:e // * Rightly prevent skolem confusion
sb (fun arr1 -> sb (fun arr2 -> arr2.Update (arr1.Init true)))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.288: 	sb (fun arr1 -> sb (fun arr2 -> arr2.Update (arr1.Init true)))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘Rep_2309` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from application:
//│ ║  l.288: 	sb (fun arr1 -> sb (fun arr2 -> arr2.Update (arr1.Init true)))
//│ ╙──       	                                             ^^^^^^^^^^^^^^
//│ res: error
//│    = [Function (anonymous)]

sb (fun arr ->
    let r2 = arr.Update (arr.Init true) 1 false
    in (arr.Sub r2 0, arr.Sub r2 1)
  )
//│ res: (bool, bool,)
//│    = [ false, false ]



:escape
def Math: nothing
//│ Math: nothing
//│     = <missing implementation>

def div: int -> int -> int
def div a b = Math.trunc(a/b)
//│ div: int -> int -> int
//│    = <missing implementation>
//│ (number & 'a & 'b) -> (forall 'b, 'c. (number & 'b) -> 'c)
//│   <:  div:
//│ int -> int -> int
//│    = [Function: div1]

def mod: int -> int -> int
//│ mod: int -> int -> int
//│    = <missing implementation>

:e // * Since the removal of "recursive definition hacks"
rec def mod a b = if a < b then a else mod (a - b) b
//│ 'mod
//│   where
//│     'mod :> forall 'a. (int & 'a) -> (forall 'mod, 'b, 'c, 'd, 'e, 'f, 'g. ((int & 'b) -> ('a | 'c)
//│   where
//│     'mod <: (int | 'e) -> ('b -> ('g & 'f & 'c) & 'd)))
//│   <:  mod:
//│ int -> int -> int
//│ ╔══[ERROR] Subtyping constraint of the form `forall ?mod. ?mod <: int -> int -> int` exceeded recursion depth limit (250)
//│ ║  l.332: 	rec def mod a b = if a < b then a else mod (a - b) b
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── while constraining:  ‹∀ 1. (α2439_2489'' -> ‹∀ 2. {(α2440_2492''' -> α2450_2495''') where: mod2438_2488# <: ((α2447_2490''',) -> α2448_2491''')}›)›  <!<  ((α2447_2854,) -> α2448_2855)
//│ ╟── while constraining:  mod2438_2488#  <!<  ((α2447_2854,) -> α2448_2855)
//│ ╟── while constraining:  {(α2440_2856 -> α2450_2859) where: mod2438_2488# <: ((α2447_2854,) -> α2448_2855)}  <!<  ((α2440_2843,) -> α2449_2844)
//│ ╟── while constraining:  ‹∀ 2. {(α2440_2850''' -> α2450_2853''') where: mod2438_2488# <: ((α2447_2848''',) -> α2448_2849''')}›  <!<  ((α2440_2843,) -> α2449_2844)
//│ ╟── while constraining:  ‹∀ 2. {(α2440_2850''' -> α2450_2853''') where: mod2438_2488# <: ((α2447_2848''',) -> α2448_2849''')}›  <!<  α2448_2842
//│ ╟── while constraining:  (α2439_2847 -> ‹∀ 2. {(α2440_2850''' -> α2450_2853''') where: mod2438_2488# <: ((α2447_2848''',) -> α2448_2849''')}›)  <!<  ((α2447_2841,) -> α2448_2842)
//│ ╟── while constraining:  ‹∀ 1. (α2439_2489'' -> ‹∀ 2. {(α2440_2492''' -> α2450_2495''') where: mod2438_2488# <: ((α2447_2490''',) -> α2448_2491''')}›)›  <!<  ((α2447_2841,) -> α2448_2842)
//│ ╟── while constraining:  mod2438_2488#  <!<  ((α2447_2841,) -> α2448_2842)
//│ ╟── while constraining:  {(α2440_2843 -> α2450_2846) where: mod2438_2488# <: ((α2447_2841,) -> α2448_2842)}  <!<  ((α2440_2830,) -> α2449_2831)
//│ ╟── while constraining:  ‹∀ 2. {(α2440_2837''' -> α2450_2840''') where: mod2438_2488# <: ((α2447_2835''',) -> α2448_2836''')}›  <!<  ((α2440_2830,) -> α2449_2831)
//│ ╟── while constraining:  ‹∀ 2. {(α2440_2837''' -> α2450_2840''') where: mod2438_2488# <: ((α2447_2835''',) -> α2448_2836''')}›  <!<  α2448_2829
//│ ╟── while constraining:  (α2439_2834 -> ‹∀ 2. {(α2440_2837''' -> α2450_2840''') where: mod2438_2488# <: ((α2447_2835''',) -> α2448_2836''')}›)  <!<  ((α2447_2828,) -> α2448_2829)
//│ ╟── while constraining:  ‹∀ 1. (α2439_2489'' -> ‹∀ 2. {(α2440_2492''' -> α2450_2495''') where: mod2438_2488# <: ((α2447_2490''',) -> α2448_2491''')}›)›  <!<  ((α2447_2828,) -> α2448_2829)
//│ ╟── while constraining:  mod2438_2488#  <!<  ((α2447_2828,) -> α2448_2829)
//│ ╟── while constraining:  {(α2440_2830 -> α2450_2833) where: mod2438_2488# <: ((α2447_2828,) -> α2448_2829)}  <!<  ((α2440_2817,) -> α2449_2818)
//│ ╟── ......
//│ ╟── ......
//│ ╟── while constraining:  (α2439_2522 -> ‹∀ 2. {(α2440_2525''' -> α2450_2528''') where: mod2438_2488# <: ((α2447_2523''',) -> α2448_2524''')}›)  <!<  ((α2447_2516,) -> α2448_2517)
//│ ╟── while constraining:  ‹∀ 1. (α2439_2489'' -> ‹∀ 2. {(α2440_2492''' -> α2450_2495''') where: mod2438_2488# <: ((α2447_2490''',) -> α2448_2491''')}›)›  <!<  ((α2447_2516,) -> α2448_2517)
//│ ╟── while constraining:  mod2438_2488#  <!<  ((α2447_2516,) -> α2448_2517)
//│ ╟── while constraining:  {(α2440_2518 -> α2450_2521) where: mod2438_2488# <: ((α2447_2516,) -> α2448_2517)}  <!<  ((α2440_2505,) -> α2449_2506)
//│ ╟── while constraining:  ‹∀ 2. {(α2440_2512''' -> α2450_2515''') where: mod2438_2488# <: ((α2447_2510''',) -> α2448_2511''')}›  <!<  ((α2440_2505,) -> α2449_2506)
//│ ╟── while constraining:  ‹∀ 2. {(α2440_2512''' -> α2450_2515''') where: mod2438_2488# <: ((α2447_2510''',) -> α2448_2511''')}›  <!<  α2448_2504
//│ ╟── while constraining:  (α2439_2509 -> ‹∀ 2. {(α2440_2512''' -> α2450_2515''') where: mod2438_2488# <: ((α2447_2510''',) -> α2448_2511''')}›)  <!<  ((α2447_2503,) -> α2448_2504)
//│ ╟── while constraining:  ‹∀ 1. (α2439_2489'' -> ‹∀ 2. {(α2440_2492''' -> α2450_2495''') where: mod2438_2488# <: ((α2447_2490''',) -> α2448_2491''')}›)›  <!<  ((α2447_2503,) -> α2448_2504)
//│ ╟── while constraining:  mod2438_2488#  <!<  ((α2447_2503,) -> α2448_2504)
//│ ╟── while constraining:  {(α2440_2505 -> α2450_2508) where: mod2438_2488# <: ((α2447_2503,) -> α2448_2504)}  <!<  (Int -> Int)
//│ ╟── while constraining:  ‹∀ 2. {(α2440_2499''' -> α2450_2502''') where: mod2438_2488# <: ((α2447_2497''',) -> α2448_2498''')}›  <!<  (Int -> Int)
//│ ╟── while constraining:  (α2439_2496 -> ‹∀ 2. {(α2440_2499''' -> α2450_2502''') where: mod2438_2488# <: ((α2447_2497''',) -> α2448_2498''')}›)  <!<  (Int -> (Int -> Int))
//│ ╟── while constraining:  ‹∀ 1. (α2439_2489'' -> ‹∀ 2. {(α2440_2492''' -> α2450_2495''') where: mod2438_2488# <: ((α2447_2490''',) -> α2448_2491''')}›)›  <!<  (Int -> (Int -> Int))
//│ ╟── while constraining:  mod2438_2488#  <!<  (Int -> (Int -> Int))
//│ ╙── while constraining:  ‹∀ 0. mod2438'#›  <!<  (Int -> (Int -> Int))
//│    = [Function: mod]

def stepImpl arrImpl = ArraysImpl {
    init = fun a -> (arrImpl.Init a, arrImpl.Init a);
    sub = fun ((r0, r1)) -> fun i ->
      if mod i 2 == 0
      then arrImpl.Sub r0 (div i 2)
      else arrImpl.Sub r1 (div i 2);
    update = fun ((r0, r1)) -> fun i -> fun a ->
      if mod i 2 == 0
      then (arrImpl.Update r0 (div i 2) a, r1)
      else (r0, arrImpl.Update r1 (div i 2) a);
    fold = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f (arrImpl.Fold f b r0) r1
  }
//│ stepImpl: (ArraysRep[in 'A | 'A0 | 'A1 | 'A2 | 'a & 'c & 'A3 & 'd & 'A4 | 'A3 & ('A5 | 'A6) out 'A7 & 'A & 'A0 & 'A1 & 'A2 & 'A4 & ('A8 & ('A6 | 'A9) | 'A5 & ('A6 | 'A9)), in 'Rep | 'Rep0 | 'e & 'f & 'g & 'h & 'Rep1 & 'Rep2 | 'i & 'j & 'k & 'l & 'Rep3 & 'Rep4 | 'e & 'f & 'h & 'Rep1 & 'm & 'Rep5 | 'i & 'j & 'l & 'Rep3 & 'n & 'Rep6 | 'Rep7 | 'Rep8 out ('i | 'Rep0) & ('f | 'Rep2) & 'Rep5 & 'Rep1 & 'Rep6 & ('j | 'Rep4) & ('e | 'Rep) & ('Rep3 | 'Rep8 | 'Rep9)] & 'o) -> ((ArraysImpl['A3, 'Rep10] with {fold: forall 'p. 'p -> (forall 'q. 'q -> (forall 'r, 'Rep11, 's, 'b, 'q, 'A10, 'Rep12, 't, 'b0, 'p, 'u, 'o, 'A11. (('Rep12 & 'r, 'Rep11 & 's,) -> ('q | 'u)
//│   where
//│     'o <: ArraysRep['A10, 'Rep11] & ArraysRep['A11, 'Rep12]
//│     'p <: 'A10 -> ('b | 'q) -> ('b & 'u) & 'A11 -> ('b0 | 'q) -> ('b & 'u & 'b0 & 't)))) | 'fold, init: forall 'Rep13, 'init, 'v, 'w, 'Rep14, 'A12, 'o, 'A13, 'x. (('A13 & 'A12 & 'w) -> ('v, 'x,) | 'init
//│   where
//│     'o <: ArraysRep['A13, 'Rep13] & ArraysRep['A12, 'Rep14]), sub: forall 'y, 'z. ('y, 'z,) -> (forall 'y, 'Rep15, 'A14, 'a1, 'A15, 'b1, 'c1, 'd1, 'e1, 'Rep16, 'o, 'z. ((int & 'd1) -> 'b1
//│   where
//│     'o <: ArraysRep['A15, 'Rep15] & ArraysRep['A14, 'Rep16])) | 'sub, update: forall 'f1, 'g1. ('f1, 'g1,) -> (forall 'h1, 'd1. (int & 'h1 & 'd1) -> (forall 'i1, 'j1, 'g1, 'k1, 'Rep17, 'f1, 'l1, 'A16, 'A17, 'Rep18, 'o. (('A16 & 'A17 & 'j1) -> (('f1 | 'i1, 'g1 | 'l1,) | 'k1)
//│   where
//│     'o <: ArraysRep['A16, 'Rep17] & ArraysRep['A17, 'Rep18]))) | 'update}) | 'm1)
//│   where
//│     'Rep18 :> 'g1
//│            <: 'l1
//│     'Rep17 :> 'f1
//│            <: 'i1
//│     'Rep16 :> 'z
//│     'A14 <: 'e1 & 'b1 & 'a1
//│     'Rep15 :> 'y
//│     'A15 <: 'c1 & 'e1 & 'b1
//│     'Rep14 <: 'x
//│     'Rep13 <: 'v
//│     'Rep10 :> ('n | 'j | 'k, 'm | 'f | 'g,)
//│            <: ('i & 'j & 'l & 'Rep3, 'e & 'f & 'h & 'Rep1,)
//│     'A3 <: 'n1 & 'A & 'A0 & 'o1 & 'A1 & 'A2
//│         = [Function: stepImpl]

def stepImpl2_ty: (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, 'Rep)]
//│ stepImpl2_ty: (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, 'Rep,)]
//│             = <missing implementation>

def stepImpl2 arr = arr stepImpl
//│ stepImpl2: ((forall 'A, 'a, 'c, 'Rep, 'd, 'sub, 'e, 'A0, 'f, 'Rep0, 'Rep1, 'g, 'Rep2, 'update, 'h, 'i, 'Rep3, 'fold, 'j, 'Rep4, 'A1, 'k, 'l, 'Rep5, 'm, 'n, 'o, 'Rep6, 'A2, 'A3, 'A4, 'Rep7, 'Rep8, 'A5, 'p, 'A6, 'Rep9, 'q, 'Rep10, 'A7, 'A8, 'r, 'A9. (ArraysRep[in 'A5 | 'A8 | 'A1 | 'A2 | 'h & 'i & 'A9 & 'g & 'A6 | 'A9 & ('A0 | 'A4) out 'A5 & 'A8 & 'A1 & 'A2 & 'A6 & 'A3 & ('A7 & ('A0 | 'A) | 'A4 & ('A0 | 'A)), in 'Rep5 | 'Rep7 | 'a & 'n & 'm & 'r & 'Rep9 & 'Rep0 | 'j & 'e & 'p & 'c & 'Rep4 & 'Rep6 | 'a & 'n & 'r & 'Rep9 & 'd & 'Rep3 | 'j & 'e & 'c & 'Rep4 & 'f & 'Rep10 | 'Rep2 | 'Rep out 'Rep9 & 'Rep10 & ('e | 'Rep6) & ('a | 'Rep5) & ('j | 'Rep7) & ('n | 'Rep0) & 'Rep3 & ('Rep4 | 'Rep | 'Rep8)] & 'k) -> ((ArraysImpl['A9, 'Rep1] with {fold: forall 's. 's -> (forall 't. 't -> (forall 'b, 'A10, 'k, 'Rep11, 'u, 'A11, 'v, 's, 'Rep12, 'w, 'x, 'b0, 't. (('Rep11 & 'v, 'Rep12 & 'x,) -> ('t | 'w)
//│   where
//│     'k <: ArraysRep['A10, 'Rep12] & ArraysRep['A11, 'Rep11]
//│     's <: 'A10 -> ('b0 | 't) -> ('b0 & 'w) & 'A11 -> ('b | 't) -> ('b0 & 'w & 'b & 'u)))) | 'fold, init: forall 'Rep13, 'k, 'A12, 'y, 'z, 'A13, 'init, 'a1, 'Rep14. (('A13 & 'A12 & 'a1) -> ('y, 'z,) | 'init
//│   where
//│     'k <: ArraysRep['A13, 'Rep14] & ArraysRep['A12, 'Rep13]), sub: forall 'b1, 'c1. ('c1, 'b1,) -> (forall 'A14, 'k, 'Rep15, 'A15, 'd1, 'c1, 'e1, 'f1, 'g1, 'h1, 'Rep16, 'b1. ((int & 'h1) -> 'g1
//│   where
//│     'k <: ArraysRep['A14, 'Rep16] & ArraysRep['A15, 'Rep15])) | 'sub, update: forall 'i1, 'j1. ('i1, 'j1,) -> (forall 'h1, 'k1. (int & 'k1 & 'h1) -> (forall 'Rep17, 'j1, 'k, 'l1, 'm1, 'i1, 'A16, 'n1, 'Rep18, 'A17, 'o1. (('A16 & 'A17 & 'n1) -> (('i1 | 'm1, 'j1 | 'l1,) | 'o1)
//│   where
//│     'k <: ArraysRep['A16, 'Rep18] & ArraysRep['A17, 'Rep17]))) | 'update}) | 'l)) -> 'p1 & 'q1) -> 'p1
//│   where
//│     'Rep17 :> 'j1
//│            <: 'l1
//│     'Rep18 :> 'i1
//│            <: 'm1
//│     'Rep15 :> 'b1
//│     'A15 <: 'f1 & 'g1 & 'e1
//│     'Rep16 :> 'c1
//│     'A14 <: 'd1 & 'f1 & 'g1
//│     'Rep13 <: 'z
//│     'Rep14 <: 'y
//│     'Rep1 :> ('f | 'e | 'p, 'd | 'n | 'm,)
//│           <: ('j & 'e & 'c & 'Rep4, 'a & 'n & 'r & 'Rep9,)
//│     'A9 <: 'q & 'A5 & 'A8 & 'o & 'A1 & 'A2
//│          = [Function: stepImpl2]

stepImpl2_ty = stepImpl2
//│ ((forall 'A, 'a, 'A0, 'Rep, 'c, 'fold, 'd, 'e, 'Rep0, 'f, 'g, 'A1, 'Rep1, 'A2, 'h, 'i, 'Rep2, 'Rep3, 'j, 'Rep4, 'A3, 'Rep5, 'update, 'A4, 'k, 'Rep6, 'l, 'A5, 'm, 'A6, 'Rep7, 'Rep8, 'n, 'o, 'p, 'A7, 'Rep9, 'q, 'r, 'Rep10, 'sub, 'A8, 'A9. (ArraysRep[in 'A4 | 'A1 | 'A9 | 'A0 | 'g & 'm & 'A3 & 'k & 'A6 | 'A3 & ('A | 'A8) out 'A6 & 'A7 & 'A4 & 'A1 & 'A9 & 'A0 & ('A2 & ('A | 'A5) | 'A8 & ('A | 'A5)), in 'Rep0 | 'Rep10 | 'c & 'l & 'i & 'p & 'Rep8 & 'Rep2 | 'j & 'r & 'o & 'a & 'Rep7 & 'Rep | 'c & 'l & 'p & 'Rep8 & 'h & 'Rep1 | 'j & 'r & 'a & 'Rep7 & 'n & 'Rep6 | 'Rep9 | 'Rep3 out ('c | 'Rep0) & ('j | 'Rep10) & ('l | 'Rep2) & 'Rep1 & 'Rep8 & 'Rep6 & ('r | 'Rep) & ('Rep7 | 'Rep3 | 'Rep5)] & 'd) -> ((ArraysImpl['A3, 'Rep4] with {fold: forall 's. 's -> (forall 't. 't -> (forall 'Rep11, 'u, 'v, 'b, 'A10, 'd, 'w, 't, 'A11, 'b0, 'Rep12, 'x, 's. (('Rep12 & 'x, 'Rep11 & 'v,) -> ('t | 'u)
//│   where
//│     'd <: ArraysRep['A10, 'Rep11] & ArraysRep['A11, 'Rep12]
//│     's <: 'A10 -> ('b0 | 't) -> ('b0 & 'u) & 'A11 -> ('b | 't) -> ('b0 & 'u & 'b & 'w)))) | 'fold, init: forall 'y, 'Rep13, 'Rep14, 'd, 'A12, 'A13, 'z, 'init, 'a1. (('A12 & 'A13 & 'z) -> ('a1, 'y,) | 'init
//│   where
//│     'd <: ArraysRep['A12, 'Rep13] & ArraysRep['A13, 'Rep14]), sub: forall 'b1, 'c1. ('b1, 'c1,) -> (forall 'A14, 'd1, 'b1, 'e1, 'f1, 'g1, 'c1, 'h1, 'A15, 'Rep15, 'd, 'Rep16. ((int & 'e1) -> 'h1
//│   where
//│     'd <: ArraysRep['A15, 'Rep15] & ArraysRep['A14, 'Rep16])) | 'sub, update: forall 'i1, 'j1. ('i1, 'j1,) -> (forall 'e1, 'k1. (int & 'k1 & 'e1) -> (forall 'A16, 'l1, 'A17, 'j1, 'Rep17, 'd, 'm1, 'i1, 'n1, 'o1, 'Rep18. (('A17 & 'A16 & 'o1) -> (('i1 | 'n1, 'j1 | 'm1,) | 'l1)
//│   where
//│     'd <: ArraysRep['A17, 'Rep18] & ArraysRep['A16, 'Rep17]))) | 'update}) | 'e)) -> 'p1 & 'q1) -> 'p1
//│   where
//│     'Rep17 :> 'j1
//│            <: 'm1
//│     'Rep18 :> 'i1
//│            <: 'n1
//│     'Rep16 :> 'c1
//│     'A14 <: 'g1 & 'h1 & 'f1
//│     'Rep15 :> 'b1
//│     'A15 <: 'd1 & 'g1 & 'h1
//│     'Rep14 <: 'y
//│     'Rep13 <: 'a1
//│     'Rep4 :> ('n | 'r | 'o, 'h | 'l | 'i,)
//│           <: ('j & 'r & 'a & 'Rep7, 'c & 'l & 'p & 'Rep8,)
//│     'A3 <: 'q & 'A4 & 'A1 & 'f & 'A9 & 'A0
//│   <:  stepImpl2_ty:
//│ (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, 'Rep,)]
//│             = [Function: stepImpl2]


def step: Arrays['a] -> Arrays['a]
//│ step: Arrays['a] -> Arrays['a]
//│     = <missing implementation>

:e // * Since "sound extrusion"
def step arr f = f (stepImpl2 arr)
//│ 'a -> (forall 'c, 'd, 'e, 'a, 'f. (('d -> 'c & 'f) -> 'c
//│   where
//│     'a <: (forall 'update, 'Rep, 'A, 'g, 'fold, 'Rep0, 'Rep1, 'h, 'A0, 'i, 'j, 'k, 'A1, 'Rep2, 'l, 'm, 'A2, 'Rep3, 'Rep4, 'n, 'A3, 'A4, 'A5, 'o, 'Rep5, 'A6, 'Rep6, 'A7, 'p, 'Rep7, 'q, 'sub, 'r, 'A8, 'Rep8, 's, 't, 'u, 'Rep9, 'A9, 'v, 'Rep10, 'w. (ArraysRep[in 'A4 | 'A0 | 'A6 | 'A3 | 'j & 'q & 'A & 'l & 'A9 | 'A & ('A5 | 'A7) out 'A9 & 'A8 & 'A4 & 'A0 & 'A6 & 'A3 & ('A1 & ('A5 | 'A2) | 'A7 & ('A5 | 'A2)), in 'Rep1 | 'Rep6 | 'w & 's & 'r & 'o & 'Rep2 & 'Rep3 | 'p & 'u & 'm & 'g & 'Rep0 & 'Rep9 | 'w & 's & 'o & 'Rep2 & 'k & 'Rep8 | 'p & 'u & 'g & 'Rep0 & 'h & 'Rep4 | 'Rep5 | 'Rep out ('w | 'Rep1) & ('p | 'Rep6) & ('s | 'Rep3) & 'Rep8 & 'Rep2 & 'Rep4 & ('u | 'Rep9) & ('Rep0 | 'Rep | 'Rep10)] & 'i) -> ((ArraysImpl['A, 'Rep7] with {fold: forall 'x. 'x -> (forall 'y. 'y -> (forall 'b, 'x, 'A10, 'z, 'a1, 'Rep11, 'b0, 'i, 'b1, 'y, 'Rep12, 'c1, 'A11. (('Rep11 & 'c1, 'Rep12 & 'a1,) -> ('y | 'b1)
//│   where
//│     'i <: ArraysRep['A11, 'Rep12] & ArraysRep['A10, 'Rep11]
//│     'x <: 'A11 -> ('b0 | 'y) -> ('b0 & 'b1) & 'A10 -> ('b | 'y) -> ('b0 & 'b1 & 'b & 'z)))) | 'fold, init: forall 'A12, 'd1, 'e1, 'Rep13, 'Rep14, 'init, 'A13, 'f1, 'i. (('A13 & 'A12 & 'f1) -> ('d1, 'e1,) | 'init
//│   where
//│     'i <: ArraysRep['A13, 'Rep13] & ArraysRep['A12, 'Rep14]), sub: forall 'g1, 'h1. ('g1, 'h1,) -> (forall 'i1, 'j1, 'g1, 'A14, 'Rep15, 'i, 'k1, 'Rep16, 'A15, 'h1, 'l1, 'm1. ((int & 'l1) -> 'm1
//│   where
//│     'i <: ArraysRep['A14, 'Rep15] & ArraysRep['A15, 'Rep16])) | 'sub, update: forall 'n1, 'o1. ('n1, 'o1,) -> (forall 'l1, 'p1. (int & 'p1 & 'l1) -> (forall 'Rep17, 'n1, 'q1, 'r1, 'Rep18, 'o1, 's1, 'i, 'A16, 'A17, 't1. (('A17 & 'A16 & 'r1) -> (('n1 | 's1, 'o1 | 'q1,) | 't1)
//│   where
//│     'i <: ArraysRep['A17, 'Rep18] & ArraysRep['A16, 'Rep17]))) | 'update}) | 'v)) -> ('e & 'd)))
//│   where
//│     'Rep17 :> 'o1
//│            <: 'q1
//│     'Rep18 :> 'n1
//│            <: 's1
//│     'Rep16 :> 'h1
//│     'A15 <: 'j1 & 'm1 & 'i1
//│     'Rep15 :> 'g1
//│     'A14 <: 'k1 & 'j1 & 'm1
//│     'Rep14 <: 'e1
//│     'Rep13 <: 'd1
//│     'Rep7 :> ('h | 'u | 'm, 'k | 's | 'r,)
//│           <: ('p & 'u & 'g & 'Rep0, 'w & 's & 'o & 'Rep2,)
//│     'A <: 'n & 'A4 & 'A0 & 't & 'A6 & 'A3
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.481: 	def step arr f = f (stepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.381: 	      then arrImpl.Sub r0 (div i 2)
//│ ╙──       	                       ^^
//│     = [Function: step]

// * Now the annotation was okay [until "sound extrusion"] because the result no longer extruded it...
:e // * Since "sound extrusion"
def step (arr: Arrays['a]) f = f (stepImpl2 arr)
//│ Arrays['a] -> (forall 'fold, 'c, 'd, 'A, 'e, 'Rep, 'A0, 'f, 'A1, 'a0, 'update, 'A2, 'sub, 'A3, 'A4, 'Rep0, 'g. (((ArraysImpl[in 'a0 & 'A & 'c & 'A1 & 'A0 & 'e & 'A3 & 'A2 out 'a0 | 'A | 'A4, in (nothing, nothing,) & 'Rep out (anything, anything,) | 'Rep | 'Rep0] with {fold: forall 'h. 'h -> (forall 'i. 'i -> (forall 'A5, 'i, 'j, 'A6, 'k, 'Rep1, 'h, 'l, 'Rep2, 'm, 'n, 'a0, 'b, 'b0. (('Rep2 & 'j, 'Rep1 & 'n,) -> ('i | 'l)
//│   where
//│     'h <: 'A6 -> ('b0 | 'i) -> ('b0 & 'l) & 'A5 -> ('b | 'i) -> ('b0 & 'l & 'b & 'k)
//│     ArraysRep['a0, ?] | 'm <: ArraysRep['A6, 'Rep1] & ArraysRep['A5, 'Rep2]))) | 'fold, init: forall 'Rep3, 'A7, 'Rep4, 'o, 'p, 'a0, 'init, 'A8, 'q, 'm. (('A7 & 'A8 & 'o) -> ('p, 'q,) | 'init
//│   where
//│     ArraysRep['a0, ?] | 'm <: ArraysRep['A7, in 'Rep4 & 'p out 'Rep4] & ArraysRep['A8, in 'Rep3 & 'q out 'Rep3]), sub: forall 'r, 's. ('r, 's,) -> (forall 's, 't, 'm, 'r, 'u, 'v, 'w, 'Rep5, 'a0, 'x, 'Rep6, 'A9, 'A10. ((int & 'x) -> 't
//│   where
//│     ArraysRep['a0, ?] | 'm <: ArraysRep[in 'A9 & 'w & 'u & 't out 'A9, in 'Rep6 out 'Rep6 | 'r] & ArraysRep[in 'u & 't & 'A10 & 'v out 'A10, in 'Rep5 out 'Rep5 | 's])) | 'sub, update: forall 'y, 'z. ('y, 'z,) -> (forall 'x, 'a1. (int & 'a1 & 'x) -> (forall 'A11, 'A12, 'm, 'y, 'b1, 'z, 'c1, 'd1, 'Rep7, 'a0, 'Rep8, 'e1. (('A11 & 'A12 & 'b1) -> (('y | 'e1, 'z | 'c1,) | 'd1)
//│   where
//│     ArraysRep['a0, ?] | 'm <: ArraysRep['A11, in 'Rep7 & 'e1 out 'Rep7 | 'y] & ArraysRep['A12, in 'Rep8 & 'c1 out 'Rep8 | 'z]))) | 'update}) | 'd) -> 'f & 'g) -> 'f)
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.526: 	def step (arr: Arrays['a]) f = f (stepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.381: 	      then arrImpl.Sub r0 (div i 2)
//│ ╙──       	                       ^^
//│     = [Function: step1]

// * Don't know why these don't work:
:e
def step arr f = f (stepImpl2_ty arr)
//│ 'a -> (forall 'Rep, 'a, 'b, 'c, 'd, 'A. (((ArraysImpl['A, ('Rep, 'Rep,)] | 'c) -> 'd & 'b) -> 'd
//│   where
//│     'a <: forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r))
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.555: 	def step arr f = f (stepImpl2_ty arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│     = [Function: step2]
:e
def step (arr: Arrays['a]) f = f (stepImpl2_ty arr)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.572: 	def step (arr: Arrays['a]) f = f (stepImpl2_ty arr)
//│ ║         	                                  ^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ Arrays['a] -> (forall 'b, 'c, 'd. ((error | 'b) -> 'c & 'd) -> 'c)
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│     = [Function: step3]


ssb = step (step base)
//│ ssb: Arrays['a]
//│    = [Function (anonymous)]

ssb (fun arr ->
    let r2 = arr.Update (arr.Init true) 1 false
    in (arr.Sub r2 0, arr.Sub r2 1)
  )
//│ res: (bool, bool,)
//│    = [ true, false ]



rec def mkMonoArray n =
  if n == 0 then base else step (mkMonoArray(n - 1))
//│ mkMonoArray: 'mkMonoArray
//│   where
//│     'mkMonoArray :> forall 'b, 'a, 'c, 'd, 'mkMonoArray. ((int & 'c) -> (forall 'a, 'e. Arrays['a] | 'e)
//│   where
//│     'mkMonoArray <: (int | 'd) -> (Arrays['a] & 'b))
//│            = [Function: mkMonoArray]

:e // * Since the removal of "recursive definition hacks"
snb = mkMonoArray 5
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.611: 	snb = mkMonoArray 5
//│ ║         	      ^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  mkMonoArray5510_5549'#  <:  ((α5518_5560',) -> α5519_5561')    TypeVariable  FunctionType
//│ ╙──  ... looks like:  mkMonoArray5510'#  <:  ((α5518_5550'',) -> α5519_5551'')
//│ snb: error
//│    = [Function (anonymous)]

snb (fun arr -> arr.Init true)
//│ res: error
//│    = [
//│        [ [ [Array], [Array] ], [ [Array], [Array] ] ],
//│        [ [ [Array], [Array] ], [ [Array], [Array] ] ]
//│      ]


// * From the paper:
// let mkPolyArray n = {∀α(∃ρ.∀β.sig(α,ρ,β))} (mkMonoArray n)





