// * Adaptation of QML's original existentials example; using encoded existentials and classes


:NoRecursiveTypes
:GeneralizeCurriedFunctions
:ConstrainedTypes
// :DistributeForalls
// :ArgGen

// TODO try without some signatures



class ArraysRep[A, Rep]
  method Init: A -> Rep
  method Sub: Rep -> int -> A
  method Update: Rep -> int -> A -> Rep
  method Fold: (A -> 'b -> 'b) -> 'b -> Rep -> 'b
//│ Defined class ArraysRep[=A, =Rep]
//│ Declared ArraysRep.Init: ArraysRep['A, 'Rep] -> 'A -> 'Rep
//│ Declared ArraysRep.Sub: ArraysRep['A, 'Rep] -> 'Rep -> int -> 'A
//│ Declared ArraysRep.Update: ArraysRep['A, 'Rep] -> 'Rep -> int -> 'A -> 'Rep
//│ Declared ArraysRep.Fold: ArraysRep['A, 'Rep] -> ('A -> 'b -> 'b) -> 'b -> 'Rep -> 'b

class ArraysImpl[A, Rep]: ArraysRep[A, Rep] & {
    init: A -> Rep;
    sub: Rep -> int -> A;
    update: Rep -> int -> A -> Rep;
    fold: forall 'b. (A -> 'b -> 'b) -> 'b -> Rep -> 'b
  }
  method Init = this.init
  method Sub = this.sub
  method Update = this.update
  method Fold = this.fold
//│ Defined class ArraysImpl[=A, =Rep]
//│ Defined ArraysImpl.Init: ArraysImpl['A, 'Rep] -> 'A -> 'Rep
//│ Defined ArraysImpl.Sub: ArraysImpl['A, 'Rep] -> 'Rep -> int -> 'A
//│ Defined ArraysImpl.Update: ArraysImpl['A, 'Rep] -> 'Rep -> int -> 'A -> 'Rep
//│ Defined ArraysImpl.Fold: ArraysImpl['A, 'Rep] -> (forall 'b. ('A -> 'b -> 'b) -> 'b -> 'Rep -> 'b)

type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ Defined type alias Arrays[=A]



baseImpl = ArraysImpl {
    init   = fun a -> a;
    sub    = fun r -> fun (i : int) -> r;
    update = fun r -> fun (i : int) -> fun a -> a;
    fold   = fun f -> fun b -> fun r -> f r b
  }
//│ baseImpl: ArraysImpl['Rep, 'Rep] with {fold: forall 'a. 'a -> (forall 'b. 'b -> (forall 'c, 'd. ('c -> 'd
//│   where
//│     'a <: 'c -> 'b -> 'd))), init: forall 'e. 'e -> 'e, sub: forall 'f. 'f -> int -> 'f, update: anything -> int -> (forall 'g. 'g -> 'g)}
//│         = ArraysImpl {
//│             init: [Function: init],
//│             sub: [Function: sub],
//│             update: [Function: update],
//│             fold: [Function: fold]
//│           }

def base: Arrays['a]
def base f = f baseImpl
//│ base: Arrays['a]
//│     = <missing implementation>
//│ ((forall 'Rep. ArraysImpl['Rep, 'Rep] with {fold: forall 'a. 'a -> (forall 'b. 'b -> (forall 'c, 'd. ('c -> 'd
//│   where
//│     'a <: 'c -> 'b -> 'd))), init: forall 'e. 'e -> 'e, sub: forall 'f. 'f -> int -> 'f, update: anything -> int -> (forall 'g. 'g -> 'g)}) -> 'h) -> 'h
//│   <:  base:
//│ Arrays['a]
//│     = [Function: base]



def simpleStepImpl arrImpl = ArraysImpl {
    init   = fun a -> (arrImpl.Init a, "initialized");
    sub    = fun ((r0, r1)) -> fun i -> arrImpl.Sub r0 i;
    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.Update r0 i a, "updated");
    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f b r0
  }
//│ simpleStepImpl: (ArraysRep[in 'A | 'A0 | 'A1 & 'A2 out nothing, in 'Rep | 'Rep0 out nothing] & 'a) -> (ArraysImpl['A1, 'Rep1] with {fold: forall 'c. 'c -> (forall 'd. 'd -> (forall 'A3, 'Rep2, 'b. (('Rep2, anything,) -> ('d | 'b)
//│   where
//│     'a <: ArraysRep['A3, 'Rep2]
//│     'c <: 'A3 -> ('d | 'b) -> 'b))), init: forall 'A4, 'Rep3. ('A4 -> ('Rep3, "initialized",)
//│   where
//│     'a <: ArraysRep['A4, 'Rep3]), sub: forall 'e. ('e, anything,) -> (forall 'A5, 'Rep4. (int -> 'A5
//│   where
//│     'a <: ArraysRep['A5, 'Rep4])), update: forall 'f. ('f, anything,) -> int -> (forall 'A6, 'Rep5. ('A6 -> ('Rep5, "updated",)
//│   where
//│     'a <: ArraysRep['A6, 'Rep5]))})
//│   where
//│     'Rep5 :> 'f
//│     'Rep4 :> 'e
//│     'Rep1 :> (nothing, "initialized" | "updated",)
//│           <: (nothing, anything,)
//│     'A1 <: 'A & 'A0
//│               = [Function: simpleStepImpl]

simpleStepImpl : ArraysImpl['a, 'r] -> ArraysImpl['a, ('r, string)]
//│ res: ArraysImpl['a, 'r] -> ArraysImpl['a, ('r, string,)]
//│    = [Function: simpleStepImpl]

// def simpleStepImpl2_ty: Arrays['a] -> ArraysImpl['a, ('_, string)]
// def simpleStepImpl2_ty: Arrays['a] -> ArraysImpl['a, '_]
// def simpleStepImpl2 arr = arr simpleStepImpl

def simpleStepImpl2_ty: (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, string)]
//│ simpleStepImpl2_ty: (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, string,)]
//│                   = <missing implementation>


def simpleStepImpl2 arr = arr simpleStepImpl
//│ simpleStepImpl2: ((forall 'a, 'A, 'A0, 'Rep, 'A1, 'Rep0, 'Rep1, 'A2. (ArraysRep[in 'A0 | 'A1 | 'A2 & 'A out nothing, in 'Rep1 | 'Rep out nothing] & 'a) -> (ArraysImpl['A2, 'Rep0] with {fold: forall 'c. 'c -> (forall 'd. 'd -> (forall 'A3, 'Rep2, 'b. (('Rep2, anything,) -> ('d | 'b)
//│   where
//│     'c <: 'A3 -> ('d | 'b) -> 'b
//│     'a <: ArraysRep['A3, 'Rep2]))), init: forall 'A4, 'Rep3. ('A4 -> ('Rep3, "initialized",)
//│   where
//│     'a <: ArraysRep['A4, 'Rep3]), sub: forall 'e. ('e, anything,) -> (forall 'A5, 'Rep4. (int -> 'A5
//│   where
//│     'a <: ArraysRep['A5, 'Rep4])), update: forall 'f. ('f, anything,) -> int -> (forall 'A6, 'Rep5. ('A6 -> ('Rep5, "updated",)
//│   where
//│     'a <: ArraysRep['A6, 'Rep5]))})) -> 'g) -> 'g
//│   where
//│     'Rep5 :> 'f
//│     'Rep4 :> 'e
//│     'Rep0 :> (nothing, "initialized" | "updated",)
//│           <: (nothing, anything,)
//│     'A2 <: 'A0 & 'A1
//│                = [Function: simpleStepImpl2]

simpleStepImpl2_ty = simpleStepImpl2
//│ ((forall 'Rep, 'A, 'A0, 'a, 'A1, 'A2, 'Rep0, 'Rep1. (ArraysRep[in 'A1 | 'A | 'A0 & 'A2 out nothing, in 'Rep1 | 'Rep out nothing] & 'a) -> (ArraysImpl['A0, 'Rep0] with {fold: forall 'c. 'c -> (forall 'd. 'd -> (forall 'A3, 'Rep2, 'b. (('Rep2, anything,) -> ('d | 'b)
//│   where
//│     'a <: ArraysRep['A3, 'Rep2]
//│     'c <: 'A3 -> ('d | 'b) -> 'b))), init: forall 'A4, 'Rep3. ('A4 -> ('Rep3, "initialized",)
//│   where
//│     'a <: ArraysRep['A4, 'Rep3]), sub: forall 'e. ('e, anything,) -> (forall 'A5, 'Rep4. (int -> 'A5
//│   where
//│     'a <: ArraysRep['A5, 'Rep4])), update: forall 'f. ('f, anything,) -> int -> (forall 'A6, 'Rep5. ('A6 -> ('Rep5, "updated",)
//│   where
//│     'a <: ArraysRep['A6, 'Rep5]))})) -> 'g) -> 'g
//│   where
//│     'Rep5 :> 'f
//│     'Rep4 :> 'e
//│     'Rep0 :> (nothing, "initialized" | "updated",)
//│           <: (nothing, anything,)
//│     'A0 <: 'A1 & 'A
//│   <:  simpleStepImpl2_ty:
//│ (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, string,)]
//│                   = [Function: simpleStepImpl2]

:e // * Annotation is actually counter-productive... probably because the rigid universal in Arrays gets extruded!
def simpleStepImpl2_ty (arr: Arrays['a]) = arr simpleStepImpl
//│ Arrays['a] -> (ArraysImpl[out 'a0, in (nothing, anything,) & 'Rep out (anything, "initialized" | "updated",) | 'Rep] with {fold: forall 'c. 'c -> (forall 'd. 'd -> (forall 'A, 'Rep0, 'b. (('Rep0, anything,) -> ('d | 'b)
//│   where
//│     ArraysRep['a0, ?] <: ArraysRep['A, 'Rep0]
//│     'c <: 'A -> ('d | 'b) -> 'b))), init: forall 'A0, 'Rep1. ('A0 -> ('Rep1, "initialized",)
//│   where
//│     ArraysRep['a0, ?] <: ArraysRep['A0, 'Rep1]), sub: forall 'e. ('e, anything,) -> (forall 'A1, 'Rep2. (int -> 'A1
//│   where
//│     ArraysRep['a0, ?] <: ArraysRep['A1, 'Rep2])), update: forall 'f. ('f, anything,) -> int -> (forall 'A2, 'Rep3. ('A2 -> ('Rep3, "updated",)
//│   where
//│     ArraysRep['a0, ?] <: ArraysRep['A2, 'Rep3]))})
//│   where
//│     'Rep3 :> 'f
//│     'Rep2 :> 'e
//│   <:  simpleStepImpl2_ty:
//│ (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, string,)]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.153: 	def simpleStepImpl2_ty (arr: Arrays['a]) = arr simpleStepImpl
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘Rep_1402` does not match type `nothing`
//│ ║  l.107: 	def simpleStepImpl2_ty: (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, string)]
//│ ║         	                                                                                          ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.77: 	    sub    = fun ((r0, r1)) -> fun i -> arrImpl.Sub r0 i;
//│ ╙──      	                                                    ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.153: 	def simpleStepImpl2_ty (arr: Arrays['a]) = arr simpleStepImpl
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘Rep_1402` does not match type `nothing`
//│ ║  l.107: 	def simpleStepImpl2_ty: (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, string)]
//│ ║         	                                                                                          ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.78: 	    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.Update r0 i a, "updated");
//│ ╙──      	                                                                 ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.153: 	def simpleStepImpl2_ty (arr: Arrays['a]) = arr simpleStepImpl
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘Rep_1402` does not match type `nothing`
//│ ║  l.107: 	def simpleStepImpl2_ty: (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, string)]
//│ ║         	                                                                                          ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.78: 	    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.Update r0 i a, "updated");
//│ ╙──      	                                                                 ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.153: 	def simpleStepImpl2_ty (arr: Arrays['a]) = arr simpleStepImpl
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘Rep_1402` does not match type `nothing`
//│ ║  l.107: 	def simpleStepImpl2_ty: (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, string)]
//│ ║         	                                                                                          ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.78: 	    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.Update r0 i a, "updated");
//│ ╙──      	                                                                 ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.153: 	def simpleStepImpl2_ty (arr: Arrays['a]) = arr simpleStepImpl
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘Rep_1402` does not match type `nothing`
//│ ║  l.107: 	def simpleStepImpl2_ty: (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, string)]
//│ ║         	                                                                                          ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.79: 	    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f b r0
//│ ╙──      	                                                                  ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.153: 	def simpleStepImpl2_ty (arr: Arrays['a]) = arr simpleStepImpl
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` is not an instance of type `'Rep_1402`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from type variable:
//│ ║  l.107: 	def simpleStepImpl2_ty: (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, string)]
//│ ╙──       	                                                                                          ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.153: 	def simpleStepImpl2_ty (arr: Arrays['a]) = arr simpleStepImpl
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` is not an instance of type `'Rep_1402`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from type variable:
//│ ║  l.107: 	def simpleStepImpl2_ty: (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, string)]
//│ ╙──       	                                                                                          ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.153: 	def simpleStepImpl2_ty (arr: Arrays['a]) = arr simpleStepImpl
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` is not an instance of type `'Rep_1402`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from type variable:
//│ ║  l.107: 	def simpleStepImpl2_ty: (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, string)]
//│ ╙──       	                                                                                          ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.153: 	def simpleStepImpl2_ty (arr: Arrays['a]) = arr simpleStepImpl
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` is not an instance of type `'Rep_1402`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from type variable:
//│ ║  l.107: 	def simpleStepImpl2_ty: (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, string)]
//│ ╙──       	                                                                                          ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.153: 	def simpleStepImpl2_ty (arr: Arrays['a]) = arr simpleStepImpl
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.153: 	def simpleStepImpl2_ty (arr: Arrays['a]) = arr simpleStepImpl
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` is not an instance of type `'Rep_1402`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from type variable:
//│ ║  l.107: 	def simpleStepImpl2_ty: (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, string)]
//│ ╙──       	                                                                                          ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.153: 	def simpleStepImpl2_ty (arr: Arrays['a]) = arr simpleStepImpl
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.153: 	def simpleStepImpl2_ty (arr: Arrays['a]) = arr simpleStepImpl
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘Rep_1402` does not match type `nothing`
//│ ║  l.107: 	def simpleStepImpl2_ty: (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, string)]
//│ ║         	                                                                                          ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.153: 	def simpleStepImpl2_ty (arr: Arrays['a]) = arr simpleStepImpl
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.153: 	def simpleStepImpl2_ty (arr: Arrays['a]) = arr simpleStepImpl
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘Rep_1402` does not match type `nothing`
//│ ║  l.107: 	def simpleStepImpl2_ty: (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, string)]
//│ ║         	                                                                                          ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.153: 	def simpleStepImpl2_ty (arr: Arrays['a]) = arr simpleStepImpl
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` is not an instance of type `'Rep_1402`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from type variable:
//│ ║  l.107: 	def simpleStepImpl2_ty: (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, string)]
//│ ╙──       	                                                                                          ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.153: 	def simpleStepImpl2_ty (arr: Arrays['a]) = arr simpleStepImpl
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.153: 	def simpleStepImpl2_ty (arr: Arrays['a]) = arr simpleStepImpl
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘Rep_1402` does not match type `nothing`
//│ ║  l.107: 	def simpleStepImpl2_ty: (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, string)]
//│ ║         	                                                                                          ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│                   = [Function: simpleStepImpl2_ty1]

def simpleStep: Arrays['a] -> Arrays['a]
//│ simpleStep: Arrays['a] -> Arrays['a]
//│           = <missing implementation>

:e // * Since "sound extrusion"
def simpleStep arr f = f (simpleStepImpl2 arr)
//│ 'a -> (forall 'c, 'd. (('c -> 'd) -> 'd
//│   where
//│     'a <: (forall 'A, 'e, 'Rep. (ArraysRep[in anything out nothing, in anything out nothing] & 'e) -> (ArraysImpl['A, 'Rep] with {fold: forall 'f. 'f -> (forall 'g. 'g -> (forall 'A0, 'Rep0, 'b. (('Rep0, anything,) -> ('g | 'b)
//│   where
//│     'f <: 'A0 -> ('g | 'b) -> 'b
//│     'e <: ArraysRep['A0, 'Rep0]))), init: forall 'A1, 'Rep1. ('A1 -> ('Rep1, "initialized",)
//│   where
//│     'e <: ArraysRep['A1, 'Rep1]), sub: forall 'h. ('h, anything,) -> (forall 'Rep2, 'A2. (int -> 'A2
//│   where
//│     'e <: ArraysRep['A2, 'Rep2])), update: forall 'i. ('i, anything,) -> int -> (forall 'A3, 'Rep3. ('A3 -> ('Rep3, "updated",)
//│   where
//│     'e <: ArraysRep['A3, 'Rep3]))})) -> 'c))
//│   where
//│     'Rep3 :> 'i
//│     'Rep2 :> 'h
//│     'Rep :> (nothing, "initialized" | "updated",)
//│          <: (nothing, anything,)
//│     'A <: nothing
//│   <:  simpleStep:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.353: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.77: 	    sub    = fun ((r0, r1)) -> fun i -> arrImpl.Sub r0 i;
//│ ╙──      	                                                    ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.353: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.77: 	    sub    = fun ((r0, r1)) -> fun i -> arrImpl.Sub r0 i;
//│ ╙──      	                                                    ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.353: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.77: 	    sub    = fun ((r0, r1)) -> fun i -> arrImpl.Sub r0 i;
//│ ╙──      	                                                    ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.353: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.78: 	    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.Update r0 i a, "updated");
//│ ╙──      	                                                                 ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.353: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.78: 	    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.Update r0 i a, "updated");
//│ ╙──      	                                                                 ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.353: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.78: 	    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.Update r0 i a, "updated");
//│ ╙──      	                                                                 ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.353: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.78: 	    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.Update r0 i a, "updated");
//│ ╙──      	                                                                 ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.353: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.78: 	    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.Update r0 i a, "updated");
//│ ╙──      	                                                                 ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.353: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.78: 	    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.Update r0 i a, "updated");
//│ ╙──      	                                                                 ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.353: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.78: 	    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.Update r0 i a, "updated");
//│ ╙──      	                                                                 ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.353: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.78: 	    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.Update r0 i a, "updated");
//│ ╙──      	                                                                 ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.353: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.78: 	    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.Update r0 i a, "updated");
//│ ╙──      	                                                                 ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.353: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.78: 	    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.Update r0 i a, "updated");
//│ ╙──      	                                                                 ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.353: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.78: 	    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.Update r0 i a, "updated");
//│ ╙──      	                                                                 ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.353: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.78: 	    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.Update r0 i a, "updated");
//│ ╙──      	                                                                 ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.353: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.79: 	    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f b r0
//│ ╙──      	                                                                  ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.353: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.79: 	    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f b r0
//│ ╙──      	                                                                  ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.353: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.79: 	    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f b r0
//│ ╙──      	                                                                  ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.353: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.79: 	    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f b r0
//│ ╙──      	                                                                  ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.353: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.79: 	    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f b r0
//│ ╙──      	                                                                  ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.353: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.79: 	    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f b r0
//│ ╙──      	                                                                  ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.353: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.77: 	    sub    = fun ((r0, r1)) -> fun i -> arrImpl.Sub r0 i;
//│ ╙──      	                                                    ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.353: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.78: 	    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.Update r0 i a, "updated");
//│ ╙──      	                                                                 ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.353: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.78: 	    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.Update r0 i a, "updated");
//│ ╙──      	                                                                 ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.353: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.78: 	    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.Update r0 i a, "updated");
//│ ╙──      	                                                                 ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.353: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.78: 	    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.Update r0 i a, "updated");
//│ ╙──      	                                                                 ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.353: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.78: 	    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.Update r0 i a, "updated");
//│ ╙──      	                                                                 ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.353: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.79: 	    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f b r0
//│ ╙──      	                                                                  ^^
//│           = [Function: simpleStep]

:e // TODO update: seems like the given type for `simpleStepImpl2_ty` is not precise enough
def simpleStep arr f = f (simpleStepImpl2_ty arr)
//│ 'a -> (forall 'A, 'Rep, 'b. ((ArraysImpl['A, ('Rep, string,)] -> 'b) -> 'b
//│   where
//│     'a <: forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r))
//│   <:  simpleStep:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.713: 	def simpleStep arr f = f (simpleStepImpl2_ty arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│           = [Function: simpleStep1]

sb = simpleStep base
//│ sb: Arrays['a]
//│   = [Function (anonymous)]

sb (fun arr -> arr.Init true)
//│ res: anything
//│    = [ true, 'initialized' ]

sb (fun arr -> arr.Sub (arr.Init true) 1)
//│ res: true
//│    = true

:e // * Expected – argument order confusion
sb (fun arr -> arr.Sub 0 (arr.Init true))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.743: 	sb (fun arr -> arr.Sub 0 (arr.Init true))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘Rep_1919` is not an instance of type `int`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.16: 	  method Sub: Rep -> int -> A
//│ ║        	                     ^^^
//│ ╟── from application:
//│ ║  l.743: 	sb (fun arr -> arr.Sub 0 (arr.Init true))
//│ ║         	                          ^^^^^^^^^^^^^
//│ ╟── Note: class type parameter Rep is defined at:
//│ ║  l.14: 	class ArraysRep[A, Rep]
//│ ╙──      	                   ^^^
//│ res: error | true
//│ Runtime error:
//│   TypeError: number 0 is not iterable (cannot read property Symbol(Symbol.iterator))

sb (fun arr -> arr.Update (arr.Init true) 1 false)
//│ res: anything
//│    = [ false, 'updated' ]

:e // * Rightly prevent skolem confusion
sb (fun arr1 -> sb (fun arr2 -> arr2.Update (arr1.Init true)))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.768: 	sb (fun arr1 -> sb (fun arr2 -> arr2.Update (arr1.Init true)))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘Rep_2026` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from application:
//│ ║  l.768: 	sb (fun arr1 -> sb (fun arr2 -> arr2.Update (arr1.Init true)))
//│ ╙──       	                                             ^^^^^^^^^^^^^^
//│ res: int -> anything -> anything | error
//│    = [Function (anonymous)]

sb (fun arr ->
    let r2 = arr.Update (arr.Init true) 1 false
    in (arr.Sub r2 0, arr.Sub r2 1)
  )
//│ res: (bool, bool,)
//│    = [ false, false ]



:escape
def Math: nothing
//│ Math: nothing
//│     = <missing implementation>

def div: int -> int -> int
def div a b = Math.trunc(a/b)
//│ div: int -> int -> int
//│    = <missing implementation>
//│ number -> number -> nothing
//│   <:  div:
//│ int -> int -> int
//│    = [Function: div1]

def mod: int -> int -> int
//│ mod: int -> int -> int
//│    = <missing implementation>

:e // * Since the removal of "recursive definition hacks"
rec def mod a b = if a < b then a else mod (a - b) b
//│ 'mod
//│   where
//│     'mod :> forall 'a. (int & 'a) -> (forall 'b, 'c. ((int & 'b) -> ('a | 'c)
//│   where
//│     'mod <: int -> 'b -> 'c))
//│   <:  mod:
//│ int -> int -> int
//│ ╔══[ERROR] Subtyping constraint of the form `forall ?mod. ?mod <: int -> int -> int` exceeded recursion depth limit (200)
//│ ║  l.812: 	rec def mod a b = if a < b then a else mod (a - b) b
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── while constraining:  α2166_2487  <!<  α2158_2493
//│ ╟── while constraining:  (α2166_2487,)  <!<  (α2158_2493,)
//│ ╟── while constraining:  (α2158_2493 -> ‹∀ 2. {(α2159_2496''' -> α2169_2499''') where: mod2157_2199# <: ((α2166_2494''',) -> α2167_2495''')}›)  <!<  ((α2166_2487,) -> α2167_2488)
//│ ╟── while constraining:  ‹∀ 1. (α2158_2200'' -> ‹∀ 2. {(α2159_2203''' -> α2169_2206''') where: mod2157_2199# <: ((α2166_2201''',) -> α2167_2202''')}›)›  <!<  ((α2166_2487,) -> α2167_2488)
//│ ╟── while constraining:  mod2157_2199#  <!<  ((α2166_2487,) -> α2167_2488)
//│ ╟── while constraining:  {(α2159_2489 -> α2169_2492) where: mod2157_2199# <: ((α2166_2487,) -> α2167_2488)}  <!<  ((α2159_2476,) -> α2168_2477)
//│ ╟── while constraining:  ‹∀ 2. {(α2159_2483''' -> α2169_2486''') where: mod2157_2199# <: ((α2166_2481''',) -> α2167_2482''')}›  <!<  ((α2159_2476,) -> α2168_2477)
//│ ╟── while constraining:  ‹∀ 2. {(α2159_2483''' -> α2169_2486''') where: mod2157_2199# <: ((α2166_2481''',) -> α2167_2482''')}›  <!<  α2167_2475
//│ ╟── while constraining:  (α2158_2480 -> ‹∀ 2. {(α2159_2483''' -> α2169_2486''') where: mod2157_2199# <: ((α2166_2481''',) -> α2167_2482''')}›)  <!<  ((α2166_2474,) -> α2167_2475)
//│ ╟── while constraining:  ‹∀ 1. (α2158_2200'' -> ‹∀ 2. {(α2159_2203''' -> α2169_2206''') where: mod2157_2199# <: ((α2166_2201''',) -> α2167_2202''')}›)›  <!<  ((α2166_2474,) -> α2167_2475)
//│ ╟── while constraining:  mod2157_2199#  <!<  ((α2166_2474,) -> α2167_2475)
//│ ╟── while constraining:  {(α2159_2476 -> α2169_2479) where: mod2157_2199# <: ((α2166_2474,) -> α2167_2475)}  <!<  ((α2159_2463,) -> α2168_2464)
//│ ╟── while constraining:  ‹∀ 2. {(α2159_2470''' -> α2169_2473''') where: mod2157_2199# <: ((α2166_2468''',) -> α2167_2469''')}›  <!<  ((α2159_2463,) -> α2168_2464)
//│ ╟── while constraining:  ‹∀ 2. {(α2159_2470''' -> α2169_2473''') where: mod2157_2199# <: ((α2166_2468''',) -> α2167_2469''')}›  <!<  α2167_2462
//│ ╟── while constraining:  (α2158_2467 -> ‹∀ 2. {(α2159_2470''' -> α2169_2473''') where: mod2157_2199# <: ((α2166_2468''',) -> α2167_2469''')}›)  <!<  ((α2166_2461,) -> α2167_2462)
//│ ╟── ......
//│ ╟── ......
//│ ╟── while constraining:  (α2158_2233 -> ‹∀ 2. {(α2159_2236''' -> α2169_2239''') where: mod2157_2199# <: ((α2166_2234''',) -> α2167_2235''')}›)  <!<  ((α2166_2227,) -> α2167_2228)
//│ ╟── while constraining:  ‹∀ 1. (α2158_2200'' -> ‹∀ 2. {(α2159_2203''' -> α2169_2206''') where: mod2157_2199# <: ((α2166_2201''',) -> α2167_2202''')}›)›  <!<  ((α2166_2227,) -> α2167_2228)
//│ ╟── while constraining:  mod2157_2199#  <!<  ((α2166_2227,) -> α2167_2228)
//│ ╟── while constraining:  {(α2159_2229 -> α2169_2232) where: mod2157_2199# <: ((α2166_2227,) -> α2167_2228)}  <!<  ((α2159_2216,) -> α2168_2217)
//│ ╟── while constraining:  ‹∀ 2. {(α2159_2223''' -> α2169_2226''') where: mod2157_2199# <: ((α2166_2221''',) -> α2167_2222''')}›  <!<  ((α2159_2216,) -> α2168_2217)
//│ ╟── while constraining:  ‹∀ 2. {(α2159_2223''' -> α2169_2226''') where: mod2157_2199# <: ((α2166_2221''',) -> α2167_2222''')}›  <!<  α2167_2215
//│ ╟── while constraining:  (α2158_2220 -> ‹∀ 2. {(α2159_2223''' -> α2169_2226''') where: mod2157_2199# <: ((α2166_2221''',) -> α2167_2222''')}›)  <!<  ((α2166_2214,) -> α2167_2215)
//│ ╟── while constraining:  ‹∀ 1. (α2158_2200'' -> ‹∀ 2. {(α2159_2203''' -> α2169_2206''') where: mod2157_2199# <: ((α2166_2201''',) -> α2167_2202''')}›)›  <!<  ((α2166_2214,) -> α2167_2215)
//│ ╟── while constraining:  mod2157_2199#  <!<  ((α2166_2214,) -> α2167_2215)
//│ ╟── while constraining:  {(α2159_2216 -> α2169_2219) where: mod2157_2199# <: ((α2166_2214,) -> α2167_2215)}  <!<  (Int -> Int)
//│ ╟── while constraining:  ‹∀ 2. {(α2159_2210''' -> α2169_2213''') where: mod2157_2199# <: ((α2166_2208''',) -> α2167_2209''')}›  <!<  (Int -> Int)
//│ ╟── while constraining:  (α2158_2207 -> ‹∀ 2. {(α2159_2210''' -> α2169_2213''') where: mod2157_2199# <: ((α2166_2208''',) -> α2167_2209''')}›)  <!<  (Int -> (Int -> Int))
//│ ╟── while constraining:  ‹∀ 1. (α2158_2200'' -> ‹∀ 2. {(α2159_2203''' -> α2169_2206''') where: mod2157_2199# <: ((α2166_2201''',) -> α2167_2202''')}›)›  <!<  (Int -> (Int -> Int))
//│ ╟── while constraining:  mod2157_2199#  <!<  (Int -> (Int -> Int))
//│ ╙── while constraining:  ‹∀ 0. mod2157'#›  <!<  (Int -> (Int -> Int))
//│    = [Function: mod]

def stepImpl arrImpl = ArraysImpl {
    init = fun a -> (arrImpl.Init a, arrImpl.Init a);
    sub = fun ((r0, r1)) -> fun i ->
      if mod i 2 == 0
      then arrImpl.Sub r0 (div i 2)
      else arrImpl.Sub r1 (div i 2);
    update = fun ((r0, r1)) -> fun i -> fun a ->
      if mod i 2 == 0
      then (arrImpl.Update r0 (div i 2) a, r1)
      else (r0, arrImpl.Update r1 (div i 2) a);
    fold = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f (arrImpl.Fold f b r0) r1
  }
//│ stepImpl: (ArraysRep[in 'A | 'A0 | 'A1 | 'A2 | 'A3 & 'A4 | 'A3 & ('A5 | 'A6) out nothing, in anything out nothing] & 'a) -> (ArraysImpl['A3, 'Rep] with {fold: forall 'c. 'c -> (forall 'd. 'd -> (forall 'Rep0, 'b, 'Rep1, 'b0, 'A7, 'A8. (('Rep1, 'Rep0,) -> ('d | 'b)
//│   where
//│     'a <: ArraysRep['A8, 'Rep0] & ArraysRep['A7, 'Rep1]
//│     'c <: 'A8 -> ('d | 'b) -> 'b & 'A7 -> ('b0 | 'd) -> ('b & 'b0)))), init: forall 'A9, 'Rep2, 'A10, 'Rep3. (('A9 & 'A10) -> ('Rep2, 'Rep3,)
//│   where
//│     'a <: ArraysRep['A9, 'Rep2] & ArraysRep['A10, 'Rep3]), sub: forall 'e, 'f. ('f, 'e,) -> (forall 'Rep4, 'A11, 'Rep5, 'g, 'A12. (int -> 'g
//│   where
//│     'a <: ArraysRep['A12, 'Rep5] & ArraysRep['A11, 'Rep4])), update: forall 'h, 'i. ('h, 'i,) -> int -> (forall 'A13, 'Rep6, 'A14, 'Rep7. (('A13 & 'A14) -> ('Rep6 | 'h, 'Rep7 | 'i,)
//│   where
//│     'a <: ArraysRep['A13, 'Rep6] & ArraysRep['A14, 'Rep7]))})
//│   where
//│     'Rep7 :> 'i
//│     'Rep6 :> 'h
//│     'Rep4 :> 'e
//│     'A11 <: 'g
//│     'Rep5 :> 'f
//│     'A12 <: 'g
//│     'Rep :> ('j, 'k,)
//│          <: (nothing, nothing,)
//│     'A3 <: 'A & 'A0 & 'A1 & 'A2
//│         = [Function: stepImpl]

def stepImpl2_ty: (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, 'Rep)]
//│ stepImpl2_ty: (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, 'Rep,)]
//│             = <missing implementation>

def stepImpl2 arr = arr stepImpl
//│ stepImpl2: ((forall 'A, 'A0, 'A1, 'a, 'A2, 'A3, 'A4, 'A5, 'Rep, 'c, 'A6, 'd. (ArraysRep[in 'A2 | 'A0 | 'A4 | 'A5 | 'A & 'A1 | 'A & ('A6 | 'A3) out nothing, in anything out nothing] & 'a) -> (ArraysImpl['A, 'Rep] with {fold: forall 'e. 'e -> (forall 'f. 'f -> (forall 'Rep0, 'b, 'Rep1, 'A7, 'A8, 'b0. (('Rep0, 'Rep1,) -> ('f | 'b)
//│   where
//│     'a <: ArraysRep['A8, 'Rep1] & ArraysRep['A7, 'Rep0]
//│     'e <: 'A8 -> ('f | 'b) -> 'b & 'A7 -> ('b0 | 'f) -> ('b & 'b0)))), init: forall 'A9, 'Rep2, 'A10, 'Rep3. (('A9 & 'A10) -> ('Rep2, 'Rep3,)
//│   where
//│     'a <: ArraysRep['A9, 'Rep2] & ArraysRep['A10, 'Rep3]), sub: forall 'g, 'h. ('g, 'h,) -> (forall 'A11, 'A12, 'Rep4, 'i, 'Rep5. (int -> 'i
//│   where
//│     'a <: ArraysRep['A12, 'Rep5] & ArraysRep['A11, 'Rep4])), update: forall 'j, 'k. ('j, 'k,) -> int -> (forall 'A13, 'Rep6, 'A14, 'Rep7. (('A13 & 'A14) -> ('Rep6 | 'j, 'Rep7 | 'k,)
//│   where
//│     'a <: ArraysRep['A13, 'Rep6] & ArraysRep['A14, 'Rep7]))})) -> 'l) -> 'l
//│   where
//│     'Rep7 :> 'k
//│     'Rep6 :> 'j
//│     'Rep4 :> 'h
//│     'A11 <: 'i
//│     'Rep5 :> 'g
//│     'A12 <: 'i
//│     'Rep :> ('d, 'c,)
//│          <: (nothing, nothing,)
//│     'A <: 'A2 & 'A0 & 'A4 & 'A5
//│          = [Function: stepImpl2]

stepImpl2_ty = stepImpl2
//│ ((forall 'a, 'A, 'c, 'A0, 'A1, 'd, 'Rep, 'A2, 'A3, 'A4, 'A5, 'A6. (ArraysRep[in 'A1 | 'A4 | 'A2 | 'A3 | 'A5 & 'A6 | 'A5 & ('A | 'A0) out nothing, in anything out nothing] & 'd) -> (ArraysImpl['A5, 'Rep] with {fold: forall 'e. 'e -> (forall 'f. 'f -> (forall 'A7, 'Rep0, 'b, 'Rep1, 'A8, 'b0. (('Rep0, 'Rep1,) -> ('f | 'b)
//│   where
//│     'e <: 'A8 -> ('f | 'b) -> 'b & 'A7 -> ('b0 | 'f) -> ('b & 'b0)
//│     'd <: ArraysRep['A8, 'Rep1] & ArraysRep['A7, 'Rep0]))), init: forall 'A9, 'Rep2, 'A10, 'Rep3. (('A9 & 'A10) -> ('Rep2, 'Rep3,)
//│   where
//│     'd <: ArraysRep['A9, 'Rep2] & ArraysRep['A10, 'Rep3]), sub: forall 'g, 'h. ('g, 'h,) -> (forall 'i, 'Rep4, 'A11, 'A12, 'Rep5. (int -> 'i
//│   where
//│     'd <: ArraysRep['A12, 'Rep5] & ArraysRep['A11, 'Rep4])), update: forall 'j, 'k. ('j, 'k,) -> int -> (forall 'A13, 'Rep6, 'A14, 'Rep7. (('A13 & 'A14) -> ('Rep6 | 'j, 'Rep7 | 'k,)
//│   where
//│     'd <: ArraysRep['A13, 'Rep6] & ArraysRep['A14, 'Rep7]))})) -> 'l) -> 'l
//│   where
//│     'Rep7 :> 'k
//│     'Rep6 :> 'j
//│     'Rep4 :> 'h
//│     'A11 <: 'i
//│     'Rep5 :> 'g
//│     'A12 <: 'i
//│     'Rep :> ('c, 'a,)
//│          <: (nothing, nothing,)
//│     'A5 <: 'A1 & 'A4 & 'A2 & 'A3
//│   <:  stepImpl2_ty:
//│ (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, 'Rep,)]
//│             = [Function: stepImpl2]


def step: Arrays['a] -> Arrays['a]
//│ step: Arrays['a] -> Arrays['a]
//│     = <missing implementation>

:e // * Since "sound extrusion"
def step arr f = f (stepImpl2 arr)
//│ 'a -> (forall 'c, 'd. (('c -> 'd) -> 'd
//│   where
//│     'a <: (forall 'e, 'A, 'Rep, 'f, 'g. (ArraysRep[in anything out nothing, in anything out nothing] & 'f) -> (ArraysImpl['A, 'Rep] with {fold: forall 'h. 'h -> (forall 'i. 'i -> (forall 'b, 'Rep0, 'b0, 'Rep1, 'A0, 'A1. (('Rep1, 'Rep0,) -> ('i | 'b0)
//│   where
//│     'f <: ArraysRep['A0, 'Rep0] & ArraysRep['A1, 'Rep1]
//│     'h <: 'A0 -> ('i | 'b0) -> 'b0 & 'A1 -> ('b | 'i) -> ('b0 & 'b)))), init: forall 'A2, 'Rep2, 'A3, 'Rep3. (('A2 & 'A3) -> ('Rep2, 'Rep3,)
//│   where
//│     'f <: ArraysRep['A2, 'Rep2] & ArraysRep['A3, 'Rep3]), sub: forall 'j, 'k. ('j, 'k,) -> (forall 'A4, 'Rep4, 'Rep5, 'A5, 'l. (int -> 'l
//│   where
//│     'f <: ArraysRep['A4, 'Rep5] & ArraysRep['A5, 'Rep4])), update: forall 'm, 'n. ('m, 'n,) -> int -> (forall 'A6, 'Rep6, 'A7, 'Rep7. (('A6 & 'A7) -> ('Rep6 | 'm, 'Rep7 | 'n,)
//│   where
//│     'f <: ArraysRep['A6, 'Rep6] & ArraysRep['A7, 'Rep7]))})) -> 'c))
//│   where
//│     'Rep7 :> 'n
//│     'Rep6 :> 'm
//│     'Rep4 :> 'k
//│     'A5 <: 'l
//│     'Rep5 :> 'j
//│     'A4 <: 'l
//│     'Rep :> ('g, 'e,)
//│          <: (nothing, nothing,)
//│     'A <: nothing
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.949: 	def step arr f = f (stepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.861: 	      then arrImpl.Sub r0 (div i 2)
//│ ╙──       	                       ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.949: 	def step arr f = f (stepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.861: 	      then arrImpl.Sub r0 (div i 2)
//│ ╙──       	                       ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.949: 	def step arr f = f (stepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.862: 	      else arrImpl.Sub r1 (div i 2);
//│ ╙──       	                       ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.949: 	def step arr f = f (stepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.862: 	      else arrImpl.Sub r1 (div i 2);
//│ ╙──       	                       ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.949: 	def step arr f = f (stepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.862: 	      else arrImpl.Sub r1 (div i 2);
//│ ╙──       	                       ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.949: 	def step arr f = f (stepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.866: 	      else (r0, arrImpl.Update r1 (div i 2) a);
//│ ╙──       	            ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.949: 	def step arr f = f (stepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.865: 	      then (arrImpl.Update r0 (div i 2) a, r1)
//│ ╙──       	                           ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.949: 	def step arr f = f (stepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.866: 	      else (r0, arrImpl.Update r1 (div i 2) a);
//│ ╙──       	            ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.949: 	def step arr f = f (stepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.865: 	      then (arrImpl.Update r0 (div i 2) a, r1)
//│ ╙──       	                           ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.949: 	def step arr f = f (stepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.866: 	      else (r0, arrImpl.Update r1 (div i 2) a);
//│ ╙──       	            ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.949: 	def step arr f = f (stepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.865: 	      then (arrImpl.Update r0 (div i 2) a, r1)
//│ ╙──       	                           ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.949: 	def step arr f = f (stepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.866: 	      else (r0, arrImpl.Update r1 (div i 2) a);
//│ ╙──       	            ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.949: 	def step arr f = f (stepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.865: 	      then (arrImpl.Update r0 (div i 2) a, r1)
//│ ╙──       	                           ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.949: 	def step arr f = f (stepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.866: 	      else (r0, arrImpl.Update r1 (div i 2) a);
//│ ╙──       	                               ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.949: 	def step arr f = f (stepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.866: 	      else (r0, arrImpl.Update r1 (div i 2) a);
//│ ╙──       	                               ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.949: 	def step arr f = f (stepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.866: 	      else (r0, arrImpl.Update r1 (div i 2) a);
//│ ╙──       	                               ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.949: 	def step arr f = f (stepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.865: 	      then (arrImpl.Update r0 (div i 2) a, r1)
//│ ╙──       	                                           ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.949: 	def step arr f = f (stepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.866: 	      else (r0, arrImpl.Update r1 (div i 2) a);
//│ ╙──       	                               ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.949: 	def step arr f = f (stepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.866: 	      else (r0, arrImpl.Update r1 (div i 2) a);
//│ ╙──       	                               ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.949: 	def step arr f = f (stepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.866: 	      else (r0, arrImpl.Update r1 (div i 2) a);
//│ ╙──       	                               ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.949: 	def step arr f = f (stepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.865: 	      then (arrImpl.Update r0 (div i 2) a, r1)
//│ ╙──       	                                           ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.949: 	def step arr f = f (stepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.866: 	      else (r0, arrImpl.Update r1 (div i 2) a);
//│ ╙──       	                               ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.949: 	def step arr f = f (stepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.866: 	      else (r0, arrImpl.Update r1 (div i 2) a);
//│ ╙──       	                               ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.949: 	def step arr f = f (stepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.866: 	      else (r0, arrImpl.Update r1 (div i 2) a);
//│ ╙──       	                               ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.949: 	def step arr f = f (stepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.865: 	      then (arrImpl.Update r0 (div i 2) a, r1)
//│ ╙──       	                                           ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.949: 	def step arr f = f (stepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.861: 	      then arrImpl.Sub r0 (div i 2)
//│ ╙──       	                       ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.949: 	def step arr f = f (stepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.861: 	      then arrImpl.Sub r0 (div i 2)
//│ ╙──       	                       ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.949: 	def step arr f = f (stepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.862: 	      else arrImpl.Sub r1 (div i 2);
//│ ╙──       	                       ^^
//│     = [Function: step]

// * Now the annotation was okay [until "sound extrusion"] because the result no longer extruded it...
:e // * Since "sound extrusion"
def step (arr: Arrays['a]) f = f (stepImpl2 arr)
//│ Arrays['a] -> (forall 'c, 'a0, 'Rep. ((ArraysImpl[out 'a0, in (nothing, nothing,) & 'Rep out (anything, anything,) | 'Rep] with {fold: forall 'd. 'd -> (forall 'e. 'e -> (forall 'b, 'Rep0, 'A, 'Rep1, 'b0, 'A0. (('Rep0, 'Rep1,) -> ('e | 'b0)
//│   where
//│     ArraysRep['a0, ?] <: ArraysRep['A, 'Rep1] & ArraysRep['A0, 'Rep0]
//│     'd <: 'A -> ('e | 'b0) -> 'b0 & 'A0 -> ('b | 'e) -> ('b0 & 'b)))), init: forall 'A1, 'Rep2, 'A2, 'Rep3. (('A1 & 'A2) -> ('Rep2, 'Rep3,)
//│   where
//│     ArraysRep['a0, ?] <: ArraysRep['A1, 'Rep2] & ArraysRep['A2, 'Rep3]), sub: forall 'f, 'g. ('f, 'g,) -> (forall 'Rep4, 'A3, 'Rep5, 'A4, 'h. (int -> 'h
//│   where
//│     ArraysRep['a0, ?] <: ArraysRep['A4, 'Rep4] & ArraysRep['A3, 'Rep5])), update: forall 'i, 'j. ('i, 'j,) -> int -> (forall 'A5, 'Rep6, 'A6, 'Rep7. (('A5 & 'A6) -> ('Rep6 | 'i, 'Rep7 | 'j,)
//│   where
//│     ArraysRep['a0, ?] <: ArraysRep['A5, 'Rep6] & ArraysRep['A6, 'Rep7]))}) -> 'c) -> 'c)
//│   where
//│     'Rep7 :> 'j
//│     'Rep6 :> 'i
//│     'Rep5 :> 'g
//│     'A3 <: 'h
//│     'Rep4 :> 'f
//│     'A4 <: 'h
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1314: 	def step (arr: Arrays['a]) f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.861: 	      then arrImpl.Sub r0 (div i 2)
//│ ╙──       	                       ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1314: 	def step (arr: Arrays['a]) f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.861: 	      then arrImpl.Sub r0 (div i 2)
//│ ╙──       	                       ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1314: 	def step (arr: Arrays['a]) f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.862: 	      else arrImpl.Sub r1 (div i 2);
//│ ╙──       	                       ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1314: 	def step (arr: Arrays['a]) f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.862: 	      else arrImpl.Sub r1 (div i 2);
//│ ╙──       	                       ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1314: 	def step (arr: Arrays['a]) f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.862: 	      else arrImpl.Sub r1 (div i 2);
//│ ╙──       	                       ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1314: 	def step (arr: Arrays['a]) f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.866: 	      else (r0, arrImpl.Update r1 (div i 2) a);
//│ ╙──       	            ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1314: 	def step (arr: Arrays['a]) f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.865: 	      then (arrImpl.Update r0 (div i 2) a, r1)
//│ ╙──       	                           ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1314: 	def step (arr: Arrays['a]) f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.866: 	      else (r0, arrImpl.Update r1 (div i 2) a);
//│ ╙──       	            ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1314: 	def step (arr: Arrays['a]) f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.865: 	      then (arrImpl.Update r0 (div i 2) a, r1)
//│ ╙──       	                           ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1314: 	def step (arr: Arrays['a]) f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.866: 	      else (r0, arrImpl.Update r1 (div i 2) a);
//│ ╙──       	            ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1314: 	def step (arr: Arrays['a]) f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.865: 	      then (arrImpl.Update r0 (div i 2) a, r1)
//│ ╙──       	                           ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1314: 	def step (arr: Arrays['a]) f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.866: 	      else (r0, arrImpl.Update r1 (div i 2) a);
//│ ╙──       	            ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1314: 	def step (arr: Arrays['a]) f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.865: 	      then (arrImpl.Update r0 (div i 2) a, r1)
//│ ╙──       	                           ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1314: 	def step (arr: Arrays['a]) f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.866: 	      else (r0, arrImpl.Update r1 (div i 2) a);
//│ ╙──       	                               ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1314: 	def step (arr: Arrays['a]) f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.866: 	      else (r0, arrImpl.Update r1 (div i 2) a);
//│ ╙──       	                               ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1314: 	def step (arr: Arrays['a]) f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.866: 	      else (r0, arrImpl.Update r1 (div i 2) a);
//│ ╙──       	                               ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1314: 	def step (arr: Arrays['a]) f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.865: 	      then (arrImpl.Update r0 (div i 2) a, r1)
//│ ╙──       	                                           ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1314: 	def step (arr: Arrays['a]) f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.866: 	      else (r0, arrImpl.Update r1 (div i 2) a);
//│ ╙──       	                               ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1314: 	def step (arr: Arrays['a]) f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.866: 	      else (r0, arrImpl.Update r1 (div i 2) a);
//│ ╙──       	                               ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1314: 	def step (arr: Arrays['a]) f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.866: 	      else (r0, arrImpl.Update r1 (div i 2) a);
//│ ╙──       	                               ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1314: 	def step (arr: Arrays['a]) f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.865: 	      then (arrImpl.Update r0 (div i 2) a, r1)
//│ ╙──       	                                           ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1314: 	def step (arr: Arrays['a]) f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.866: 	      else (r0, arrImpl.Update r1 (div i 2) a);
//│ ╙──       	                               ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1314: 	def step (arr: Arrays['a]) f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.866: 	      else (r0, arrImpl.Update r1 (div i 2) a);
//│ ╙──       	                               ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1314: 	def step (arr: Arrays['a]) f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.866: 	      else (r0, arrImpl.Update r1 (div i 2) a);
//│ ╙──       	                               ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1314: 	def step (arr: Arrays['a]) f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.865: 	      then (arrImpl.Update r0 (div i 2) a, r1)
//│ ╙──       	                                           ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1314: 	def step (arr: Arrays['a]) f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.861: 	      then arrImpl.Sub r0 (div i 2)
//│ ╙──       	                       ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1314: 	def step (arr: Arrays['a]) f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.861: 	      then arrImpl.Sub r0 (div i 2)
//│ ╙──       	                       ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1314: 	def step (arr: Arrays['a]) f = f (stepImpl2 arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.862: 	      else arrImpl.Sub r1 (div i 2);
//│ ╙──       	                       ^^
//│     = [Function: step1]

// * Don't know why these don't work:
:e
def step arr f = f (stepImpl2_ty arr)
//│ 'a -> (forall 'A, 'Rep, 'b. ((ArraysImpl['A, ('Rep, 'Rep,)] -> 'b) -> 'b
//│   where
//│     'a <: forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r))
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.1674: 	def step arr f = f (stepImpl2_ty arr)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│     = [Function: step2]
:e
def step (arr: Arrays['a]) f = f (stepImpl2_ty arr)
//│ Arrays['a] -> (forall 'A, 'Rep, 'b. ((ArraysImpl['A, ('Rep, 'Rep,)] | error) -> 'b) -> 'b)
//│   where
//│     'Rep :> anything
//│          <: nothing
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.1691: 	def step (arr: Arrays['a]) f = f (stepImpl2_ty arr)
//│ ║          	                                  ^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.41: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│     = [Function: step3]


ssb = step (step base)
//│ ssb: Arrays['a]
//│    = [Function (anonymous)]

ssb (fun arr ->
    let r2 = arr.Update (arr.Init true) 1 false
    in (arr.Sub r2 0, arr.Sub r2 1)
  )
//│ res: (bool, bool,)
//│    = [ true, false ]



rec def mkMonoArray n =
  if n == 0 then base else step (mkMonoArray(n - 1))
//│ mkMonoArray: 'mkMonoArray
//│   where
//│     'mkMonoArray :> forall 'a. (int -> (forall 'a. Arrays['a])
//│   where
//│     'mkMonoArray <: int -> Arrays['a])
//│            = [Function: mkMonoArray]

:e // * Since the removal of "recursive definition hacks"
snb = mkMonoArray 5
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.1733: 	snb = mkMonoArray 5
//│ ║          	      ^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  mkMonoArray4697_4728'#  <:  ((α4705_4739',) -> α4706_4740')    TypeVariable  FunctionType
//│ ╙──  ... looks like:  mkMonoArray4697'#  <:  ((α4705_4729'',) -> α4706_4730'')
//│ snb: error | Arrays['a]
//│    = [Function (anonymous)]

snb (fun arr -> arr.Init true)
//│ res: anything
//│    = [
//│        [ [ [Array], [Array] ], [ [Array], [Array] ] ],
//│        [ [ [Array], [Array] ], [ [Array], [Array] ] ]
//│      ]


// * From the paper:
// let mkPolyArray n = {∀α(∃ρ.∀β.sig(α,ρ,β))} (mkMonoArray n)





