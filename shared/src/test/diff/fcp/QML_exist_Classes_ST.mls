// * Adaptation of QML's original existentials example; using encoded existentials and classes


:NoRecursiveTypes
:NoConstrainedTypes
// :DistributeForalls
// :GeneralizeArguments

// TODO try without some signatures



class ArraysRep[A, Rep]
  method Init: A -> Rep
  method Sub: Rep -> int -> A
  method Update: Rep -> int -> A -> Rep
  method Fold: (A -> 'b -> 'b) -> 'b -> Rep -> 'b
//│ Defined class ArraysRep[=A, =Rep]
//│ Declared ArraysRep.Init: ArraysRep['A, 'Rep] -> 'A -> 'Rep
//│ Declared ArraysRep.Sub: ArraysRep['A, 'Rep] -> 'Rep -> int -> 'A
//│ Declared ArraysRep.Update: ArraysRep['A, 'Rep] -> 'Rep -> int -> 'A -> 'Rep
//│ Declared ArraysRep.Fold: ArraysRep['A, 'Rep] -> ('A -> 'b -> 'b) -> 'b -> 'Rep -> 'b

class ArraysImpl[A, Rep]: ArraysRep[A, Rep] & {
    init: A -> Rep;
    sub: Rep -> int -> A;
    update: Rep -> int -> A -> Rep;
    fold: forall 'b. (A -> 'b -> 'b) -> 'b -> Rep -> 'b
  }
  method Init = this.init
  method Sub = this.sub
  method Update = this.update
  method Fold = this.fold
//│ Defined class ArraysImpl[=A, =Rep]
//│ Defined ArraysImpl.Init: ArraysImpl['A, 'Rep] -> 'A -> 'Rep
//│ Defined ArraysImpl.Sub: ArraysImpl['A, 'Rep] -> 'Rep -> int -> 'A
//│ Defined ArraysImpl.Update: ArraysImpl['A, 'Rep] -> 'Rep -> int -> 'A -> 'Rep
//│ Defined ArraysImpl.Fold: ArraysImpl['A, 'Rep] -> ('A -> 'b -> 'b) -> 'b -> 'Rep -> 'b

type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ Defined type alias Arrays[=A]



baseImpl = ArraysImpl {
    init   = fun a -> a;
    sub    = fun r -> fun (i : int) -> r;
    update = fun r -> fun (i : int) -> fun a -> a;
    fold   = fun f -> fun b -> fun r -> f r b
  }
//│ baseImpl: ArraysImpl['Rep, 'Rep] with {fold: forall 'a 'b 'c. ('a -> 'b -> 'c) -> 'b -> 'a -> 'c, init: forall 'd. 'd -> 'd, sub: forall 'e. 'e -> int -> 'e, update: forall 'f. anything -> int -> 'f -> 'f}
//│         = ArraysImpl {
//│             init: [Function: init],
//│             sub: [Function: sub],
//│             update: [Function: update],
//│             fold: [Function: fold]
//│           }

def base: Arrays['a]
def base f = f baseImpl
//│ base: Arrays['a]
//│     = <missing implementation>
//│ ((forall 'Rep. ArraysImpl['Rep, 'Rep] with {fold: forall 'a 'b 'c. ('a -> 'b -> 'c) -> 'b -> 'a -> 'c, init: forall 'd. 'd -> 'd, sub: forall 'e. 'e -> int -> 'e, update: forall 'f. anything -> int -> 'f -> 'f}) -> 'g) -> 'g
//│   <:  base:
//│ Arrays['a]
//│     = [Function: base]



def simpleStepImpl arrImpl = ArraysImpl {
    init   = fun a -> (arrImpl.Init a, "initialized");
    sub    = fun ((r0, r1)) -> fun i -> arrImpl.Sub r0 i;
    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.Update r0 i a, "updated");
    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f b r0
  }
//│ simpleStepImpl: ArraysRep[in 'A & 'A0 & 'A1 out 'A0 | 'A, in 'Rep & 'Rep0 & 'a out 'Rep | 'Rep0] -> (ArraysImpl['A1, 'Rep1] with {fold: forall 'b. ('A0 -> 'b -> 'b) -> 'b -> ('Rep0, anything,) -> 'b, init: 'A -> ('Rep, "initialized",), sub: ('Rep0, anything,) -> int -> 'A0, update: forall 'c. ('Rep0 & 'c, anything,) -> int -> 'A -> ('Rep | 'c, "updated",)})
//│   where
//│     'Rep1 :> ('Rep | 'd, "initialized" | "updated",)
//│           <: ('Rep0 & 'a, anything,)
//│     'a <: 'Rep0 & 'd
//│     'd :> 'Rep
//│        <: 'Rep0 & 'a
//│     'A1 :> 'A0
//│         <: 'A
//│               = [Function: simpleStepImpl]


def simpleStepImpl2_ty: (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, string)]
//│ simpleStepImpl2_ty: (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, string,)]
//│                   = <missing implementation>


def simpleStepImpl2 arr = arr simpleStepImpl
//│ simpleStepImpl2: ((forall 'Rep 'a 'A 'c 'Rep0 'A0 'A1 'Rep1. ArraysRep[in 'A1 & 'A0 & 'A out 'A0 | 'A1, in 'Rep & 'Rep1 & 'a out 'Rep | 'Rep1] -> (ArraysImpl['A, 'Rep0] with {fold: forall 'b. ('A0 -> 'b -> 'b) -> 'b -> ('Rep1, anything,) -> 'b, init: 'A1 -> ('Rep, "initialized",), sub: ('Rep1, anything,) -> int -> 'A0, update: forall 'd. ('Rep1 & 'd, anything,) -> int -> 'A1 -> ('Rep | 'd, "updated",)})) -> 'e) -> 'e
//│   where
//│     'Rep0 :> ('Rep | 'c, "initialized" | "updated",)
//│           <: ('Rep1 & 'a, anything,)
//│     'a <: 'Rep1 & 'c
//│     'c :> 'Rep
//│        <: 'Rep1 & 'a
//│     'A :> 'A0
//│        <: 'A1
//│                = [Function: simpleStepImpl2]

simpleStepImpl2_ty = simpleStepImpl2
//│ ((forall 'Rep 'Rep0 'A 'a 'A0 'c 'A1 'Rep1. ArraysRep[in 'A1 & 'A0 & 'A out 'A0 | 'A1, in 'Rep0 & 'Rep1 & 'c out 'Rep0 | 'Rep1] -> (ArraysImpl['A, 'Rep] with {fold: forall 'b. ('A0 -> 'b -> 'b) -> 'b -> ('Rep1, anything,) -> 'b, init: 'A1 -> ('Rep0, "initialized",), sub: ('Rep1, anything,) -> int -> 'A0, update: forall 'd. ('Rep1 & 'd, anything,) -> int -> 'A1 -> ('Rep0 | 'd, "updated",)})) -> 'e) -> 'e
//│   where
//│     'Rep :> ('Rep0 | 'a, "initialized" | "updated",)
//│          <: ('Rep1 & 'c, anything,)
//│     'c <: 'Rep1 & 'a
//│     'a :> 'Rep0
//│        <: 'Rep1 & 'c
//│     'A :> 'A0
//│        <: 'A1
//│   <:  simpleStepImpl2_ty:
//│ (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, string,)]
//│                   = [Function: simpleStepImpl2]

:e // * Annotation is actually counter-productive... probably because the rigid universal in Arrays gets extruded!
def simpleStepImpl2_ty (arr: Arrays['a]) = arr simpleStepImpl
//│ Arrays['a] -> error
//│   <:  simpleStepImpl2_ty:
//│ (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, string,)]
//│ ╔══[ERROR] Type error in application
//│ ║  l.120: 	def simpleStepImpl2_ty (arr: Arrays['a]) = arr simpleStepImpl
//│ ║         	                                           ^^^^^^^^^^^^^^^^^^
//│ ╟── type variable `'Rep` leaks out of its scope
//│ ║  l.40: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                                            ^^^^
//│ ╟── adding a type annotation to any of the following terms may help resolve the problem
//│ ╟── • this function:
//│ ║  l.70: 	def simpleStepImpl arrImpl = ArraysImpl {
//│ ║        	                   ^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.71: 	    init   = fun a -> (arrImpl.Init a, "initialized");
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.72: 	    sub    = fun ((r0, r1)) -> fun i -> arrImpl.Sub r0 i;
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.73: 	    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.Update r0 i a, "updated");
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.74: 	    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f b r0
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.75: 	  }
//│ ║        	^^^
//│ ╟── • this reference:
//│ ║  l.120: 	def simpleStepImpl2_ty (arr: Arrays['a]) = arr simpleStepImpl
//│ ║         	                                               ^^^^^^^^^^^^^^
//│ ╟── • this reference:
//│ ║  l.120: 	def simpleStepImpl2_ty (arr: Arrays['a]) = arr simpleStepImpl
//│ ║         	                                           ^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.72: 	    sub    = fun ((r0, r1)) -> fun i -> arrImpl.Sub r0 i;
//│ ╙──      	                                                    ^^
//│                   = [Function: simpleStepImpl2_ty1]

def simpleStep: Arrays['a] -> Arrays['a]
//│ simpleStep: Arrays['a] -> Arrays['a]
//│           = <missing implementation>

:e // * Since "sound extrusion"
def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ((forall 'A 'Rep 'a 'A0 'c 'A1 'Rep0 'Rep1. ArraysRep[in 'A1 & 'A0 & 'A out 'A0 | 'A1, in 'Rep1 & 'Rep0 & 'c out 'Rep1 | 'Rep0] -> (ArraysImpl['A, 'Rep] with {fold: forall 'b. ('A0 -> 'b -> 'b) -> 'b -> ('Rep0, anything,) -> 'b, init: 'A1 -> ('Rep1, "initialized",), sub: ('Rep0, anything,) -> int -> 'A0, update: forall 'd. ('Rep0 & 'd, anything,) -> int -> 'A1 -> ('Rep1 | 'd, "updated",)})) -> 'e) -> ('e -> 'f) -> 'f
//│   where
//│     'Rep :> ('Rep1 | 'a, "initialized" | "updated",)
//│          <: ('Rep0 & 'c, anything,)
//│     'c <: 'Rep0 & 'a
//│     'a :> 'Rep1
//│        <: 'Rep0 & 'c
//│     'A :> 'A0
//│        <: 'A1
//│   <:  simpleStep:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type error in def definition
//│ ║  l.160: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type variable `'Rep` leaks out of its scope
//│ ║  l.40: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                                            ^^^^
//│ ╟── adding a type annotation to any of the following terms may help resolve the problem
//│ ╟── • this applied expression:
//│ ║  l.93: 	def simpleStepImpl2 arr = arr simpleStepImpl
//│ ║        	                          ^^^
//│ ╟── • this reference:
//│ ║  l.160: 	def simpleStep arr f = f (simpleStepImpl2 arr)
//│ ║         	                                          ^^^
//│ ╟── • this function:
//│ ║  l.70: 	def simpleStepImpl arrImpl = ArraysImpl {
//│ ║        	                   ^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.71: 	    init   = fun a -> (arrImpl.Init a, "initialized");
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.72: 	    sub    = fun ((r0, r1)) -> fun i -> arrImpl.Sub r0 i;
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.73: 	    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.Update r0 i a, "updated");
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.74: 	    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f b r0
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.75: 	  }
//│ ║        	^^^
//│ ╟── • this reference:
//│ ║  l.93: 	def simpleStepImpl2 arr = arr simpleStepImpl
//│ ║        	                              ^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.72: 	    sub    = fun ((r0, r1)) -> fun i -> arrImpl.Sub r0 i;
//│ ╙──      	                                                    ^^
//│           = [Function: simpleStep]

:e // TODO update: seems like the given type for `simpleStepImpl2_ty` is not precise enough
def simpleStep arr f = f (simpleStepImpl2_ty arr)
//│ (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> (ArraysImpl['A, ('Rep, string,)] -> 'a) -> 'a
//│   <:  simpleStep:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type error in def definition
//│ ║  l.207: 	def simpleStep arr f = f (simpleStepImpl2_ty arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type variable `'Rep` leaks out of its scope
//│ ║  l.40: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                                            ^^^^
//│ ╟── adding a type annotation to any of the following terms may help resolve the problem
//│ ╟── • this reference:
//│ ║  l.207: 	def simpleStep arr f = f (simpleStepImpl2_ty arr)
//│ ╙──       	                                             ^^^
//│           = [Function: simpleStep1]

sb = simpleStep base
//│ sb: Arrays['a]
//│   = [Function (anonymous)]

sb (fun arr -> arr.Init true)
//│ res: ??Rep
//│    = [ true, 'initialized' ]

sb (fun arr -> arr.Sub (arr.Init true) 1)
//│ res: true
//│    = true

:e // * Expected – argument order confusion
sb (fun arr -> arr.Sub 0 (arr.Init true))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.236: 	sb (fun arr -> arr.Sub 0 (arr.Init true))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `'Rep` is not an instance of type `int`
//│ ║  l.40: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                                            ^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.15: 	  method Sub: Rep -> int -> A
//│ ║        	                     ^^^
//│ ╟── from application:
//│ ║  l.236: 	sb (fun arr -> arr.Sub 0 (arr.Init true))
//│ ║         	                          ^^^^^^^^^^^^^
//│ ╟── Note: quantified type variable 'Rep is defined at:
//│ ║  l.40: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟──       class type parameter Rep is defined at:
//│ ║  l.13: 	class ArraysRep[A, Rep]
//│ ╙──      	                   ^^^
//│ res: error | true
//│ Runtime error:
//│   TypeError: number 0 is not iterable (cannot read property Symbol(Symbol.iterator))

sb (fun arr -> arr.Update (arr.Init true) 1 false)
//│ res: ??Rep
//│    = [ false, 'updated' ]

:e // * Rightly prevent skolem confusion
sb (fun arr1 -> sb (fun arr2 -> arr2.Update (arr1.Init true)))
//│ ╔══[ERROR] Type error in application
//│ ║  l.264: 	sb (fun arr1 -> sb (fun arr2 -> arr2.Update (arr1.Init true)))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type variable `'Rep` leaks out of its scope
//│ ║  l.40: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                                            ^^^^
//│ ╟── adding a type annotation to any of the following terms may help resolve the problem
//│ ╟── • this application:
//│ ║  l.264: 	sb (fun arr1 -> sb (fun arr2 -> arr2.Update (arr1.Init true)))
//│ ║         	                                             ^^^^^^^^^^^^^^
//│ ╟── • this application:
//│ ║  l.223: 	sb = simpleStep base
//│ ║         	     ^^^^^^^^^^^^^^^
//│ ╟── • this reference:
//│ ║  l.264: 	sb (fun arr1 -> sb (fun arr2 -> arr2.Update (arr1.Init true)))
//│ ║         	                ^^
//│ ╟── • this reference:
//│ ║  l.264: 	sb (fun arr1 -> sb (fun arr2 -> arr2.Update (arr1.Init true)))
//│ ║         	                                ^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.264: 	sb (fun arr1 -> sb (fun arr2 -> arr2.Update (arr1.Init true)))
//│ ╙──       	                                             ^^^^^^^^^^^^^^
//│ res: error | int -> anything -> (??Rep | ??Rep0)
//│    = [Function (anonymous)]

sb (fun arr ->
    let r2 = arr.Update (arr.Init true) 1 false
    in (arr.Sub r2 0, arr.Sub r2 1)
  )
//│ res: (Bool, Bool,)
//│    = [ false, false ]



:escape
def Math: nothing
//│ Math: nothing
//│     = <missing implementation>

def div: int -> int -> int
def div a b = Math.trunc(a/b)
//│ div: int -> int -> int
//│    = <missing implementation>
//│ number -> number -> nothing
//│   <:  div:
//│ int -> int -> int
//│    = [Function: div1]

def mod: int -> int -> int
rec def mod a b = if a < b then a else mod (a - b) b
//│ mod: int -> int -> int
//│    = <missing implementation>
//│ int -> int -> int
//│   <:  mod:
//│ int -> int -> int
//│    = [Function: mod]

def stepImpl arrImpl = ArraysImpl {
    init = fun a -> (arrImpl.Init a, arrImpl.Init a);
    sub = fun ((r0, r1)) -> fun i ->
      if mod i 2 == 0
      then arrImpl.Sub r0 (div i 2)
      else arrImpl.Sub r1 (div i 2);
    update = fun ((r0, r1)) -> fun i -> fun a ->
      if mod i 2 == 0
      then (arrImpl.Update r0 (div i 2) a, r1)
      else (r0, arrImpl.Update r1 (div i 2) a);
    fold = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f (arrImpl.Fold f b r0) r1
  }
//│ stepImpl: ArraysRep[in 'A & 'A0 & 'A1 out 'A0 | 'A, in 'Rep & 'Rep0 & 'a & 'c out 'Rep | 'Rep0] -> (ArraysImpl['A1, 'Rep1] with {fold: forall 'b 'b0. ('A0 -> 'b -> 'b & 'A0 -> 'b0 -> ('b & 'b0)) -> ('b & 'b0) -> ('Rep0, 'Rep0,) -> 'b, init: 'A -> ('Rep, 'Rep,), sub: ('Rep0, 'Rep0,) -> int -> 'A0, update: forall 'd 'e. ('Rep0 & 'd, 'Rep0 & 'e,) -> int -> 'A -> ('Rep | 'd, 'Rep | 'e,)})
//│   where
//│     'Rep1 :> ('Rep | 'a | 'f, 'Rep | 'c | 'g,)
//│           <: ('Rep0 & 'a, 'Rep0 & 'c,)
//│     'c <: 'Rep0 & 'g
//│     'g :> 'Rep
//│        <: 'Rep0 & 'c
//│     'a <: 'Rep0 & 'f
//│     'f :> 'Rep
//│        <: 'Rep0 & 'a
//│     'A1 :> 'A0
//│         <: 'A
//│         = [Function: stepImpl]

def stepImpl2_ty: (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, 'Rep)]
//│ stepImpl2_ty: (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, 'Rep,)]
//│             = <missing implementation>

def stepImpl2 arr = arr stepImpl
//│ stepImpl2: ((forall 'a 'c 'A 'A0 'Rep 'd 'A1 'e 'Rep0 'Rep1. ArraysRep[in 'A0 & 'A & 'A1 out 'A | 'A0, in 'Rep & 'Rep1 & 'c & 'e out 'Rep | 'Rep1] -> (ArraysImpl['A1, 'Rep0] with {fold: forall 'b 'b0. ('A -> 'b -> 'b & 'A -> 'b0 -> ('b & 'b0)) -> ('b & 'b0) -> ('Rep1, 'Rep1,) -> 'b, init: 'A0 -> ('Rep, 'Rep,), sub: ('Rep1, 'Rep1,) -> int -> 'A, update: forall 'f 'g. ('Rep1 & 'g, 'Rep1 & 'f,) -> int -> 'A0 -> ('Rep | 'g, 'Rep | 'f,)})) -> 'h) -> 'h
//│   where
//│     'Rep0 :> ('Rep | 'c | 'd, 'Rep | 'e | 'a,)
//│           <: ('Rep1 & 'c, 'Rep1 & 'e,)
//│     'e <: 'Rep1 & 'a
//│     'a :> 'Rep
//│        <: 'Rep1 & 'e
//│     'c <: 'Rep1 & 'd
//│     'd :> 'Rep
//│        <: 'Rep1 & 'c
//│     'A1 :> 'A
//│         <: 'A0
//│          = [Function: stepImpl2]

stepImpl2_ty = stepImpl2
//│ ((forall 'Rep 'A 'a 'c 'd 'Rep0 'A0 'e 'A1 'Rep1. ArraysRep[in 'A1 & 'A0 & 'A out 'A0 | 'A1, in 'Rep1 & 'Rep0 & 'c & 'd out 'Rep1 | 'Rep0] -> (ArraysImpl['A, 'Rep] with {fold: forall 'b 'b0. ('A0 -> 'b -> 'b & 'A0 -> 'b0 -> ('b & 'b0)) -> ('b & 'b0) -> ('Rep0, 'Rep0,) -> 'b, init: 'A1 -> ('Rep1, 'Rep1,), sub: ('Rep0, 'Rep0,) -> int -> 'A0, update: forall 'f 'g. ('Rep0 & 'g, 'Rep0 & 'f,) -> int -> 'A1 -> ('Rep1 | 'g, 'Rep1 | 'f,)})) -> 'h) -> 'h
//│   where
//│     'Rep :> ('Rep1 | 'c | 'a, 'Rep1 | 'd | 'e,)
//│          <: ('Rep0 & 'c, 'Rep0 & 'd,)
//│     'd <: 'Rep0 & 'e
//│     'e :> 'Rep1
//│        <: 'Rep0 & 'd
//│     'c <: 'Rep0 & 'a
//│     'a :> 'Rep1
//│        <: 'Rep0 & 'c
//│     'A :> 'A0
//│        <: 'A1
//│   <:  stepImpl2_ty:
//│ (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, 'Rep,)]
//│             = [Function: stepImpl2]


def step: Arrays['a] -> Arrays['a]
//│ step: Arrays['a] -> Arrays['a]
//│     = <missing implementation>

:e // * Since "sound extrusion"
def step arr f = f (stepImpl2 arr)
//│ ((forall 'a 'A 'Rep 'A0 'c 'd 'Rep0 'Rep1 'A1 'e. ArraysRep[in 'A0 & 'A1 & 'A out 'A1 | 'A0, in 'Rep & 'Rep0 & 'a & 'd out 'Rep | 'Rep0] -> (ArraysImpl['A, 'Rep1] with {fold: forall 'b 'b0. ('A1 -> 'b -> 'b & 'A1 -> 'b0 -> ('b & 'b0)) -> ('b & 'b0) -> ('Rep0, 'Rep0,) -> 'b, init: 'A0 -> ('Rep, 'Rep,), sub: ('Rep0, 'Rep0,) -> int -> 'A1, update: forall 'f 'g. ('Rep0 & 'f, 'Rep0 & 'g,) -> int -> 'A0 -> ('Rep | 'f, 'Rep | 'g,)})) -> 'h) -> ('h -> 'i) -> 'i
//│   where
//│     'Rep1 :> ('Rep | 'a | 'e, 'Rep | 'd | 'c,)
//│           <: ('Rep0 & 'a, 'Rep0 & 'd,)
//│     'd <: 'Rep0 & 'c
//│     'c :> 'Rep
//│        <: 'Rep0 & 'd
//│     'a <: 'Rep0 & 'e
//│     'e :> 'Rep
//│        <: 'Rep0 & 'a
//│     'A :> 'A1
//│        <: 'A0
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type error in def definition
//│ ║  l.390: 	def step arr f = f (stepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type variable `'Rep` leaks out of its scope
//│ ║  l.40: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                                            ^^^^
//│ ╟── adding a type annotation to any of the following terms may help resolve the problem
//│ ╟── • this applied expression:
//│ ║  l.352: 	def stepImpl2 arr = arr stepImpl
//│ ║         	                    ^^^
//│ ╟── • this reference:
//│ ║  l.390: 	def step arr f = f (stepImpl2 arr)
//│ ║         	                              ^^^
//│ ╟── • this function:
//│ ║  l.322: 	def stepImpl arrImpl = ArraysImpl {
//│ ║         	             ^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.323: 	    init = fun a -> (arrImpl.Init a, arrImpl.Init a);
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.324: 	    sub = fun ((r0, r1)) -> fun i ->
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.325: 	      if mod i 2 == 0
//│ ║         	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.326: 	      then arrImpl.Sub r0 (div i 2)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.327: 	      else arrImpl.Sub r1 (div i 2);
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.328: 	    update = fun ((r0, r1)) -> fun i -> fun a ->
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.329: 	      if mod i 2 == 0
//│ ║         	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.330: 	      then (arrImpl.Update r0 (div i 2) a, r1)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.331: 	      else (r0, arrImpl.Update r1 (div i 2) a);
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.332: 	    fold = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f (arrImpl.Fold f b r0) r1
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.333: 	  }
//│ ║         	^^^
//│ ╟── • this reference:
//│ ║  l.352: 	def stepImpl2 arr = arr stepImpl
//│ ║         	                        ^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.326: 	      then arrImpl.Sub r0 (div i 2)
//│ ╙──       	                       ^^
//│     = [Function: step]

// * Now the annotation was okay [until "sound extrusion"] because the result no longer extruded it...
:e // * Since "sound extrusion"
def step (arr: Arrays['a]) f = f (stepImpl2 arr)
//│ Arrays['a] -> (error -> 'b) -> 'b
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type error in application
//│ ║  l.453: 	def step (arr: Arrays['a]) f = f (stepImpl2 arr)
//│ ║         	                                  ^^^^^^^^^^^^^
//│ ╟── type variable `'Rep` leaks out of its scope
//│ ║  l.40: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                                            ^^^^
//│ ╟── adding a type annotation to any of the following terms may help resolve the problem
//│ ╟── • this applied expression:
//│ ║  l.352: 	def stepImpl2 arr = arr stepImpl
//│ ║         	                    ^^^
//│ ╟── • this function:
//│ ║  l.322: 	def stepImpl arrImpl = ArraysImpl {
//│ ║         	             ^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.323: 	    init = fun a -> (arrImpl.Init a, arrImpl.Init a);
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.324: 	    sub = fun ((r0, r1)) -> fun i ->
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.325: 	      if mod i 2 == 0
//│ ║         	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.326: 	      then arrImpl.Sub r0 (div i 2)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.327: 	      else arrImpl.Sub r1 (div i 2);
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.328: 	    update = fun ((r0, r1)) -> fun i -> fun a ->
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.329: 	      if mod i 2 == 0
//│ ║         	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.330: 	      then (arrImpl.Update r0 (div i 2) a, r1)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.331: 	      else (r0, arrImpl.Update r1 (div i 2) a);
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.332: 	    fold = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f (arrImpl.Fold f b r0) r1
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.333: 	  }
//│ ║         	^^^
//│ ╟── • this reference:
//│ ║  l.352: 	def stepImpl2 arr = arr stepImpl
//│ ║         	                        ^^^^^^^^
//│ ╟── • this reference:
//│ ║  l.453: 	def step (arr: Arrays['a]) f = f (stepImpl2 arr)
//│ ║         	                                            ^^^
//│ ╟── • this reference:
//│ ║  l.453: 	def step (arr: Arrays['a]) f = f (stepImpl2 arr)
//│ ║         	                                  ^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.326: 	      then arrImpl.Sub r0 (div i 2)
//│ ╙──       	                       ^^
//│ ╔══[ERROR] Subtyping constraint of the form `forall ?a ?b 'a. Arrays['a] -> ?b -> ?a <: forall 'a0. Arrays['a0] -> Arrays['a0]` took too many steps and ran out of fuel (10000)
//│ ║  l.453: 	def step (arr: Arrays['a]) f = f (stepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╙── Note: use flag `:ex` to see internal error info.
//│     = [Function: step1]

// * Don't know why these don't work:
:e
def step arr f = f (stepImpl2_ty arr)
//│ (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> (ArraysImpl['A, ('Rep, 'Rep,)] -> 'a) -> 'a
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type error in def definition
//│ ║  l.512: 	def step arr f = f (stepImpl2_ty arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type variable `'Rep` leaks out of its scope
//│ ║  l.40: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                                            ^^^^
//│ ╟── adding a type annotation to any of the following terms may help resolve the problem
//│ ╟── • this reference:
//│ ║  l.512: 	def step arr f = f (stepImpl2_ty arr)
//│ ╙──       	                                 ^^^
//│     = [Function: step2]
:e
def step (arr: Arrays['a]) f = f (stepImpl2_ty arr)
//│ Arrays['a] -> ((ArraysImpl['a, ('Rep, 'Rep,)] | error) -> 'b) -> 'b
//│   where
//│     'Rep :> ??Rep
//│          <: ??Rep0
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type error in application
//│ ║  l.528: 	def step (arr: Arrays['a]) f = f (stepImpl2_ty arr)
//│ ║         	                                  ^^^^^^^^^^^^^^^^
//│ ╟── type variable `'Rep` leaks out of its scope
//│ ║  l.40: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                                            ^^^^
//│ ╟── adding a type annotation to any of the following terms may help resolve the problem
//│ ╟── • this reference:
//│ ║  l.528: 	def step (arr: Arrays['a]) f = f (stepImpl2_ty arr)
//│ ║         	                                               ^^^
//│ ╟── • this reference:
//│ ║  l.528: 	def step (arr: Arrays['a]) f = f (stepImpl2_ty arr)
//│ ╙──       	                                  ^^^^^^^^^^^^
//│     = [Function: step3]


ssb = step (step base)
//│ ssb: Arrays['a]
//│    = [Function (anonymous)]

ssb (fun arr ->
    let r2 = arr.Update (arr.Init true) 1 false
    in (arr.Sub r2 0, arr.Sub r2 1)
  )
//│ res: (Bool, Bool,)
//│    = [ true, false ]



rec def mkMonoArray n =
  if n == 0 then base else step (mkMonoArray(n - 1))
//│ mkMonoArray: int -> Arrays['a]
//│            = [Function: mkMonoArray]

snb = mkMonoArray 5
//│ snb: Arrays['a]
//│    = [Function (anonymous)]

snb (fun arr -> arr.Init true)
//│ res: ??Rep | ??Rep0
//│    = [
//│        [ [ [Array], [Array] ], [ [Array], [Array] ] ],
//│        [ [ [Array], [Array] ], [ [Array], [Array] ] ]
//│      ]


// * From the paper:
// let mkPolyArray n = {∀α(∃ρ.∀β.sig(α,ρ,β))} (mkMonoArray n)





