// * Adaptation of QML's original existentials example; using encoded existentials and plain records


:NoRecursiveTypes
:GeneralizeCurriedFunctions
// :DistributeForalls
// :ArgGen
// :ConstrainedTypes



type ArraysRep[A, Rep] = {
    init: A -> Rep;
    sub: Rep -> int -> A;
    update: Rep -> int -> A -> Rep;
    fold: forall 'b. (A -> 'b -> 'b) -> 'b -> Rep -> 'b
  }
//│ Defined type alias ArraysRep[=A, =Rep]

type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ Defined type alias Arrays[=A]


def baseImpl: ArraysRep['a, 'a]
baseImpl = {
    init   = fun a -> a;
    sub    = fun r -> fun (i : int) -> r;
    update = fun r -> fun (i : int) -> fun a -> a;
    fold   = fun f -> fun b -> fun r -> f r b
  }
//│ baseImpl: ArraysRep['a, 'a]
//│         = <missing implementation>
//│ {fold: forall 'a, 'b, 'c, 'd, 'e. ('b -> ('a -> 'c & 'd) & 'e) -> (forall 'f. ('a & 'f) -> (forall 'g, 'h. ('b & 'g) -> ('h | 'c))), init: forall 'i. 'i -> 'i, sub: forall 'j. 'j -> int -> 'j, update: forall 'k. 'k -> int -> (forall 'l. 'l -> 'l)}
//│   <:  baseImpl:
//│ ArraysRep['a, 'a]
//│         = {
//│             init: [Function: init],
//│             sub: [Function: sub],
//│             update: [Function: update],
//│             fold: [Function: fold]
//│           }

def base: Arrays['a]
def base f = f baseImpl
//│ base: Arrays['a]
//│     = <missing implementation>
//│ ((forall 'a. ArraysRep['a, 'a]) -> 'b & 'c) -> 'b
//│   <:  base:
//│ Arrays['a]
//│     = [Function: base]


def stepImpl_ty: ArraysRep['a, 'r] -> ArraysRep['a, ('r, string)]
//│ stepImpl_ty: ArraysRep['a, 'r] -> ArraysRep['a, ('r, string,)]
//│            = <missing implementation>

// * Not enough to type `step` later in the file
def stepImpl arrImpl = {
    init   = fun a -> (arrImpl.init a, "hi");
    sub    = fun ((r0, r1)) -> fun i -> arrImpl.sub r0 i;
    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.update r0 i a, "hey");
    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.fold f b r0
  }
//│ stepImpl: ({fold: 'a -> ('b -> ('c -> 'd & 'e) & 'f) & 'fold, init: 'g -> 'h & 'init, sub: 'i -> ('j -> 'k & 'l) & 'sub, update: 'm -> ('n -> ('o -> 'p & 'q) & 'r) & 'update} & 's) -> {fold: forall 't. ('a & 't) -> (forall 'u. ('b & 'u) -> (forall 'v, 'w, 'x. ('c & 'v, 'w,) -> ('x | 'd))), init: forall 'y, 'z. ('g & 'y) -> ('z | 'h, "hi",), sub: forall 'a1, 'b1. ('i & 'a1, 'b1,) -> (forall 'c1, 'd1. ('j & 'c1) -> ('d1 | 'k)), update: forall 'e1, 'f1. ('m & 'f1, 'e1,) -> (forall 'g1. ('n & 'g1) -> (forall 'h1, 'i1. ('o & 'h1) -> ('i1 | 'p, "hey",)))}
//│         = [Function: stepImpl]

:e // * Since "sound extrusion"
stepImpl_ty = stepImpl
//│ ({fold: 'a -> ('b -> ('c -> 'd & 'e) & 'f) & 'fold, init: 'g -> 'h & 'init, sub: 'i -> ('j -> 'k & 'l) & 'sub, update: 'm -> ('n -> ('o -> 'p & 'q) & 'r) & 'update} & 's) -> {fold: forall 't. ('a & 't) -> (forall 'u. ('b & 'u) -> (forall 'v, 'w, 'x. ('c & 'v, 'w,) -> ('x | 'd))), init: forall 'y, 'z. ('g & 'y) -> ('z | 'h, "hi",), sub: forall 'a1, 'b1. ('i & 'a1, 'b1,) -> (forall 'c1, 'd1. ('j & 'c1) -> ('d1 | 'k)), update: forall 'e1, 'f1. ('m & 'e1, 'f1,) -> (forall 'g1. ('n & 'g1) -> (forall 'h1, 'i1. ('o & 'h1) -> ('i1 | 'p, "hey",)))}
//│   <:  stepImpl_ty:
//│ ArraysRep['a, 'r] -> ArraysRep['a, ('r, string,)]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.68: 	stepImpl_ty = stepImpl
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.16: 	    fold: forall 'b. (A -> 'b -> 'b) -> 'b -> Rep -> 'b
//│ ║        	                 ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.16: 	    fold: forall 'b. (A -> 'b -> 'b) -> 'b -> Rep -> 'b
//│ ╙──      	                 ^^
//│            = [Function: stepImpl]

type Fold[A, Rep] = (A -> 'b -> 'b) -> 'b -> Rep -> 'b
//│ Defined type alias Fold[+A, -Rep]

// * Bad annotation: polymorphism level at which it's typed makes 'a and 'rep locally quantified,
// *  which is NOT what we want!
def stepImpl_Ann_1 arrImpl = {
    init   = fun a -> (arrImpl.init a, "hi");
    sub    = fun ((r0, r1)) -> fun i -> arrImpl.sub r0 i;
    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.update r0 i a, "hey");
    fold   = fun f -> fun b -> fun ((r0, r1)) -> (arrImpl.fold: Fold['a, 'rep]) f b r0
  }
//│ stepImpl_Ann_1: ({fold: Fold['a, 'rep] & 'fold, init: 'c -> 'd & 'init, sub: 'e -> ('f -> 'g & 'h) & 'sub, update: 'i -> ('j -> ('k -> 'l & 'm) & 'n) & 'update} & 'o) -> {fold: forall 'b, 'p, 'a0, 'a1, 'b0. (('a0 | 'a1) -> 'b0 -> ('b0 & 'b) & 'p) -> (forall 'q. ('b0 & 'q) -> (forall 'rep0, 'r, 's, 'rep1, 't. ('s & 'rep1 & 'rep0, 't,) -> ('b | 'q | 'r))), init: forall 'u, 'v. ('c & 'u) -> ('v | 'd, "hi",), sub: forall 'w, 'x. ('e & 'w, 'x,) -> (forall 'y, 'z. ('f & 'y) -> ('z | 'g)), update: forall 'a1, 'b1. ('i & 'a1, 'b1,) -> (forall 'c1. ('j & 'c1) -> (forall 'd1, 'e1. ('k & 'd1) -> ('e1 | 'l, "hey",)))}
//│               = [Function: stepImpl_Ann_1]

// * Still not enough to type `step` later in the file – this annotation actually doesn't help at all
def stepImpl_Ann_2 (arrImpl: ArraysRep['a, 'r]) = {
    init   = fun a -> (arrImpl.init a, "hi");
    sub    = fun ((r0, r1)) -> fun i -> arrImpl.sub r0 i;
    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.update r0 i a, "hey");
    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.fold f b r0
  }
//│ stepImpl_Ann_2: ArraysRep['a, 'r] -> {fold: forall 'b, 'b0, 'c. ('a -> 'b -> ('b & 'b0) & 'c) -> (forall 'd. ('b & 'd) -> (forall 'e, 'f, 'g. ('r & 'e, 'f,) -> ('b0 | 'd | 'g))), init: forall 'h, 'i. ('a & 'h) -> ('r | 'i, "hi",), sub: forall 'j, 'k. ('r & 'j, 'k,) -> (forall 'l, 'm, 'n. (int & 'l & 'm) -> ('a | 'n)), update: forall 'o, 'p. ('r & 'o, 'p,) -> (forall 'm. (int & 'm) -> (forall 'q, 's. ('a & 'q) -> ('r | 's, "hey",)))}
//│               = [Function: stepImpl_Ann_2]

stepImpl_ty = stepImpl_Ann_2
//│ ArraysRep['a, 'r] -> {fold: forall 'b, 'b0, 'c. ('a -> 'b -> ('b & 'b0) & 'c) -> (forall 'd. ('b & 'd) -> (forall 'e, 'f, 'g. ('r & 'e, 'f,) -> ('b0 | 'd | 'g))), init: forall 'h, 'i. ('a & 'h) -> ('r | 'i, "hi",), sub: forall 'j, 'k. ('r & 'j, 'k,) -> (forall 'l, 'm, 'n. (int & 'l & 'm) -> ('a | 'n)), update: forall 'o, 'p. ('r & 'p, 'o,) -> (forall 'm. (int & 'm) -> (forall 'q, 's. ('a & 'q) -> ('r | 's, "hey",)))}
//│   <:  stepImpl_ty:
//│ ArraysRep['a, 'r] -> ArraysRep['a, ('r, string,)]
//│            = [Function: stepImpl_Ann_2]

// * This one seems that it would work but it's again typed at the wrong polymorphism level (I think?)
def stepImpl_Ann_3 arrImpl = {
    init   = fun a -> (arrImpl.init a, "hi");
    sub    = fun ((r0, r1)) -> fun i -> arrImpl.sub r0 i;
    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.update r0 i a, "hey");
    fold   = (fun f -> fun b -> fun ((r0, r1)) -> arrImpl.fold f b r0) : Fold['a, ('rep, string)]
  }
//│ stepImpl_Ann_3: ({fold: (nothing -> nothing -> anything | 'b) -> (anything -> (anything -> nothing & 'c) & 'd) & 'fold, init: 'e -> 'f & 'init, sub: 'g -> ('h -> 'i & 'j) & 'sub, update: 'k -> ('l -> ('m -> 'n & 'o) & 'p) & 'update} & 'q) -> {fold: Fold['a, ('rep, string,)], init: forall 'r, 's. ('e & 'r) -> ('s | 'f, "hi",), sub: forall 't, 'u. ('g & 't, 'u,) -> (forall 'v, 'w. ('h & 'v) -> ('w | 'i)), update: forall 'x, 'y. ('k & 'x, 'y,) -> (forall 'z. ('l & 'z) -> (forall 'a1, 'b1. ('m & 'a1) -> ('b1 | 'n, "hey",)))}
//│               = [Function: stepImpl_Ann_3]

:e
stepImpl_ty = stepImpl_Ann_3
//│ ({fold: (nothing -> nothing -> anything | 'b) -> (anything -> (anything -> nothing & 'c) & 'd) & 'fold, init: 'e -> 'f & 'init, sub: 'g -> ('h -> 'i & 'j) & 'sub, update: 'k -> ('l -> ('m -> 'n & 'o) & 'p) & 'update} & 'q) -> {fold: Fold['a, ('rep, string,)], init: forall 'r, 's. ('e & 'r) -> ('s | 'f, "hi",), sub: forall 't, 'u. ('g & 't, 'u,) -> (forall 'v, 'w. ('h & 'v) -> ('w | 'i)), update: forall 'x, 'y. ('k & 'x, 'y,) -> (forall 'z. ('l & 'z) -> (forall 'a1, 'b1. ('m & 'a1) -> ('b1 | 'n, "hey",)))}
//│   <:  stepImpl_ty:
//│ ArraysRep['a, 'r] -> ArraysRep['a, ('r, string,)]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.124: 	stepImpl_ty = stepImpl_Ann_3
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘a_1391` does not match type `nothing`
//│ ║  l.53: 	def stepImpl_ty: ArraysRep['a, 'r] -> ArraysRep['a, ('r, string)]
//│ ║        	                           ^^
//│ ╟── Note: constraint arises from type variable:
//│ ║  l.118: 	    fold   = (fun f -> fun b -> fun ((r0, r1)) -> arrImpl.fold f b r0) : Fold['a, ('rep, string)]
//│ ╙──       	                                                                              ^^
//│            = [Function: stepImpl_Ann_3]

// * This one finally works! The annotation needs to be on the result!
// *  Notice the skolem in the parameter's inferred fold type:
def stepImpl_Ann_4 arrImpl = {
    init   = fun a -> (arrImpl.init a, "hi");
    sub    = fun ((r0, r1)) -> fun i -> arrImpl.sub r0 i;
    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.update r0 i a, "hey");
    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.fold f b r0
  } : ArraysRep['a, 'r]
//│ stepImpl_Ann_4: ({fold: ('a -> nothing -> anything | 'b) -> (anything -> ('c -> nothing & 'd) & 'e) & 'fold, init: 'f -> ('c & 'g & 'h & 'i & 'j & 'k & 'l) & 'init, sub: 'l -> ((int | 'm) -> ('a & 'n) & 'o) & 'sub, update: 'j -> ((int | 'm | 'p) -> ('q -> ('c & 'h & 'i & 'j & 'k & 'l & 's) & 't) & 'u) & 'update} & 'v) -> ArraysRep['a, 'r]
//│   where
//│     'r :> ('w | 'g | 'x | 's, "hey" | "hi",)
//│        <: ('c & 'h & 'i & 'j & 'k & 'l, 'y & 'z & 'a1,)
//│     'a <: 'b1 & 'q & 'c1 & 'f
//│               = [Function: stepImpl_Ann_4]

:e // * Since "sound extrusion"
test = stepImpl_Ann_4 baseImpl
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.155: 	test = stepImpl_Ann_4 baseImpl
//│ ║         	       ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.16: 	    fold: forall 'b. (A -> 'b -> 'b) -> 'b -> Rep -> 'b
//│ ║        	                 ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.16: 	    fold: forall 'b. (A -> 'b -> 'b) -> 'b -> Rep -> 'b
//│ ╙──      	                 ^^
//│ test: error
//│     = {
//│         init: [Function: init],
//│         sub: [Function: sub],
//│         update: [Function: update],
//│         fold: [Function: fold]
//│       }

:e // * Since "sound extrusion"
stepImpl_ty = stepImpl_Ann_4
//│ ({fold: ('a -> nothing -> anything | 'b) -> (anything -> ('c -> nothing & 'd) & 'e) & 'fold, init: 'f -> ('c & 'g & 'h & 'i & 'j & 'k & 'l) & 'init, sub: 'l -> ((int | 'm) -> ('a & 'n) & 'o) & 'sub, update: 'j -> ((int | 'm | 'p) -> ('q -> ('c & 'h & 'i & 'j & 'k & 'l & 's) & 't) & 'u) & 'update} & 'v) -> ArraysRep['a, 'r]
//│   where
//│     'r :> ('w | 'g | 'x | 's, "hey" | "hi",)
//│        <: ('c & 'h & 'i & 'j & 'k & 'l, 'y & 'z & 'a1,)
//│     'a <: 'b1 & 'q & 'c1 & 'f
//│   <:  stepImpl_ty:
//│ ArraysRep['a, 'r] -> ArraysRep['a, ('r, string,)]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.174: 	stepImpl_ty = stepImpl_Ann_4
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.16: 	    fold: forall 'b. (A -> 'b -> 'b) -> 'b -> Rep -> 'b
//│ ║        	                 ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.16: 	    fold: forall 'b. (A -> 'b -> 'b) -> 'b -> Rep -> 'b
//│ ╙──      	                 ^^
//│            = [Function: stepImpl_Ann_4]

// * Note: this one expectedly doesn't work, as in `QML_exist_Classes.mls`
// def stepImpl2 (arr: Arrays['a]) = arr stepImpl

def stepImpl2 arr = arr stepImpl
//│ stepImpl2: ((forall 'sub, 'a, 'fold, 'update, 'b, 'c, 'd, 'e, 'f, 'g, 'h, 'init, 'i, 'j, 'k, 'l, 'm, 'n, 'o, 'p, 'q, 'r, 's. ({fold: 'q -> ('g -> ('d -> 'j & 'e) & 'p) & 'fold, init: 'n -> 'f & 'init, sub: 'a -> ('c -> 'm & 'b) & 'sub, update: 'i -> ('h -> ('l -> 'k & 'r) & 's) & 'update} & 'o) -> {fold: forall 't. ('q & 't) -> (forall 'u. ('g & 'u) -> (forall 'v, 'w, 'x. ('d & 'w, 'x,) -> ('v | 'j))), init: forall 'y, 'z. ('n & 'y) -> ('z | 'f, "hi",), sub: forall 'a1, 'b1. ('a & 'a1, 'b1,) -> (forall 'c1, 'd1. ('c & 'c1) -> ('d1 | 'm)), update: forall 'e1, 'f1. ('i & 'e1, 'f1,) -> (forall 'g1. ('h & 'g1) -> (forall 'h1, 'i1. ('l & 'h1) -> ('i1 | 'k, "hey",)))}) -> 'j1 & 'k1) -> 'j1
//│          = [Function: stepImpl2]

def stepImpl2_ arr = arr stepImpl_ty
//│ stepImpl2_: ((forall 'a, 'r. ArraysRep['a, 'r] -> ArraysRep['a, ('r, string,)]) -> 'b & 'c) -> 'b
//│           = [Function: stepImpl2_]

// * Expectedly doesn't work (see comment on `stepImpl_Ann_1`)
// def stepImpl2_Ann_1 arr = arr stepImpl_Ann_1

def stepImpl2_Ann_2 arr = arr stepImpl_Ann_2
//│ stepImpl2_Ann_2: ((forall 'a, 'r. ArraysRep['a, 'r] -> {fold: forall 'b, 'b0, 'c. ('a -> 'b -> ('b & 'b0) & 'c) -> (forall 'd. ('b & 'd) -> (forall 'e, 'f, 'g. ('r & 'e, 'f,) -> ('b0 | 'd | 'g))), init: forall 'h, 'i. ('a & 'h) -> ('r | 'i, "hi",), sub: forall 'j, 'k. ('r & 'j, 'k,) -> (forall 'l, 'm, 'n. (int & 'l & 'm) -> ('a | 'n)), update: forall 'o, 'p. ('r & 'o, 'p,) -> (forall 'm. (int & 'm) -> (forall 'q, 's. ('a & 'q) -> ('r | 's, "hey",)))}) -> 't & 'u) -> 't
//│                = [Function: stepImpl2_Ann_2]

def stepImpl2_Ann_3 arr = arr stepImpl_Ann_3
//│ stepImpl2_Ann_3: ((forall 'b, 'c, 'd, 'e, 'f, 'g, 'sub, 'h, 'i, 'init, 'j, 'k, 'l, 'm, 'update, 'n, 'rep, 'o, 'p, 'q, 'fold, 'a. ({fold: (nothing -> nothing -> anything | 'n) -> (anything -> (anything -> nothing & 'l) & 'd) & 'fold, init: 'b -> 'c & 'init, sub: 'g -> ('o -> 'j & 'i) & 'sub, update: 'p -> ('h -> ('k -> 'm & 'e) & 'q) & 'update} & 'f) -> {fold: Fold['a, ('rep, string,)], init: forall 'r, 's. ('b & 'r) -> ('s | 'c, "hi",), sub: forall 't, 'u. ('g & 't, 'u,) -> (forall 'v, 'w. ('o & 'v) -> ('w | 'j)), update: forall 'x, 'y. ('p & 'x, 'y,) -> (forall 'z. ('h & 'z) -> (forall 'a1, 'b1. ('k & 'a1) -> ('b1 | 'm, "hey",)))}) -> 'c1 & 'd1) -> 'c1
//│                = [Function: stepImpl2_Ann_3]

def stepImpl2_Ann_4 arr = arr stepImpl_Ann_4
//│ stepImpl2_Ann_4: ((forall 'b, 'r, 'c, 'd, 'e, 'f, 'g, 'h, 'fold, 'i, 'j, 'k, 'a, 'l, 'm, 'n, 'o, 'p, 'q, 's, 'init, 't, 'u, 'v, 'w, 'x, 'y, 'z, 'a1, 'b1, 'c1, 'sub, 'update. ({fold: ('a -> nothing -> anything | 'e) -> (anything -> ('z -> nothing & 't) & 'n) & 'fold, init: 'j -> ('z & 'c1 & 'v & 'p & 'b1 & 'h & 'm) & 'init, sub: 'm -> ((int | 'a1) -> ('a & 'd) & 'i) & 'sub, update: 'b1 -> ((int | 'a1 | 'x) -> ('w -> ('z & 'v & 'p & 'b1 & 'h & 'm & 's) & 'l) & 'f) & 'update} & 'u) -> ArraysRep['a, 'r]) -> 'd1 & 'e1) -> 'd1
//│   where
//│     'r :> ('y | 'c1 | 'g | 's, "hey" | "hi",)
//│        <: ('z & 'v & 'p & 'b1 & 'h & 'm, 'o & 'c & 'k,)
//│     'a <: 'q & 'w & 'b & 'j
//│                = [Function: stepImpl2_Ann_4]

def stepImpl2_Ann_2_Ann (arr: Arrays['a]) = arr stepImpl_Ann_2
// def stepImpl2_Ann_2_Ann (arr: Arrays['a]) = arr stepImpl_Ann_2 : Arrays['a]
// def stepImpl2_Ann_2_Ann (arr: ArraysRep['a, 'r]) = arr stepImpl_Ann_2
//│ stepImpl2_Ann_2_Ann: Arrays['a] -> ({fold: forall 'b, 'b0, 'c. (('a0 | 'a1 | 'a2) -> 'b -> ('b & 'b0) & 'c) -> (forall 'd. ('b & 'd) -> (forall 'e, 'f. (nothing, 'e,) -> ('b0 | 'd | 'f))), init: forall 'g. ('g & 'a1 & 'a0) -> (anything, "hi",), sub: forall 'h. (nothing, 'h,) -> (forall 'i, 'j, 'k. (int & 'k & 'i) -> ('a0 | 'a1 | 'a2 | 'j)), update: forall 'l. (nothing, 'l,) -> (forall 'i. (int & 'i) -> (forall 'm. ('a1 & 'a0 & 'm) -> (anything, "hey",)))} | 'n)
//│                    = [Function: stepImpl2_Ann_2_Ann]



def step: Arrays['a] -> Arrays['a]
//│ step: Arrays['a] -> Arrays['a]
//│     = <missing implementation>

// * There used to be a very subtly extrusion here related to the polymorphism of `arrImpl.fold`
// *  and it not being known at the `stepImpl` definition site.
// * But this problem actually disappeared after fixing a subtle bug in type freshening...!
:e // * Since "sound extrusion"
def step arr f = f (stepImpl2 arr)
//│ ((forall 'sub, 'a, 'b, 'c, 'd, 'e, 'update, 'f, 'g, 'h, 'i, 'j, 'k, 'l, 'm, 'n, 'init, 'o, 'p, 'q, 'r, 's, 'fold. ({fold: 'm -> ('f -> ('r -> 'a & 'o) & 'j) & 'fold, init: 'c -> 'i & 'init, sub: 'd -> ('g -> 'h & 'n) & 'sub, update: 'e -> ('s -> ('b -> 'p & 'k) & 'q) & 'update} & 'l) -> {fold: forall 't. ('m & 't) -> (forall 'u. ('f & 'u) -> (forall 'v, 'w, 'x. ('r & 'v, 'w,) -> ('x | 'a))), init: forall 'y, 'z. ('c & 'y) -> ('z | 'i, "hi",), sub: forall 'a1, 'b1. ('d & 'b1, 'a1,) -> (forall 'c1, 'd1. ('g & 'c1) -> ('d1 | 'h)), update: forall 'e1, 'f1. ('e & 'e1, 'f1,) -> (forall 'g1. ('s & 'g1) -> (forall 'h1, 'i1. ('b & 'h1) -> ('i1 | 'p, "hey",)))}) -> 'j1 & 'k1) -> (forall 'l1, 'm1, 'n1. (('l1 | 'j1) -> 'm1 & 'n1) -> 'm1)
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.239: 	def step arr f = f (stepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.20: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.20: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.60: 	    sub    = fun ((r0, r1)) -> fun i -> arrImpl.sub r0 i;
//│ ╙──      	                                                    ^^
//│     = [Function: step]

// * Expectedly doesn't work (see comment on `stepImpl_Ann_1`)
// def step arr f = f (stepImpl2_Ann_1 arr)

:e // * Since "sound extrusion"
def step arr f = f (stepImpl2_Ann_2 arr)
//│ ((forall 'a, 'r. ArraysRep['a, 'r] -> {fold: forall 'b, 'b0, 'c. ('a -> 'b -> ('b & 'b0) & 'c) -> (forall 'd. ('b & 'd) -> (forall 'e, 'f, 'g. ('r & 'e, 'f,) -> ('b0 | 'd | 'g))), init: forall 'h, 'i. ('a & 'h) -> ('r | 'i, "hi",), sub: forall 'j, 'k. ('r & 'j, 'k,) -> (forall 'l, 'm, 'n. (int & 'l & 'm) -> ('a | 'n)), update: forall 'o, 'p. ('r & 'o, 'p,) -> (forall 'm. (int & 'm) -> (forall 'q, 's. ('a & 'q) -> ('r | 's, "hey",)))}) -> 't & 'u) -> (forall 'v, 'w, 'x. (('v | 't) -> 'w & 'x) -> 'w)
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.261: 	def step arr f = f (stepImpl2_Ann_2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.20: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.20: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.100: 	    sub    = fun ((r0, r1)) -> fun i -> arrImpl.sub r0 i;
//│ ╙──       	                                                    ^^
//│     = [Function: step1]

:e
def step arr f = f (stepImpl2_Ann_3 arr)
//│ ((forall 'a, 'b, 'c, 'd, 'rep, 'e, 'f, 'g, 'h, 'i, 'j, 'fold, 'k, 'l, 'update, 'init, 'm, 'sub, 'n, 'o, 'p, 'q. ({fold: (nothing -> nothing -> anything | 'd) -> (anything -> (anything -> nothing & 'g) & 'o) & 'fold, init: 'f -> 'i & 'init, sub: 'p -> ('m -> 'e & 'l) & 'sub, update: 'n -> ('b -> ('j -> 'h & 'k) & 'c) & 'update} & 'q) -> {fold: Fold['a, ('rep, string,)], init: forall 'r, 's. ('f & 's) -> ('r | 'i, "hi",), sub: forall 't, 'u. ('p & 't, 'u,) -> (forall 'v, 'w. ('m & 'v) -> ('w | 'e)), update: forall 'x, 'y. ('n & 'x, 'y,) -> (forall 'z. ('b & 'z) -> (forall 'a1, 'b1. ('j & 'a1) -> ('b1 | 'h, "hey",)))}) -> 'c1 & 'd1) -> (forall 'e1, 'f1, 'g1. (('e1 | 'c1) -> 'f1 & 'g1) -> 'f1)
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.280: 	def step arr f = f (stepImpl2_Ann_3 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘a_2978` does not match type `nothing`
//│ ║  l.231: 	def step: Arrays['a] -> Arrays['a]
//│ ║         	                 ^^
//│ ╟── Note: constraint arises from type variable:
//│ ║  l.118: 	    fold   = (fun f -> fun b -> fun ((r0, r1)) -> arrImpl.fold f b r0) : Fold['a, ('rep, string)]
//│ ╙──       	                                                                              ^^
//│     = [Function: step2]

// * This used to be the only working one based on an internal annotation
:e // * Since "sound extrusion"
def step arr f = f (stepImpl2_Ann_4 arr)
//│ ((forall 'b, 'c, 'd, 'e, 'f, 'g, 'h, 'i, 'j, 'r, 'k, 'l, 'm, 'sub, 'n, 'o, 'p, 'q, 'fold, 's, 'init, 't, 'u, 'v, 'w, 'x, 'update, 'y, 'a, 'z, 'a1, 'b1, 'c1. ({fold: ('a -> nothing -> anything | 'm) -> (anything -> ('w -> nothing & 'e) & 'l) & 'fold, init: 'h -> ('w & 'k & 'g & 'u & 'p & 'b1 & 'd) & 'init, sub: 'd -> ((int | 'n) -> ('a & 'x) & 'i) & 'sub, update: 'p -> ((int | 'n | 'b) -> ('t -> ('w & 'g & 'u & 'p & 'b1 & 'd & 'z) & 'j) & 'a1) & 'update} & 'q) -> ArraysRep['a, 'r]) -> 'd1 & 'e1) -> (forall 'f1, 'g1, 'h1. (('f1 | 'd1) -> 'g1 & 'h1) -> 'g1)
//│   where
//│     'r :> ('f | 'k | 'v | 'z, "hey" | "hi",)
//│        <: ('w & 'g & 'u & 'p & 'b1 & 'd, 'o & 'c1 & 'c,)
//│     'a <: 's & 't & 'y & 'h
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.297: 	def step arr f = f (stepImpl2_Ann_4 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.16: 	    fold: forall 'b. (A -> 'b -> 'b) -> 'b -> Rep -> 'b
//│ ║        	                 ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.16: 	    fold: forall 'b. (A -> 'b -> 'b) -> 'b -> Rep -> 'b
//│ ╙──      	                 ^^
//│     = [Function: step3]

:e // * Since "sound extrusion"
def step arr f = f (stepImpl2_Ann_2_Ann arr)
//│ (Arrays[in 'a out 'a | 'a0] & 'c) -> (forall 'd, 'a1, 'a2, 'e, 'f, 'a3. (({fold: forall 'b, 'b0, 'g. (('a2 | 'a1 | 'a3) -> 'b -> ('b & 'b0) & 'g) -> (forall 'h. ('b & 'h) -> (forall 'i, 'j. (nothing, 'i,) -> ('b0 | 'h | 'j))), init: forall 'k. ('k & 'a1 & 'a2) -> (anything, "hi",), sub: forall 'l. (nothing, 'l,) -> (forall 'm, 'n, 'o. (int & 'm & 'n) -> ('a2 | 'a1 | 'a3 | 'o)), update: forall 'p. (nothing, 'p,) -> (forall 'n. (int & 'n) -> (forall 'q. ('a1 & 'a2 & 'q) -> (anything, "hey",)))} | 'd) -> 'e & 'f) -> 'e)
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.317: 	def step arr f = f (stepImpl2_Ann_2_Ann arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.20: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.20: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.100: 	    sub    = fun ((r0, r1)) -> fun i -> arrImpl.sub r0 i;
//│ ╙──       	                                                    ^^
//│     = [Function: step4]

:e // * Since "sound extrusion"
def step (arr: Arrays['a]) f = f (stepImpl2_Ann_2_Ann arr)
//│ Arrays['a] -> (forall 'a0, 'c, 'd, 'e, 'a1, 'a2. (({fold: forall 'b, 'b0, 'f. (('a2 | 'a1 | 'a0) -> 'b -> ('b & 'b0) & 'f) -> (forall 'g. ('b & 'g) -> (forall 'h, 'i. (nothing, 'i,) -> ('b0 | 'g | 'h))), init: forall 'j. ('j & 'a1 & 'a2) -> (anything, "hi",), sub: forall 'k. (nothing, 'k,) -> (forall 'l, 'm, 'n. (int & 'l & 'm) -> ('a2 | 'a1 | 'a0 | 'n)), update: forall 'o. (nothing, 'o,) -> (forall 'm. (int & 'm) -> (forall 'p. ('a1 & 'a2 & 'p) -> (anything, "hey",)))} | 'e) -> 'c & 'd) -> 'c)
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.336: 	def step (arr: Arrays['a]) f = f (stepImpl2_Ann_2_Ann arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.20: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.20: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.100: 	    sub    = fun ((r0, r1)) -> fun i -> arrImpl.sub r0 i;
//│ ╙──       	                                                    ^^
//│     = [Function: step5]

// * Also worked, but this one is easier as it internally uses the fully-annotated `stepImpl_ty`
:e // * Since "sound extrusion"
def step arr f = f (stepImpl2_ arr)
//│ ((forall 'a, 'r. ArraysRep['a, 'r] -> ArraysRep['a, ('r, string,)]) -> 'b & 'c) -> (forall 'd, 'e, 'f. (('d | 'b) -> 'e & 'f) -> 'e)
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.356: 	def step arr f = f (stepImpl2_ arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.20: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.20: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from type variable:
//│ ║  l.53: 	def stepImpl_ty: ArraysRep['a, 'r] -> ArraysRep['a, ('r, string)]
//│ ╙──      	                                                     ^^
//│     = [Function: step6]



ssb = step (step base)
//│ ssb: Arrays['a]
//│    = [Function (anonymous)]

ssb (fun arr ->
    let r2 = arr.update (arr.init true) 1 false
    in (arr.sub r2 0, arr.sub r2 1)
  )
//│ res: (bool, bool,)
//│    = [ false, false ]



rec def mkMonoArray n =
  if n == 0 then base else step (mkMonoArray(n - 1))
//│ mkMonoArray: (int & 'b) -> (forall 'a, 'c. Arrays['a] | 'c)
//│            = [Function: mkMonoArray]

snb = mkMonoArray 5
//│ snb: Arrays['a]
//│    = [Function (anonymous)]

snb (fun arr -> arr.init true)
//│ res: anything
//│    = [ [ [ [Array], 'hi' ], 'hi' ], 'hi' ]



