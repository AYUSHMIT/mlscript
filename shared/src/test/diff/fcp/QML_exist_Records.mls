// * Adaptation of QML's original existentials example; using encoded existentials and plain records


:NoRecursiveTypes
:GeneralizeCurriedFunctions
// :DistributeForalls
// :ArgGen
// :NoConstrainedTypes



type ArraysRep[A, Rep] = {
    init: A -> Rep;
    sub: Rep -> int -> A;
    update: Rep -> int -> A -> Rep;
    fold: forall 'b. (A -> 'b -> 'b) -> 'b -> Rep -> 'b
  }
//│ Defined type alias ArraysRep[=A, =Rep]

type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ Defined type alias Arrays[=A]


def baseImpl: ArraysRep['a, 'a]
baseImpl = {
    init   = fun a -> a;
    sub    = fun r -> fun (i : int) -> r;
    update = fun r -> fun (i : int) -> fun a -> a;
    fold   = fun f -> fun b -> fun r -> f r b
  }
//│ baseImpl: ArraysRep['a, 'a]
//│         = <missing implementation>
//│ {fold: forall 'a. 'a -> (forall 'b. 'b -> (forall 'b, 'c, 'd, 'a, 'e. ('c -> 'e
//│   where
//│     'a <: 'c -> ('b -> 'e & 'd)))), init: forall 'f. 'f -> 'f, sub: forall 'g. 'g -> int -> 'g, update: forall 'h. 'h -> int -> (forall 'i. 'i -> 'i)}
//│   <:  baseImpl:
//│ ArraysRep['a, 'a]
//│         = {
//│             init: [Function: init],
//│             sub: [Function: sub],
//│             update: [Function: update],
//│             fold: [Function: fold]
//│           }

def base: Arrays['a]
def base f = f baseImpl
//│ base: Arrays['a]
//│     = <missing implementation>
//│ ((forall 'a. ArraysRep['a, 'a]) -> 'b & 'c) -> 'b
//│   <:  base:
//│ Arrays['a]
//│     = [Function: base]


def stepImpl_ty: ArraysRep['a, 'r] -> ArraysRep['a, ('r, string)]
//│ stepImpl_ty: ArraysRep['a, 'r] -> ArraysRep['a, ('r, string,)]
//│            = <missing implementation>

// * Not enough to type `step` later in the file
def stepImpl arrImpl = {
    init   = fun a -> (arrImpl.init a, "hi");
    sub    = fun ((r0, r1)) -> fun i -> arrImpl.sub r0 i;
    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.update r0 i a, "hey");
    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.fold f b r0
  }
//│ stepImpl: 'a -> {fold: forall 'b. 'b -> (forall 'c. 'c -> (forall 'd, 'c, 'fold, 'e, 'f, 'a, 'g, 'b, 'h. (('e, 'h,) -> 'f
//│   where
//│     'a <: {fold: 'b -> ('c -> ('e -> 'f & 'g) & 'd) & 'fold}))), init: forall 'i, 'j, 'init, 'a. ('i -> ('j, "hi",)
//│   where
//│     'a <: {init: 'i -> 'j & 'init}), sub: forall 'k, 'l. ('k, 'l,) -> (forall 'm, 'n, 'o, 'sub, 'a, 'k. ('n -> 'm
//│   where
//│     'a <: {sub: 'k -> ('n -> 'm & 'o) & 'sub})), update: forall 'p, 'q. ('p, 'q,) -> (forall 'r. 'r -> (forall 'r, 'update, 's, 't, 'p, 'u, 'v, 'a. ('s -> ('v, "hey",)
//│   where
//│     'a <: {update: 'p -> ('r -> ('s -> 'v & 'u) & 't) & 'update})))}
//│         = [Function: stepImpl]

:e // * Since "sound extrusion"
stepImpl_ty = stepImpl
//│ 'a -> {fold: forall 'b. 'b -> (forall 'c. 'c -> (forall 'a, 'b, 'd, 'e, 'f, 'g, 'h, 'fold, 'c. (('f, 'e,) -> 'h
//│   where
//│     'a <: {fold: 'b -> ('c -> ('f -> 'h & 'g) & 'd) & 'fold}))), init: forall 'i, 'j, 'init, 'a. ('i -> ('j, "hi",)
//│   where
//│     'a <: {init: 'i -> 'j & 'init}), sub: forall 'k, 'l. ('k, 'l,) -> (forall 'm, 'k, 'n, 'sub, 'a, 'o. ('n -> 'o
//│   where
//│     'a <: {sub: 'k -> ('n -> 'o & 'm) & 'sub})), update: forall 'p, 'q. ('p, 'q,) -> (forall 'r. 'r -> (forall 'update, 's, 'a, 'r, 't, 'u, 'p, 'v. ('t -> ('u, "hey",)
//│   where
//│     'a <: {update: 'p -> ('r -> ('t -> 'u & 'v) & 's) & 'update})))}
//│   <:  stepImpl_ty:
//│ ArraysRep['a, 'r] -> ArraysRep['a, ('r, string,)]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.78: 	stepImpl_ty = stepImpl
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.16: 	    fold: forall 'b. (A -> 'b -> 'b) -> 'b -> Rep -> 'b
//│ ║        	                 ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.16: 	    fold: forall 'b. (A -> 'b -> 'b) -> 'b -> Rep -> 'b
//│ ╙──      	                 ^^
//│            = [Function: stepImpl]

type Fold[A, Rep] = (A -> 'b -> 'b) -> 'b -> Rep -> 'b
//│ Defined type alias Fold[+A, -Rep]

// * Bad annotation: polymorphism level at which it's typed makes 'a and 'rep locally quantified,
// *  which is NOT what we want!
def stepImpl_Ann_1 arrImpl = {
    init   = fun a -> (arrImpl.init a, "hi");
    sub    = fun ((r0, r1)) -> fun i -> arrImpl.sub r0 i;
    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.update r0 i a, "hey");
    fold   = fun f -> fun b -> fun ((r0, r1)) -> (arrImpl.fold: Fold['a, 'rep]) f b r0
  }
//│ stepImpl_Ann_1: 'c -> {fold: forall 'd. 'd -> (forall 'e. 'e -> (forall 'a, 'f, 'b, 'a0, 'g, 'c, 'fold, 'rep, 'd, 'h, 'e, 'rep0. (('h & 'rep, 'f,) -> ('e | 'g)
//│   where
//│     'c <: {fold: Fold['a0, 'rep0] & 'fold}
//│     'd <: 'a -> ('b | 'e) -> ('b & 'g)))), init: forall 'i, 'j, 'init, 'c. ('i -> ('j, "hi",)
//│   where
//│     'c <: {init: 'i -> 'j & 'init}), sub: forall 'k, 'l. ('k, 'l,) -> (forall 'm, 'k, 'n, 'c, 'o, 'sub. ('o -> 'm
//│   where
//│     'c <: {sub: 'k -> ('o -> 'm & 'n) & 'sub})), update: forall 'p, 'q. ('p, 'q,) -> (forall 'r. 'r -> (forall 's, 'p, 't, 'r, 'update, 'u, 'c, 'v. ('v -> ('u, "hey",)
//│   where
//│     'c <: {update: 'p -> ('r -> ('v -> 'u & 't) & 's) & 'update})))}
//│               = [Function: stepImpl_Ann_1]

// * Still not enough to type `step` later in the file – this annotation actually doesn't help at all
def stepImpl_Ann_2 (arrImpl: ArraysRep['a, 'r]) = {
    init   = fun a -> (arrImpl.init a, "hi");
    sub    = fun ((r0, r1)) -> fun i -> arrImpl.sub r0 i;
    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.update r0 i a, "hey");
    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.fold f b r0
  }
//│ stepImpl_Ann_2: ArraysRep['a, 'r] -> {fold: forall 'c. 'c -> (forall 'd. 'd -> (forall 'd, 'e, 'b, 'a, 'f, 'g, 'c, 'r. (('r & 'e, 'g,) -> ('d | 'f)
//│   where
//│     'c <: 'a -> ('b | 'd) -> ('b & 'f)))), init: forall 'h, 'i. ('a & 'h) -> ('r | 'i, "hi",), sub: forall 'j, 'k. ('r & 'j, 'k,) -> (forall 'l, 'm, 'n. (int & 'l & 'm) -> ('a | 'n)), update: forall 'o, 'p. ('r & 'o, 'p,) -> (forall 'm. (int & 'm) -> (forall 'q, 's. ('a & 'q) -> ('r | 's, "hey",)))}
//│               = [Function: stepImpl_Ann_2]

stepImpl_ty = stepImpl_Ann_2
//│ ArraysRep['a, 'r] -> {fold: forall 'c. 'c -> (forall 'd. 'd -> (forall 'c, 'e, 'r, 'f, 'b, 'a, 'g, 'd. (('r & 'f, 'g,) -> ('d | 'e)
//│   where
//│     'c <: 'a -> ('b | 'd) -> ('b & 'e)))), init: forall 'h, 'i. ('a & 'h) -> ('r | 'i, "hi",), sub: forall 'j, 'k. ('r & 'j, 'k,) -> (forall 'l, 'm, 'n. (int & 'l & 'm) -> ('a | 'n)), update: forall 'o, 'p. ('r & 'o, 'p,) -> (forall 'm. (int & 'm) -> (forall 'q, 's. ('a & 'q) -> ('r | 's, "hey",)))}
//│   <:  stepImpl_ty:
//│ ArraysRep['a, 'r] -> ArraysRep['a, ('r, string,)]
//│            = [Function: stepImpl_Ann_2]

// * This one seems that it would work but it's again typed at the wrong polymorphism level (I think?)
def stepImpl_Ann_3 arrImpl = {
    init   = fun a -> (arrImpl.init a, "hi");
    sub    = fun ((r0, r1)) -> fun i -> arrImpl.sub r0 i;
    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.update r0 i a, "hey");
    fold   = (fun f -> fun b -> fun ((r0, r1)) -> arrImpl.fold f b r0) : Fold['a, ('rep, string)]
  }
//│ stepImpl_Ann_3: ({fold: (nothing -> nothing -> anything | 'b) -> (anything -> (anything -> nothing & 'c) & 'd) & 'fold} & 'e) -> {fold: Fold['a, ('rep, string,)], init: forall 'e, 'f, 'g, 'init. ('f -> ('g, "hi",)
//│   where
//│     'e <: {init: 'f -> 'g & 'init}), sub: forall 'h, 'i. ('h, 'i,) -> (forall 'j, 'k, 'e, 'h, 'sub, 'l. ('k -> 'j
//│   where
//│     'e <: {sub: 'h -> ('k -> 'j & 'l) & 'sub})), update: forall 'm, 'n. ('m, 'n,) -> (forall 'o. 'o -> (forall 'm, 'update, 'o, 'e, 'p, 'q, 'r, 's. ('q -> ('s, "hey",)
//│   where
//│     'e <: {update: 'm -> ('o -> ('q -> 's & 'p) & 'r) & 'update})))}
//│               = [Function: stepImpl_Ann_3]

:e
stepImpl_ty = stepImpl_Ann_3
//│ ({fold: (nothing -> nothing -> anything | 'b) -> (anything -> (anything -> nothing & 'c) & 'd) & 'fold} & 'e) -> {fold: Fold['a, ('rep, string,)], init: forall 'e, 'f, 'g, 'init. ('f -> ('g, "hi",)
//│   where
//│     'e <: {init: 'f -> 'g & 'init}), sub: forall 'h, 'i. ('h, 'i,) -> (forall 'h, 'sub, 'j, 'k, 'l, 'e. ('j -> 'l
//│   where
//│     'e <: {sub: 'h -> ('j -> 'l & 'k) & 'sub})), update: forall 'm, 'n. ('m, 'n,) -> (forall 'o. 'o -> (forall 'm, 'p, 'q, 'update, 'o, 'e, 'r, 's. ('r -> ('q, "hey",)
//│   where
//│     'e <: {update: 'm -> ('o -> ('r -> 'q & 'p) & 's) & 'update})))}
//│   <:  stepImpl_ty:
//│ ArraysRep['a, 'r] -> ArraysRep['a, ('r, string,)]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.161: 	stepImpl_ty = stepImpl_Ann_3
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘a_1274` does not match type `nothing`
//│ ║  l.55: 	def stepImpl_ty: ArraysRep['a, 'r] -> ArraysRep['a, ('r, string)]
//│ ║        	                           ^^
//│ ╟── Note: constraint arises from type variable:
//│ ║  l.149: 	    fold   = (fun f -> fun b -> fun ((r0, r1)) -> arrImpl.fold f b r0) : Fold['a, ('rep, string)]
//│ ╙──       	                                                                              ^^
//│            = [Function: stepImpl_Ann_3]

// * This one finally works! The annotation needs to be on the result!
// *  Notice the skolem in the parameter's inferred fold type:
def stepImpl_Ann_4 arrImpl = {
    init   = fun a -> (arrImpl.init a, "hi");
    sub    = fun ((r0, r1)) -> fun i -> arrImpl.sub r0 i;
    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.update r0 i a, "hey");
    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.fold f b r0
  } : ArraysRep['a, 'r]
//│ stepImpl_Ann_4: ({fold: ('a -> nothing -> anything | 'b) -> (anything -> ('c -> nothing & 'd) & 'e) & 'fold, init: 'f -> ('c & 'g & 'h & 'i & 'j) & 'init, sub: 'j -> ((int | 'k) -> ('a & 'l) & 'm) & 'sub, update: 'i -> ((int | 'k | 'n) -> ('o -> ('c & 'h & 'i & 'j & 'p) & 'q) & 's) & 'update} & 't) -> ArraysRep['a, 'r]
//│   where
//│     'r :> ('g | 'p, "hey" | "hi",)
//│        <: ('c & 'h & 'i & 'j, 'u & 'v & 'w,)
//│     'a <: 'o & 'f
//│               = [Function: stepImpl_Ann_4]

:e // * Since "sound extrusion"
test = stepImpl_Ann_4 baseImpl
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.198: 	test = stepImpl_Ann_4 baseImpl
//│ ║         	       ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.16: 	    fold: forall 'b. (A -> 'b -> 'b) -> 'b -> Rep -> 'b
//│ ║        	                 ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.16: 	    fold: forall 'b. (A -> 'b -> 'b) -> 'b -> Rep -> 'b
//│ ╙──      	                 ^^
//│ test: error
//│     = {
//│         init: [Function: init],
//│         sub: [Function: sub],
//│         update: [Function: update],
//│         fold: [Function: fold]
//│       }

:e // * Since "sound extrusion"
stepImpl_ty = stepImpl_Ann_4
//│ ({fold: ('a -> nothing -> anything | 'b) -> (anything -> ('c -> nothing & 'd) & 'e) & 'fold, init: 'f -> ('c & 'g & 'h & 'i & 'j) & 'init, sub: 'j -> ((int | 'k) -> ('a & 'l) & 'm) & 'sub, update: 'i -> ((int | 'k | 'n) -> ('o -> ('c & 'h & 'i & 'j & 'p) & 'q) & 's) & 'update} & 't) -> ArraysRep['a, 'r]
//│   where
//│     'r :> ('g | 'p, "hey" | "hi",)
//│        <: ('c & 'h & 'i & 'j, 'u & 'v & 'w,)
//│     'a <: 'o & 'f
//│   <:  stepImpl_ty:
//│ ArraysRep['a, 'r] -> ArraysRep['a, ('r, string,)]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.217: 	stepImpl_ty = stepImpl_Ann_4
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.16: 	    fold: forall 'b. (A -> 'b -> 'b) -> 'b -> Rep -> 'b
//│ ║        	                 ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.16: 	    fold: forall 'b. (A -> 'b -> 'b) -> 'b -> Rep -> 'b
//│ ╙──      	                 ^^
//│            = [Function: stepImpl_Ann_4]

// * Note: this one expectedly doesn't work, as in `QML_exist_Classes.mls`
// def stepImpl2 (arr: Arrays['a]) = arr stepImpl

def stepImpl2 arr = arr stepImpl
//│ stepImpl2: ((forall 'a. 'a -> {fold: forall 'b. 'b -> (forall 'c. 'c -> (forall 'd, 'a, 'e, 'b, 'f, 'g, 'c, 'fold, 'h. (('h, 'g,) -> 'd
//│   where
//│     'a <: {fold: 'b -> ('c -> ('h -> 'd & 'e) & 'f) & 'fold}))), init: forall 'a, 'i, 'j, 'init. ('i -> ('j, "hi",)
//│   where
//│     'a <: {init: 'i -> 'j & 'init}), sub: forall 'k, 'l. ('k, 'l,) -> (forall 'm, 'n, 'a, 'o, 'sub, 'k. ('n -> 'm
//│   where
//│     'a <: {sub: 'k -> ('n -> 'm & 'o) & 'sub})), update: forall 'p, 'q. ('p, 'q,) -> (forall 'r. 'r -> (forall 'update, 'p, 's, 't, 'r, 'u, 'v, 'a. ('s -> ('v, "hey",)
//│   where
//│     'a <: {update: 'p -> ('r -> ('s -> 'v & 't) & 'u) & 'update})))}) -> 'w & 'x) -> 'w
//│          = [Function: stepImpl2]

def stepImpl2_ arr = arr stepImpl_ty
//│ stepImpl2_: ((forall 'a, 'r. ArraysRep['a, 'r] -> ArraysRep['a, ('r, string,)]) -> 'b & 'c) -> 'b
//│           = [Function: stepImpl2_]

// * Expectedly doesn't work (see comment on `stepImpl_Ann_1`)
// def stepImpl2_Ann_1 arr = arr stepImpl_Ann_1

def stepImpl2_Ann_2 arr = arr stepImpl_Ann_2
//│ stepImpl2_Ann_2: ((forall 'a, 'r. ArraysRep['a, 'r] -> {fold: forall 'c. 'c -> (forall 'd. 'd -> (forall 'b, 'd, 'e, 'a, 'f, 'g, 'r, 'c. (('r & 'f, 'e,) -> ('d | 'g)
//│   where
//│     'c <: 'a -> ('b | 'd) -> ('b & 'g)))), init: forall 'h, 'i. ('a & 'h) -> ('r | 'i, "hi",), sub: forall 'j, 'k. ('r & 'j, 'k,) -> (forall 'l, 'm, 'n. (int & 'l & 'm) -> ('a | 'n)), update: forall 'o, 'p. ('r & 'o, 'p,) -> (forall 'm. (int & 'm) -> (forall 'q, 's. ('a & 'q) -> ('r | 's, "hey",)))}) -> 't & 'u) -> 't
//│                = [Function: stepImpl2_Ann_2]

def stepImpl2_Ann_3 arr = arr stepImpl_Ann_3
//│ stepImpl2_Ann_3: ((forall 'a, 'fold, 'b, 'c, 'd, 'e, 'rep. ({fold: (nothing -> nothing -> anything | 'b) -> (anything -> (anything -> nothing & 'd) & 'c) & 'fold} & 'e) -> {fold: Fold['a, ('rep, string,)], init: forall 'e, 'f, 'g, 'init. ('f -> ('g, "hi",)
//│   where
//│     'e <: {init: 'f -> 'g & 'init}), sub: forall 'h, 'i. ('h, 'i,) -> (forall 'j, 'k, 'l, 'h, 'e, 'sub. ('j -> 'k
//│   where
//│     'e <: {sub: 'h -> ('j -> 'k & 'l) & 'sub})), update: forall 'm, 'n. ('n, 'm,) -> (forall 'o. 'o -> (forall 'p, 'n, 'q, 'update, 'o, 'r, 'e, 's. ('q -> ('p, "hey",)
//│   where
//│     'e <: {update: 'n -> ('o -> ('q -> 'p & 's) & 'r) & 'update})))}) -> 't & 'u) -> 't
//│                = [Function: stepImpl2_Ann_3]

def stepImpl2_Ann_4 arr = arr stepImpl_Ann_4
//│ stepImpl2_Ann_4: ((forall 'b, 'c, 'd, 'e, 'f, 'g, 'h, 'init, 'i, 'j, 'k, 'l, 'm, 'n, 'r, 'fold, 'o, 'sub, 'p, 'q, 's, 't, 'a, 'u, 'v, 'update, 'w. ({fold: ('a -> nothing -> anything | 'p) -> (anything -> ('s -> nothing & 'h) & 'c) & 'fold, init: 'n -> ('s & 'v & 'g & 'f & 'j) & 'init, sub: 'j -> ((int | 'm) -> ('a & 'u) & 'd) & 'sub, update: 'f -> ((int | 'm | 'k) -> ('l -> ('s & 'g & 'f & 'j & 't) & 'b) & 'o) & 'update} & 'i) -> ArraysRep['a, 'r]) -> 'x & 'y) -> 'x
//│   where
//│     'r :> ('v | 't, "hey" | "hi",)
//│        <: ('s & 'g & 'f & 'j, 'q & 'e & 'w,)
//│     'a <: 'l & 'n
//│                = [Function: stepImpl2_Ann_4]

def stepImpl2_Ann_2_Ann (arr: Arrays['a]) = arr stepImpl_Ann_2
// def stepImpl2_Ann_2_Ann (arr: Arrays['a]) = arr stepImpl_Ann_2 : Arrays['a]
// def stepImpl2_Ann_2_Ann (arr: ArraysRep['a, 'r]) = arr stepImpl_Ann_2
//│ stepImpl2_Ann_2_Ann: Arrays['a] -> ({fold: forall 'c. 'c -> (forall 'd. 'd -> (forall 'a0, 'd, 'e, 'a1, 'f, 'a2, 'b, 'c. ((nothing, 'e,) -> ('f | 'd)
//│   where
//│     'c <: ('a1 | 'a0 | 'a2) -> ('b | 'd) -> ('b & 'f)))), init: forall 'g. ('g & 'a0 & 'a1) -> (anything, "hi",), sub: forall 'h. (nothing, 'h,) -> (forall 'i, 'j, 'k. (int & 'i & 'j) -> ('a1 | 'a0 | 'a2 | 'k)), update: forall 'l. (nothing, 'l,) -> (forall 'j. (int & 'j) -> (forall 'm. ('a0 & 'a1 & 'm) -> (anything, "hey",)))} | 'n)
//│                    = [Function: stepImpl2_Ann_2_Ann]



def step: Arrays['a] -> Arrays['a]
//│ step: Arrays['a] -> Arrays['a]
//│     = <missing implementation>

// * There used to be a very subtly extrusion here related to the polymorphism of `arrImpl.fold`
// *  and it not being known at the `stepImpl` definition site.
// * But this problem actually disappeared after fixing a subtle bug in type freshening...!
:e // * Since "sound extrusion"
def step arr f = f (stepImpl2 arr)
//│ 'a -> (forall 'b, 'c, 'd, 'a, 'e. (('d -> 'e & 'b) -> 'e
//│   where
//│     'a <: (forall 'f. 'f -> {fold: forall 'g. 'g -> (forall 'h. 'h -> (forall 'f, 'i, 'g, 'fold, 'j, 'h, 'k, 'l, 'm. (('i, 'l,) -> 'm
//│   where
//│     'f <: {fold: 'g -> ('h -> ('i -> 'm & 'k) & 'j) & 'fold}))), init: forall 'f, 'n, 'o, 'init. ('n -> ('o, "hi",)
//│   where
//│     'f <: {init: 'n -> 'o & 'init}), sub: forall 'p, 'q. ('p, 'q,) -> (forall 'f, 'sub, 'p, 'r, 's, 't. ('s -> 't
//│   where
//│     'f <: {sub: 'p -> ('s -> 't & 'r) & 'sub})), update: forall 'u, 'v. ('u, 'v,) -> (forall 'w. 'w -> (forall 'x, 'u, 'y, 'w, 'z, 'a1, 'f, 'update. ('y -> ('x, "hey",)
//│   where
//│     'f <: {update: 'u -> ('w -> ('y -> 'x & 'z) & 'a1) & 'update})))}) -> ('c & 'd)))
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.300: 	def step arr f = f (stepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.20: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.20: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│     = [Function: step]

// * Expectedly doesn't work (see comment on `stepImpl_Ann_1`)
// def step arr f = f (stepImpl2_Ann_1 arr)

:e // * Since "sound extrusion"
def step arr f = f (stepImpl2_Ann_2 arr)
//│ 'c -> (forall 'd, 'e, 'f, 'c, 'g. (('e -> 'f & 'g) -> 'f
//│   where
//│     'c <: (forall 'a, 'r. ArraysRep['a, 'r] -> {fold: forall 'h. 'h -> (forall 'i. 'i -> (forall 'b, 'r, 'j, 'a, 'h, 'k, 'l, 'i. (('r & 'k, 'l,) -> ('i | 'j)
//│   where
//│     'h <: 'a -> ('b | 'i) -> ('b & 'j)))), init: forall 'm, 'n. ('a & 'm) -> ('r | 'n, "hi",), sub: forall 'o, 'p. ('r & 'o, 'p,) -> (forall 'q, 's, 't. (int & 'q & 's) -> ('a | 't)), update: forall 'u, 'v. ('r & 'u, 'v,) -> (forall 's. (int & 's) -> (forall 'w, 'x. ('a & 'w) -> ('r | 'x, "hey",)))}) -> ('d & 'e)))
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.329: 	def step arr f = f (stepImpl2_Ann_2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.20: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.20: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.127: 	    sub    = fun ((r0, r1)) -> fun i -> arrImpl.sub r0 i;
//│ ╙──       	                                                    ^^
//│     = [Function: step1]

:e
def step arr f = f (stepImpl2_Ann_3 arr)
//│ 'b -> (forall 'c, 'd, 'e, 'f, 'b. (('d -> 'c & 'e) -> 'c
//│   where
//│     'b <: (forall 'g, 'h, 'i, 'rep, 'fold, 'a, 'j. ({fold: (nothing -> nothing -> anything | 'j) -> (anything -> (anything -> nothing & 'i) & 'g) & 'fold} & 'h) -> {fold: Fold['a, ('rep, string,)], init: forall 'h, 'k, 'l, 'init. ('k -> ('l, "hi",)
//│   where
//│     'h <: {init: 'k -> 'l & 'init}), sub: forall 'm, 'n. ('m, 'n,) -> (forall 'o, 'h, 'p, 'm, 'sub, 'q. ('p -> 'o
//│   where
//│     'h <: {sub: 'm -> ('p -> 'o & 'q) & 'sub})), update: forall 'r, 's. ('r, 's,) -> (forall 't. 't -> (forall 'u, 'r, 'v, 'w, 'x, 't, 'h, 'update. ('w -> ('v, "hey",)
//│   where
//│     'h <: {update: 'r -> ('t -> ('w -> 'v & 'x) & 'u) & 'update})))}) -> ('f & 'd)))
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.352: 	def step arr f = f (stepImpl2_Ann_3 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘a_2668` does not match type `nothing`
//│ ║  l.292: 	def step: Arrays['a] -> Arrays['a]
//│ ║         	                 ^^
//│ ╟── Note: constraint arises from type variable:
//│ ║  l.149: 	    fold   = (fun f -> fun b -> fun ((r0, r1)) -> arrImpl.fold f b r0) : Fold['a, ('rep, string)]
//│ ╙──       	                                                                              ^^
//│     = [Function: step2]

// * This used to be the only working one based on an internal annotation
:e // * Since "sound extrusion"
def step arr f = f (stepImpl2_Ann_4 arr)
//│ 'b -> (forall 'c, 'b, 'd, 'e, 'f. (('f -> 'c & 'd) -> 'c
//│   where
//│     'b <: (forall 'g, 'h, 'i, 'j, 'k, 'l, 'm, 'sub, 'update, 'fold, 'n, 'o, 'a, 'p, 'q, 's, 't, 'u, 'v, 'w, 'x, 'y, 'init, 'r, 'z, 'a1, 'b1. ({fold: ('a -> nothing -> anything | 'b1) -> (anything -> ('t -> nothing & 'j) & 'w) & 'fold, init: 'm -> ('t & 'h & 's & 'a1 & 'z) & 'init, sub: 'z -> ((int | 'l) -> ('a & 'i) & 'o) & 'sub, update: 'a1 -> ((int | 'l | 'x) -> ('k -> ('t & 's & 'a1 & 'z & 'n) & 'q) & 'v) & 'update} & 'g) -> ArraysRep['a, 'r]) -> ('e & 'f)))
//│   where
//│     'r :> ('h | 'n, "hey" | "hi",)
//│        <: ('t & 's & 'a1 & 'z, 'y & 'p & 'u,)
//│     'a <: 'k & 'm
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.377: 	def step arr f = f (stepImpl2_Ann_4 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.16: 	    fold: forall 'b. (A -> 'b -> 'b) -> 'b -> Rep -> 'b
//│ ║        	                 ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.16: 	    fold: forall 'b. (A -> 'b -> 'b) -> 'b -> Rep -> 'b
//│ ╙──      	                 ^^
//│     = [Function: step3]

:e // * Since "sound extrusion"
def step arr f = f (stepImpl2_Ann_2_Ann arr)
//│ 'c -> (forall 'd, 'e, 'a, 'f, 'c, 'a0, 'a1, 'a2. ((({fold: forall 'g. 'g -> (forall 'h. 'h -> (forall 'g, 'h, 'i, 'a, 'j, 'b, 'a0, 'a1. ((nothing, 'i,) -> ('j | 'h)
//│   where
//│     'g <: ('a | 'a0 | 'a1) -> ('b | 'h) -> ('b & 'j)))), init: forall 'k. ('k & 'a0 & 'a) -> (anything, "hi",), sub: forall 'l. (nothing, 'l,) -> (forall 'm, 'n, 'o. (int & 'm & 'n) -> ('a | 'a0 | 'a1 | 'o)), update: forall 'p. (nothing, 'p,) -> (forall 'n. (int & 'n) -> (forall 'q. ('a0 & 'a & 'q) -> (anything, "hey",)))} | 'd) -> 'e & 'f) -> 'e
//│   where
//│     'c <: Arrays['a2]))
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.399: 	def step arr f = f (stepImpl2_Ann_2_Ann arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.20: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.20: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.127: 	    sub    = fun ((r0, r1)) -> fun i -> arrImpl.sub r0 i;
//│ ╙──       	                                                    ^^
//│     = [Function: step4]

:e // * Since "sound extrusion"
def step (arr: Arrays['a]) f = f (stepImpl2_Ann_2_Ann arr)
//│ Arrays['a] -> (forall 'c, 'd, 'a0, 'a1, 'e, 'a2. (({fold: forall 'f. 'f -> (forall 'g. 'g -> (forall 'h, 'i, 'g, 'f, 'b, 'a0, 'a1, 'a2. ((nothing, 'h,) -> ('i | 'g)
//│   where
//│     'f <: ('a2 | 'a0 | 'a1) -> ('b | 'g) -> ('b & 'i)))), init: forall 'j. ('j & 'a0 & 'a2) -> (anything, "hi",), sub: forall 'k. (nothing, 'k,) -> (forall 'l, 'm, 'n. (int & 'l & 'm) -> ('a2 | 'a0 | 'a1 | 'n)), update: forall 'o. (nothing, 'o,) -> (forall 'm. (int & 'm) -> (forall 'p. ('a0 & 'a2 & 'p) -> (anything, "hey",)))} | 'd) -> 'c & 'e) -> 'c)
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.422: 	def step (arr: Arrays['a]) f = f (stepImpl2_Ann_2_Ann arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.20: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.20: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.127: 	    sub    = fun ((r0, r1)) -> fun i -> arrImpl.sub r0 i;
//│ ╙──       	                                                    ^^
//│     = [Function: step5]

// * Also worked, but this one is easier as it internally uses the fully-annotated `stepImpl_ty`
:e // * Since "sound extrusion"
def step arr f = f (stepImpl2_ arr)
//│ 'b -> (forall 'c, 'd, 'b, 'e, 'f. (('e -> 'f & 'c) -> 'f
//│   where
//│     'b <: (forall 'r, 'a. ArraysRep['a, 'r] -> ArraysRep['a, ('r, string,)]) -> ('d & 'e)))
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.444: 	def step arr f = f (stepImpl2_ arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.20: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.20: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from type variable:
//│ ║  l.55: 	def stepImpl_ty: ArraysRep['a, 'r] -> ArraysRep['a, ('r, string)]
//│ ╙──      	                                                     ^^
//│     = [Function: step6]



ssb = step (step base)
//│ ssb: Arrays['a]
//│    = [Function (anonymous)]

ssb (fun arr ->
    let r2 = arr.update (arr.init true) 1 false
    in (arr.sub r2 0, arr.sub r2 1)
  )
//│ res: (bool, bool,)
//│    = [ false, false ]



rec def mkMonoArray n =
  if n == 0 then base else step (mkMonoArray(n - 1))
//│ mkMonoArray: int -> (forall 'a. Arrays['a])
//│            = [Function: mkMonoArray]

snb = mkMonoArray 5
//│ snb: Arrays['a]
//│    = [Function (anonymous)]

snb (fun arr -> arr.init true)
//│ res: anything
//│    = [ [ [ [Array], 'hi' ], 'hi' ], 'hi' ]



