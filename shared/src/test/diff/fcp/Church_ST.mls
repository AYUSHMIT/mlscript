:NoRecursiveTypes
:GeneralizeCurriedFunctions
:NoConstrainedTypes
:DontDistributeForalls



type ChurchInt = forall 'N. ('N -> 'N) -> ('N -> 'N)
//│ Defined type alias ChurchInt



// * === Explicitly Annotated ===


def zero: forall 'a. ('a -> 'a) -> ('a -> 'a)
def zero f x = x
//│ zero: ('a -> 'a) -> 'a -> 'a
//│     = <missing implementation>
//│ 'a -> (forall 'b. 'b -> 'b)
//│   <:  zero:
//│ ('a -> 'a) -> 'a -> 'a
//│     = [Function: zero]

def zero: ChurchInt
def zero f x = x
//│ zero: ChurchInt
//│     = <missing implementation>
//│ 'a -> (forall 'b. 'b -> 'b)
//│   <:  zero:
//│ ChurchInt
//│     = [Function: zero1]


def succ: (forall 'N. ('N -> 'N) -> ('N -> 'N)) -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ succ: (forall 'N. ('N -> 'N) -> 'N -> 'N) -> (forall 'M. ('M -> 'M) -> 'M -> 'M)
//│     = <missing implementation>

// * When we don't infer constrained types and extrude eagerly instead,
// * this one requires distributing the RHS forall to rigidify it earlier:
:e
def succ n f x = f (n f x)
//│ ('a -> ('b -> 'c & 'd) & 'e) -> (forall 'f, 'g, 'h. (('c | 'f) -> 'g & 'a & 'h) -> (forall 'i, 'j. ('b & 'i) -> ('j | 'g)))
//│   <:  succ:
//│ (forall 'N. ('N -> 'N) -> 'N -> 'N) -> (forall 'M. ('M -> 'M) -> 'M -> 'M)
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.42: 	def succ n f x = f (n f x)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.35: 	def succ: (forall 'N. ('N -> 'N) -> ('N -> 'N)) -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ║        	                                                           ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.35: 	def succ: (forall 'N. ('N -> 'N) -> ('N -> 'N)) -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ║        	                                                           ^^
//│ ╟── from quantified type variable:
//│ ║  l.35: 	def succ: (forall 'N. ('N -> 'N) -> ('N -> 'N)) -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ╙──      	                  ^^
//│     = [Function: succ1]

// * This explicit annotation makes it type check; like in MLF:
def succ (n: (forall 'N. ('N -> 'N) -> ('N -> 'N))) = fun f -> fun x -> f (n f x)
//│ (forall 'N. ('N -> 'N) -> 'N -> 'N) -> (forall 'N0, 'a, 'b, 'N1, 'c. (('N0 | 'a) -> 'b & 'N1 -> ('N0 & 'N1) & 'c) -> (forall 'd, 'N2, 'e, 'f. ('a & 'N1 & 'd & 'N2 & 'e) -> ('f | 'b)))
//│   <:  succ:
//│ (forall 'N. ('N -> 'N) -> 'N -> 'N) -> (forall 'M. ('M -> 'M) -> 'M -> 'M)
//│     = [Function: succ2]

def succ (n: ChurchInt) f x = f (n f x)
//│ ChurchInt -> (forall 'a, 'b, 'N, 'c, 'N0. (('N0 | 'a) -> 'b & 'N -> ('N0 & 'N) & 'c) -> (forall 'd, 'N1, 'e, 'f. ('a & 'N & 'd & 'N1 & 'e) -> ('f | 'b)))
//│   <:  succ:
//│ (forall 'N. ('N -> 'N) -> 'N -> 'N) -> (forall 'M. ('M -> 'M) -> 'M -> 'M)
//│     = [Function: succ3]

// * Manually distributing the signature also fixes the type checking:
def succD: forall 'M. ChurchInt -> ('M -> 'M) -> ('M -> 'M)
def succD n f x = f (n f x)
//│ succD: ChurchInt -> ('M -> 'M) -> 'M -> 'M
//│      = <missing implementation>
//│ ('a -> ('b -> 'c & 'd) & 'e) -> (forall 'f, 'g, 'h. (('c | 'f) -> 'g & 'a & 'h) -> (forall 'i, 'j. ('b & 'i) -> ('j | 'g)))
//│   <:  succD:
//│ ChurchInt -> ('M -> 'M) -> 'M -> 'M
//│      = [Function: succD]

succD = succ
//│ (forall 'N. ('N -> 'N) -> 'N -> 'N) -> (forall 'M. ('M -> 'M) -> 'M -> 'M)
//│   <:  succD:
//│ ChurchInt -> ('M -> 'M) -> 'M -> 'M
//│      = [Function: succ3]

// * This does not hold without distrobutivity
:e
succ = succD
//│ ChurchInt -> ('M -> 'M) -> 'M -> 'M
//│   <:  succ:
//│ (forall 'N. ('N -> 'N) -> 'N -> 'N) -> (forall 'M. ('M -> 'M) -> 'M -> 'M)
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.91: 	succ = succD
//│ ║        	^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.35: 	def succ: (forall 'N. ('N -> 'N) -> ('N -> 'N)) -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ║        	                                                           ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.35: 	def succ: (forall 'N. ('N -> 'N) -> ('N -> 'N)) -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ║        	                                                           ^^
//│ ╟── from quantified type variable:
//│ ║  l.74: 	def succD: forall 'M. ChurchInt -> ('M -> 'M) -> ('M -> 'M)
//│ ╙──      	                  ^^
//│     = [Function: succ3]



// * === Usages ===


n1 = succ zero
//│ n1: ('M -> 'M) -> 'M -> 'M
//│   = [Function (anonymous)]

n2 = succ (succ zero)
//│ n2: ('M -> 'M) -> 'M -> 'M
//│   = [Function (anonymous)]

n3 = succ (succ (succ zero))
//│ n3: ('M -> 'M) -> 'M -> 'M
//│   = [Function (anonymous)]


wrap x = { x }
//│ wrap: 'a -> {x: 'a}
//│     = [Function: wrap]

n1w = n1 wrap
//│ n1w: 'M -> 'M
//│   where
//│     'M :> {x: 'M}
//│    = [Function (anonymous)]

n1w 0
//│ res: 'a
//│   where
//│     'a :> 0 | {x: 'a}
//│    = { x: 0 }

n1 wrap 0
//│ res: 'a
//│   where
//│     'a :> 0 | {x: 'a}
//│    = { x: 0 }

:e
res.x + 1
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.150: 	res.x + 1
//│ ║         	^^^^^
//│ ╟── integer literal of type `0` does not have field 'x'
//│ ║  l.143: 	n1 wrap 0
//│ ║         	        ^
//│ ╟── but it flows into reference with expected type `{x: ?x}`
//│ ║  l.150: 	res.x + 1
//│ ╙──       	^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.150: 	res.x + 1
//│ ║         	^^^^^^^
//│ ╟── record literal of type `{x: ?a}` is not an instance of type `int`
//│ ║  l.127: 	wrap x = { x }
//│ ║         	         ^^^^^
//│ ╟── but it flows into field selection with expected type `int`
//│ ║  l.150: 	res.x + 1
//│ ╙──       	^^^^^
//│ res: error
//│    = 1

n2 wrap 0
//│ res: 'a
//│   where
//│     'a :> 0 | {x: 'a}
//│    = { x: { x: 0 } }

:e
res.x.x + 1
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.179: 	res.x.x + 1
//│ ║         	^^^^^
//│ ╟── integer literal of type `0` does not have field 'x'
//│ ║  l.172: 	n2 wrap 0
//│ ║         	        ^
//│ ╟── but it flows into reference with expected type `{x: ?x}`
//│ ║  l.179: 	res.x.x + 1
//│ ╙──       	^^^
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.179: 	res.x.x + 1
//│ ║         	^^^^^^^
//│ ╟── integer literal of type `0` does not have field 'x'
//│ ║  l.172: 	n2 wrap 0
//│ ║         	        ^
//│ ╟── but it flows into field selection with expected type `{x: ?x}`
//│ ║  l.179: 	res.x.x + 1
//│ ╙──       	^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.179: 	res.x.x + 1
//│ ║         	^^^^^^^^^
//│ ╟── record literal of type `{x: ?a}` is not an instance of type `int`
//│ ║  l.127: 	wrap x = { x }
//│ ║         	         ^^^^^
//│ ╟── but it flows into field selection with expected type `int`
//│ ║  l.179: 	res.x.x + 1
//│ ╙──       	^^^^^^^
//│ res: error
//│    = 1


def wrap_ty: 'a -> {x: 'a}
//│ wrap_ty: 'a -> {x: 'a}
//│        = <missing implementation>

wrap_ty = wrap
//│ 'a -> {x: 'a}
//│   <:  wrap_ty:
//│ 'a -> {x: 'a}
//│        = [Function: wrap]

n1w = n1 wrap_ty
//│ n1w: 'M -> 'M
//│   where
//│     'M :> {x: 'M}
//│    = [Function (anonymous)]

n1w 0
//│ res: 'a
//│   where
//│     'a :> 0 | {x: 'a}
//│    = { x: 0 }

:e
res.x + 1
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.234: 	res.x + 1
//│ ║         	^^^^^
//│ ╟── integer literal of type `0` does not have field 'x'
//│ ║  l.227: 	n1w 0
//│ ║         	    ^
//│ ╟── but it flows into reference with expected type `{x: ?x}`
//│ ║  l.234: 	res.x + 1
//│ ╙──       	^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.234: 	res.x + 1
//│ ║         	^^^^^^^
//│ ╟── type `{x: ?a}` is not an instance of type `int`
//│ ║  l.211: 	def wrap_ty: 'a -> {x: 'a}
//│ ║         	                   ^^^^^^^
//│ ╟── but it flows into field selection with expected type `int`
//│ ║  l.234: 	res.x + 1
//│ ╙──       	^^^^^
//│ res: error
//│    = 1



// * === Unannotated (More Powerful) ===


def z f x = x
//│ z: 'a -> (forall 'b. 'b -> 'b)
//│  = [Function: z]

def s n f x = f (n f x)
//│ s: ('a -> ('b -> 'c & 'd) & 'e) -> (forall 'f, 'g, 'h. (('c | 'f) -> 'g & 'a & 'h) -> (forall 'i, 'j. ('b & 'j) -> ('i | 'g)))
//│  = [Function: s]

def s_A1 (n: ChurchInt) f x = f (n f x)
//│ s_A1: ChurchInt -> (forall 'a, 'N, 'b, 'N0, 'c. (('N | 'a) -> 'c & 'N0 -> ('N & 'N0) & 'b) -> (forall 'N1, 'd, 'e, 'f. ('a & 'N0 & 'f & 'N1 & 'd) -> ('e | 'c)))
//│     = [Function: s_A1]

zero = z
//│ 'a -> (forall 'b. 'b -> 'b)
//│   <:  zero:
//│ ChurchInt
//│     = [Function: z]

// * Similalry as before, unannotated succ impl requires constrained types
:e
succ = s
//│ ('a -> ('b -> 'c & 'd) & 'e) -> (forall 'f, 'g, 'h. (('c | 'f) -> 'g & 'a & 'h) -> (forall 'i, 'j. ('b & 'i) -> ('j | 'g)))
//│   <:  succ:
//│ (forall 'N. ('N -> 'N) -> 'N -> 'N) -> (forall 'M. ('M -> 'M) -> 'M -> 'M)
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.281: 	succ = s
//│ ║         	^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.35: 	def succ: (forall 'N. ('N -> 'N) -> ('N -> 'N)) -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ║        	                                                           ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.35: 	def succ: (forall 'N. ('N -> 'N) -> ('N -> 'N)) -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ║        	                                                           ^^
//│ ╟── from quantified type variable:
//│ ║  l.35: 	def succ: (forall 'N. ('N -> 'N) -> ('N -> 'N)) -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
//│ ╙──      	                  ^^
//│     = [Function: s]

succ = s_A1
//│ ChurchInt -> (forall 'a, 'N, 'b, 'N0, 'c. (('N0 | 'c) -> 'a & 'N -> ('N0 & 'N) & 'b) -> (forall 'd, 'N1, 'e, 'f. ('c & 'N & 'd & 'N1 & 'e) -> ('f | 'a)))
//│   <:  succ:
//│ (forall 'N. ('N -> 'N) -> 'N -> 'N) -> (forall 'M. ('M -> 'M) -> 'M -> 'M)
//│     = [Function: s_A1]

succD = s
//│ ('a -> ('b -> 'c & 'd) & 'e) -> (forall 'f, 'g, 'h. (('c | 'f) -> 'g & 'a & 'h) -> (forall 'i, 'j. ('b & 'i) -> ('j | 'g)))
//│   <:  succD:
//│ ChurchInt -> ('M -> 'M) -> 'M -> 'M
//│      = [Function: s]

:stats
z: ChurchInt
//│ res: ChurchInt
//│    = [Function: z]
//│ constrain calls  : 15
//│ annoying  calls  : 0
//│ subtyping calls  : 0

:e
:stats
s: ChurchInt -> ChurchInt
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.321: 	s: ChurchInt -> ChurchInt
//│ ║         	^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.8: 	type ChurchInt = forall 'N. ('N -> 'N) -> ('N -> 'N)
//│ ║       	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.8: 	type ChurchInt = forall 'N. ('N -> 'N) -> ('N -> 'N)
//│ ╙──     	                        ^^
//│ res: ChurchInt -> ChurchInt
//│    = [Function: s]
//│ constrain calls  : 64
//│ annoying  calls  : 0
//│ subtyping calls  : 0



// * === Usages ===


// * Interestingly, even without constrained types,
// * we can still use these inferred types to check the following uses:


n1 = s z
//│ n1: (('a | 'b) -> 'c & 'd) -> (forall 'e, 'f. ('a & 'e) -> ('f | 'c))
//│   = [Function (anonymous)]

n2 = s (s z)
//│ n2: (('a | 'b) -> 'c & 'd -> 'a & 'e) -> (forall 'f, 'g. ('d & 'f) -> ('g | 'c))
//│   = [Function (anonymous)]

n3 = s (s (s z))
//│ n3: (('a | 'b) -> 'c & 'd -> 'a & 'e -> 'd & 'f) -> (forall 'g, 'h. ('e & 'g) -> ('h | 'c))
//│   = [Function (anonymous)]


wrap x = { x }
//│ wrap: 'a -> {x: 'a}
//│     = [Function: wrap1]

n1w = n1 wrap
//│ n1w: ('a & 'b) -> ({x: 'b} | 'c)
//│    = [Function (anonymous)]

n1w 0
//│ res: {x: 0}
//│    = { x: 0 }

n1 wrap 0
//│ res: {x: 0}
//│    = { x: 0 }

res.x + 1
//│ res: int
//│    = 1

n2 wrap 0
//│ res: {x: {x: 0}}
//│    = { x: { x: 0 } }

res.x.x + 1
//│ res: int
//│    = 1

n3 wrap 0
//│ res: {x: {x: {x: 0}}}
//│    = { x: { x: { x: 0 } } }

res.x.x.x + 1
//│ res: int
//│    = 1


def wrap_ty: 'a -> {x: 'a}
//│ wrap_ty: 'a -> {x: 'a}
//│        = <missing implementation>

wrap_ty = wrap
//│ 'a -> {x: 'a}
//│   <:  wrap_ty:
//│ 'a -> {x: 'a}
//│        = [Function: wrap1]

n1w = n1 wrap_ty
//│ n1w: ('b & 'a) -> ({x: 'a} | 'c)
//│    = [Function (anonymous)]

n1w 0
//│ res: {x: 0}
//│    = { x: 0 }

res.x + 1
//│ res: int
//│    = 1

n2 wrap_ty 0
//│ res: {x: {x: 0}}
//│    = { x: { x: 0 } }

res.x.x + 1
//│ res: int
//│    = 1

n3 wrap_ty 0
//│ res: {x: {x: {x: 0}}}
//│    = { x: { x: { x: 0 } } }

res.x.x.x + 1
//│ res: int
//│    = 1



// * === Conversions (Using Annotated Defs) ===


rec def to_church n =
  if n == 0 then zero
  else succ (to_church (n - 1))
//│ to_church: (int & 'a) -> (forall 'M, 'b. ('M -> 'M) -> 'M -> 'M | ChurchInt | 'b)
//│          = [Function: to_church]

def to_church_ty: int -> ChurchInt
//│ to_church_ty: int -> ChurchInt
//│             = <missing implementation>

to_church_ty = to_church
//│ (int & 'a) -> (forall 'M, 'b. ('M -> 'M) -> 'M -> 'M | ChurchInt | 'b)
//│   <:  to_church_ty:
//│ int -> ChurchInt
//│             = [Function: to_church]

// * Non-recursive def emulates annotated recursive def
def to_church_ty n =
  if n == 0 then zero
  else succ (to_church_ty (n - 1))
//│ (int & 'a) -> (forall 'b, 'M. ('M -> 'M) -> 'M -> 'M | ChurchInt | 'b)
//│   <:  to_church_ty:
//│ int -> ChurchInt
//│             = [Function: to_church_ty1]



// * === Other Usages ===


sz = s zero
//│ sz: (('N | 'a) -> 'b & 'N -> 'N & 'c) -> (forall 'd, 'e. ('N & 'd) -> ('e | 'b))
//│   = [Function (anonymous)]

:ns
sz
//│ res: forall 'N, 'a, 'b, 'c, 'd. 'a
//│   where
//│     'a :> forall 'e, 'f, 'g. 'e -> (forall 'h, 'i. 'h -> 'i)
//│     'i :> 'g
//│     'h <: 'b
//│     'b <: 'N
//│     'e <: 'f -> 'g & 'c
//│     'c <: 'N -> 'N
//│     'N <: 'd
//│     'f :> 'd
//│    = [Function (anonymous)]

sz: ChurchInt
//│ res: ChurchInt
//│    = [Function (anonymous)]

// * This one works with CT...
// * Apparently worked when generalizing the LHS of ascriptions
:e
s zero : ChurchInt
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.494: 	s zero : ChurchInt
//│ ║         	^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.8: 	type ChurchInt = forall 'N. ('N -> 'N) -> ('N -> 'N)
//│ ║       	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.8: 	type ChurchInt = forall 'N. ('N -> 'N) -> ('N -> 'N)
//│ ╙──     	                        ^^
//│ res: ChurchInt
//│    = [Function (anonymous)]

// * Unlike with CT, here the error is not delayed
:e
sz1 = sz 1
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.509: 	sz1 = sz 1
//│ ║         	      ^^^^
//│ ╟── integer literal of type `1` is not a function
//│ ║  l.509: 	sz1 = sz 1
//│ ║         	         ^
//│ ╟── Note: constraint arises from application:
//│ ║  l.265: 	def s n f x = f (n f x)
//│ ║         	              ^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.265: 	def s n f x = f (n f x)
//│ ╙──       	              ^
//│ sz1: error
//│    = [Function (anonymous)]

:re
sz1 2
//│ res: error
//│ Runtime error:
//│   TypeError: f is not a function



// * === Conversions (Using Unannotated Defs) ===

rec def to_ch_s n =
  if n == 0 then z
  else s (to_ch_s (n - 1))
//│ to_ch_s: (int & 'a) -> (forall 'b, 'c, 'd, 'e, 'f, 'g, 'h, 'i. (('j | 'c | 'e) -> 'b & 'f & 'i & 'g & 'j -> 'j) -> (forall 'b, 'k, 'l, 'm. ('k & 'l & 'h & 'j) -> ('k | 'm | 'b)) | 'd)
//│        = [Function: to_ch_s]


// Q: what's the difference with to_ch_s?!
rec def to_ch n =
  if n == 0 then z
  else s (to_ch (n - 1))
//│ to_ch: (int & 'a) -> (forall 'b, 'c, 'd, 'e, 'f, 'g, 'h, 'i. (('j | 'c | 'g) -> 'b & 'h & 'e & 'f & 'j -> 'j) -> (forall 'b, 'k, 'l, 'm. ('k & 'l & 'i & 'j) -> ('k | 'm | 'b)) | 'd)
//│      = [Function: to_ch]

:e // * Needs distrib (see below)
to_church_ty = to_ch
//│ (int & 'a) -> (forall 'b, 'c, 'd, 'e, 'f, 'g, 'h, 'i. (('j | 'e | 'h) -> 'b & 'd & 'i & 'g & 'j -> 'j) -> (forall 'b, 'k, 'l, 'm. ('k & 'l & 'c & 'j) -> ('k | 'm | 'b)) | 'f)
//│   <:  to_church_ty:
//│ int -> ChurchInt
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.550: 	to_church_ty = to_ch
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.8: 	type ChurchInt = forall 'N. ('N -> 'N) -> ('N -> 'N)
//│ ║       	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.8: 	type ChurchInt = forall 'N. ('N -> 'N) -> ('N -> 'N)
//│ ║       	                        ^^
//│ ╟── from application:
//│ ║  l.265: 	def s n f x = f (n f x)
//│ ╙──       	              ^^^^^^^^^
//│             = [Function: to_ch]

// * Works with version where `s` has annotated `n: ChurchInt` parameter
rec def to_ch_s_A1 n =
  if n == 0 then z
  else s_A1 (to_ch_s_A1 (n - 1))
//│ to_ch_s_A1: (int & 'a) -> (forall 'b, 'c, 'd, 'e, 'N, 'N0, 'f. (('N0 | 'b) -> 'e & 'N -> ('N0 & 'N) & 'f & 'd) -> (forall 'b, 'g, 'h, 'e, 'i, 'N1, 'N, 'j. ('g & 'b & 'N & 'i & 'N1 & 'h) -> ('g | 'j | 'e)) | 'c)
//│           = [Function: to_ch_s_A1]

to_church_ty = to_ch_s_A1
//│ (int & 'a) -> (forall 'N, 'N0, 'b, 'c, 'd, 'e, 'f. (('N0 | 'b) -> 'e & 'N -> ('N0 & 'N) & 'f & 'd) -> (forall 'N, 'g, 'h, 'N1, 'b, 'i, 'j, 'e. ('h & 'b & 'N & 'g & 'N1 & 'j) -> ('h | 'i | 'e)) | 'c)
//│   <:  to_church_ty:
//│ int -> ChurchInt
//│             = [Function: to_ch_s_A1]

// * Boil down the problem with `to_ch`
rec def to_ch_simplif n = s (to_ch_simplif n)
//│ to_ch_simplif: 'a -> (forall 'b, 'c, 'd. (('e | 'f | 'b) -> 'c & 'd & 'g & 'e -> 'e) -> (forall 'h, 'i. ('h & 'j) -> ('i | 'c)) | 'k)
//│              = [Function: to_ch_simplif]

:e
to_church_ty = to_ch_simplif
//│ 'a -> (forall 'b, 'c, 'd. (('e | 'f | 'b) -> 'c & 'd & 'g & 'e -> 'e) -> (forall 'h, 'i. ('h & 'j) -> ('i | 'c)) | 'k)
//│   <:  to_church_ty:
//│ int -> ChurchInt
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.587: 	to_church_ty = to_ch_simplif
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.8: 	type ChurchInt = forall 'N. ('N -> 'N) -> ('N -> 'N)
//│ ║       	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.8: 	type ChurchInt = forall 'N. ('N -> 'N) -> ('N -> 'N)
//│ ║       	                        ^^
//│ ╟── from application:
//│ ║  l.265: 	def s n f x = f (n f x)
//│ ╙──       	              ^^^^^^^^^
//│             = [Function: to_ch_simplif]


// * This annotation here doesn't help
:e
rec def to_ch_A1 n =
  if n == 0 then z
  else s (to_ch_A1 (n - 1) : ChurchInt)
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.608: 	rec def to_ch_A1 n =
//│ ║         	                 ^^^
//│ ║  l.609: 	  if n == 0 then z
//│ ║         	^^^^^^^^^^^^^^^^^^
//│ ║  l.610: 	  else s (to_ch_A1 (n - 1) : ChurchInt)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.8: 	type ChurchInt = forall 'N. ('N -> 'N) -> ('N -> 'N)
//│ ║       	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.8: 	type ChurchInt = forall 'N. ('N -> 'N) -> ('N -> 'N)
//│ ╙──     	                        ^^
//│ to_ch_A1: (int & 'a) -> (forall 'N, 'b, 'c, 'd, 'e, 'f, 'g, 'h, 'i. (('i | 'e) -> 'c & 'N -> ('i & 'N) & 'g & 'h & 'd) -> (forall 'j, 'k, 'l, 'c. ('j & 'i & 'N & 'k & 'b) -> ('j | 'l | 'c)) | 'f)
//│         = [Function: to_ch_A1]

// * nope
// to_church_ty = to_ch_A1

// * This annotation makes it work with Constrained Types, but not without them!!
:e
rec def to_ch_A2 n = (
    if n == 0 then z
    else s (to_ch_A2 (n - 1))
  ) : ChurchInt
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.632: 	rec def to_ch_A2 n = (
//│ ║         	                 ^^^^^
//│ ║  l.633: 	    if n == 0 then z
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.634: 	    else s (to_ch_A2 (n - 1))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.635: 	  ) : ChurchInt
//│ ║         	^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.8: 	type ChurchInt = forall 'N. ('N -> 'N) -> ('N -> 'N)
//│ ║       	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.8: 	type ChurchInt = forall 'N. ('N -> 'N) -> ('N -> 'N)
//│ ╙──     	                        ^^
//│ to_ch_A2: (int & 'a) -> ChurchInt
//│         = [Function: to_ch_A2]

to_church_ty = to_ch_A2
//│ (int & 'a) -> ChurchInt
//│   <:  to_church_ty:
//│ int -> ChurchInt
//│             = [Function: to_ch_A2]


// * Uses `to_church` as the rec call
def to_church_mix n =
  if n == 0 then z
  else s (to_church (n - 1))
//│ to_church_mix: (int & 'a) -> (forall 'b, 'c, 'd, 'e, 'M, 'f, 'g, 'h, 'N, 'i. (('e | 'i) -> 'g & 'N -> ('e & 'N) & 'M -> ('e & 'M) & 'd & 'c & 'f) -> (forall 'g, 'j, 'k, 'l. ('j & 'e & 'N & 'M & 'k & 'b) -> ('j | 'l | 'g)) | 'h)
//│              = [Function: to_church_mix]

// * Works with Constrained Types
:e
to_church_ty = to_church_mix
//│ (int & 'a) -> (forall 'N, 'b, 'M, 'c, 'd, 'e, 'f, 'g, 'h, 'i. (('b | 'h) -> 'e & 'N -> ('b & 'N) & 'M -> ('b & 'M) & 'd & 'i & 'f) -> (forall 'j, 'k, 'l, 'e. ('j & 'b & 'N & 'M & 'k & 'c) -> ('j | 'l | 'e)) | 'g)
//│   <:  to_church_ty:
//│ int -> ChurchInt
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.670: 	to_church_ty = to_church_mix
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.8: 	type ChurchInt = forall 'N. ('N -> 'N) -> ('N -> 'N)
//│ ║       	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.8: 	type ChurchInt = forall 'N. ('N -> 'N) -> ('N -> 'N)
//│ ╙──     	                        ^^
//│             = [Function: to_church_mix]


:e // * Needs to distribute back (in the other direction) here:
rec def to_chD n =
  succD (to_chD n)
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.687: 	rec def to_chD n =
//│ ║         	               ^^^
//│ ║  l.688: 	  succD (to_chD n)
//│ ║         	^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.8: 	type ChurchInt = forall 'N. ('N -> 'N) -> ('N -> 'N)
//│ ║       	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.8: 	type ChurchInt = forall 'N. ('N -> 'N) -> ('N -> 'N)
//│ ║       	                        ^^
//│ ╟── from quantified type variable:
//│ ║  l.74: 	def succD: forall 'M. ChurchInt -> ('M -> 'M) -> ('M -> 'M)
//│ ╙──      	                  ^^
//│ to_chD: 'a -> (('M -> 'M) -> 'M -> 'M | 'b)
//│       = [Function: to_chD]



// * === With Distributivity ===


:DistributeForalls


def zero f x = x
//│ 'a -> (forall 'b. 'b -> 'b)
//│   <:  zero:
//│ ChurchInt
//│     = [Function: zero3]

// * Now it works!
def succ n f x = f (n f x)
//│ ('a -> ('b -> 'c & 'd) & 'e) -> (forall 'f, 'g, 'h. (('c | 'f) -> 'g & 'a & 'h) -> (forall 'i, 'j. ('b & 'i) -> ('j | 'g)))
//│   <:  succ:
//│ (forall 'N. ('N -> 'N) -> 'N -> 'N) -> (forall 'M. ('M -> 'M) -> 'M -> 'M)
//│     = [Function: succ7]

zero = z
//│ 'a -> (forall 'b. 'b -> 'b)
//│   <:  zero:
//│ ChurchInt
//│     = [Function: z]

// * Now works
succ = s
//│ ('a -> ('b -> 'c & 'd) & 'e) -> (forall 'f, 'g, 'h. (('c | 'f) -> 'g & 'a & 'h) -> (forall 'i, 'j. ('b & 'i) -> ('j | 'g)))
//│   <:  succ:
//│ (forall 'N. ('N -> 'N) -> 'N -> 'N) -> (forall 'M. ('M -> 'M) -> 'M -> 'M)
//│     = [Function: s]

// * Still works
succD = s
//│ ('a -> ('b -> 'c & 'd) & 'e) -> (forall 'f, 'g, 'h. (('c | 'f) -> 'g & 'a & 'h) -> (forall 'i, 'j. ('b & 'i) -> ('j | 'g)))
//│   <:  succD:
//│ ChurchInt -> ('M -> 'M) -> 'M -> 'M
//│      = [Function: s]

// * Now works
succ = succD
//│ ChurchInt -> ('M -> 'M) -> 'M -> 'M
//│   <:  succ:
//│ (forall 'N. ('N -> 'N) -> 'N -> 'N) -> (forall 'M. ('M -> 'M) -> 'M -> 'M)
//│     = [Function: s]

// * Now works
rec def to_chD n =
  succD (to_chD n)
//│ to_chD: 'a -> (forall 'M, 'b. ('M -> 'M) -> 'M -> 'M | 'b)
//│       = [Function: to_chD1]

:stats
z: ChurchInt
//│ res: ChurchInt
//│    = [Function: z]
//│ constrain calls  : 15
//│ annoying  calls  : 0
//│ subtyping calls  : 0

:stats
s: ChurchInt -> ChurchInt
//│ res: ChurchInt -> ChurchInt
//│    = [Function: s]
//│ constrain calls  : 79
//│ annoying  calls  : 0
//│ subtyping calls  : 0

// * Now works
to_church_ty = to_ch
//│ (int & 'a) -> (forall 'b, 'c, 'd, 'e, 'f, 'g, 'h, 'i. (('j | 'e | 'g) -> 'h & 'c & 'd & 'b & 'j -> 'j) -> (forall 'h, 'k, 'l, 'm. ('k & 'l & 'f & 'j) -> ('k | 'm | 'h)) | 'i)
//│   <:  to_church_ty:
//│ int -> ChurchInt
//│             = [Function: to_ch]

// * Still works
to_church_ty = to_ch_s_A1
//│ (int & 'a) -> (forall 'b, 'c, 'd, 'e, 'N, 'f, 'N0. (('N0 | 'f) -> 'e & 'N -> ('N0 & 'N) & 'b & 'c) -> (forall 'N1, 'f, 'e, 'g, 'h, 'N, 'i, 'j. ('g & 'f & 'N & 'i & 'N1 & 'j) -> ('g | 'h | 'e)) | 'd)
//│   <:  to_church_ty:
//│ int -> ChurchInt
//│             = [Function: to_ch_s_A1]

// * Now works
to_church_ty = to_ch_simplif
//│ 'a -> (forall 'b, 'c, 'd. (('e | 'f | 'b) -> 'c & 'd & 'g & 'e -> 'e) -> (forall 'h, 'i. ('h & 'j) -> ('i | 'c)) | 'k)
//│   <:  to_church_ty:
//│ int -> ChurchInt
//│             = [Function: to_ch_simplif]

// * Redefinition in the context of distrib, just for the record (still works)
rec def to_ch_simplif n = s (to_ch_simplif n)
to_church_ty = to_ch_simplif
//│ to_ch_simplif: 'a -> (forall 'b, 'c, 'd. ((forall 'e. 'f | 'e | 'b | 'g) -> 'c & 'd & 'h & (forall 'e. 'e | 'g) -> 'g) -> (forall 'i, 'j. ('i & 'k) -> ('j | 'c)) | 'l)
//│              = [Function: to_ch_simplif1]
//│ 'a -> (forall 'b, 'c, 'd. ((forall 'e. 'f | 'e | 'd | 'g) -> 'b & 'c & 'h & (forall 'e. 'e | 'g) -> 'g) -> (forall 'i, 'j. ('i & 'k) -> ('j | 'b)) | 'l)
//│   <:  to_church_ty:
//│ int -> ChurchInt
//│             = [Function: to_ch_simplif1]

to_church_ty = to_ch_A1
//│ (int & 'a) -> (forall 'b, 'N, 'c, 'd, 'e, 'f, 'g, 'h, 'i. (('c | 'e) -> 'g & 'N -> ('c & 'N) & 'i & 'f & 'h) -> (forall 'g, 'j, 'k, 'l. ('j & 'c & 'N & 'k & 'd) -> ('j | 'l | 'g)) | 'b)
//│   <:  to_church_ty:
//│ int -> ChurchInt
//│             = [Function: to_ch_A1]

// * Now works
to_church_ty = to_ch_A2
//│ (int & 'a) -> ChurchInt
//│   <:  to_church_ty:
//│ int -> ChurchInt
//│             = [Function: to_ch_A2]

// * Now works
to_church_ty = to_church_mix
//│ (int & 'a) -> (forall 'N, 'b, 'M, 'c, 'd, 'e, 'f, 'g, 'h, 'i. (('f | 'c) -> 'h & 'N -> ('f & 'N) & 'M -> ('f & 'M) & 'd & 'e & 'b) -> (forall 'j, 'k, 'l, 'h. ('j & 'f & 'N & 'M & 'k & 'g) -> ('j | 'l | 'h)) | 'i)
//│   <:  to_church_ty:
//│ int -> ChurchInt
//│             = [Function: to_church_mix]



// * === Usages ===


n3 = s (s (s z))
//│ n3: ((forall 'a. 'a | 'b | 'c) -> 'd & (forall 'e. 'e | 'f) -> 'c & 'g -> 'f & 'h) -> (forall 'i, 'j. ('g & 'i) -> ('j | 'd))
//│   = [Function (anonymous)]

n3 wrap_ty 0
//│ res: {x: forall 'a. {x: forall 'b. {x: 0} | 'b} | 'a} | 'c
//│    = { x: { x: { x: 0 } } }

res.x.x.x + 1
//│ res: int
//│    = 1


