
:GeneralizeCurriedFunctions
:ArgGen // Type of cons is much simpler without this...

:AllowTypeErrors // FIXME


class Z
class S[P]
  method Inv: P -> P
  method Inv = id
//│ Defined class Z
//│ Defined class S[=P]
//│ Declared S.Inv: S['P] -> 'P -> 'P
//│ Defined S.Inv: S['P] -> (forall 'a. 'a -> 'a)

:IrregularTypes

class Cons[A, N]: { size: S[N]; head: A; tail: Vec[A, N] }
class Nil: { size: Z }
type Vec[A, N] = forall 'r. (forall 'p. (Nil & { size: N } | Cons[A, S['p]] & Cons[A, N]) -> 'r) -> 'r
//│ Defined class Cons[+A, =N]
//│ Defined class Nil
//│ Defined type alias Vec[±A, ±N]
//│ ╔══[WARNING] Type definition Vec has bivariant type parameters:
//│ ║  l.21: 	type Vec[A, N] = forall 'r. (forall 'p. (Nil & { size: N } | Cons[A, S['p]] & Cons[A, N]) -> 'r) -> 'r
//│ ║        	     ^^^
//│ ╟── A is irrelevant and may be removed
//│ ║  l.21: 	type Vec[A, N] = forall 'r. (forall 'p. (Nil & { size: N } | Cons[A, S['p]] & Cons[A, N]) -> 'r) -> 'r
//│ ║        	         ^
//│ ╟── N is irrelevant and may be removed
//│ ║  l.21: 	type Vec[A, N] = forall 'r. (forall 'p. (Nil & { size: N } | Cons[A, S['p]] & Cons[A, N]) -> 'r) -> 'r
//│ ╙──      	            ^

type AnyVec[A] = forall 'r. (forall 'p. Nil | Cons[A, S['p]] -> 'r) -> 'r
//│ Defined type alias AnyVec[±A]
//│ ╔══[WARNING] Type definition AnyVec has bivariant type parameters:
//│ ║  l.35: 	type AnyVec[A] = forall 'r. (forall 'p. Nil | Cons[A, S['p]] -> 'r) -> 'r
//│ ║        	     ^^^^^^
//│ ╟── A is irrelevant and may be removed
//│ ║  l.35: 	type AnyVec[A] = forall 'r. (forall 'p. Nil | Cons[A, S['p]] -> 'r) -> 'r
//│ ╙──      	            ^

def Nil = Nil { size = Z{} }
def Cons head tail = Cons { head; tail; size = S{} }
//│ Nil: Nil
//│ Cons: 'a -> (forall 'a, 'head, 'tail, 'P. ((Vec[?, ?] & 'tail) -> (Cons['head, 'P] with {tail: 'tail})
//│   where
//│     'a <: 'head))


def nil k = k Nil
def cons h t k = k (Cons h t)
//│ nil: (Nil -> 'a) -> 'a
//│ cons: 'a -> (forall 'b. 'b -> ((forall 'a, 'b, 'tail, 'P. (Cons[nothing, 'P] with {tail: 'tail}
//│   where
//│     'b <: Vec[?, ?] & 'tail
//│     'a <: 'b
//│     'b <: Vec[?, ?] & 'tail
//│     'a <: 'b)) -> 'c) -> 'c)

nil_ty = nil : Vec[int, Z]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.62: 	nil_ty = nil : Vec[int, Z]
//│ ║        	         ^^^
//│ ╟── application of type `Z` is not an instance of type `N`
//│ ║  l.44: 	def Nil = Nil { size = Z{} }
//│ ║        	                       ^^^
//│ ╟── Note: constraint arises from type alias type parameter:
//│ ║  l.21: 	type Vec[A, N] = forall 'r. (forall 'p. (Nil & { size: N } | Cons[A, S['p]] & Cons[A, N]) -> 'r) -> 'r
//│ ║        	            ^
//│ ╟── Note: class Z is defined at:
//│ ║  l.8: 	class Z
//│ ╙──     	      ^
//│ nil_ty: Vec[?, ?]

def cons_ty : forall 'a. 'a -> Vec['a, 'n] -> Vec['a, S['n]]
//│ cons_ty: anything -> Vec[?, ?] -> Vec[?, ?]

cons_ty = cons : forall 'a. 'a -> Vec['a, 'n] -> Vec['a, S['n]]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.80: 	cons_ty = cons : forall 'a. 'a -> Vec['a, 'n] -> Vec['a, S['n]]
//│ ║        	          ^^^^
//│ ╟── type `S[?p]` is not an instance of type `N`
//│ ║  l.21: 	type Vec[A, N] = forall 'r. (forall 'p. (Nil & { size: N } | Cons[A, S['p]] & Cons[A, N]) -> 'r) -> 'r
//│ ║        	                                                                     ^^^^^
//│ ╟── Note: constraint arises from type alias type parameter:
//│ ║  l.21: 	type Vec[A, N] = forall 'r. (forall 'p. (Nil & { size: N } | Cons[A, S['p]] & Cons[A, N]) -> 'r) -> 'r
//│ ╙──      	            ^
//│ anything -> Vec[?, ?] -> Vec[?, ?]
//│   <:  cons_ty:
//│ anything -> Vec[?, ?] -> Vec[?, ?]

cons_ty2 = cons : forall 'a. 'a -> Vec['a, 'n] -> Vec['a, S['n]]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.94: 	cons_ty2 = cons : forall 'a. 'a -> Vec['a, 'n] -> Vec['a, S['n]]
//│ ║        	           ^^^^
//│ ╟── type `S[?p]` is not an instance of type `N`
//│ ║  l.21: 	type Vec[A, N] = forall 'r. (forall 'p. (Nil & { size: N } | Cons[A, S['p]] & Cons[A, N]) -> 'r) -> 'r
//│ ║        	                                                                     ^^^^^
//│ ╟── Note: constraint arises from type alias type parameter:
//│ ║  l.21: 	type Vec[A, N] = forall 'r. (forall 'p. (Nil & { size: N } | Cons[A, S['p]] & Cons[A, N]) -> 'r) -> 'r
//│ ╙──      	            ^
//│ cons_ty2: anything -> Vec[?, ?] -> Vec[?, ?]

type Cons_ty = forall 'a. 'a -> Vec['a, 'n] -> Vec['a, S['n]]
//│ Defined type alias Cons_ty












// :exit
// ====================================================================================================


















cons_ty = cons : Cons_ty
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.140: 	cons_ty = cons : Cons_ty
//│ ║         	          ^^^^
//│ ╟── type `S[?p]` is not an instance of type `N`
//│ ║  l.21: 	type Vec[A, N] = forall 'r. (forall 'p. (Nil & { size: N } | Cons[A, S['p]] & Cons[A, N]) -> 'r) -> 'r
//│ ║        	                                                                     ^^^^^
//│ ╟── Note: constraint arises from type alias type parameter:
//│ ║  l.21: 	type Vec[A, N] = forall 'r. (forall 'p. (Nil & { size: N } | Cons[A, S['p]] & Cons[A, N]) -> 'r) -> 'r
//│ ╙──      	            ^
//│ Cons_ty
//│   <:  cons_ty:
//│ anything -> Vec[?, ?] -> Vec[?, ?]

cons_ty3 = cons : Cons_ty
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.154: 	cons_ty3 = cons : Cons_ty
//│ ║         	           ^^^^
//│ ╟── type `S[?p]` is not an instance of type `N`
//│ ║  l.21: 	type Vec[A, N] = forall 'r. (forall 'p. (Nil & { size: N } | Cons[A, S['p]] & Cons[A, N]) -> 'r) -> 'r
//│ ║        	                                                                     ^^^^^
//│ ╟── Note: constraint arises from type alias type parameter:
//│ ║  l.21: 	type Vec[A, N] = forall 'r. (forall 'p. (Nil & { size: N } | Cons[A, S['p]] & Cons[A, N]) -> 'r) -> 'r
//│ ╙──      	            ^
//│ cons_ty3: Cons_ty

def cons h (t: Vec['a, 'n]) k = k (Cons h t)
//│ cons: 'a -> Vec[?, ?] -> ((forall 'a, 'b, 'tail, 'P. (Cons[nothing, 'P] with {tail: 'tail}
//│   where
//│     'a <: 'a
//│     'b <: Vec[?, ?] & 'tail
//│     'a <: 'a
//│     'b <: Vec[?, ?] & 'tail)) -> 'c) -> 'c

cons : Cons_ty
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.174: 	cons : Cons_ty
//│ ║         	^^^^
//│ ╟── type `S[?p]` is not an instance of type `N`
//│ ║  l.21: 	type Vec[A, N] = forall 'r. (forall 'p. (Nil & { size: N } | Cons[A, S['p]] & Cons[A, N]) -> 'r) -> 'r
//│ ║        	                                                                     ^^^^^
//│ ╟── Note: constraint arises from type alias type parameter:
//│ ║  l.21: 	type Vec[A, N] = forall 'r. (forall 'p. (Nil & { size: N } | Cons[A, S['p]] & Cons[A, N]) -> 'r) -> 'r
//│ ╙──      	            ^
//│ res: Cons_ty

def cons h (t: Vec['a, 'n]) k = k (Cons h t)
//│ cons: 'a -> Vec[?, ?] -> ((forall 'a, 'b, 'tail, 'P. (Cons[nothing, 'P] with {tail: 'tail}
//│   where
//│     'b <: Vec[?, ?] & 'tail
//│     'a <: 'a
//│     'b <: Vec[?, ?] & 'tail
//│     'a <: 'a)) -> 'c) -> 'c

cons : Cons_ty
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.194: 	cons : Cons_ty
//│ ║         	^^^^
//│ ╟── type `S[?p]` is not an instance of type `N`
//│ ║  l.21: 	type Vec[A, N] = forall 'r. (forall 'p. (Nil & { size: N } | Cons[A, S['p]] & Cons[A, N]) -> 'r) -> 'r
//│ ║        	                                                                     ^^^^^
//│ ╟── Note: constraint arises from type alias type parameter:
//│ ║  l.21: 	type Vec[A, N] = forall 'r. (forall 'p. (Nil & { size: N } | Cons[A, S['p]] & Cons[A, N]) -> 'r) -> 'r
//│ ╙──      	            ^
//│ res: Cons_ty


// v0 = nil

// v0_ty = v0 : Vec[int, Z]

v1_ = Cons 1 nil
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.211: 	v1_ = Cons 1 nil
//│ ║         	      ^^^^^^^^^^
//│ ╟── application of type `Z` is not an instance of type `N`
//│ ║  l.44: 	def Nil = Nil { size = Z{} }
//│ ║        	                       ^^^
//│ ╟── Note: constraint arises from type alias type parameter:
//│ ║  l.21: 	type Vec[A, N] = forall 'r. (forall 'p. (Nil & { size: N } | Cons[A, S['p]] & Cons[A, N]) -> 'r) -> 'r
//│ ║        	            ^
//│ ╟── Note: class Z is defined at:
//│ ║  l.8: 	class Z
//│ ╙──     	      ^
//│ v1_: error

v1_ty = v1_ : Cons[int, Z]
//│ v1_ty: Cons[int, Z]

v1_0 = cons 1 nil
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.229: 	v1_0 = cons 1 nil
//│ ║         	       ^^^^^^^^^^
//│ ╟── application of type `Z` is not an instance of type `N`
//│ ║  l.44: 	def Nil = Nil { size = Z{} }
//│ ║        	                       ^^^
//│ ╟── Note: constraint arises from type alias type parameter:
//│ ║  l.21: 	type Vec[A, N] = forall 'r. (forall 'p. (Nil & { size: N } | Cons[A, S['p]] & Cons[A, N]) -> 'r) -> 'r
//│ ║        	            ^
//│ ╟── Note: class Z is defined at:
//│ ║  l.8: 	class Z
//│ ╙──     	      ^
//│ v1_0: error

v1_0 : Vec[int, S[Z]]
//│ res: Vec[?, ?]

v1_1 k = k v1_
//│ v1_1: (error -> 'a) -> 'a

// :e
v1_1 : Vec[int, S[Z]]
//│ res: Vec[?, ?]


v1_tty = cons_ty 1 nil_ty
//│ v1_tty: Vec[?, ?]

v1_tty = cons_ty2 1 nil_ty
//│ v1_tty: Vec[?, ?]

v1_tty = cons_ty3 1 nil_ty
//│ v1_tty: Vec[?, ?]


v2 = cons 1 (cons 2 nil)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.265: 	v2 = cons 1 (cons 2 nil)
//│ ║         	             ^^^^^^^^^^
//│ ╟── application of type `Z` is not an instance of type `N`
//│ ║  l.44: 	def Nil = Nil { size = Z{} }
//│ ║        	                       ^^^
//│ ╟── Note: constraint arises from type alias type parameter:
//│ ║  l.21: 	type Vec[A, N] = forall 'r. (forall 'p. (Nil & { size: N } | Cons[A, S['p]] & Cons[A, N]) -> 'r) -> 'r
//│ ║        	            ^
//│ ╟── Note: class Z is defined at:
//│ ║  l.8: 	class Z
//│ ╙──     	      ^
//│ v2: ((forall 'a, 'tail, 'b, 'P. (Cons[nothing, 'P] with {tail: 'tail}
//│   where
//│     'a <: Vec[?, ?] & 'tail
//│     'b <: anything
//│     'a <: Vec[?, ?] & 'tail
//│     'b <: anything)) -> 'c) -> 'c


def impossible x = case x of {}
//│ impossible: nothing -> nothing

def head1 vec = vec (fun v -> case v of {
  | Nil -> impossible v.size
  | Cons -> v.head
  })
//│ head1: ((forall 'head. ((Cons[?, ?]\size\tail with {head: 'head}) | Nil & {size: nothing}) -> 'head) -> 'a) -> 'a

def head1_ty : Vec['a, S['p]] -> 'a
head1_ty = head1
//│ head1_ty: Vec[?, ?] -> nothing
//│ ((forall 'head. ((Cons[?, ?]\size\tail with {head: 'head}) | Nil & {size: nothing}) -> 'head) -> 'a) -> 'a
//│   <:  head1_ty:
//│ Vec[?, ?] -> nothing

// FIXME works without `:GeneralizeCurriedFunctions`!
def head2 (vec: Vec['a, S['p]]) = vec (fun v -> case v of {
  | Nil -> impossible v.size
  | Cons -> v.head
  })
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.303: 	def head2 (vec: Vec['a, S['p]]) = vec (fun v -> case v of {
//│ ║         	                                  ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.304: 	  | Nil -> impossible v.size
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.305: 	  | Cons -> v.head
//│ ║         	^^^^^^^^^^^^^^^^^^
//│ ║  l.306: 	  })
//│ ║         	^^^^
//│ ╟── expression of type `Z & N` does not match type `nothing`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.286: 	def impossible x = case x of {}
//│ ║         	                        ^
//│ ╟── from field selection:
//│ ║  l.304: 	  | Nil -> impossible v.size
//│ ╙──       	                      ^^^^^^
//│ head2: Vec[?, ?] -> error

head1 v1
head1 v2
//│ ╔══[ERROR] identifier not found: v1
//│ ║  l.325: 	head1 v1
//│ ╙──       	      ^^
//│ res: error
//│ res: nothing

:e
head1 nil
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.334: 	head1 nil
//│ ║         	^^^^^^^^^
//│ ╟── application of type `Z` does not match type `nothing`
//│ ║  l.44: 	def Nil = Nil { size = Z{} }
//│ ║        	                       ^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.286: 	def impossible x = case x of {}
//│ ║         	                        ^
//│ ╟── from field selection:
//│ ║  l.290: 	  | Nil -> impossible v.size
//│ ║         	                      ^^^^^^
//│ ╟── Note: class Z is defined at:
//│ ║  l.8: 	class Z
//│ ╙──     	      ^
//│ res: error


rec def sum vec = vec (fun v -> case v of {
  | Nil -> 0
  | Cons -> v.head + sum v.tail
  })
//│ sum: 'a -> 'b
//│   where
//│     'a <: (((Cons[?, ?]\size with {head: int, tail: 'a}) | Nil) -> int) -> (int & 'b)

def sum_ty : Vec[int, 'n] -> int
//│ sum_ty: Vec[?, ?] -> int

// FIXME should be a cycle error
sum_ty = sum
//│ 'a -> 'b
//│   where
//│     'a <: (((Cons[?, ?]\size with {head: int, tail: 'a}) | Nil) -> int) -> (int & 'b)
//│   <:  sum_ty:
//│ Vec[?, ?] -> int


sum nil
//│ res: int

sum v1_0
//│ res: error

sum v2
//│ res: int




// === === === ERROR CASES === === === //


:ShowRelativeLineNums
:AllowTypeErrors


def head1_ty v = case v of {
  | Nil -> impossible v.size
  | Cons -> v.head
  }
//│ ((Cons[?, ?]\size\tail with {head: 'head}) | Nil & {size: nothing}) -> 'head
//│   <:  head1_ty:
//│ Vec[?, ?] -> nothing
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.+1: 	def head1_ty v = case v of {
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.+2: 	  | Nil -> impossible v.size
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.+3: 	  | Cons -> v.head
//│ ║        	^^^^^^^^^^^^^^^^^^
//│ ║  l.+4: 	  }
//│ ║        	^^^
//│ ╟── type `(forall ?p. (Cons[?A, in ?N | S[?p] out S[?p] & ?N] | (Nil with {size: ?N})) -> ?r) -> ?r` does not match type `Cons[?, ?] & ?a | Nil & ?b`
//│ ║  l.21: 	type Vec[A, N] = forall 'r. (forall 'p. (Nil & { size: N } | Cons[A, S['p]] & Cons[A, N]) -> 'r) -> 'r
//│ ║        	                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.+1: 	def head1_ty v = case v of {
//│ ╙──      	                      ^


sum v1_ty
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	sum v1_ty
//│ ║        	^^^^^^^^^
//│ ╟── type `Cons[int, Z] with {tail: Vec[?, ?]}` is not a function
//│ ║  l.226: 	v1_ty = v1_ : Cons[int, Z]
//│ ║         	              ^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `(?a -> ?b) -> ?c`
//│ ║  l.+1: 	sum v1_ty
//│ ║        	    ^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.353: 	rec def sum vec = vec (fun v -> case v of {
//│ ║         	                  ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.354: 	  | Nil -> 0
//│ ║         	^^^^^^^^^^^^
//│ ║  l.355: 	  | Cons -> v.head + sum v.tail
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.356: 	  })
//│ ║         	^^^^
//│ ╟── from reference:
//│ ║  l.353: 	rec def sum vec = vec (fun v -> case v of {
//│ ╙──       	                  ^^^
//│ res: error


