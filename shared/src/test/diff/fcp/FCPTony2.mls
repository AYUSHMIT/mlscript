:GeneralizeCurriedFunctions
:ArgGen
:NoRecursiveTypes
:DistributeForalls

type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ Defined type alias ChurchInt

def zero f x = x
//│ zero: 'a -> (forall 'b. 'b -> 'b)
//│     = [Function: zero]

zero: ChurchInt
//│ res: ChurchInt
//│    = [Function: zero]

def succ: ChurchInt -> ChurchInt
def succ n f x = f (n f x)
//│ succ: ChurchInt -> ChurchInt
//│     = <missing implementation>
//│ ('a -> ('b -> 'c & 'd) & 'e) -> (forall 'f, 'g. ((forall 'h. 'h | 'c) -> 'f & 'a & 'g) -> (forall 'i, 'j. ('b & 'i) -> ('j | 'f)))
//│   <:  succ:
//│ ChurchInt -> ChurchInt
//│     = [Function: succ1]

// def to_church: int -> ChurchInt
rec def to_church n =
  if n == 0 then zero
  else succ (to_church (n - 1))
//│ to_church: (int & 'a) -> (forall 'b, 'c. 'b -> (forall 'd. 'd -> 'd) | ChurchInt | 'c)
//│          = [Function: to_church]

to_church: int -> ChurchInt
//│ res: int -> ChurchInt
//│    = [Function: to_church]

// def add: ChurchInt -> ChurchInt -> ChurchInt
def add n m = n succ m
//│ add: ((ChurchInt -> ChurchInt) -> ('a -> 'b & 'c) & 'd) -> (forall 'e, 'f. ('a & 'e) -> ('f | 'b))
//│    = [Function: add]

:e // * Since "sound extrusion"
add: ChurchInt -> ChurchInt -> ChurchInt
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.43: 	add: ChurchInt -> ChurchInt -> ChurchInt
//│ ║        	^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.6: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║       	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.6: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ╙──     	                        ^^
//│ res: ChurchInt -> ChurchInt -> ChurchInt
//│    = [Function: add]

// def mul: ChurchInt -> ChurchInt -> ChurchInt
def mul n m = n (add m) zero
//│ mul: ((forall 'a, 'b, 'c, 'd, 'e. ('a & 'b & 'f) -> ('d | 'c | 'g) | 'e) -> ((forall 'h. 'h -> (forall 'i. 'i -> 'i)) -> 'j & 'k) & 'l) -> (forall 'm, 'n, 'o, 'p, 'q. ((ChurchInt -> ChurchInt) -> (('q | 'f) -> ('g & 'm) & 'n) & 'o) -> ('p | 'j))
//│    = [Function: mul]

:e // fails since the fix to spurious-TV-cycles
mul: ChurchInt -> ChurchInt -> ChurchInt
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.62: 	mul: ChurchInt -> ChurchInt -> ChurchInt
//│ ║        	^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.6: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║       	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.6: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ╙──     	                        ^^
//│ res: ChurchInt -> ChurchInt -> ChurchInt
//│    = [Function: mul]

// def pow: ChurchInt -> ChurchInt -> ChurchInt
def pow n m = n (mul m) (succ zero)
//│ pow: ((forall 'a, 'b, 'c, 'd, 'e, 'f, 'g, 'h, 'i, 'j. ((ChurchInt -> (ChurchInt | 'j)) -> (('d | 'f | 'k) -> ('i & 'b & 'l) & 'g) & 'c) -> ('e | 'h | 'm) | 'a) -> ((forall 'j. ChurchInt | 'j) -> 'n & 'o) & 'p) -> (forall 'q, 'r, 's, 't, 'u, 'v. ((forall 'w, 'x, 'y, 'z, 'a1. ('k & 'x & 'w & 'u) -> ('z | 'y | 'r | 'l) | 'a1) -> ((forall 'b1. 'b1 -> (forall 'c1. 'c1 -> 'c1)) -> ('m & 't) & 'v) & 'q) -> ('s | 'n))
//│    = [Function: pow]

:e
pow: ChurchInt -> ChurchInt -> ChurchInt
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.81: 	pow: ChurchInt -> ChurchInt -> ChurchInt
//│ ║        	^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.6: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║       	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.6: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ╙──     	                        ^^
//│ res: ChurchInt -> ChurchInt -> ChurchInt
//│    = [Function: pow]

def unit = id
//│ unit: 'a -> 'a
//│     = [Function: unit]

type Unit_t = 'a -> 'a
unit : Unit_t
//│ Defined type alias Unit_t
//│ res: Unit_t
//│    = [Function: id]

def tru x _ = x unit
//│ tru: ((forall 'a. 'a -> 'a) -> 'b & 'c) -> (forall 'd, 'e. 'd -> ('e | 'b))
//│    = [Function: tru]

def fls _ x = x unit
//│ fls: 'a -> (forall 'b, 'c. ((forall 'd. 'd -> 'd) -> 'c & 'b) -> 'c)
//│    = [Function: fls]

type If_t = (Unit_t -> 'a) -> (Unit_t -> 'a) -> 'a
tru : If_t
fls : If_t
//│ Defined type alias If_t
//│ res: If_t
//│    = [Function: tru]
//│ res: If_t
//│    = [Function: fls]

def iszero n = n (fun _ -> fls) tru
//│ iszero: ((forall 'a. 'a -> (forall 'b. 'b -> (forall 'c, 'd. ((forall 'e. 'e -> 'e) -> 'c & 'd) -> 'c))) -> ((forall 'f, 'g. ((forall 'e. 'e -> 'e) -> 'f & 'g) -> (forall 'h, 'i. 'h -> ('i | 'f))) -> 'j & 'k) & 'l) -> 'j
//│       = [Function: iszero]

iszero : ChurchInt -> If_t
//│ res: ChurchInt -> If_t
//│    = [Function: iszero]

def pair x y f = f x y
//│ pair: 'a -> (forall 'b. 'b -> (forall 'c, 'd, 'e. ('a -> ('b -> 'c & 'd) & 'e) -> 'c))
//│     = [Function: pair]

def fst p = p (fun x -> fun _ -> x)
//│ fst: ((forall 'a. 'a -> (forall 'b. 'b -> 'a)) -> 'c & 'd) -> 'c
//│    = [Function: fst]

def snd p = p (fun _ -> fun x -> x)
//│ snd: ((forall 'a. 'a -> (forall 'b. 'b -> 'b)) -> 'c & 'd) -> 'c
//│    = [Function: snd]

def pred n =
  let s p = pair (snd p) (succ (snd p)) in
  let z = pair zero zero in
  fst (n s z)
//│ pred: ((forall 'a, 'b, 'c, 'd, 'e, 'f. ((forall 'g. 'g -> (forall 'h. 'h -> 'h)) -> ((nothing -> anything) -> anything -> nothing & 'c) & (forall 'g. 'g -> (forall 'h. 'h -> 'h)) -> 'b & 'a) -> (forall 'i, 'j, 'k. ((forall 'l. 'd | 'l | 'b) -> ((forall 'm. ChurchInt | 'f | 'm) -> 'i & 'j) & 'k) -> 'i | 'e)) -> ((forall 'n, 'o, 'p, 'q. ((forall 'r, 's, 't. 't -> (forall 'u. 'u -> 'u) | 'r | 's) -> ((forall 's, 't. 't -> (forall 'u. 'u -> 'u) | 's) -> 'n & 'o) & 'p) -> 'n | 'q) -> ((forall 'v. 'v -> (forall 'w. 'w -> 'v)) -> ('x & 'y) & 'z) & 'a1) & 'b1) -> 'y
//│     = [Function: pred]

:e // * Since "sound extrusion"
pred : ChurchInt -> ChurchInt
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.149: 	pred : ChurchInt -> ChurchInt
//│ ║         	^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.6: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║       	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.6: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ╙──     	                        ^^
//│ res: ChurchInt -> ChurchInt
//│    = [Function: pred]

:e
rec def fact (n: ChurchInt) = (iszero n) (fun _ -> succ zero) (fun _ -> mul n (fact (pred n)))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.163: 	rec def fact (n: ChurchInt) = (iszero n) (fun _ -> succ zero) (fun _ -> mul n (fact (pred n)))
//│ ║         	                                                                                     ^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.6: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║       	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.6: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ╙──     	                        ^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.163: 	rec def fact (n: ChurchInt) = (iszero n) (fun _ -> succ zero) (fun _ -> mul n (fact (pred n)))
//│ ║         	             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.6: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║       	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.6: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ╙──     	                        ^^
//│ fact: ChurchInt -> (forall 'a, 'b, 'c, 'd, 'e, 'f, 'g, 'h, 'i, 'j, 'k. 'k -> (forall 'l. 'l -> 'l) | ChurchInt | 'j | 'g | 'm | 'b | 'd | 'h | 'e | 'c | 'a | 'i | 'f)
//│   where
//│     'm :> forall 'k. 'k -> (forall 'l. 'l -> 'l)
//│     = [Function: fact]

:e
def fact (n: ChurchInt) = (iszero n) (fun _ -> succ zero) (fun _ -> mul n {})
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.188: 	def fact (n: ChurchInt) = (iszero n) (fun _ -> succ zero) (fun _ -> mul n {})
//│ ║         	                                                                    ^^^^^^^^
//│ ╟── record literal of type `anything` is not a function
//│ ║  l.188: 	def fact (n: ChurchInt) = (iszero n) (fun _ -> succ zero) (fun _ -> mul n {})
//│ ║         	                                                                          ^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.38: 	def add n m = n succ m
//│ ║        	              ^^^^^^
//│ ╟── from reference:
//│ ║  l.57: 	def mul n m = n (add m) zero
//│ ╙──      	                     ^
//│ fact: ChurchInt -> (forall 'a, 'b, 'c. error | ChurchInt | 'a | 'b | 'd | 'c | 'e)
//│     = [Function: fact1]

fact : ChurchInt -> ChurchInt
//│ res: ChurchInt -> ChurchInt
//│    = [Function: fact1]

:re
(fact (to_church 1)) (fun x -> x + 1) 0
//│ res: error | int | 'a
//│ Runtime error:
//│   TypeError: n is not a function

