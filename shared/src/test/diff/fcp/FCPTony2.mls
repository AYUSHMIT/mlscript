:GeneralizeCurriedFunctions
:ArgGen
:NoRecursiveTypes
:DistributeForalls

type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ Defined type alias ChurchInt

def zero f x = x
//│ zero: anything -> (forall 'a. 'a -> 'a)
//│     = [Function: zero]

zero: ChurchInt
//│ res: ChurchInt
//│    = [Function: zero]

def succ: ChurchInt -> ChurchInt
def succ n f x = f (n f x)
//│ succ: ChurchInt -> ChurchInt
//│     = <missing implementation>
//│ ('a -> 'b -> 'c) -> (forall 'd. ('c -> 'd & 'a) -> 'b -> 'd)
//│   <:  succ:
//│ ChurchInt -> ChurchInt
//│     = [Function: succ1]

// def to_church: int -> ChurchInt
rec def to_church n =
  if n == 0 then zero
  else succ (to_church (n - 1))
//│ to_church: int -> (anything -> (forall 'a. 'a -> 'a) | ChurchInt)
//│          = [Function: to_church]

to_church: int -> ChurchInt
//│ res: int -> ChurchInt
//│    = [Function: to_church]

// def add: ChurchInt -> ChurchInt -> ChurchInt
def add n m = n succ m
//│ add: ((ChurchInt -> ChurchInt) -> 'a -> 'b) -> 'a -> 'b
//│    = [Function: add]

:e // * Since "sound extrusion"
add: ChurchInt -> ChurchInt -> ChurchInt
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.43: 	add: ChurchInt -> ChurchInt -> ChurchInt
//│ ║        	^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.6: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║       	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.6: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ╙──     	                        ^^
//│ res: ChurchInt -> ChurchInt -> ChurchInt
//│    = [Function: add]

// def mul: ChurchInt -> ChurchInt -> ChurchInt
def mul n m = n (add m) zero
//│ mul: (('a -> 'b) -> (anything -> (forall 'c. 'c -> 'c)) -> 'd) -> ((ChurchInt -> ChurchInt) -> 'a -> 'b) -> 'd
//│    = [Function: mul]

:e // fails since the fix to spurious-TV-cycles
mul: ChurchInt -> ChurchInt -> ChurchInt
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.62: 	mul: ChurchInt -> ChurchInt -> ChurchInt
//│ ║        	^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.6: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║       	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.6: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ╙──     	                        ^^
//│ res: ChurchInt -> ChurchInt -> ChurchInt
//│    = [Function: mul]

// def pow: ChurchInt -> ChurchInt -> ChurchInt
def pow n m = n (mul m) (succ zero)
//│ pow: ((((ChurchInt -> ChurchInt) -> 'a -> 'b) -> 'c) -> ChurchInt -> 'd) -> (('a -> 'b) -> (anything -> (forall 'e. 'e -> 'e)) -> 'c) -> 'd
//│    = [Function: pow]

:e
pow: ChurchInt -> ChurchInt -> ChurchInt
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.81: 	pow: ChurchInt -> ChurchInt -> ChurchInt
//│ ║        	^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.6: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║       	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.6: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ╙──     	                        ^^
//│ res: ChurchInt -> ChurchInt -> ChurchInt
//│    = [Function: pow]

def unit = id
//│ unit: 'a -> 'a
//│     = [Function: unit]

type Unit_t = 'a -> 'a
unit : Unit_t
//│ Defined type alias Unit_t
//│ res: Unit_t
//│    = [Function: id]

def tru x _ = x unit
//│ tru: ((forall 'a. 'a -> 'a) -> 'b) -> anything -> 'b
//│    = [Function: tru]

def fls _ x = x unit
//│ fls: anything -> (forall 'a. ((forall 'b. 'b -> 'b) -> 'a) -> 'a)
//│    = [Function: fls]

type If_t = (Unit_t -> 'a) -> (Unit_t -> 'a) -> 'a
tru : If_t
fls : If_t
//│ Defined type alias If_t
//│ res: If_t
//│    = [Function: tru]
//│ res: If_t
//│    = [Function: fls]

def iszero n = n (fun _ -> fls) tru
//│ iszero: ((anything -> anything -> (forall 'a. ((forall 'b. 'b -> 'b) -> 'a) -> 'a)) -> (forall 'c. ((forall 'b. 'b -> 'b) -> 'c) -> anything -> 'c) -> 'd) -> 'd
//│       = [Function: iszero]

iszero : ChurchInt -> If_t
//│ res: ChurchInt -> If_t
//│    = [Function: iszero]

def pair x y f = f x y
//│ pair: 'a -> (forall 'b. 'b -> (forall 'c. ('a -> 'b -> 'c) -> 'c))
//│     = [Function: pair]

def fst p = p (fun x -> fun _ -> x)
//│ fst: ((forall 'a. 'a -> anything -> 'a) -> 'b) -> 'b
//│    = [Function: fst]

def snd p = p (fun _ -> fun x -> x)
//│ snd: ((anything -> (forall 'a. 'a -> 'a)) -> 'b) -> 'b
//│    = [Function: snd]

def pred n =
  let s p = pair (snd p) (succ (snd p)) in
  let z = pair zero zero in
  fst (n s z)
//│ pred: ((forall 'a. ((anything -> (forall 'b. 'b -> 'b)) -> (nothing -> anything) -> anything -> nothing & (anything -> (forall 'b. 'b -> 'b)) -> 'a) -> (forall 'c. ('a -> ChurchInt -> 'c) -> 'c)) -> (forall 'd. ((anything -> (forall 'e. 'e -> 'e)) -> (anything -> (forall 'e. 'e -> 'e)) -> 'd) -> 'd) -> (forall 'f. 'f -> anything -> 'f) -> 'g) -> 'g
//│     = [Function: pred]

:e // * Since "sound extrusion"
pred : ChurchInt -> ChurchInt
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.149: 	pred : ChurchInt -> ChurchInt
//│ ║         	^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.6: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║       	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.6: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ╙──     	                        ^^
//│ res: ChurchInt -> ChurchInt
//│    = [Function: pred]

:e
rec def fact (n: ChurchInt) = (iszero n) (fun _ -> succ zero) (fun _ -> mul n (fact (pred n)))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.163: 	rec def fact (n: ChurchInt) = (iszero n) (fun _ -> succ zero) (fun _ -> mul n (fact (pred n)))
//│ ║         	                                                                                     ^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.6: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║       	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.6: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ╙──     	                        ^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.163: 	rec def fact (n: ChurchInt) = (iszero n) (fun _ -> succ zero) (fun _ -> mul n (fact (pred n)))
//│ ║         	             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.6: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║       	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.6: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ╙──     	                        ^^
//│ fact: ChurchInt -> (ChurchInt | anything -> (forall 'a. 'a -> 'a))
//│     = [Function: fact]

:e
def fact (n: ChurchInt) = (iszero n) (fun _ -> succ zero) (fun _ -> mul n {})
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.186: 	def fact (n: ChurchInt) = (iszero n) (fun _ -> succ zero) (fun _ -> mul n {})
//│ ║         	                                                                    ^^^^^^^^
//│ ╟── record literal of type `anything` is not a function
//│ ║  l.186: 	def fact (n: ChurchInt) = (iszero n) (fun _ -> succ zero) (fun _ -> mul n {})
//│ ║         	                                                                          ^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.38: 	def add n m = n succ m
//│ ║        	              ^^^^^^
//│ ╟── from reference:
//│ ║  l.57: 	def mul n m = n (add m) zero
//│ ╙──      	                     ^
//│ fact: ChurchInt -> (error | ChurchInt)
//│     = [Function: fact1]

fact : ChurchInt -> ChurchInt
//│ res: ChurchInt -> ChurchInt
//│    = [Function: fact1]

:re
(fact (to_church 1)) (fun x -> x + 1) 0
//│ res: error | int
//│ Runtime error:
//│   TypeError: n is not a function

