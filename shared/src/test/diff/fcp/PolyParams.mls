:NoRecursiveTypes
:GeneralizeCurriedFunctions


// def foo(f: forall 'a. 'a -> 'a) =
//   (f 1, f true)
// //│ foo: (forall 'a. 'a -> 'a) -> (forall 'b, 'c, 'd. (('c, 'd,)
// //│   where
// //│     'b <: 1 -> 'c & true -> 'd))
// //│    = [Function: foo]

// fooid = foo id
// //│ fooid: ('a, 'b,)
// //│   where
// //│     'c <: 1 -> 'a & true -> 'b
// //│      = [ 1, true ]

// fooid._1
// fooid._2
// //│ res: 1
// //│    = undefined
// //│ res: true
// //│    = undefined

// def foo(f: (forall 'A. 'A -> 'A) -> (forall 'B. 'B -> 'B)) =
//   id f id (f id)
// //│ foo: ((forall 'A. 'A -> 'A) -> (forall 'B. 'B -> 'B)) -> (forall 'a. ('b
// //│   where
// //│     'a <: (forall 'c. 'c -> 'c) -> 'd -> 'b & (forall 'c. 'c -> 'c) -> 'd))
// //│    = [Function: foo1]

// foo id
// //│ res: 'a
// //│   where
// //│     'b <: (forall 'c. 'c -> 'c) -> 'd -> 'a & (forall 'c. 'c -> 'c) -> 'd
// //│    = [Function: id]

// foo id id



class Ls[A] method Head: A
def cons: ('a, Ls['a]) -> Ls['a]
def nil: Ls['a]
def single: 'a -> Ls['a]
//│ Defined class Ls[+A]
//│ Declared Ls.Head: Ls['A] -> 'A
//│ cons: ('a, Ls['a],) -> Ls['a]
//│     = <missing implementation>
//│ nil: Ls[nothing]
//│    = <missing implementation>
//│ single: 'a -> Ls['a]
//│       = <missing implementation>


// def build0 (g: forall 'b. ('a -> 'b) -> 'b) = g single
// //│ build0: (forall 'b. (anything -> 'b) -> 'b) -> (forall 'c. ('d
// //│   where
// //│     'c <: (forall 'a. 'a -> Ls['a]) -> 'd))
// //│       = <no result>
// //│         single is not implemented

// build0 (fun s -> s 1)
// //│ res: 'b
// //│   where
// //│     'c <: (forall 'a. 'a -> Ls['a]) -> 'b
// //│    = <no result>
// //│      build0 and single are not implemented

// res: Ls[int]
// //│ res: Ls[int]
// //│    = [Function: id]


// def build0 (g: forall 'b. ('a -> 'b) -> 'b) = g (fun x -> single ((x,x)))
// //│ build0: (forall 'b. (anything -> 'b) -> 'b) -> (forall 'a, 'c. ('c
// //│   where
// //│     'a <: (forall 'd. 'd -> Ls[('d, 'd,)]) -> 'c))
// //│       = <no result>
// //│         single is not implemented

// // def build0 (g: forall 'b. ('a -> 'a -> 'b) -> 'b) = g (fun x -> fun y -> single ((x,y)))

// def build0 (g: forall 'b. ('a -> 'b -> 'b) -> 'b) = g (fun x -> fun y -> single ((x,y)))
// //│ build0: (forall 'b. (anything -> 'b -> 'b) -> 'b) -> (forall 'a, 'c. ('c
// //│   where
// //│     'a <: (forall 'd. 'd -> (forall 'e. 'e -> Ls[('d, 'e,)])) -> 'c))
// //│       = <no result>
// //│         single is not implemented


// def build0 (g: forall 'b. (('a, 'b) -> 'b) -> 'b) = g cons

// :d
// def build0 (g: forall 'b. (('a, 'b) -> 'b) -> 'b) = g (fun (x, xs) -> cons (x, xs))

// def g: forall 'b. (('a, 'b) -> 'b) -> 'b
// def g: (('a, 'b) -> 'b) -> 'b
def g: ((int, 'b) -> 'b) -> 'b
def g: ((int, 'b) -> 'b) -> anything
// def g: (('a, {x:'a}) -> {x:'a}) -> {x:'a}
//│ g: ((int, 'b,) -> 'b) -> 'b
//│  = <missing implementation>
//│ g: ((int, 'b,) -> 'b) -> anything
//│  = <missing implementation>

// g (fun (x, xs) -> cons (x, xs))

def cons: ('a, {x:'a}) -> {x:'a}
// def cons: ('a, 'a) -> 'a
//│ cons: ('a, {x: 'a},) -> {x: 'a}
//│     = <missing implementation>

f (x, xs) = cons (x, xs)
//│ f: ('b, 'c,) -> (forall 'b, 'c, 'a. ({x: 'a | 'b}
//│   where
//│     'c <: {x: 'a}))
//│  = <no result>
//│    cons is not implemented

:d
g f
//│ 0. Typing term (g (f,))   None
//│ | 0. Typing term g   None
//│ | 0. : ‹∀ 0. (((Int, 'b41',) -> 'b41') -> Anything)›
//│ | 0. Typing term f   None
//│ | 0. : ‹∀ 0. ‹∀ 1. ((α49'', α50'',) -> ‹∀ 2. {α51''' where: α50'' <: {x: 'a45_52'''}}›)››
//│ | CONSTRAIN ‹∀ 0. (((Int, 'b41',) -> 'b41') -> Anything)› <! (‹∀ 0. ‹∀ 1. ((α49'', α50'',) -> ‹∀ 2. {α51''' where: α50'' <: {x: 'a45_52'''}}›)›› -> α63)
//│ |   where 
//│ 		α51''' :> {x: 'a45_52'''}
//│ 		'a45_52''' :> α49''
//│ | 0. C ‹∀ 0. (((Int, 'b41',) -> 'b41') -> Anything)› <! (‹∀ 0. ‹∀ 1. ((α49'', α50'',) -> ‹∀ 2. {α51''' where: α50'' <: {x: 'a45_52'''}}›)›› -> α63)
//│ | | INST [0]   ‹∀ 0. (((Int, 'b41',) -> 'b41') -> Anything)›
//│ | |   where  
//│ | | TO [0] ~>  (((Int, 'b41_64,) -> 'b41_64) -> Anything)
//│ | |   where  
//│ | | 0. C (((Int, 'b41_64,) -> 'b41_64) -> Anything) <! (‹∀ 0. ‹∀ 1. ((α49'', α50'',) -> ‹∀ 2. {α51''' where: α50'' <: {x: 'a45_52'''}}›)›› -> α63)
//│ | | | 0. C (‹∀ 0. ‹∀ 1. ((α49'', α50'',) -> ‹∀ 2. {α51''' where: α50'' <: {x: 'a45_52'''}}›)››,) <! (((Int, 'b41_64,) -> 'b41_64),)
//│ | | | | 0. C ‹∀ 0. ‹∀ 1. ((α49'', α50'',) -> ‹∀ 2. {α51''' where: α50'' <: {x: 'a45_52'''}}›)›› <! ((Int, 'b41_64,) -> 'b41_64)
//│ | | | | | 0. C ‹∀ 1. ((α49'', α50'',) -> ‹∀ 2. {α51''' where: α50'' <: {x: 'a45_52'''}}›)› <! ((Int, 'b41_64,) -> 'b41_64)
//│ | | | | | | INST [1]   ‹∀ 1. ((α49'', α50'',) -> ‹∀ 2. {α51''' where: α50'' <: {x: 'a45_52'''}}›)›
//│ | | | | | |   where  
//│ 		α51''' :> {x: 'a45_52'''}
//│ 		'a45_52''' :> α49''
//│ | | | | | | TO [0] ~>  ((α49_65, α50_66,) -> ‹∀ 2. {α51_68''' where: α50_66 <: {x: 'a45_67'''}}›)
//│ | | | | | |   where  
//│ 		'a45_67''' :> α49_65
//│ 		α51_68''' :> {x: 'a45_67'''}
//│ | | | | | | 0. C ((α49_65, α50_66,) -> ‹∀ 2. {α51_68''' where: α50_66 <: {x: 'a45_67'''}}›) <! ((Int, 'b41_64,) -> 'b41_64)
//│ | | | | | | | 0. C (Int, 'b41_64,) <! (α49_65, α50_66,)
//│ | | | | | | | | 0. C Int <! α49_65
//│ | | | | | | | | | NEW α49_65 LB (0)
//│ | | | | | | | | 0. C 'b41_64 <! α50_66
//│ | | | | | | | | | 0. C 'b41_64 <! α50_66
//│ | | | | | | | | | | NEW 'b41_64 UB (0)
//│ | | | | | | | 0. C ‹∀ 2. {α51_68''' where: α50_66 <: {x: 'a45_67'''}}› <! 'b41_64
//│ | | | | | | | | 0. C ‹∀ 2. {α51_68''' where: α50_66 <: {x: 'a45_67'''}}› <! 'b41_64
//│ | | | | | | | | | NEW 'b41_64 LB (0)
//│ | | | | | | | | | 0. C ‹∀ 2. {α51_68''' where: α50_66 <: {x: 'a45_67'''}}› <! α50_66
//│ | | | | | | | | | | NEW α50_66 LB (0)
//│ | | | 0. C Anything <! α63
//│ | | | | NEW α63 LB (0)
//│ 0. : α63
//│ ⬤ Typed as: ‹∀ 0. α63›
//│  where: 
//│ 		α63 :> Anything
//│ res: anything
//│    = <no result>
//│      g is not implemented




// def build0 (g: forall 'b. ('a -> 'b -> 'b) -> 'b) = g (fun x -> fun xs -> cons (x, xs))


// def build = fun (g: forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> g (fun x -> fun xs -> cons (x, xs)) nil





