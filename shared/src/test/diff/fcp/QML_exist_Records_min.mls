// * This is a minimization of the error that happens in `QML_exist_Records`
// * when we don't annotate `arrImpl` in `stepImpl`.

:NoRecursiveTypes



type ArraysImpl = { fold: forall 'b. 'b -> 'b }
//│ Defined type alias ArraysImpl

type ArraysImplConsumer[R] = ArraysImpl -> R
//│ Defined type alias ArraysImplConsumer[+R]

type Arrays = (ArraysImpl -> 'r) -> 'r
//│ Defined type alias Arrays


def stepImpl (arrImpl: ArraysImpl) = { fold = fun f -> arrImpl.fold f }
//│ stepImpl: ArraysImpl -> {fold: forall 'a. 'a -> 'a}
//│         = [Function: stepImpl]

def stepImpl_noAnn arrImpl = { fold = fun f -> arrImpl.fold f }
//│ stepImpl_noAnn: {fold: 'a -> 'b} -> {fold: 'a -> 'b}
//│               = [Function: stepImpl_noAnn]


def step2: Arrays -> Arrays
//│ step2: Arrays -> Arrays
//│      = <missing implementation>


def step2 arr k = k (arr stepImpl)
//│ ((ArraysImpl -> {fold: forall 'a. 'a -> 'a}) -> 'b) -> ('b -> 'c) -> 'c
//│   <:  step2:
//│ Arrays -> Arrays
//│      = [Function: step2]

def step2 arr (k: ArraysImplConsumer['rep]) = k (arr stepImpl)
//│ ((ArraysImpl -> {fold: forall 'a. 'a -> 'a}) -> ArraysImpl) -> ArraysImplConsumer['b] -> 'b
//│   <:  step2:
//│ Arrays -> Arrays
//│      = [Function: step21]

def step2 (arr: Arrays) k = k (arr stepImpl)
//│ Arrays -> ({fold: forall 'a. 'a -> 'a} -> 'b) -> 'b
//│   <:  step2:
//│ Arrays -> Arrays
//│      = [Function: step22]

// * Using `stepImpl_noAnn` fails to work, as expected:

:e
def step2 arr k = k (arr stepImpl_noAnn)
//│ ((forall 'a 'b. {fold: 'a -> 'b} -> {fold: 'a -> 'b}) -> 'c) -> ('c -> 'd) -> 'd
//│   <:  step2:
//│ Arrays -> Arrays
//│ ╔══[ERROR] Type error in def definition
//│ ║  l.53: 	def step2 arr k = k (arr stepImpl_noAnn)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type variable `'b` leaks out of its scope
//│ ║  l.8: 	type ArraysImpl = { fold: forall 'b. 'b -> 'b }
//│ ║       	                                     ^^
//│ ╟── back into type variable `'b`
//│ ║  l.8: 	type ArraysImpl = { fold: forall 'b. 'b -> 'b }
//│ ║       	                                           ^^
//│ ╟── adding a type annotation to any of the following terms may help resolve the problem
//│ ╟── • this applied expression:
//│ ║  l.53: 	def step2 arr k = k (arr stepImpl_noAnn)
//│ ║        	                  ^
//│ ╟── • this application:
//│ ║  l.53: 	def step2 arr k = k (arr stepImpl_noAnn)
//│ ║        	                     ^^^^^^^^^^^^^^^^^^
//│ ╟── • this application:
//│ ║  l.22: 	def stepImpl_noAnn arrImpl = { fold = fun f -> arrImpl.fold f }
//│ ╙──      	                                               ^^^^^^^^^^^^^^
//│      = [Function: step23]

:e
def step2 arr (k: ArraysImplConsumer['rep]) = k (arr stepImpl_noAnn)
//│ ((forall 'a 'b. {fold: 'a -> 'b} -> {fold: 'a -> 'b}) -> ArraysImpl) -> ArraysImplConsumer['c] -> 'c
//│   <:  step2:
//│ Arrays -> Arrays
//│ ╔══[ERROR] Type error in def definition
//│ ║  l.79: 	def step2 arr (k: ArraysImplConsumer['rep]) = k (arr stepImpl_noAnn)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type variable `'b` leaks out of its scope
//│ ║  l.8: 	type ArraysImpl = { fold: forall 'b. 'b -> 'b }
//│ ║       	                                     ^^
//│ ╟── back into type variable `'b`
//│ ║  l.8: 	type ArraysImpl = { fold: forall 'b. 'b -> 'b }
//│ ║       	                                           ^^
//│ ╟── adding a type annotation to any of the following terms may help resolve the problem
//│ ╟── • this applied expression:
//│ ║  l.79: 	def step2 arr (k: ArraysImplConsumer['rep]) = k (arr stepImpl_noAnn)
//│ ║        	                                                 ^^^
//│ ╟── • this application:
//│ ║  l.22: 	def stepImpl_noAnn arrImpl = { fold = fun f -> arrImpl.fold f }
//│ ╙──      	                                               ^^^^^^^^^^^^^^
//│      = [Function: step24]

:e
def step2 (arr: Arrays) k = k (arr stepImpl_noAnn)
//│ Arrays -> ({fold: 'a -> 'a} -> 'b) -> 'b
//│   <:  step2:
//│ Arrays -> Arrays
//│ ╔══[ERROR] Type error in def definition
//│ ║  l.102: 	def step2 (arr: Arrays) k = k (arr stepImpl_noAnn)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type variable `'b` leaks out of its scope
//│ ║  l.8: 	type ArraysImpl = { fold: forall 'b. 'b -> 'b }
//│ ║       	                                     ^^
//│ ╟── back into type variable `'b`
//│ ║  l.8: 	type ArraysImpl = { fold: forall 'b. 'b -> 'b }
//│ ║       	                                           ^^
//│ ╟── adding a type annotation to any of the following terms may help resolve the problem
//│ ╟── • this applied expression:
//│ ║  l.102: 	def step2 (arr: Arrays) k = k (arr stepImpl_noAnn)
//│ ║         	                            ^
//│ ╟── • this application:
//│ ║  l.102: 	def step2 (arr: Arrays) k = k (arr stepImpl_noAnn)
//│ ║         	                               ^^^^^^^^^^^^^^^^^^
//│ ╟── • this application:
//│ ║  l.22: 	def stepImpl_noAnn arrImpl = { fold = fun f -> arrImpl.fold f }
//│ ╙──      	                                               ^^^^^^^^^^^^^^
//│      = [Function: step25]



// * A slight variation with `:ConstrainedTypes`, because why not:

:ConstrainedTypes


type ArraysImpl2[Rep] = { fold: forall 'b. 'b -> Rep -> 'b }
//│ Defined type alias ArraysImpl2[-Rep]

type Arrays2 = (forall 'Rep. ArraysImpl2['Rep] -> 'r) -> 'r
//│ Defined type alias Arrays2

def stepImpl arrImpl = { fold = fun f -> fun r0 -> arrImpl.fold f r0 }
//│ stepImpl: 'a -> {fold: forall 'b 'c 'd. 'b -> ('c -> 'd
//│   where
//│     'a <: {fold: 'b -> 'c -> 'd})}
//│         = [Function: stepImpl1]


def step: Arrays2 -> Arrays2
//│ step: Arrays2 -> Arrays2
//│     = <missing implementation>

:e
def step arr k = k (arr stepImpl)
//│ 'a -> (('b -> 'c) -> 'c
//│   where
//│     'a <: (forall 'd. 'd -> {fold: forall 'e 'f 'g. 'e -> ('f -> 'g
//│   where
//│     'd <: {fold: 'e -> 'f -> 'g})}) -> 'b)
//│   <:  step:
//│ Arrays2 -> Arrays2
//│ ╔══[ERROR] Type error in def definition
//│ ║  l.152: 	def step arr k = k (arr stepImpl)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type variable `'b` leaks out of its scope
//│ ║  l.134: 	type ArraysImpl2[Rep] = { fold: forall 'b. 'b -> Rep -> 'b }
//│ ║         	                                           ^^
//│ ╟── back into type variable `'b`
//│ ║  l.134: 	type ArraysImpl2[Rep] = { fold: forall 'b. 'b -> Rep -> 'b }
//│ ║         	                                                        ^^
//│ ╟── adding a type annotation to any of the following terms may help resolve the problem
//│ ╟── • this function:
//│ ║  l.140: 	def stepImpl arrImpl = { fold = fun f -> fun r0 -> arrImpl.fold f r0 }
//│ ║         	                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── • this application:
//│ ║  l.152: 	def step arr k = k (arr stepImpl)
//│ ║         	                    ^^^^^^^^^^^^
//│ ╟── • this applied expression:
//│ ║  l.152: 	def step arr k = k (arr stepImpl)
//│ ║         	                 ^
//│ ╟── Note: constraint arises from application:
//│ ║  l.140: 	def stepImpl arrImpl = { fold = fun f -> fun r0 -> arrImpl.fold f r0 }
//│ ╙──       	                                                   ^^^^^^^^^^^^^^^^^
//│     = [Function: step]


