:NoRecursiveTypes
:GeneralizeCurriedFunctions
:ConstrainedTypes // * The test takes too much time without this

// * Perfect Trees (https://www.cis.upenn.edu/~plclub/blog/2020-12-04-nested-datatypes/)

// data NTree (a :: Type) =
//     NLeaf a
//   | NNode (NTree (Two a))


type Two[A] = (A, A)
//│ Defined type alias Two[+A]

def mapTwo f ((a, b)) = (f a, f b)
//│ mapTwo: 'a -> (('b, 'c,) -> ('d, 'e,)
//│   where
//│     'a <: 'b -> 'd & 'c -> 'e)
//│       = [Function: mapTwo]

class Leaf[A]: { value: A }
//│ Defined class Leaf[+A]

:e
class Node[A]: { subTree: PerfectTree[Two[A]] }
type PerfectTree[A] = Leaf[A] | Node[A]
//│ ╔══[ERROR] Type definition is not regular: it occurs within itself as Node[Two['A]], but is defined as Node['A]
//│ ║  l.25: 	class Node[A]: { subTree: PerfectTree[Two[A]] }
//│ ╙──      	      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type definition is not regular: it occurs within itself as PerfectTree[Two['A]], but is defined as PerfectTree['A]
//│ ║  l.26: 	type PerfectTree[A] = Leaf[A] | Node[A]
//│ ╙──      	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

:IrregularTypes

class Node[A]: { subTree: PerfectTree[Two[A]] }
type PerfectTree[A] = Leaf[A] | Node[A]
//│ Defined class Node[+A]
//│ Defined type alias PerfectTree[+A]


n1 = Leaf { value = 1 }
//│ n1: Leaf[1]
//│   = Leaf { value: 1 }
n1: PerfectTree[int]
//│ res: PerfectTree[int]
//│    = Leaf { value: 1 }

n2 = Node { subTree = Leaf { value = (1, 2) } }
//│ n2: Node[1 | 2] with {subTree: Leaf[(1, 2,)]}
//│   = Node1 { subTree: Leaf { value: [ 1, 2 ] } }
n2: PerfectTree[int]
//│ res: PerfectTree[int]
//│    = Node1 { subTree: Leaf { value: [ 1, 2 ] } }

n4 = Node { subTree = Node { subTree = Leaf { value = ((1, 2), (3, 4)) } } }
//│ n4: Node[1 | 2 | 3 | 4] with {subTree: Node[(1 | 3, 2 | 4,)] with {subTree: Leaf[((1, 2,), (3, 4,),)]}}
//│   = Node1 { subTree: Node1 { subTree: Leaf { value: [Array] } } }
n4: PerfectTree[int]
//│ res: PerfectTree[int]
//│    = Node1 { subTree: Node1 { subTree: Leaf { value: [Array] } } }


// * Works since the removal of "recursive definition hacks"
rec def map f tree = case tree of {
  | Leaf -> Leaf { value = f tree.value }
  | Node -> Node { subTree = map (mapTwo f) tree.subTree }
  }
//│ map: 'map
//│   where
//│     'map :> forall 'subTree, 'value, 'value0, 'a, 'subTree0, 'A. 'a -> (((Leaf[?] with {value: 'value0}) | (Node[?] with {subTree: 'subTree})) -> (Leaf['value] | (Node['A] with {subTree: 'subTree0}))
//│   where
//│     'a <: 'value0 -> 'value
//│     'map <: (forall 'b, 'c, 'd, 'e. (('c, 'e,) -> ('d, 'b,)
//│   where
//│     'a <: 'c -> 'd & 'e -> 'b)) -> 'subTree -> (PerfectTree[Two['A]] & 'subTree0))
//│    = [Function: map]

:e
map succ n4
//│ ╔══[ERROR] Subtyping constraint of the form `?a <: (forall ?value, ?A, ?subTree, ?subTree0, ?b, ?A0, ?A1. ?b) -> ?c` exceeded recursion depth limit (250)
//│ ║  l.80: 	map succ n4
//│ ║        	^^^^^^^^^^^
//│ ╟── while constraining:  ‹∀ 1. (α132_264'' -> ‹∀ 2. {(α133_280''' -> (α137_283''' | α154_284''')) where: map131_263# <: ((α141_265''',) -> α151_271'''), α132_264'' <: ((value135_276''',) -> α136_277''')}›)›  <!<  ((α141_1414,) -> α151_1420)
//│ ╟── while constraining:  map131_263#  <!<  ((α141_1414,) -> α151_1420)
//│ ╟── while constraining:  {(α133_1429 -> (α137_1432 | α154_1433)) where: map131_263# <: ((α141_1414,) -> α151_1420), α132_1393 <: ((value135_1425,) -> α136_1426)}  <!<  ((subTree152_1380,) -> α153_1381)
//│ ╟── while constraining:  ‹∀ 2. {(α133_1409''' -> (α137_1412''' | α154_1413''')) where: map131_263# <: ((α141_1394''',) -> α151_1400'''), α132_1393 <: ((value135_1405''',) -> α136_1406''')}›  <!<  ((subTree152_1380,) -> α153_1381)
//│ ╟── while constraining:  ‹∀ 2. {(α133_1409''' -> (α137_1412''' | α154_1413''')) where: map131_263# <: ((α141_1394''',) -> α151_1400'''), α132_1393 <: ((value135_1405''',) -> α136_1406''')}›  <!<  α151_1379
//│ ╟── while constraining:  (α132_1393 -> ‹∀ 2. {(α133_1409''' -> (α137_1412''' | α154_1413''')) where: map131_263# <: ((α141_1394''',) -> α151_1400'''), α132_1393 <: ((value135_1405''',) -> α136_1406''')}›)  <!<  ((α141_1373,) -> α151_1379)
//│ ╟── while constraining:  ‹∀ 1. (α132_264'' -> ‹∀ 2. {(α133_280''' -> (α137_283''' | α154_284''')) where: map131_263# <: ((α141_265''',) -> α151_271'''), α132_264'' <: ((value135_276''',) -> α136_277''')}›)›  <!<  ((α141_1373,) -> α151_1379)
//│ ╟── while constraining:  map131_263#  <!<  ((α141_1373,) -> α151_1379)
//│ ╟── while constraining:  {(α133_1388 -> (α137_1391 | α154_1392)) where: map131_263# <: ((α141_1373,) -> α151_1379), α132_1352 <: ((value135_1384,) -> α136_1385)}  <!<  ((subTree152_1339,) -> α153_1340)
//│ ╟── while constraining:  ‹∀ 2. {(α133_1368''' -> (α137_1371''' | α154_1372''')) where: map131_263# <: ((α141_1353''',) -> α151_1359'''), α132_1352 <: ((value135_1364''',) -> α136_1365''')}›  <!<  ((subTree152_1339,) -> α153_1340)
//│ ╟── while constraining:  ‹∀ 2. {(α133_1368''' -> (α137_1371''' | α154_1372''')) where: map131_263# <: ((α141_1353''',) -> α151_1359'''), α132_1352 <: ((value135_1364''',) -> α136_1365''')}›  <!<  α151_1338
//│ ╟── while constraining:  (α132_1352 -> ‹∀ 2. {(α133_1368''' -> (α137_1371''' | α154_1372''')) where: map131_263# <: ((α141_1353''',) -> α151_1359'''), α132_1352 <: ((value135_1364''',) -> α136_1365''')}›)  <!<  ((α141_1332,) -> α151_1338)
//│ ╟── while constraining:  ‹∀ 1. (α132_264'' -> ‹∀ 2. {(α133_280''' -> (α137_283''' | α154_284''')) where: map131_263# <: ((α141_265''',) -> α151_271'''), α132_264'' <: ((value135_276''',) -> α136_277''')}›)›  <!<  ((α141_1332,) -> α151_1338)
//│ ╟── while constraining:  map131_263#  <!<  ((α141_1332,) -> α151_1338)
//│ ╟── while constraining:  {(α133_1347 -> (α137_1350 | α154_1351)) where: map131_263# <: ((α141_1332,) -> α151_1338), α132_1311 <: ((value135_1343,) -> α136_1344)}  <!<  ((subTree152_1298,) -> α153_1299)
//│ ╟── ......
//│ ╟── ......
//│ ╟── while constraining:  {(α133_404 -> (α137_407 | α154_408)) where: map131_263# <: ((α141_389,) -> α151_395), α132_368 <: ((value135_400,) -> α136_401)}  <!<  ((subTree152_355,) -> α153_356)
//│ ╟── while constraining:  ‹∀ 2. {(α133_384''' -> (α137_387''' | α154_388''')) where: map131_263# <: ((α141_369''',) -> α151_375'''), α132_368 <: ((value135_380''',) -> α136_381''')}›  <!<  ((subTree152_355,) -> α153_356)
//│ ╟── while constraining:  ‹∀ 2. {(α133_384''' -> (α137_387''' | α154_388''')) where: map131_263# <: ((α141_369''',) -> α151_375'''), α132_368 <: ((value135_380''',) -> α136_381''')}›  <!<  α151_354
//│ ╟── while constraining:  (α132_368 -> ‹∀ 2. {(α133_384''' -> (α137_387''' | α154_388''')) where: map131_263# <: ((α141_369''',) -> α151_375'''), α132_368 <: ((value135_380''',) -> α136_381''')}›)  <!<  ((α141_348,) -> α151_354)
//│ ╟── while constraining:  ‹∀ 1. (α132_264'' -> ‹∀ 2. {(α133_280''' -> (α137_283''' | α154_284''')) where: map131_263# <: ((α141_265''',) -> α151_271'''), α132_264'' <: ((value135_276''',) -> α136_277''')}›)›  <!<  ((α141_348,) -> α151_354)
//│ ╟── while constraining:  map131_263#  <!<  ((α141_348,) -> α151_354)
//│ ╟── while constraining:  {(α133_363 -> (α137_366 | α154_367)) where: map131_263# <: ((α141_348,) -> α151_354), α132_327 <: ((value135_359,) -> α136_360)}  <!<  ((subTree152_314,) -> α153_315)
//│ ╟── while constraining:  ‹∀ 2. {(α133_343''' -> (α137_346''' | α154_347''')) where: map131_263# <: ((α141_328''',) -> α151_334'''), α132_327 <: ((value135_339''',) -> α136_340''')}›  <!<  ((subTree152_314,) -> α153_315)
//│ ╟── while constraining:  ‹∀ 2. {(α133_343''' -> (α137_346''' | α154_347''')) where: map131_263# <: ((α141_328''',) -> α151_334'''), α132_327 <: ((value135_339''',) -> α136_340''')}›  <!<  α151_313
//│ ╟── while constraining:  (α132_327 -> ‹∀ 2. {(α133_343''' -> (α137_346''' | α154_347''')) where: map131_263# <: ((α141_328''',) -> α151_334'''), α132_327 <: ((value135_339''',) -> α136_340''')}›)  <!<  ((α141_307,) -> α151_313)
//│ ╟── while constraining:  ‹∀ 1. (α132_264'' -> ‹∀ 2. {(α133_280''' -> (α137_283''' | α154_284''')) where: map131_263# <: ((α141_265''',) -> α151_271'''), α132_264'' <: ((value135_276''',) -> α136_277''')}›)›  <!<  ((α141_307,) -> α151_313)
//│ ╟── while constraining:  map131_263#  <!<  ((α141_307,) -> α151_313)
//│ ╟── while constraining:  {(α133_322 -> (α137_325 | α154_326)) where: map131_263# <: ((α141_307,) -> α151_313), α132_285 <: ((value135_318,) -> α136_319)}  <!<  ((‹∀ 0. α114'›,) -> α306)
//│ ╟── while constraining:  ‹∀ 2. {(α133_301''' -> (α137_304''' | α154_305''')) where: map131_263# <: ((α141_286''',) -> α151_292'''), α132_285 <: ((value135_297''',) -> α136_298''')}›  <!<  ((‹∀ 0. α114'›,) -> α306)
//│ ╙── while constraining:  α262  <!<  ((‹∀ 0. α114'›,) -> α306)
//│ res: error
//│    = Node1 { subTree: Node1 { subTree: Leaf { value: [Array] } } }


def map: ('a -> 'b) -> PerfectTree['a] -> PerfectTree['b]
//│ map: ('a -> 'b) -> PerfectTree['a] -> PerfectTree['b]
//│    = <missing implementation>

def map f tree = case tree of {
  | Leaf -> Leaf { value = f tree.value }
  | Node -> Node { subTree = map (mapTwo f) tree.subTree }
  }
//│ 'a -> (((Leaf[?] with {value: 'value}) | (Node[?] with {subTree: PerfectTree[('b, 'c,)]})) -> (Leaf['value0] | (Node['A] with {subTree: PerfectTree[('d, 'e,)]}))
//│   where
//│     'a <: 'value -> 'value0 & 'b -> ('d & 'A) & 'c -> ('A & 'e))
//│   <:  map:
//│ ('a -> 'b) -> PerfectTree['a] -> PerfectTree['b]
//│    = <no result>
//│      map is not implemented

map succ n4
//│ res: PerfectTree[int]
//│    = <no result>
//│      map and map are not implemented




