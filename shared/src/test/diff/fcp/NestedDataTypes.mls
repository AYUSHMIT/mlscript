:NoRecursiveTypes
:GeneralizeCurriedFunctions
:ConstrainedTypes // * The test takes too much time without this

// * Perfect Trees (https://www.cis.upenn.edu/~plclub/blog/2020-12-04-nested-datatypes/)

// data NTree (a :: Type) =
//     NLeaf a
//   | NNode (NTree (Two a))


type Two[A] = (A, A)
//│ Defined type alias Two[+A]

def mapTwo f ((a, b)) = (f a, f b)
//│ mapTwo: 'a -> (forall 'b, 'c, 'a, 'd, 'e. (('d, 'b,) -> ('e, 'c,)
//│   where
//│     'a <: 'd -> 'e & 'b -> 'c))
//│       = [Function: mapTwo]

class Leaf[A]: { value: A }
//│ Defined class Leaf[+A]

:e
class Node[A]: { subTree: PerfectTree[Two[A]] }
type PerfectTree[A] = Leaf[A] | Node[A]
//│ ╔══[ERROR] Type definition is not regular: it occurs within itself as Node[Two['A]], but is defined as Node['A]
//│ ║  l.25: 	class Node[A]: { subTree: PerfectTree[Two[A]] }
//│ ╙──      	      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type definition is not regular: it occurs within itself as PerfectTree[Two['A]], but is defined as PerfectTree['A]
//│ ║  l.26: 	type PerfectTree[A] = Leaf[A] | Node[A]
//│ ╙──      	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

:IrregularTypes

class Node[A]: { subTree: PerfectTree[Two[A]] }
type PerfectTree[A] = Leaf[A] | Node[A]
//│ Defined class Node[+A]
//│ Defined type alias PerfectTree[+A]


n1 = Leaf { value = 1 }
//│ n1: Leaf[1]
//│   = Leaf { value: 1 }
n1: PerfectTree[int]
//│ res: PerfectTree[int]
//│    = Leaf { value: 1 }

n2 = Node { subTree = Leaf { value = (1, 2) } }
//│ n2: Node[1 | 2] with {subTree: Leaf[(1, 2,)]}
//│   = Node1 { subTree: Leaf { value: [ 1, 2 ] } }
n2: PerfectTree[int]
//│ res: PerfectTree[int]
//│    = Node1 { subTree: Leaf { value: [ 1, 2 ] } }

n4 = Node { subTree = Node { subTree = Leaf { value = ((1, 2), (3, 4)) } } }
//│ n4: Node[1 | 2 | 3 | 4] with {subTree: Node[(1 | 3, 2 | 4,)] with {subTree: Leaf[((1, 2,), (3, 4,),)]}}
//│   = Node1 { subTree: Node1 { subTree: Leaf { value: [Array] } } }
n4: PerfectTree[int]
//│ res: PerfectTree[int]
//│    = Node1 { subTree: Node1 { subTree: Leaf { value: [Array] } } }


// * Works since the removal of "recursive definition hacks"
rec def map f tree = case tree of {
  | Leaf -> Leaf { value = f tree.value }
  | Node -> Node { subTree = map (mapTwo f) tree.subTree }
  }
//│ map: 'map
//│   where
//│     'map :> forall 'a. 'a -> (forall 'A, 'map, 'subTree, 'value, 'value0, 'subTree0. (((Leaf[?] with {value: 'value}) | (Node[?] with {subTree: 'subTree0})) -> (Leaf['value0] | (Node['A] with {subTree: 'subTree}))
//│   where
//│     'map <: (forall 'b, 'c, 'a, 'd, 'e. (('d, 'c,) -> ('b, 'e,)
//│   where
//│     'a <: 'd -> 'b & 'c -> 'e)) -> 'subTree0 -> (PerfectTree[Two['A]] & 'subTree)
//│     'a <: 'value -> 'value0))
//│    = [Function: map]

:e
map succ n4
//│ ╔══[ERROR] Subtyping constraint of the form `?a <: (forall ?subTree, ?A, ?subTree0, ?A0, ?b, ?A1, ?value. ?b) -> ?c` exceeded recursion depth limit (200)
//│ ║  l.80: 	map succ n4
//│ ║        	^^^^^^^^^^^
//│ ╟── while constraining:  α131_1138  <!<  α122_1158
//│ ╟── while constraining:  (α131_1138,)  <!<  (α122_1158,)
//│ ╟── while constraining:  (α122_1158 -> ‹∀ 2. {(α123_1174''' -> (α127_1177''' | α144_1178''')) where: map121_233# <: ((α131_1159''',) -> α141_1165'''), α122_1158 <: ((value125_1170''',) -> α126_1171''')}›)  <!<  ((α131_1138,) -> α141_1144)
//│ ╟── while constraining:  ‹∀ 1. (α122_234'' -> ‹∀ 2. {(α123_250''' -> (α127_253''' | α144_254''')) where: map121_233# <: ((α131_235''',) -> α141_241'''), α122_234'' <: ((value125_246''',) -> α126_247''')}›)›  <!<  ((α131_1138,) -> α141_1144)
//│ ╟── while constraining:  map121_233#  <!<  ((α131_1138,) -> α141_1144)
//│ ╟── while constraining:  {(α123_1153 -> (α127_1156 | α144_1157)) where: map121_233# <: ((α131_1138,) -> α141_1144), α122_1117 <: ((value125_1149,) -> α126_1150)}  <!<  ((subTree142_1104,) -> α143_1105)
//│ ╟── while constraining:  ‹∀ 2. {(α123_1133''' -> (α127_1136''' | α144_1137''')) where: map121_233# <: ((α131_1118''',) -> α141_1124'''), α122_1117 <: ((value125_1129''',) -> α126_1130''')}›  <!<  ((subTree142_1104,) -> α143_1105)
//│ ╟── while constraining:  ‹∀ 2. {(α123_1133''' -> (α127_1136''' | α144_1137''')) where: map121_233# <: ((α131_1118''',) -> α141_1124'''), α122_1117 <: ((value125_1129''',) -> α126_1130''')}›  <!<  α141_1103
//│ ╟── while constraining:  (α122_1117 -> ‹∀ 2. {(α123_1133''' -> (α127_1136''' | α144_1137''')) where: map121_233# <: ((α131_1118''',) -> α141_1124'''), α122_1117 <: ((value125_1129''',) -> α126_1130''')}›)  <!<  ((α131_1097,) -> α141_1103)
//│ ╟── while constraining:  ‹∀ 1. (α122_234'' -> ‹∀ 2. {(α123_250''' -> (α127_253''' | α144_254''')) where: map121_233# <: ((α131_235''',) -> α141_241'''), α122_234'' <: ((value125_246''',) -> α126_247''')}›)›  <!<  ((α131_1097,) -> α141_1103)
//│ ╟── while constraining:  map121_233#  <!<  ((α131_1097,) -> α141_1103)
//│ ╟── while constraining:  {(α123_1112 -> (α127_1115 | α144_1116)) where: map121_233# <: ((α131_1097,) -> α141_1103), α122_1076 <: ((value125_1108,) -> α126_1109)}  <!<  ((subTree142_1063,) -> α143_1064)
//│ ╟── while constraining:  ‹∀ 2. {(α123_1092''' -> (α127_1095''' | α144_1096''')) where: map121_233# <: ((α131_1077''',) -> α141_1083'''), α122_1076 <: ((value125_1088''',) -> α126_1089''')}›  <!<  ((subTree142_1063,) -> α143_1064)
//│ ╟── while constraining:  ‹∀ 2. {(α123_1092''' -> (α127_1095''' | α144_1096''')) where: map121_233# <: ((α131_1077''',) -> α141_1083'''), α122_1076 <: ((value125_1088''',) -> α126_1089''')}›  <!<  α141_1062
//│ ╟── while constraining:  (α122_1076 -> ‹∀ 2. {(α123_1092''' -> (α127_1095''' | α144_1096''')) where: map121_233# <: ((α131_1077''',) -> α141_1083'''), α122_1076 <: ((value125_1088''',) -> α126_1089''')}›)  <!<  ((α131_1056,) -> α141_1062)
//│ ╟── ......
//│ ╟── ......
//│ ╟── while constraining:  {(α123_374 -> (α127_377 | α144_378)) where: map121_233# <: ((α131_359,) -> α141_365), α122_338 <: ((value125_370,) -> α126_371)}  <!<  ((subTree142_325,) -> α143_326)
//│ ╟── while constraining:  ‹∀ 2. {(α123_354''' -> (α127_357''' | α144_358''')) where: map121_233# <: ((α131_339''',) -> α141_345'''), α122_338 <: ((value125_350''',) -> α126_351''')}›  <!<  ((subTree142_325,) -> α143_326)
//│ ╟── while constraining:  ‹∀ 2. {(α123_354''' -> (α127_357''' | α144_358''')) where: map121_233# <: ((α131_339''',) -> α141_345'''), α122_338 <: ((value125_350''',) -> α126_351''')}›  <!<  α141_324
//│ ╟── while constraining:  (α122_338 -> ‹∀ 2. {(α123_354''' -> (α127_357''' | α144_358''')) where: map121_233# <: ((α131_339''',) -> α141_345'''), α122_338 <: ((value125_350''',) -> α126_351''')}›)  <!<  ((α131_318,) -> α141_324)
//│ ╟── while constraining:  ‹∀ 1. (α122_234'' -> ‹∀ 2. {(α123_250''' -> (α127_253''' | α144_254''')) where: map121_233# <: ((α131_235''',) -> α141_241'''), α122_234'' <: ((value125_246''',) -> α126_247''')}›)›  <!<  ((α131_318,) -> α141_324)
//│ ╟── while constraining:  map121_233#  <!<  ((α131_318,) -> α141_324)
//│ ╟── while constraining:  {(α123_333 -> (α127_336 | α144_337)) where: map121_233# <: ((α131_318,) -> α141_324), α122_297 <: ((value125_329,) -> α126_330)}  <!<  ((subTree142_284,) -> α143_285)
//│ ╟── while constraining:  ‹∀ 2. {(α123_313''' -> (α127_316''' | α144_317''')) where: map121_233# <: ((α131_298''',) -> α141_304'''), α122_297 <: ((value125_309''',) -> α126_310''')}›  <!<  ((subTree142_284,) -> α143_285)
//│ ╟── while constraining:  ‹∀ 2. {(α123_313''' -> (α127_316''' | α144_317''')) where: map121_233# <: ((α131_298''',) -> α141_304'''), α122_297 <: ((value125_309''',) -> α126_310''')}›  <!<  α141_283
//│ ╟── while constraining:  (α122_297 -> ‹∀ 2. {(α123_313''' -> (α127_316''' | α144_317''')) where: map121_233# <: ((α131_298''',) -> α141_304'''), α122_297 <: ((value125_309''',) -> α126_310''')}›)  <!<  ((α131_277,) -> α141_283)
//│ ╟── while constraining:  ‹∀ 1. (α122_234'' -> ‹∀ 2. {(α123_250''' -> (α127_253''' | α144_254''')) where: map121_233# <: ((α131_235''',) -> α141_241'''), α122_234'' <: ((value125_246''',) -> α126_247''')}›)›  <!<  ((α131_277,) -> α141_283)
//│ ╟── while constraining:  map121_233#  <!<  ((α131_277,) -> α141_283)
//│ ╟── while constraining:  {(α123_292 -> (α127_295 | α144_296)) where: map121_233# <: ((α131_277,) -> α141_283), α122_255 <: ((value125_288,) -> α126_289)}  <!<  ((‹∀ 0. α104'›,) -> α276)
//│ ╟── while constraining:  ‹∀ 2. {(α123_271''' -> (α127_274''' | α144_275''')) where: map121_233# <: ((α131_256''',) -> α141_262'''), α122_255 <: ((value125_267''',) -> α126_268''')}›  <!<  ((‹∀ 0. α104'›,) -> α276)
//│ ╙── while constraining:  α232  <!<  ((‹∀ 0. α104'›,) -> α276)
//│ res: error
//│    = Node1 { subTree: Node1 { subTree: Leaf { value: [Array] } } }


def map: ('a -> 'b) -> PerfectTree['a] -> PerfectTree['b]
//│ map: ('a -> 'b) -> PerfectTree['a] -> PerfectTree['b]
//│    = <missing implementation>

def map f tree = case tree of {
  | Leaf -> Leaf { value = f tree.value }
  | Node -> Node { subTree = map (mapTwo f) tree.subTree }
  }
//│ 'a -> (forall 'value, 'b, 'value0, 'c, 'd, 'e, 'a, 'A. (((Leaf[?] with {value: 'value}) | (Node[?] with {subTree: PerfectTree[('c, 'e,)]})) -> (Leaf['value0] | (Node['A] with {subTree: PerfectTree[('b, 'd,)]}))
//│   where
//│     'a <: 'value -> 'value0 & 'c -> ('b & 'A) & 'e -> ('A & 'd)))
//│   <:  map:
//│ ('a -> 'b) -> PerfectTree['a] -> PerfectTree['b]
//│    = <no result>
//│      map is not implemented

map succ n4
//│ res: PerfectTree[int]
//│    = <no result>
//│      map and map are not implemented




