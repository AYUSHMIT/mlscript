:NoRecursiveTypes
:GeneralizeCurriedFunctions
:ConstrainedTypes // * The test takes too much time without this

// * Perfect Trees (https://www.cis.upenn.edu/~plclub/blog/2020-12-04-nested-datatypes/)

// data NTree (a :: Type) =
//     NLeaf a
//   | NNode (NTree (Two a))


type Two[A] = (A, A)
//│ Defined type alias Two[+A]

def mapTwo f ((a, b)) = (f a, f b)
//│ mapTwo: 'a -> (forall 'b, 'c, 'd, 'e. (('b, 'd,) -> ('c, 'e,)
//│   where
//│     'a <: 'b -> 'c & 'd -> 'e))
//│       = [Function: mapTwo]

class Leaf[A]: { value: A }
//│ Defined class Leaf[+A]

:e
class Node[A]: { subTree: PerfectTree[Two[A]] }
type PerfectTree[A] = Leaf[A] | Node[A]
//│ ╔══[ERROR] Type definition is not regular: it occurs within itself as Node[Two['A]], but is defined as Node['A]
//│ ║  l.25: 	class Node[A]: { subTree: PerfectTree[Two[A]] }
//│ ╙──      	      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type definition is not regular: it occurs within itself as PerfectTree[Two['A]], but is defined as PerfectTree['A]
//│ ║  l.26: 	type PerfectTree[A] = Leaf[A] | Node[A]
//│ ╙──      	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

:IrregularTypes

class Node[A]: { subTree: PerfectTree[Two[A]] }
type PerfectTree[A] = Leaf[A] | Node[A]
//│ Defined class Node[+A]
//│ Defined type alias PerfectTree[+A]


n1 = Leaf { value = 1 }
//│ n1: Leaf[1]
//│   = Leaf { value: 1 }
n1: PerfectTree[int]
//│ res: PerfectTree[int]
//│    = Leaf { value: 1 }

n2 = Node { subTree = Leaf { value = (1, 2) } }
//│ n2: Node[1 | 2] with {subTree: Leaf[(1, 2,)]}
//│   = Node1 { subTree: Leaf { value: [ 1, 2 ] } }
n2: PerfectTree[int]
//│ res: PerfectTree[int]
//│    = Node1 { subTree: Leaf { value: [ 1, 2 ] } }

n4 = Node { subTree = Node { subTree = Leaf { value = ((1, 2), (3, 4)) } } }
//│ n4: Node[1 | 2 | 3 | 4] with {subTree: Node[(1 | 3, 2 | 4,)] with {subTree: Leaf[((1, 2,), (3, 4,),)]}}
//│   = Node1 { subTree: Node1 { subTree: Leaf { value: [Array] } } }
n4: PerfectTree[int]
//│ res: PerfectTree[int]
//│    = Node1 { subTree: Node1 { subTree: Leaf { value: [Array] } } }


// * Works since the removal of "recursive definition hacks"
rec def map f tree = case tree of {
  | Leaf -> Leaf { value = f tree.value }
  | Node -> Node { subTree = map (mapTwo f) tree.subTree }
  }
//│ map: 'map
//│   where
//│     'map :> forall 'a. 'a -> (forall 'subTree, 'A, 'subTree0, 'value, 'value0. (((Leaf[?] with {value: 'value}) | (Node[?] with {subTree: 'subTree})) -> (Leaf['value0] | (Node['A] with {subTree: 'subTree0}))
//│   where
//│     'map <: (forall 'b, 'c, 'd, 'e. (('b, 'd,) -> ('c, 'e,)
//│   where
//│     'a <: 'b -> 'c & 'd -> 'e)) -> 'subTree -> (PerfectTree[Two['A]] & 'subTree0)
//│     'a <: 'value -> 'value0))
//│    = [Function: map]

:e
map succ n4
//│ ╔══[ERROR] Subtyping constraint of the form `?a <: (forall ?subTree, ?value, ?b, ?A, ?subTree0, ?A0, ?A1. ?b) -> ?c` exceeded recursion depth limit (200)
//│ ║  l.80: 	map succ n4
//│ ║        	^^^^^^^^^^^
//│ ╟── while constraining:  α132_1139  <!<  α123_1159
//│ ╟── while constraining:  (α132_1139,)  <!<  (α123_1159,)
//│ ╟── while constraining:  (α123_1159 -> ‹∀ 2. {(α124_1175''' -> (α128_1178''' | α145_1179''')) where: map122_234# <: ((α132_1160''',) -> α142_1166'''), α123_1159 <: ((value126_1171''',) -> α127_1172''')}›)  <!<  ((α132_1139,) -> α142_1145)
//│ ╟── while constraining:  ‹∀ 1. (α123_235'' -> ‹∀ 2. {(α124_251''' -> (α128_254''' | α145_255''')) where: map122_234# <: ((α132_236''',) -> α142_242'''), α123_235'' <: ((value126_247''',) -> α127_248''')}›)›  <!<  ((α132_1139,) -> α142_1145)
//│ ╟── while constraining:  map122_234#  <!<  ((α132_1139,) -> α142_1145)
//│ ╟── while constraining:  {(α124_1154 -> (α128_1157 | α145_1158)) where: map122_234# <: ((α132_1139,) -> α142_1145), α123_1118 <: ((value126_1150,) -> α127_1151)}  <!<  ((subTree143_1105,) -> α144_1106)
//│ ╟── while constraining:  ‹∀ 2. {(α124_1134''' -> (α128_1137''' | α145_1138''')) where: map122_234# <: ((α132_1119''',) -> α142_1125'''), α123_1118 <: ((value126_1130''',) -> α127_1131''')}›  <!<  ((subTree143_1105,) -> α144_1106)
//│ ╟── while constraining:  ‹∀ 2. {(α124_1134''' -> (α128_1137''' | α145_1138''')) where: map122_234# <: ((α132_1119''',) -> α142_1125'''), α123_1118 <: ((value126_1130''',) -> α127_1131''')}›  <!<  α142_1104
//│ ╟── while constraining:  (α123_1118 -> ‹∀ 2. {(α124_1134''' -> (α128_1137''' | α145_1138''')) where: map122_234# <: ((α132_1119''',) -> α142_1125'''), α123_1118 <: ((value126_1130''',) -> α127_1131''')}›)  <!<  ((α132_1098,) -> α142_1104)
//│ ╟── while constraining:  ‹∀ 1. (α123_235'' -> ‹∀ 2. {(α124_251''' -> (α128_254''' | α145_255''')) where: map122_234# <: ((α132_236''',) -> α142_242'''), α123_235'' <: ((value126_247''',) -> α127_248''')}›)›  <!<  ((α132_1098,) -> α142_1104)
//│ ╟── while constraining:  map122_234#  <!<  ((α132_1098,) -> α142_1104)
//│ ╟── while constraining:  {(α124_1113 -> (α128_1116 | α145_1117)) where: map122_234# <: ((α132_1098,) -> α142_1104), α123_1077 <: ((value126_1109,) -> α127_1110)}  <!<  ((subTree143_1064,) -> α144_1065)
//│ ╟── while constraining:  ‹∀ 2. {(α124_1093''' -> (α128_1096''' | α145_1097''')) where: map122_234# <: ((α132_1078''',) -> α142_1084'''), α123_1077 <: ((value126_1089''',) -> α127_1090''')}›  <!<  ((subTree143_1064,) -> α144_1065)
//│ ╟── while constraining:  ‹∀ 2. {(α124_1093''' -> (α128_1096''' | α145_1097''')) where: map122_234# <: ((α132_1078''',) -> α142_1084'''), α123_1077 <: ((value126_1089''',) -> α127_1090''')}›  <!<  α142_1063
//│ ╟── while constraining:  (α123_1077 -> ‹∀ 2. {(α124_1093''' -> (α128_1096''' | α145_1097''')) where: map122_234# <: ((α132_1078''',) -> α142_1084'''), α123_1077 <: ((value126_1089''',) -> α127_1090''')}›)  <!<  ((α132_1057,) -> α142_1063)
//│ ╟── ......
//│ ╟── ......
//│ ╟── while constraining:  {(α124_375 -> (α128_378 | α145_379)) where: map122_234# <: ((α132_360,) -> α142_366), α123_339 <: ((value126_371,) -> α127_372)}  <!<  ((subTree143_326,) -> α144_327)
//│ ╟── while constraining:  ‹∀ 2. {(α124_355''' -> (α128_358''' | α145_359''')) where: map122_234# <: ((α132_340''',) -> α142_346'''), α123_339 <: ((value126_351''',) -> α127_352''')}›  <!<  ((subTree143_326,) -> α144_327)
//│ ╟── while constraining:  ‹∀ 2. {(α124_355''' -> (α128_358''' | α145_359''')) where: map122_234# <: ((α132_340''',) -> α142_346'''), α123_339 <: ((value126_351''',) -> α127_352''')}›  <!<  α142_325
//│ ╟── while constraining:  (α123_339 -> ‹∀ 2. {(α124_355''' -> (α128_358''' | α145_359''')) where: map122_234# <: ((α132_340''',) -> α142_346'''), α123_339 <: ((value126_351''',) -> α127_352''')}›)  <!<  ((α132_319,) -> α142_325)
//│ ╟── while constraining:  ‹∀ 1. (α123_235'' -> ‹∀ 2. {(α124_251''' -> (α128_254''' | α145_255''')) where: map122_234# <: ((α132_236''',) -> α142_242'''), α123_235'' <: ((value126_247''',) -> α127_248''')}›)›  <!<  ((α132_319,) -> α142_325)
//│ ╟── while constraining:  map122_234#  <!<  ((α132_319,) -> α142_325)
//│ ╟── while constraining:  {(α124_334 -> (α128_337 | α145_338)) where: map122_234# <: ((α132_319,) -> α142_325), α123_298 <: ((value126_330,) -> α127_331)}  <!<  ((subTree143_285,) -> α144_286)
//│ ╟── while constraining:  ‹∀ 2. {(α124_314''' -> (α128_317''' | α145_318''')) where: map122_234# <: ((α132_299''',) -> α142_305'''), α123_298 <: ((value126_310''',) -> α127_311''')}›  <!<  ((subTree143_285,) -> α144_286)
//│ ╟── while constraining:  ‹∀ 2. {(α124_314''' -> (α128_317''' | α145_318''')) where: map122_234# <: ((α132_299''',) -> α142_305'''), α123_298 <: ((value126_310''',) -> α127_311''')}›  <!<  α142_284
//│ ╟── while constraining:  (α123_298 -> ‹∀ 2. {(α124_314''' -> (α128_317''' | α145_318''')) where: map122_234# <: ((α132_299''',) -> α142_305'''), α123_298 <: ((value126_310''',) -> α127_311''')}›)  <!<  ((α132_278,) -> α142_284)
//│ ╟── while constraining:  ‹∀ 1. (α123_235'' -> ‹∀ 2. {(α124_251''' -> (α128_254''' | α145_255''')) where: map122_234# <: ((α132_236''',) -> α142_242'''), α123_235'' <: ((value126_247''',) -> α127_248''')}›)›  <!<  ((α132_278,) -> α142_284)
//│ ╟── while constraining:  map122_234#  <!<  ((α132_278,) -> α142_284)
//│ ╟── while constraining:  {(α124_293 -> (α128_296 | α145_297)) where: map122_234# <: ((α132_278,) -> α142_284), α123_256 <: ((value126_289,) -> α127_290)}  <!<  ((‹∀ 0. α105'›,) -> α277)
//│ ╟── while constraining:  ‹∀ 2. {(α124_272''' -> (α128_275''' | α145_276''')) where: map122_234# <: ((α132_257''',) -> α142_263'''), α123_256 <: ((value126_268''',) -> α127_269''')}›  <!<  ((‹∀ 0. α105'›,) -> α277)
//│ ╙── while constraining:  α233  <!<  ((‹∀ 0. α105'›,) -> α277)
//│ res: error
//│    = Node1 { subTree: Node1 { subTree: Leaf { value: [Array] } } }


def map: ('a -> 'b) -> PerfectTree['a] -> PerfectTree['b]
//│ map: ('a -> 'b) -> PerfectTree['a] -> PerfectTree['b]
//│    = <missing implementation>

def map f tree = case tree of {
  | Leaf -> Leaf { value = f tree.value }
  | Node -> Node { subTree = map (mapTwo f) tree.subTree }
  }
//│ 'a -> (forall 'b, 'c, 'value, 'value0, 'd, 'A, 'e. (((Leaf[?] with {value: 'value}) | (Node[?] with {subTree: PerfectTree[('b, 'd,)]})) -> (Leaf['value0] | (Node['A] with {subTree: PerfectTree[('e, 'c,)]}))
//│   where
//│     'a <: 'value -> 'value0 & 'b -> ('e & 'A) & 'd -> ('A & 'c)))
//│   <:  map:
//│ ('a -> 'b) -> PerfectTree['a] -> PerfectTree['b]
//│    = <no result>
//│      map is not implemented

map succ n4
//│ res: PerfectTree[int]
//│    = <no result>
//│      map and map are not implemented




