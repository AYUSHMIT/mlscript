
:GeneralizeCurriedFunctions
:NoConstrainedTypes
:DontDistributeForalls
:NoCycleCheck
:NoRecursiveTypes


// ============ Dummy classes to represent the types in the examples ============

class List[a]
  method Head: a
  method Tail: List[a]
//│ Defined class List[+a]
//│ Declared List.Head: List['a] -> 'a
//│ Declared List.Tail: List['a] -> List['a]

class Nil[a]: List[a]
  method Head = error
  method Tail = this
//│ Defined class Nil[+a]
//│ Defined Nil.Head: Nil[?] -> nothing
//│ Defined Nil.Tail: (Nil['a] & 'this) -> (Nil['a] & 'this)

class Cons[a]: List[a] & { head: a; tail: List[a] }
  method Head = this.head
  method Tail = this.tail
//│ Defined class Cons[+a]
//│ Defined Cons.Head: Cons['a] -> 'a
//│ Defined Cons.Tail: Cons['a] -> List['a]

class ST[S, A]
  method Inv_S: S -> S
  method Cov_A: A
//│ Defined class ST[=S, +A]
//│ Declared ST.Inv_S: ST['S, ?] -> 'S -> 'S
//│ Declared ST.Cov_A: ST['S, 'A] -> 'A


// ============ Type signatures for functions used in the examples ============

def head: List['a] -> 'a
def head l = l.Head
//│ head: List['a] -> 'a
//│     = <missing implementation>
//│ List['a] -> 'a
//│   <:  head:
//│ List['a] -> 'a
//│     = [Function: head]

def tail: List['a] -> List['a]
def tail l = l.Tail
//│ tail: List['a] -> List['a]
//│     = <missing implementation>
//│ List['a] -> List['a]
//│   <:  tail:
//│ List['a] -> List['a]
//│     = [Function: tail]

// Used to represent `[]` in the papers
def nil: List['a]
nil = Nil {}
//│ nil: List[nothing]
//│    = <missing implementation>
//│ Nil[nothing]
//│   <:  nil:
//│ List[nothing]
//│    = Nil {}

def cons: 'a -> List['a] -> List['a]
def cons head tail = Cons { head; tail }
//│ cons: 'a -> List['a] -> List['a]
//│     = <missing implementation>
//│ 'b -> (forall 'a, 'tail. (List['a] & 'tail) -> (Cons['a | 'b] with {head: 'b, tail: 'tail}))
//│   <:  cons:
//│ 'a -> List['a] -> List['a]
//│     = [Function: cons]

def is_empty: List['a] -> bool
def is_empty l = eq l nil
//│ is_empty: List[?] -> bool
//│         = <missing implementation>
//│ anything -> bool
//│   <:  is_empty:
//│ List[?] -> bool
//│         = [Function: is_empty]

def single: 'a -> List['a]
def single x = cons x nil
//│ single: 'a -> List['a]
//│       = <missing implementation>
//│ 'a -> List['a]
//│   <:  single:
//│ 'a -> List['a]
//│       = [Function: single]

def append: List['a] -> List['a] -> List['a]
rec def append l1 l2 =
  if is_empty l1 then l2
  else cons (head l1) (append (tail l1) l2)
//│ append: List['a] -> List['a] -> List['a]
//│       = <missing implementation>
//│ List[?] -> (forall 'b. (List['a] & 'b) -> (List['a] | 'b))
//│   <:  append:
//│ List['a] -> List['a] -> List['a]
//│       = [Function: append]

def length: List['a] -> int
rec def length l =
  if is_empty l then 0
  else succ (length (tail l))
//│ length: List[?] -> int
//│       = <missing implementation>
//│ List[?] -> int
//│   <:  length:
//│ List[?] -> int
//│       = [Function: length]

def id: 'a -> 'a
def id x = x
//│ id: 'a -> 'a
//│   = <missing implementation>
//│ 'a -> 'a
//│   <:  id:
//│ 'a -> 'a
//│   = [Function: id1]

def ids: List[forall 'a. 'a -> 'a]
def ids = single id
//│ ids: List[forall 'a. 'a -> 'a]
//│    = <missing implementation>
//│ List[forall 'a. 'a -> 'a]
//│   <:  ids:
//│ List[forall 'a. 'a -> 'a]
//│    = [Function: ids]

def inc: int -> int
def inc = succ
//│ inc: int -> int
//│    = <missing implementation>
//│ int -> int
//│   <:  inc:
//│ int -> int
//│    = [Function: inc]

def choose: 'a -> 'a -> 'a
def choose x y = if true then x else y
//│ choose: 'a -> 'a -> 'a
//│       = <missing implementation>
//│ 'a -> (forall 'b. 'b -> ('a | 'b))
//│   <:  choose:
//│ 'a -> 'a -> 'a
//│       = [Function: choose]

def poly: (forall 'a. 'a -> 'a) -> (int, bool)
def poly f = (f 1, f true)
//│ poly: (forall 'a. 'a -> 'a) -> (int, bool,)
//│     = <missing implementation>
//│ (true -> 'a & 1 -> 'b) -> ('b, 'a,)
//│   <:  poly:
//│ (forall 'a. 'a -> 'a) -> (int, bool,)
//│     = [Function: poly]

def auto : (forall 'a. 'a -> 'a) -> (forall 'b. 'b -> 'b)
def auto x = x x
//│ auto: (forall 'a. 'a -> 'a) -> (forall 'b. 'b -> 'b)
//│     = <missing implementation>
//│ ('a -> 'b & 'a) -> 'b
//│   <:  auto:
//│ (forall 'a. 'a -> 'a) -> (forall 'b. 'b -> 'b)
//│     = [Function: auto]

def auto_ : (forall 'a. 'a -> 'a) -> 'b -> 'b
def auto_ x = x x
//│ auto_: (forall 'a. 'a -> 'a) -> 'b -> 'b
//│      = <missing implementation>
//│ ('a -> 'b & 'a) -> 'b
//│   <:  auto_:
//│ (forall 'a. 'a -> 'a) -> 'b -> 'b
//│      = [Function: auto_]

def map: ('a -> 'b) -> List['a] -> List['b]
rec def map f l =
  if is_empty l then nil
  else cons (f (head l)) (map f (tail l))
//│ map: ('a -> 'b) -> List['a] -> List['b]
//│    = <missing implementation>
//│ (nothing -> 'b & nothing -> 'a) -> List[?] -> List['a | 'b]
//│   <:  map:
//│ ('a -> 'b) -> List['a] -> List['b]
//│    = [Function: map]

def app: ('a -> 'b) -> 'a -> 'b
def app f x = f x
//│ app: ('a -> 'b) -> 'a -> 'b
//│    = <missing implementation>
//│ ('a -> 'b) -> 'a -> 'b
//│   <:  app:
//│ ('a -> 'b) -> 'a -> 'b
//│    = [Function: app]

def revapp: 'a -> ('a -> 'b) -> 'b
def revapp x f = f x
//│ revapp: 'a -> ('a -> 'b) -> 'b
//│       = <missing implementation>
//│ 'a -> (forall 'b. ('a -> 'b) -> 'b)
//│   <:  revapp:
//│ 'a -> ('a -> 'b) -> 'b
//│       = [Function: revapp]

:ng
def runST: (forall 's. ST['s, 'v]) -> 'v
//│ runST: (forall 's. ST['s, 'v]) -> 'v

:ng
def argST: ST['s, int]
//│ argST: ST['s, int]

// A9
:ng
def f: ('a -> 'a) -> List['a] -> 'a
//│ f: ('a -> 'a) -> List['a] -> 'a

// C8
:ng
def g: List['a] -> List['a] -> 'a
//│ g: List['a] -> List['a] -> 'a

// E1, E2
:ng
def h: int -> (forall 'a. 'a -> 'a)
def k: 'a -> List['a] -> 'a
def lst: List[forall 'a. int -> 'a -> 'a]
//│ h: int -> (forall 'a. 'a -> 'a)
//│ k: 'a -> List['a] -> 'a
//│ lst: List[forall 'a. int -> 'a -> 'a]

// E3
:ng
def r: (forall 'a. 'a -> (forall 'b. 'b -> 'b)) -> int
//│ r: (anything -> (forall 'b. 'b -> 'b)) -> int


type ChurchInt = forall 'N. ('N -> 'N) -> ('N -> 'N)
//│ Defined type alias ChurchInt

type Pair[A, B] = (A, B)
//│ Defined type alias Pair[+A, +B]

def fst: forall 'a 'b. Pair['a, 'b] -> 'a
def fst((x, y)) = x
//│ fst: Pair['a, ?] -> 'a
//│    = <missing implementation>
//│ ('a, anything,) -> 'a
//│   <:  fst:
//│ Pair['a, ?] -> 'a
//│    = [Function: fst]

def zero: ChurchInt
def zero f x = x
//│ zero: ChurchInt
//│     = <missing implementation>
//│ anything -> (forall 'a. 'a -> 'a)
//│   <:  zero:
//│ ChurchInt
//│     = [Function: zero]

def succ: (forall 'N. ('N -> 'N) -> ('N -> 'N)) -> (forall 'M. ('M -> 'M) -> ('M -> 'M))
def succ (n: ChurchInt) f x = f (n f x)
//│ succ: (forall 'N. ('N -> 'N) -> 'N -> 'N) -> (forall 'M. ('M -> 'M) -> 'M -> 'M)
//│     = <missing implementation>
//│ ChurchInt -> (forall 'N, 'a, 'N0. ('N -> 'a & 'N0 -> ('N & 'N0)) -> ('N & 'N0) -> 'a)
//│   <:  succ:
//│ (forall 'N. ('N -> 'N) -> 'N -> 'N) -> (forall 'M. ('M -> 'M) -> 'M -> 'M)
//│     = [Function: succ1]




// ================================================================
// ======================== Vanilla SuperF ========================
// ================================================================


// ============ A. polymorphic instantiation ============

// A1
fun x -> fun y -> y
//│ res: anything -> (forall 'a. 'a -> 'a)
//│    = [Function: res]

// A2
choose id
//│ res: 'a -> (forall 'a0. 'a | 'a0 -> 'a0)
//│    = [Function (anonymous)]

// A3
choose nil ids
//│ res: List[forall 'a. 'a -> 'a]
//│    = Nil {}

// A4
fun x -> x x
//│ res: ('a -> 'b & 'a) -> 'b
//│    = [Function: res]

// A5
id auto
//│ res: (forall 'a. 'a -> 'a) -> (forall 'b. 'b -> 'b)
//│    = [Function: auto]

// A6
id auto_
//│ res: (forall 'a. 'a -> 'a) -> 'b -> 'b
//│    = [Function: auto_]

// A7
choose id auto
//│ res: (forall 'a. 'a -> 'a & 'a0) -> (forall 'b. 'a0 | 'b -> 'b)
//│    = [Function: id1]

// A8
:ns
choose id auto_
//│ res: 'c
//│   where
//│     'c :> (forall 'a. 'a -> 'a) | (forall 'b. (forall 'a0. 'a0 -> 'a0) -> 'b -> 'b)
//│    = [Function: id1]

// A9
:ng
f (choose id) ids
//│ res: 'a -> 'a

// A10
poly id
//│ res: (int, bool,)
//│    = [ 1, true ]

// A11
poly (fun x -> x)
//│ res: (int, bool,)
//│    = [ 1, true ]

// A12
id poly (fun x -> x)
//│ res: (int, bool,)
//│    = [ 1, true ]


// ============ B. inference of polymorphic arguments ============

// B1
fun f -> (f 1, f true)
//│ res: (true -> 'a & 1 -> 'b) -> ('b, 'a,)
//│    = [Function: res]

// B2
fun xs -> poly (head xs)
//│ res: List[forall 'a. 'a -> 'a] -> (int, bool,)
//│    = [Function: res]


// ============ C. functions on polymorphic lists ============

// C1
length ids
//│ res: int
//│    = 1

// C2
tail ids
//│ res: List[forall 'a. 'a -> 'a]
//│    = Nil {}

// C3
head ids
//│ res: 'a -> 'a
//│    = [Function: id1]

// C4
single id
//│ res: List[forall 'a. 'a -> 'a]
//│    = Cons { head: [Function: id1], tail: Nil {} }

// C5
cons id ids
//│ res: List[forall 'a. 'a -> 'a]
//│    = Cons {
//│        head: [Function: id1],
//│        tail: Cons { head: [Function: id1], tail: Nil {} }
//│      }

// C6
cons (fun x -> x) ids
//│ res: List[forall 'a. 'a -> 'a]
//│    = Cons {
//│        head: [Function (anonymous)],
//│        tail: Cons { head: [Function: id1], tail: Nil {} }
//│      }

// C7
append (single inc) (single id)
//│ res: List[int -> int]
//│    = Cons {
//│        head: [Function: succ],
//│        tail: Cons { head: [Function: id1], tail: Nil {} }
//│      }

// C8
:ng
g (single id) ids
//│ res: 'a -> 'a

// C9
map poly (single id)
//│ res: List[(int, bool,)]
//│    = Cons { head: [ 1, true ], tail: Nil {} }

// C10
map head (single ids)
//│ res: List[forall 'a. 'a -> 'a]
//│    = Cons { head: [Function: id1], tail: Nil {} }


// ============ D. application functions ============

// D1
app poly id
//│ res: (int, bool,)
//│    = [ 1, true ]

// D2
revapp id poly
//│ res: (int, bool,)
//│    = [ 1, true ]

// D3
:ng
runST argST
//│ res: int

// D4
:ng
app runST argST
//│ res: int

// D5
:ng
revapp argST runST
//│ res: int


// ============ E. η-expansion ============

// E1
:ng
k h lst
//│ res: int -> (forall 'a. 'a -> 'a)

// E2
:ng
k (fun x -> h x) lst
//│ res: int -> (forall 'a. 'a -> 'a)

// E3
:ng
r (fun x -> fun y -> y)
//│ res: int


// ============ F. FreezeML Additions ============

// F5
auto id
//│ res: 'b -> 'b
//│    = [Function: id1]

// F6
cons (head ids) ids
//│ res: List[forall 'a. 'a -> 'a]
//│    = Cons {
//│        head: [Function: id1],
//│        tail: Cons { head: [Function: id1], tail: Nil {} }
//│      }

// F7
(head ids) 3
//│ res: 3
//│    = 3

// F8
choose (head ids)
//│ res: 'a -> (forall 'a0. 'a | 'a0 -> 'a0)
//│    = [Function (anonymous)]

// F9
let f = revapp id in f poly
//│ res: (int, bool,)
//│    = [ 1, true ]

// F10
choose id (fun x -> auto_ x)
//│ res: (forall 'a. 'a -> 'a & 'a0) -> ('a0 | 'b -> 'b)
//│    = [Function: id1]


// ============ G. SuperF Additions ============

// G1
def z f x = x
//│ z: anything -> (forall 'a. 'a -> 'a)
//│  = [Function: z]

// G2
def s n f x = f (n f x)
//│ s: ('a -> 'b -> 'c) -> (forall 'd. ('c -> 'd & 'a) -> 'b -> 'd)
//│  = [Function: s]

// G3
n3 = s (s (s z))
//│ n3: ('a -> 'b & 'c -> 'a & 'd -> 'c) -> 'd -> 'b
//│   = [Function (anonymous)]

// G1A
z: ChurchInt
//│ res: ChurchInt
//│    = [Function: z]

:e
// G2A
s: ChurchInt -> ChurchInt
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.532: 	s: ChurchInt -> ChurchInt
//│ ║         	^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.244: 	type ChurchInt = forall 'N. ('N -> 'N) -> ('N -> 'N)
//│ ║         	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.244: 	type ChurchInt = forall 'N. ('N -> 'N) -> ('N -> 'N)
//│ ╙──       	                        ^^
//│ res: ChurchInt -> ChurchInt
//│    = [Function: s]

// G3A
n3: ChurchInt
//│ res: ChurchInt
//│    = [Function (anonymous)]

// G4
fst (fst (fst (n3 (fun x -> (x, 0)) 1)))
//│ res: 1
//│    = 1

(succ (succ zero)) (succ (succ zero))
//│ res: ('M -> 'M) -> 'M -> 'M
//│    = [Function (anonymous)]

(s (s z)) (s (s z))
//│ res: ('a -> ('a & 'b & 'c) & 'b -> ('a & 'b)) -> 'b -> 'c
//│    = [Function (anonymous)]

// G7
rec def to_ch n = if n == 0 then z else s (to_ch (n - 1))
//│ to_ch: int -> (forall 'a. ('b -> 'a & 'b -> 'b) -> (forall 'c. ('b & 'c) -> ('c | 'a)))
//│      = [Function: to_ch]

:e
// G7A
to_ch: int -> ChurchInt
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.570: 	to_ch: int -> ChurchInt
//│ ║         	^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.244: 	type ChurchInt = forall 'N. ('N -> 'N) -> ('N -> 'N)
//│ ║         	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.244: 	type ChurchInt = forall 'N. ('N -> 'N) -> ('N -> 'N)
//│ ║         	                        ^^
//│ ╟── from application:
//│ ║  l.516: 	def s n f x = f (n f x)
//│ ╙──       	              ^^^^^^^^^
//│ res: int -> ChurchInt
//│    = [Function: to_ch]

:e
// G8
rec def id1 x = if true then x else id1 id1 x
//│ ╔══[ERROR] Inferred recursive type: 'a
//│   where
//│     'a :> forall 'b, 'c. 'b -> 'c
//│        <: 'd -> 'a
//│     'b <: 'd & 'c
//│     'd :> forall 'b, 'c. 'b -> 'c
//│        <: 'a
//│     'c :> 'a
//│ ║  l.588: 	rec def id1 x = if true then x else id1 id1 x
//│ ╙──       	                                    ^^^^^^^
//│ ╔══[ERROR] Subtyping constraint of the form `forall ?a, ?b, ?c. ?b -> ?c <: ?id1` exceeded recursion depth limit (250)
//│ ║  l.588: 	rec def id1 x = if true then x else id1 id1 x
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── while constraining:  ‹∀ 1. (α1833_1843'' -> α1842_1845'')›  <!<  α1833_1864'
//│ ╟── while constraining:  α1840'  <!<  α1833_1864'
//│ ╟── while constraining:  (α1840',)  <!<  (α1833_1864',)
//│ ╟── while constraining:  (α1833_1864' -> α1842_1866')  <!<  ((α1840',) -> α1841')
//│ ╟── while constraining:  ‹∀ 1. (α1833_1843'' -> α1842_1845'')›  <!<  ((α1840',) -> α1841')
//│ ╟── while constraining:  ‹∀ 1. (α1833_1843'' -> α1842_1845'')›  <!<  α1838'
//│ ╟── while constraining:  ‹∀ 1. (α1833_1843'' -> α1842_1845'')›  <!<  α1841'
//│ ╟── while constraining:  ‹∀ 1. (α1833_1843'' -> α1842_1845'')›  <!<  α1842_1851'
//│ ╟── while constraining:  ‹∀ 1. (α1833_1843'' -> α1842_1845'')›  <!<  α6_1850'
//│ ╟── while constraining:  ‹∀ 1. (α1833_1843'' -> α1842_1845'')›  <!<  α1833_1849'
//│ ╟── while constraining:  ‹∀ 1. (α1833_1843'' -> α1842_1845'')›  <!<  α1840'
//│ ╟── while constraining:  ‹∀ 1. (α1833_1843'' -> α1842_1845'')›  <!<  α1833_1861'
//│ ╟── while constraining:  α1840'  <!<  α1833_1861'
//│ ╟── while constraining:  (α1840',)  <!<  (α1833_1861',)
//│ ╟── while constraining:  (α1833_1861' -> α1842_1863')  <!<  ((α1840',) -> α1841')
//│ ╟── ......
//│ ╟── ......
//│ ╟── while constraining:  ‹∀ 1. (α1833_1843'' -> α1842_1845'')›  <!<  α1842_1851'
//│ ╟── while constraining:  ‹∀ 1. (α1833_1843'' -> α1842_1845'')›  <!<  α6_1850'
//│ ╟── while constraining:  ‹∀ 1. (α1833_1843'' -> α1842_1845'')›  <!<  α1833_1849'
//│ ╟── while constraining:  ‹∀ 1. (α1833_1843'' -> α1842_1845'')›  <!<  α1840'
//│ ╟── while constraining:  ‹∀ 1. (α1833_1843'' -> α1842_1845'')›  <!<  α1833_1852'
//│ ╟── while constraining:  α1840'  <!<  α1833_1852'
//│ ╟── while constraining:  (α1840',)  <!<  (α1833_1852',)
//│ ╟── while constraining:  (α1833_1852' -> α1842_1854')  <!<  ((α1840',) -> α1841')
//│ ╟── while constraining:  ‹∀ 1. (α1833_1843'' -> α1842_1845'')›  <!<  ((α1840',) -> α1841')
//│ ╟── while constraining:  ‹∀ 1. (α1833_1843'' -> α1842_1845'')›  <!<  α1838'
//│ ╟── while constraining:  α1841'  <!<  α1838'
//│ ╟── while constraining:  α1842_1848'  <!<  α1838'
//│ ╟── while constraining:  (α1833_1846' -> α1842_1848')  <!<  ((id11832',) -> α1838')
//│ ╟── while constraining:  ‹∀ 1. (α1833_1843'' -> α1842_1845'')›  <!<  ((id11832',) -> α1838')
//│ ╙── while constraining:  ‹∀ 1. (α1833_1843'' -> α1842_1845'')›  <!<  id11832'
//│ id1: 'id1
//│   where
//│     'id1 :> forall 'a. ('b & 'a) -> 'a
//│     'a :> 'c
//│     'b :> 'id1
//│        <: 'c
//│     'c :> 'id1
//│        <: 'b -> 'c
//│    = [Function: id11]

:e
// G9
id1 id1
//│ ╔══[ERROR] Inferred recursive type: 'a
//│   where
//│     'a :> 'b
//│     'b :> forall 'id1, 'c, 'd, 'a, 'e. 'd -> 'a | 'id1
//│        <: 'f -> 'b
//│     'd <: 'a & 'f
//│     'f :> forall 'id1, 'c, 'd, 'a, 'e. 'd -> 'a | 'id1
//│        <: 'b & 'g
//│     'g :> forall 'id1, 'h, 'c, 'i, 'e. 'h -> 'i | 'id1
//│        <: 'j & 'k
//│     'k :> forall 'id1, 'c, 'l, 'e, 'm. 'l -> 'm | 'id1
//│        <: 'n & 'o
//│     'o :> forall 'p, 'id1, 'q, 'c, 'e. 'q -> 'p | 'id1
//│        <: 'r & 's
//│     's :> forall 'id1, 't, 'c, 'e, 'u. 't -> 'u | 'id1
//│        <: 'v & 'w
//│     'w :> forall 'id1, 'e, 'c, 'x. 'x -> 'y | 'id1
//│        <: 'z
//│     'x <: 'w & 'y
//│     'y :> 'z
//│     'z :> forall 'x, 'y. 'x -> 'y
//│        <: 'w -> 'z
//│     't <: 's & 'u
//│     'u :> 'v
//│     'v :> forall 'id1, 't, 'c, 'e, 'u. 't -> 'u | 'id1
//│        <: 's -> 'v
//│     'q <: 'o & 'p
//│     'p :> 'r
//│     'r :> forall 'p, 'id1, 'q, 'c, 'e. 'q -> 'p | 'id1
//│        <: 'o -> 'r
//│     'l <: 'k & 'm
//│     'm :> 'n
//│     'n :> forall 'id1, 'c, 'l, 'e, 'm. 'l -> 'm | 'id1
//│        <: 'k -> 'n
//│     'h <: 'g & 'i
//│     'i :> 'j
//│     'j :> forall 'id1, 'h, 'c, 'i, 'e. 'h -> 'i | 'id1
//│        <: 'g -> 'j
//│     'id1 :> forall 'a1. ('e & 'a1) -> 'a1
//│     'a1 :> 'c
//│     'e :> 'id1
//│        <: 'c
//│     'c :> 'id1
//│        <: 'e -> 'c
//│ ║  l.588: 	rec def id1 x = if true then x else id1 id1 x
//│ ╙──       	                   ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Subtyping constraint of the form `forall ?a, ?b, ?c, ?d, ?e, ?f, ?id1, ?g, ?h, ?i, ?j, ?k, ?l, ?m, ?n, ?o, ?p, ?q, ?r, ?s, ?t, ?u. ?id1 <: (forall ?v, ?w, ?id10, ?x, ?y, ?z, ?a1, ?b1, ?c1, ?d1, ?e1, ?f1, ?g1, ?h1, ?i1, ?j1, ?k1, ?l1, ?m1, ?n1, ?o1, ?p1. ?id10) -> ?q1` exceeded recursion depth limit (250)
//│ ║  l.646: 	id1 id1
//│ ║         	^^^^^^^
//│ ╟── while constraining:  ‹∀ 0. id11832'#›  <!<  α1841_2129
//│ ╟── while constraining:  ‹∀ 0. id11832'#›  <!<  α1842_2148
//│ ╟── while constraining:  ‹∀ 0. id11832'#›  <!<  α6_2147
//│ ╟── while constraining:  ‹∀ 0. id11832'#›  <!<  α1833_2146
//│ ╟── while constraining:  ‹∀ 0. id11832'#›  <!<  α1840_2127
//│ ╟── while constraining:  ‹∀ 0. id11832'#›  <!<  α1833_2150
//│ ╟── while constraining:  α1840_2099  <!<  α1833_2150
//│ ╟── while constraining:  (α1840_2099,)  <!<  (α1833_2150,)
//│ ╟── while constraining:  (α1833_2150 -> α1842_2152)  <!<  ((α1840_2099,) -> α1841_2101)
//│ ╟── while constraining:  ‹∀ 1. (α1833_2126'' -> α1842_2128'')›  <!<  ((α1840_2099,) -> α1841_2101)
//│ ╟── while constraining:  id11832_2125#  <!<  ((α1840_2099,) -> α1841_2101)
//│ ╟── while constraining:  ‹∀ 0. id11832'#›  <!<  ((α1840_2099,) -> α1841_2101)
//│ ╟── while constraining:  ‹∀ 0. id11832'#›  <!<  α1838_2102
//│ ╟── while constraining:  ‹∀ 0. id11832'#›  <!<  α1841_2101
//│ ╟── while constraining:  ‹∀ 0. id11832'#›  <!<  α1842_2120
//│ ╟── ......
//│ ╟── ......
//│ ╟── while constraining:  ‹∀ 1. (α1833_2014'' -> α1842_2016'')›  <!<  ((α1840_1987,) -> α1841_1989)
//│ ╟── while constraining:  id11832_2013#  <!<  ((α1840_1987,) -> α1841_1989)
//│ ╟── while constraining:  ‹∀ 0. id11832'#›  <!<  ((α1840_1987,) -> α1841_1989)
//│ ╟── while constraining:  ‹∀ 0. id11832'#›  <!<  α1838_1990
//│ ╟── while constraining:  ‹∀ 0. id11832'#›  <!<  α1841_1989
//│ ╟── while constraining:  ‹∀ 0. id11832'#›  <!<  α1842_2008
//│ ╟── while constraining:  ‹∀ 0. id11832'#›  <!<  α6_2007
//│ ╟── while constraining:  ‹∀ 0. id11832'#›  <!<  α1833_2006
//│ ╟── while constraining:  ‹∀ 0. id11832'#›  <!<  α1840_1987
//│ ╟── while constraining:  ‹∀ 0. id11832'#›  <!<  α1833_2010
//│ ╟── while constraining:  (‹∀ 0. id11832'#›,)  <!<  (α1833_2010,)
//│ ╟── while constraining:  (α1833_2010 -> α1842_2012)  <!<  ((‹∀ 0. id11832'#›,) -> α1984)
//│ ╟── while constraining:  ‹∀ 1. (α1833_1986'' -> α1842_1988'')›  <!<  ((‹∀ 0. id11832'#›,) -> α1984)
//│ ╟── while constraining:  id11832_1985#  <!<  ((‹∀ 0. id11832'#›,) -> α1984)
//│ ╙── while constraining:  ‹∀ 0. id11832'#›  <!<  ((‹∀ 0. id11832'#›,) -> α1984)
//│ res: error
//│    = [Function: id11]

// Gn
:e
auto auto
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.733: 	auto auto
//│ ║         	^^^^^^^^^
//│ ╟── type `‘a_2445` is not a function
//│ ║  l.164: 	def auto : (forall 'a. 'a -> 'a) -> (forall 'b. 'b -> 'b)
//│ ║         	                   ^^
//│ ╟── Note: constraint arises from function type:
//│ ║  l.164: 	def auto : (forall 'a. 'a -> 'a) -> (forall 'b. 'b -> 'b)
//│ ╙──       	                       ^^^^^^^^
//│ res: 'b -> 'b | error
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded

// Gn+1
:e
(fun x -> x x) (fun x -> x x)
//│ ╔══[ERROR] Subtyping constraint of the form `forall ?a, ?b. ?a -> ?b <: (forall ?c, ?d. ?c -> ?d) -> ?e` exceeded recursion depth limit (250)
//│ ║  l.749: 	(fun x -> x x) (fun x -> x x)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── while constraining:  ‹∀ 0. (α2456_2458' -> α2457_2459')›  <!<  α2456_2479
//│ ╟── while constraining:  α2456_2477  <!<  α2456_2479
//│ ╟── while constraining:  (α2456_2477,)  <!<  (α2456_2479,)
//│ ╟── while constraining:  (α2456_2479 -> α2457_2480)  <!<  ((α2456_2477,) -> α2457_2478)
//│ ╟── while constraining:  ‹∀ 0. (α2456_2458' -> α2457_2459')›  <!<  ((α2456_2477,) -> α2457_2478)
//│ ╟── while constraining:  ‹∀ 0. (α2456_2458' -> α2457_2459')›  <!<  α2456_2477
//│ ╟── while constraining:  α2456_2475  <!<  α2456_2477
//│ ╟── while constraining:  (α2456_2475,)  <!<  (α2456_2477,)
//│ ╟── while constraining:  (α2456_2477 -> α2457_2478)  <!<  ((α2456_2475,) -> α2457_2476)
//│ ╟── while constraining:  ‹∀ 0. (α2456_2458' -> α2457_2459')›  <!<  ((α2456_2475,) -> α2457_2476)
//│ ╟── while constraining:  ‹∀ 0. (α2456_2458' -> α2457_2459')›  <!<  α2456_2475
//│ ╟── while constraining:  α2456_2473  <!<  α2456_2475
//│ ╟── while constraining:  (α2456_2473,)  <!<  (α2456_2475,)
//│ ╟── while constraining:  (α2456_2475 -> α2457_2476)  <!<  ((α2456_2473,) -> α2457_2474)
//│ ╟── while constraining:  ‹∀ 0. (α2456_2458' -> α2457_2459')›  <!<  ((α2456_2473,) -> α2457_2474)
//│ ╟── ......
//│ ╟── ......
//│ ╟── while constraining:  ‹∀ 0. (α2456_2458' -> α2457_2459')›  <!<  ((α2456_2465,) -> α2457_2466)
//│ ╟── while constraining:  ‹∀ 0. (α2456_2458' -> α2457_2459')›  <!<  α2456_2465
//│ ╟── while constraining:  α2456_2463  <!<  α2456_2465
//│ ╟── while constraining:  (α2456_2463,)  <!<  (α2456_2465,)
//│ ╟── while constraining:  (α2456_2465 -> α2457_2466)  <!<  ((α2456_2463,) -> α2457_2464)
//│ ╟── while constraining:  ‹∀ 0. (α2456_2458' -> α2457_2459')›  <!<  ((α2456_2463,) -> α2457_2464)
//│ ╟── while constraining:  ‹∀ 0. (α2456_2458' -> α2457_2459')›  <!<  α2456_2463
//│ ╟── while constraining:  α2452_2461  <!<  α2456_2463
//│ ╟── while constraining:  (α2452_2461,)  <!<  (α2456_2463,)
//│ ╟── while constraining:  (α2456_2463 -> α2457_2464)  <!<  ((α2452_2461,) -> α2453_2462)
//│ ╟── while constraining:  ‹∀ 0. (α2456_2458' -> α2457_2459')›  <!<  ((α2452_2461,) -> α2453_2462)
//│ ╟── while constraining:  ‹∀ 0. (α2456_2458' -> α2457_2459')›  <!<  α2452_2461
//│ ╟── while constraining:  (‹∀ 0. (α2456_2458' -> α2457_2459')›,)  <!<  (α2452_2461,)
//│ ╟── while constraining:  (α2452_2461 -> α2453_2462)  <!<  ((‹∀ 0. (α2456_2458' -> α2457_2459')›,) -> α2460)
//│ ╙── while constraining:  ‹∀ 0. (α2452_2454' -> α2453_2455')›  <!<  ((‹∀ 0. (α2456_2458' -> α2457_2459')›,) -> α2460)
//│ res: error
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded

:e
:re
// Gn+2
(fun x -> x x) (fun x -> x x)!
//│ ╔══[ERROR] Inferred recursive type: 'a
//│   where
//│     'a := 'a -> 'b
//│ ╙──
//│ res: nothing
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded



// ===========================================================
// ======================== SuperF +D ========================
// ===========================================================

:DistributeForalls


// ============ A. polymorphic instantiation ============

// A1
fun x -> fun y -> y
//│ res: anything -> 'a -> 'a
//│    = [Function: res]

// A2
choose id
//│ res: 'a -> (forall 'a0. 'a | 'a0 -> 'a0)
//│    = [Function (anonymous)]

// A3
choose nil ids
//│ res: List[forall 'a. 'a -> 'a]
//│    = Nil {}

// A4
fun x -> x x
//│ res: ('a -> 'b & 'a) -> 'b
//│    = [Function: res]

// A5
id auto
//│ res: (forall 'a. 'a -> 'a) -> (forall 'b. 'b -> 'b)
//│    = [Function: auto]

// A6
id auto_
//│ res: (forall 'a. 'a -> 'a) -> 'b -> 'b
//│    = [Function: auto_]

// A7
choose id auto
//│ res: (forall 'a. 'a -> 'a & 'a0) -> ('a0 | 'b -> 'b)
//│    = [Function: id1]

// A8
:ns
choose id auto_
//│ res: 'c
//│   where
//│     'c :> (forall 'a. 'a -> 'a) | (forall 'b. (forall 'a0. 'a0 -> 'a0) -> 'b -> 'b)
//│    = [Function: id1]

// A9
:ng
f (choose id) ids
//│ res: 'a -> 'a

// A10
poly id
//│ res: (int, bool,)
//│    = [ 1, true ]

// A11
poly (fun x -> x)
//│ res: (int, bool,)
//│    = [ 1, true ]

// A12
id poly (fun x -> x)
//│ res: (int, bool,)
//│    = [ 1, true ]


// ============ B. inference of polymorphic arguments ============

// B1
fun f -> (f 1, f true)
//│ res: (true -> 'a & 1 -> 'b) -> ('b, 'a,)
//│    = [Function: res]

// B2
fun xs -> poly (head xs)
//│ res: List[forall 'a. 'a -> 'a] -> (int, bool,)
//│    = [Function: res]


// ============ C. functions on polymorphic lists ============

// C1
length ids
//│ res: int
//│    = 1

// C2
tail ids
//│ res: List[forall 'a. 'a -> 'a]
//│    = Nil {}

// C3
head ids
//│ res: 'a -> 'a
//│    = [Function: id1]

// C4
single id
//│ res: List[forall 'a. 'a -> 'a]
//│    = Cons { head: [Function: id1], tail: Nil {} }

// C5
cons id ids
//│ res: List[forall 'a. 'a -> 'a]
//│    = Cons {
//│        head: [Function: id1],
//│        tail: Cons { head: [Function: id1], tail: Nil {} }
//│      }

// C6
cons (fun x -> x) ids
//│ res: List[forall 'a. 'a -> 'a]
//│    = Cons {
//│        head: [Function (anonymous)],
//│        tail: Cons { head: [Function: id1], tail: Nil {} }
//│      }

// C7
append (single inc) (single id)
//│ res: List[int -> int]
//│    = Cons {
//│        head: [Function: succ],
//│        tail: Cons { head: [Function: id1], tail: Nil {} }
//│      }

// C8
:ng
g (single id) ids
//│ res: 'a -> 'a

// C9
map poly (single id)
//│ res: List[(int, bool,)]
//│    = Cons { head: [ 1, true ], tail: Nil {} }

// C10
map head (single ids)
//│ res: List[forall 'a. 'a -> 'a]
//│    = Cons { head: [Function: id1], tail: Nil {} }


// ============ D. application functions ============

// D1
app poly id
//│ res: (int, bool,)
//│    = [ 1, true ]

// D2
revapp id poly
//│ res: (int, bool,)
//│    = [ 1, true ]

// D3
:ng
runST argST
//│ res: int

// D4
:ng
app runST argST
//│ res: int

// D5
:ng
revapp argST runST
//│ res: int


// ============ E. η-expansion ============

// E1
:ng
k h lst
//│ res: int -> 'a -> 'a

// E2
:ng
k (fun x -> h x) lst
//│ res: int -> 'a -> 'a

// E3
:ng
r (fun x -> fun y -> y)
//│ res: int


// ============ F. FreezeML Additions ============

// F5
auto id
//│ res: 'b -> 'b
//│    = [Function: id1]

// F6
cons (head ids) ids
//│ res: List[forall 'a. 'a -> 'a]
//│    = Cons {
//│        head: [Function: id1],
//│        tail: Cons { head: [Function: id1], tail: Nil {} }
//│      }

// F7
(head ids) 3
//│ res: 3
//│    = 3

// F8
choose (head ids)
//│ res: 'a -> (forall 'a0. 'a | 'a0 -> 'a0)
//│    = [Function (anonymous)]

// F9
let f = revapp id in f poly
//│ res: (int, bool,)
//│    = [ 1, true ]

// F10
choose id (fun x -> auto_ x)
//│ res: (forall 'a. 'a -> 'a & 'a0) -> ('a0 | 'b -> 'b)
//│    = [Function: id1]


// ============ G. SuperF Additions ============

// G1
def z f x = x
//│ z: anything -> 'a -> 'a
//│  = [Function: z1]

// G2
def s n f x = f (n f x)
//│ s: ('a -> 'b -> 'c) -> ('c -> 'd & 'a) -> 'b -> 'd
//│  = [Function: s1]

// G3
n3 = s (s (s z))
//│ n3: ('a -> 'b & 'c -> 'a & 'd -> 'c) -> 'd -> 'b
//│   = [Function (anonymous)]

// G1A
z: ChurchInt
//│ res: ChurchInt
//│    = [Function: z1]

// G2A
s: ChurchInt -> ChurchInt
//│ res: ChurchInt -> ChurchInt
//│    = [Function: s1]

// G3A
n3: ChurchInt
//│ res: ChurchInt
//│    = [Function (anonymous)]

// G4
fst (fst (fst (n3 (fun x -> (x, 0)) 1)))
//│ res: 1
//│    = 1

(succ (succ zero)) (succ (succ zero))
//│ res: ('M -> 'M) -> 'M -> 'M
//│    = [Function (anonymous)]

(s (s z)) (s (s z))
//│ res: (('a | 'b) -> 'b & 'c -> 'a) -> 'c -> 'b
//│   where
//│     'c :> 'a | 'b
//│    = [Function (anonymous)]

// G7
rec def to_ch n = if n == 0 then z else s (to_ch (n - 1))
//│ to_ch: int -> ('a -> 'b & 'a -> 'a) -> ('a & 'b) -> 'b
//│      = [Function: to_ch1]

// G7A
to_ch: int -> ChurchInt
//│ res: int -> ChurchInt
//│    = [Function: to_ch1]

:e
// G8
rec def id1 x = if true then x else id1 id1 x
//│ ╔══[ERROR] Inferred recursive type: 'a
//│   where
//│     'a :> forall 'b, 'c. 'b -> 'c
//│        <: 'd -> 'a
//│     'b <: 'd & 'c
//│     'd :> forall 'b, 'c. 'b -> 'c
//│        <: 'a
//│     'c :> 'a
//│ ║  l.1092: 	rec def id1 x = if true then x else id1 id1 x
//│ ╙──        	                                    ^^^^^^^
//│ ╔══[ERROR] Subtyping constraint of the form `forall ?a, ?b, ?c. ?b -> ?c <: ?id1` exceeded recursion depth limit (250)
//│ ║  l.1092: 	rec def id1 x = if true then x else id1 id1 x
//│ ║          	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── while constraining:  ‹∀ 1. (α3481_3491'' -> α3490_3493'')›  <!<  α3481_3512'
//│ ╟── while constraining:  α3488'  <!<  α3481_3512'
//│ ╟── while constraining:  (α3488',)  <!<  (α3481_3512',)
//│ ╟── while constraining:  (α3481_3512' -> α3490_3514')  <!<  ((α3488',) -> α3489')
//│ ╟── while constraining:  ‹∀ 1. (α3481_3491'' -> α3490_3493'')›  <!<  ((α3488',) -> α3489')
//│ ╟── while constraining:  ‹∀ 1. (α3481_3491'' -> α3490_3493'')›  <!<  α3486'
//│ ╟── while constraining:  ‹∀ 1. (α3481_3491'' -> α3490_3493'')›  <!<  α3489'
//│ ╟── while constraining:  ‹∀ 1. (α3481_3491'' -> α3490_3493'')›  <!<  α3490_3499'
//│ ╟── while constraining:  ‹∀ 1. (α3481_3491'' -> α3490_3493'')›  <!<  α6_3498'
//│ ╟── while constraining:  ‹∀ 1. (α3481_3491'' -> α3490_3493'')›  <!<  α3481_3497'
//│ ╟── while constraining:  ‹∀ 1. (α3481_3491'' -> α3490_3493'')›  <!<  α3488'
//│ ╟── while constraining:  ‹∀ 1. (α3481_3491'' -> α3490_3493'')›  <!<  α3481_3509'
//│ ╟── while constraining:  α3488'  <!<  α3481_3509'
//│ ╟── while constraining:  (α3488',)  <!<  (α3481_3509',)
//│ ╟── while constraining:  (α3481_3509' -> α3490_3511')  <!<  ((α3488',) -> α3489')
//│ ╟── ......
//│ ╟── ......
//│ ╟── while constraining:  ‹∀ 1. (α3481_3491'' -> α3490_3493'')›  <!<  α3490_3499'
//│ ╟── while constraining:  ‹∀ 1. (α3481_3491'' -> α3490_3493'')›  <!<  α6_3498'
//│ ╟── while constraining:  ‹∀ 1. (α3481_3491'' -> α3490_3493'')›  <!<  α3481_3497'
//│ ╟── while constraining:  ‹∀ 1. (α3481_3491'' -> α3490_3493'')›  <!<  α3488'
//│ ╟── while constraining:  ‹∀ 1. (α3481_3491'' -> α3490_3493'')›  <!<  α3481_3500'
//│ ╟── while constraining:  α3488'  <!<  α3481_3500'
//│ ╟── while constraining:  (α3488',)  <!<  (α3481_3500',)
//│ ╟── while constraining:  (α3481_3500' -> α3490_3502')  <!<  ((α3488',) -> α3489')
//│ ╟── while constraining:  ‹∀ 1. (α3481_3491'' -> α3490_3493'')›  <!<  ((α3488',) -> α3489')
//│ ╟── while constraining:  ‹∀ 1. (α3481_3491'' -> α3490_3493'')›  <!<  α3486'
//│ ╟── while constraining:  α3489'  <!<  α3486'
//│ ╟── while constraining:  α3490_3496'  <!<  α3486'
//│ ╟── while constraining:  (α3481_3494' -> α3490_3496')  <!<  ((id13480',) -> α3486')
//│ ╟── while constraining:  ‹∀ 1. (α3481_3491'' -> α3490_3493'')›  <!<  ((id13480',) -> α3486')
//│ ╙── while constraining:  ‹∀ 1. (α3481_3491'' -> α3490_3493'')›  <!<  id13480'
//│ id1: 'id1
//│   where
//│     'id1 :> forall 'a. ('b & 'a) -> 'a
//│     'a :> 'c
//│     'b :> 'id1
//│        <: 'c
//│     'c :> 'id1
//│        <: 'b -> 'c
//│    = [Function: id12]

:e
// G9
id1 id1
//│ ╔══[ERROR] Inferred recursive type: 'a
//│   where
//│     'a :> 'b
//│     'b :> forall 'c, 'a, 'd, 'id1, 'e. 'd -> 'a | 'id1
//│        <: 'f -> 'b
//│     'd <: 'a & 'f
//│     'f :> forall 'c, 'a, 'd, 'id1, 'e. 'd -> 'a | 'id1
//│        <: 'b & 'g
//│     'g :> forall 'c, 'h, 'i, 'id1, 'e. 'h -> 'i | 'id1
//│        <: 'j & 'k
//│     'k :> forall 'c, 'l, 'm, 'id1, 'e. 'l -> 'm | 'id1
//│        <: 'n & 'o
//│     'o :> forall 'c, 'p, 'q, 'id1, 'e. 'q -> 'p | 'id1
//│        <: 'r & 's
//│     's :> forall 'c, 't, 'id1, 'e, 'u. 't -> 'u | 'id1
//│        <: 'v & 'w
//│     'w :> forall 'id1, 'e, 'c, 'x. 'x -> 'y | 'id1
//│        <: 'z
//│     'x <: 'w & 'y
//│     'y :> 'z
//│     'z :> forall 'x, 'y. 'x -> 'y
//│        <: 'w -> 'z
//│     't <: 's & 'u
//│     'u :> 'v
//│     'v :> forall 'c, 't, 'id1, 'e, 'u. 't -> 'u | 'id1
//│        <: 's -> 'v
//│     'q <: 'o & 'p
//│     'p :> 'r
//│     'r :> forall 'c, 'p, 'q, 'id1, 'e. 'q -> 'p | 'id1
//│        <: 'o -> 'r
//│     'l <: 'k & 'm
//│     'm :> 'n
//│     'n :> forall 'c, 'l, 'm, 'id1, 'e. 'l -> 'm | 'id1
//│        <: 'k -> 'n
//│     'h <: 'g & 'i
//│     'i :> 'j
//│     'j :> forall 'c, 'h, 'i, 'id1, 'e. 'h -> 'i | 'id1
//│        <: 'g -> 'j
//│     'id1 :> forall 'a1. ('e & 'a1) -> 'a1
//│     'a1 :> 'c
//│     'e :> 'id1
//│        <: 'c
//│     'c :> 'id1
//│        <: 'e -> 'c
//│ ║  l.1092: 	rec def id1 x = if true then x else id1 id1 x
//│ ╙──        	                   ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Subtyping constraint of the form `forall ?a, ?b, ?c, ?d, ?e, ?f, ?g, ?h, ?i, ?j, ?k, ?l, ?m, ?n, ?o, ?p, ?q, ?id1, ?r, ?s, ?t, ?u. ?id1 <: (forall ?v, ?w, ?x, ?y, ?z, ?a1, ?b1, ?c1, ?d1, ?e1, ?f1, ?g1, ?h1, ?id10, ?i1, ?j1, ?k1, ?l1, ?m1, ?n1, ?o1, ?p1. ?id10) -> ?q1` exceeded recursion depth limit (250)
//│ ║  l.1150: 	id1 id1
//│ ║          	^^^^^^^
//│ ╟── while constraining:  ‹∀ 0. id13480'#›  <!<  α3489_3777
//│ ╟── while constraining:  ‹∀ 0. id13480'#›  <!<  α3490_3796
//│ ╟── while constraining:  ‹∀ 0. id13480'#›  <!<  α6_3795
//│ ╟── while constraining:  ‹∀ 0. id13480'#›  <!<  α3481_3794
//│ ╟── while constraining:  ‹∀ 0. id13480'#›  <!<  α3488_3775
//│ ╟── while constraining:  ‹∀ 0. id13480'#›  <!<  α3481_3798
//│ ╟── while constraining:  α3488_3747  <!<  α3481_3798
//│ ╟── while constraining:  (α3488_3747,)  <!<  (α3481_3798,)
//│ ╟── while constraining:  (α3481_3798 -> α3490_3800)  <!<  ((α3488_3747,) -> α3489_3749)
//│ ╟── while constraining:  ‹∀ 1. (α3481_3774'' -> α3490_3776'')›  <!<  ((α3488_3747,) -> α3489_3749)
//│ ╟── while constraining:  id13480_3773#  <!<  ((α3488_3747,) -> α3489_3749)
//│ ╟── while constraining:  ‹∀ 0. id13480'#›  <!<  ((α3488_3747,) -> α3489_3749)
//│ ╟── while constraining:  ‹∀ 0. id13480'#›  <!<  α3486_3750
//│ ╟── while constraining:  ‹∀ 0. id13480'#›  <!<  α3489_3749
//│ ╟── while constraining:  ‹∀ 0. id13480'#›  <!<  α3490_3768
//│ ╟── ......
//│ ╟── ......
//│ ╟── while constraining:  ‹∀ 1. (α3481_3662'' -> α3490_3664'')›  <!<  ((α3488_3635,) -> α3489_3637)
//│ ╟── while constraining:  id13480_3661#  <!<  ((α3488_3635,) -> α3489_3637)
//│ ╟── while constraining:  ‹∀ 0. id13480'#›  <!<  ((α3488_3635,) -> α3489_3637)
//│ ╟── while constraining:  ‹∀ 0. id13480'#›  <!<  α3486_3638
//│ ╟── while constraining:  ‹∀ 0. id13480'#›  <!<  α3489_3637
//│ ╟── while constraining:  ‹∀ 0. id13480'#›  <!<  α3490_3656
//│ ╟── while constraining:  ‹∀ 0. id13480'#›  <!<  α6_3655
//│ ╟── while constraining:  ‹∀ 0. id13480'#›  <!<  α3481_3654
//│ ╟── while constraining:  ‹∀ 0. id13480'#›  <!<  α3488_3635
//│ ╟── while constraining:  ‹∀ 0. id13480'#›  <!<  α3481_3658
//│ ╟── while constraining:  (‹∀ 0. id13480'#›,)  <!<  (α3481_3658,)
//│ ╟── while constraining:  (α3481_3658 -> α3490_3660)  <!<  ((‹∀ 0. id13480'#›,) -> α3632)
//│ ╟── while constraining:  ‹∀ 1. (α3481_3634'' -> α3490_3636'')›  <!<  ((‹∀ 0. id13480'#›,) -> α3632)
//│ ╟── while constraining:  id13480_3633#  <!<  ((‹∀ 0. id13480'#›,) -> α3632)
//│ ╙── while constraining:  ‹∀ 0. id13480'#›  <!<  ((‹∀ 0. id13480'#›,) -> α3632)
//│ res: error
//│    = [Function: id12]

// Gn
:e
auto auto
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.1237: 	auto auto
//│ ║          	^^^^^^^^^
//│ ╟── type `‘a_4093` is not a function
//│ ║  l.164: 	def auto : (forall 'a. 'a -> 'a) -> (forall 'b. 'b -> 'b)
//│ ║         	                   ^^
//│ ╟── Note: constraint arises from function type:
//│ ║  l.164: 	def auto : (forall 'a. 'a -> 'a) -> (forall 'b. 'b -> 'b)
//│ ╙──       	                       ^^^^^^^^
//│ res: 'b -> 'b | error
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded

// Gn+1
:e
(fun x -> x x) (fun x -> x x)
//│ ╔══[ERROR] Subtyping constraint of the form `forall ?a, ?b. ?a -> ?b <: (forall ?c, ?d. ?c -> ?d) -> ?e` exceeded recursion depth limit (250)
//│ ║  l.1253: 	(fun x -> x x) (fun x -> x x)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── while constraining:  ‹∀ 0. (α4104_4106' -> α4105_4107')›  <!<  α4104_4127
//│ ╟── while constraining:  α4104_4125  <!<  α4104_4127
//│ ╟── while constraining:  (α4104_4125,)  <!<  (α4104_4127,)
//│ ╟── while constraining:  (α4104_4127 -> α4105_4128)  <!<  ((α4104_4125,) -> α4105_4126)
//│ ╟── while constraining:  ‹∀ 0. (α4104_4106' -> α4105_4107')›  <!<  ((α4104_4125,) -> α4105_4126)
//│ ╟── while constraining:  ‹∀ 0. (α4104_4106' -> α4105_4107')›  <!<  α4104_4125
//│ ╟── while constraining:  α4104_4123  <!<  α4104_4125
//│ ╟── while constraining:  (α4104_4123,)  <!<  (α4104_4125,)
//│ ╟── while constraining:  (α4104_4125 -> α4105_4126)  <!<  ((α4104_4123,) -> α4105_4124)
//│ ╟── while constraining:  ‹∀ 0. (α4104_4106' -> α4105_4107')›  <!<  ((α4104_4123,) -> α4105_4124)
//│ ╟── while constraining:  ‹∀ 0. (α4104_4106' -> α4105_4107')›  <!<  α4104_4123
//│ ╟── while constraining:  α4104_4121  <!<  α4104_4123
//│ ╟── while constraining:  (α4104_4121,)  <!<  (α4104_4123,)
//│ ╟── while constraining:  (α4104_4123 -> α4105_4124)  <!<  ((α4104_4121,) -> α4105_4122)
//│ ╟── while constraining:  ‹∀ 0. (α4104_4106' -> α4105_4107')›  <!<  ((α4104_4121,) -> α4105_4122)
//│ ╟── ......
//│ ╟── ......
//│ ╟── while constraining:  ‹∀ 0. (α4104_4106' -> α4105_4107')›  <!<  ((α4104_4113,) -> α4105_4114)
//│ ╟── while constraining:  ‹∀ 0. (α4104_4106' -> α4105_4107')›  <!<  α4104_4113
//│ ╟── while constraining:  α4104_4111  <!<  α4104_4113
//│ ╟── while constraining:  (α4104_4111,)  <!<  (α4104_4113,)
//│ ╟── while constraining:  (α4104_4113 -> α4105_4114)  <!<  ((α4104_4111,) -> α4105_4112)
//│ ╟── while constraining:  ‹∀ 0. (α4104_4106' -> α4105_4107')›  <!<  ((α4104_4111,) -> α4105_4112)
//│ ╟── while constraining:  ‹∀ 0. (α4104_4106' -> α4105_4107')›  <!<  α4104_4111
//│ ╟── while constraining:  α4100_4109  <!<  α4104_4111
//│ ╟── while constraining:  (α4100_4109,)  <!<  (α4104_4111,)
//│ ╟── while constraining:  (α4104_4111 -> α4105_4112)  <!<  ((α4100_4109,) -> α4101_4110)
//│ ╟── while constraining:  ‹∀ 0. (α4104_4106' -> α4105_4107')›  <!<  ((α4100_4109,) -> α4101_4110)
//│ ╟── while constraining:  ‹∀ 0. (α4104_4106' -> α4105_4107')›  <!<  α4100_4109
//│ ╟── while constraining:  (‹∀ 0. (α4104_4106' -> α4105_4107')›,)  <!<  (α4100_4109,)
//│ ╟── while constraining:  (α4100_4109 -> α4101_4110)  <!<  ((‹∀ 0. (α4104_4106' -> α4105_4107')›,) -> α4108)
//│ ╙── while constraining:  ‹∀ 0. (α4100_4102' -> α4101_4103')›  <!<  ((‹∀ 0. (α4104_4106' -> α4105_4107')›,) -> α4108)
//│ res: error
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded

:e
:re
// Gn+2
(fun x -> x x) (fun x -> x x)!
//│ ╔══[ERROR] Inferred recursive type: 'a
//│   where
//│     'a := 'a -> 'b
//│ ╙──
//│ res: nothing
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded



// ==============================================================
// ======================== SuperF +D+CC ========================
// ==============================================================

:CycleCheck


// ============ A. polymorphic instantiation ============

// A1
fun x -> fun y -> y
//│ res: anything -> 'a -> 'a
//│    = [Function: res]

// A2
choose id
//│ res: 'a -> (forall 'a0. 'a | 'a0 -> 'a0)
//│    = [Function (anonymous)]

// A3
choose nil ids
//│ res: List[forall 'a. 'a -> 'a]
//│    = Nil {}

// A4
fun x -> x x
//│ res: ('a -> 'b & 'a) -> 'b
//│    = [Function: res]

// A5
id auto
//│ res: (forall 'a. 'a -> 'a) -> (forall 'b. 'b -> 'b)
//│    = [Function: auto]

// A6
id auto_
//│ res: (forall 'a. 'a -> 'a) -> 'b -> 'b
//│    = [Function: auto_]

// A7
choose id auto
//│ res: (forall 'a. 'a -> 'a & 'a0) -> ('a0 | 'b -> 'b)
//│    = [Function: id1]

// A8
:ns
choose id auto_
//│ res: 'c
//│   where
//│     'c :> (forall 'a. 'a -> 'a) | (forall 'b. (forall 'a0. 'a0 -> 'a0) -> 'b -> 'b)
//│    = [Function: id1]

// A9
:ng
f (choose id) ids
//│ res: 'a -> 'a

// A10
poly id
//│ res: (int, bool,)
//│    = [ 1, true ]

// A11
poly (fun x -> x)
//│ res: (int, bool,)
//│    = [ 1, true ]

// A12
id poly (fun x -> x)
//│ res: (int, bool,)
//│    = [ 1, true ]


// ============ B. inference of polymorphic arguments ============

// B1
fun f -> (f 1, f true)
//│ res: (true -> 'a & 1 -> 'b) -> ('b, 'a,)
//│    = [Function: res]

// B2
fun xs -> poly (head xs)
//│ res: List[forall 'a. 'a -> 'a] -> (int, bool,)
//│    = [Function: res]


// ============ C. functions on polymorphic lists ============

// C1
length ids
//│ res: int
//│    = 1

// C2
tail ids
//│ res: List[forall 'a. 'a -> 'a]
//│    = Nil {}

// C3
head ids
//│ res: 'a -> 'a
//│    = [Function: id1]

// C4
single id
//│ res: List[forall 'a. 'a -> 'a]
//│    = Cons { head: [Function: id1], tail: Nil {} }

// C5
cons id ids
//│ res: List[forall 'a. 'a -> 'a]
//│    = Cons {
//│        head: [Function: id1],
//│        tail: Cons { head: [Function: id1], tail: Nil {} }
//│      }

// C6
cons (fun x -> x) ids
//│ res: List[forall 'a. 'a -> 'a]
//│    = Cons {
//│        head: [Function (anonymous)],
//│        tail: Cons { head: [Function: id1], tail: Nil {} }
//│      }

// C7
append (single inc) (single id)
//│ res: List[int -> int]
//│    = Cons {
//│        head: [Function: succ],
//│        tail: Cons { head: [Function: id1], tail: Nil {} }
//│      }

// C8
:ng
g (single id) ids
//│ res: 'a -> 'a

// C9
map poly (single id)
//│ res: List[(int, bool,)]
//│    = Cons { head: [ 1, true ], tail: Nil {} }

// C10
map head (single ids)
//│ res: List[forall 'a. 'a -> 'a]
//│    = Cons { head: [Function: id1], tail: Nil {} }


// ============ D. application functions ============

// D1
app poly id
//│ res: (int, bool,)
//│    = [ 1, true ]

// D2
revapp id poly
//│ res: (int, bool,)
//│    = [ 1, true ]

// D3
:ng
runST argST
//│ res: int

// D4
:ng
app runST argST
//│ res: int

// D5
:ng
revapp argST runST
//│ res: int


// ============ E. η-expansion ============

// E1
:ng
k h lst
//│ res: int -> 'a -> 'a

// E2
:ng
k (fun x -> h x) lst
//│ res: int -> 'a -> 'a

// E3
:ng
r (fun x -> fun y -> y)
//│ res: int


// ============ F. FreezeML Additions ============

// F5
auto id
//│ res: 'b -> 'b
//│    = [Function: id1]

// F6
cons (head ids) ids
//│ res: List[forall 'a. 'a -> 'a]
//│    = Cons {
//│        head: [Function: id1],
//│        tail: Cons { head: [Function: id1], tail: Nil {} }
//│      }

// F7
(head ids) 3
//│ res: 3
//│    = 3

// F8
choose (head ids)
//│ res: 'a -> (forall 'a0. 'a | 'a0 -> 'a0)
//│    = [Function (anonymous)]

// F9
let f = revapp id in f poly
//│ res: (int, bool,)
//│    = [ 1, true ]

// F10
choose id (fun x -> auto_ x)
//│ res: (forall 'a. 'a -> 'a & 'a0) -> ('a0 | 'b -> 'b)
//│    = [Function: id1]


// ============ G. SuperF Additions ============

// G1
def z f x = x
//│ z: anything -> 'a -> 'a
//│  = [Function: z2]

// G2
def s n f x = f (n f x)
//│ s: ('a -> 'b -> 'c) -> ('c -> 'd & 'a) -> 'b -> 'd
//│  = [Function: s2]

// G3
n3 = s (s (s z))
//│ n3: ('a -> 'b & 'c -> 'a & 'd -> 'c) -> 'd -> 'b
//│   = [Function (anonymous)]

// G1A
z: ChurchInt
//│ res: ChurchInt
//│    = [Function: z2]

// G2A
s: ChurchInt -> ChurchInt
//│ res: ChurchInt -> ChurchInt
//│    = [Function: s2]

// G3A
n3: ChurchInt
//│ res: ChurchInt
//│    = [Function (anonymous)]

// G4
fst (fst (fst (n3 (fun x -> (x, 0)) 1)))
//│ res: 1
//│    = 1

(succ (succ zero)) (succ (succ zero))
//│ res: ('M -> 'M) -> 'M -> 'M
//│    = [Function (anonymous)]

:e
(s (s z)) (s (s z))
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.1579: 	(s (s z)) (s (s z))
//│ ║          	^^^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 4. α4551_4887'''''›  <:  α4544_4908    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 4. α4551_4887'''''›  <:  α4544_4905''''
//│ res: (('a | 'b) -> 'b & 'c -> 'a) -> 'c -> 'b | error
//│   where
//│     'c :> 'a | 'b
//│    = [Function (anonymous)]

// G7
rec def to_ch n = if n == 0 then z else s (to_ch (n - 1))
//│ to_ch: int -> ('a -> 'b & 'a -> 'a) -> ('a & 'b) -> 'b
//│      = [Function: to_ch2]

// G7A
to_ch: int -> ChurchInt
//│ res: int -> ChurchInt
//│    = [Function: to_ch2]

:e
// G8
rec def id1 x = if true then x else id1 id1 x
//│ ╔══[ERROR] Inferred recursive type: 'a
//│   where
//│     'a :> forall 'b, 'c. 'b -> 'c
//│        <: 'd -> 'a
//│     'b <: 'd & 'c
//│     'd :> forall 'b, 'c. 'b -> 'c
//│        <: 'a
//│     'c :> 'a
//│ ║  l.1603: 	rec def id1 x = if true then x else id1 id1 x
//│ ╙──        	                                    ^^^^^^^
//│ ╔══[ERROR] Cyclic-looking constraint while typing binding of lambda expression; a type annotation may be required
//│ ║  l.1603: 	rec def id1 x = if true then x else id1 id1 x
//│ ║          	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 1. (α5129_5139'' -> α5138_5141'')›  <:  α5129_5145'    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 1. (α5129_5139'' -> α5138_5141'')›  <:  α5129_5139''
//│ ╔══[ERROR] Cyclic-looking constraint while typing binding of lambda expression; a type annotation may be required
//│ ║  l.1603: 	rec def id1 x = if true then x else id1 id1 x
//│ ║          	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 1. (α5129_5139'' -> α5138_5141'')›  <:  α5129_5145'    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 1. (α5129_5139'' -> α5138_5141'')›  <:  α5129_5139''
//│ ╔══[ERROR] Cyclic-looking constraint while typing binding of lambda expression; a type annotation may be required
//│ ║  l.1603: 	rec def id1 x = if true then x else id1 id1 x
//│ ║          	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 1. (α5129_5139'' -> α5138_5141'')›  <:  α5134'    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 1. (α5129_5139'' -> α5138_5141'')›  <:  α5134'
//│ ╔══[ERROR] Cyclic-looking constraint while typing binding of lambda expression; a type annotation may be required
//│ ║  l.1603: 	rec def id1 x = if true then x else id1 id1 x
//│ ║          	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 1. (α5129_5139'' -> α5138_5141'')›  <:  α5134'    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 1. (α5129_5139'' -> α5138_5141'')›  <:  α5134'
//│ id1: 'id1
//│   where
//│     'id1 :> forall 'a. ('b & 'a) -> 'a
//│     'a :> 'c
//│     'b :> 'id1
//│        <: 'c
//│     'c :> 'id1
//│        <: 'b -> 'c
//│    = [Function: id13]

:e
// G9
id1 id1
//│ ╔══[ERROR] Inferred recursive type: 'a
//│   where
//│     'a :> 'b
//│     'b :> forall 'c, 'd, 'e, 'id1, 'a. 'c -> 'a | 'id1
//│        <: 'f -> 'b
//│     'c <: 'a & 'f
//│     'f :> forall 'c, 'd, 'e, 'id1, 'a. 'c -> 'a | 'id1
//│        <: 'b & 'g
//│     'g :> forall 'h, 'i, 'a, 'c. ('c & 'h) -> ('a | 'i)
//│        <: 'f & 'j
//│     'h <: 'g & 'i
//│     'i :> 'j
//│     'j :> forall 'h, 'i, 'a, 'c. ('c & 'h) -> ('a | 'i)
//│        <: 'g -> 'j
//│     'id1 :> forall 'k. ('e & 'k) -> 'k
//│     'k :> 'd
//│     'e :> 'id1
//│        <: 'd
//│     'd :> 'id1
//│        <: 'e -> 'd
//│ ║  l.1603: 	rec def id1 x = if true then x else id1 id1 x
//│ ╙──        	                   ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.1650: 	id1 id1
//│ ║          	^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 0. id15128'#›  <:  α5136_5211    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 0. id15128'#›  <:  α5136'
//│ res: error
//│    = [Function: id13]

// Gn
:e
auto auto
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.1684: 	auto auto
//│ ║          	^^^^^^^^^
//│ ╟── type `‘a_5303` is not a function
//│ ║  l.164: 	def auto : (forall 'a. 'a -> 'a) -> (forall 'b. 'b -> 'b)
//│ ║         	                   ^^
//│ ╟── Note: constraint arises from function type:
//│ ║  l.164: 	def auto : (forall 'a. 'a -> 'a) -> (forall 'b. 'b -> 'b)
//│ ╙──       	                       ^^^^^^^^
//│ res: 'b -> 'b | error
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded

// Gn+1
:e
(fun x -> x x) (fun x -> x x)
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.1700: 	(fun x -> x x) (fun x -> x x)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 0. (α5314_5316' -> α5315_5317')›  <:  α5314_5323    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 0. (α5314_5316' -> α5315_5317')›  <:  α5314_5316'
//│ res: error
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded

:e
:re
// Gn+2
(fun x -> x x) (fun x -> x x)!
//│ ╔══[ERROR] Inferred recursive type: 'a
//│   where
//│     'a := 'a -> 'b
//│ ╙──
//│ res: nothing
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded



// =================================================================
// ======================== SuperF +D+CC+RT ========================
// =================================================================

:RecursiveTypes


// ============ A. polymorphic instantiation ============

// A1
fun x -> fun y -> y
//│ res: anything -> 'a -> 'a
//│    = [Function: res]

// A2
choose id
//│ res: 'a -> (forall 'a0. 'a | 'a0 -> 'a0)
//│    = [Function (anonymous)]

// A3
choose nil ids
//│ res: List[forall 'a. 'a -> 'a]
//│    = Nil {}

// A4
fun x -> x x
//│ res: ('a -> 'b & 'a) -> 'b
//│    = [Function: res]

// A5
id auto
//│ res: (forall 'a. 'a -> 'a) -> (forall 'b. 'b -> 'b)
//│    = [Function: auto]

// A6
id auto_
//│ res: (forall 'a. 'a -> 'a) -> 'b -> 'b
//│    = [Function: auto_]

// A7
choose id auto
//│ res: (forall 'a. 'a -> 'a & 'a0) -> ('a0 | 'b -> 'b)
//│    = [Function: id1]

// A8
:ns
choose id auto_
//│ res: 'c
//│   where
//│     'c :> (forall 'a. 'a -> 'a) | (forall 'b. (forall 'a0. 'a0 -> 'a0) -> 'b -> 'b)
//│    = [Function: id1]

// A9
:ng
f (choose id) ids
//│ res: 'a -> 'a

// A10
poly id
//│ res: (int, bool,)
//│    = [ 1, true ]

// A11
poly (fun x -> x)
//│ res: (int, bool,)
//│    = [ 1, true ]

// A12
id poly (fun x -> x)
//│ res: (int, bool,)
//│    = [ 1, true ]


// ============ B. inference of polymorphic arguments ============

// B1
fun f -> (f 1, f true)
//│ res: (true -> 'a & 1 -> 'b) -> ('b, 'a,)
//│    = [Function: res]

// B2
fun xs -> poly (head xs)
//│ res: List[forall 'a. 'a -> 'a] -> (int, bool,)
//│    = [Function: res]


// ============ C. functions on polymorphic lists ============

// C1
length ids
//│ res: int
//│    = 1

// C2
tail ids
//│ res: List[forall 'a. 'a -> 'a]
//│    = Nil {}

// C3
head ids
//│ res: 'a -> 'a
//│    = [Function: id1]

// C4
single id
//│ res: List[forall 'a. 'a -> 'a]
//│    = Cons { head: [Function: id1], tail: Nil {} }

// C5
cons id ids
//│ res: List[forall 'a. 'a -> 'a]
//│    = Cons {
//│        head: [Function: id1],
//│        tail: Cons { head: [Function: id1], tail: Nil {} }
//│      }

// C6
cons (fun x -> x) ids
//│ res: List[forall 'a. 'a -> 'a]
//│    = Cons {
//│        head: [Function (anonymous)],
//│        tail: Cons { head: [Function: id1], tail: Nil {} }
//│      }

// C7
append (single inc) (single id)
//│ res: List[int -> int]
//│    = Cons {
//│        head: [Function: succ],
//│        tail: Cons { head: [Function: id1], tail: Nil {} }
//│      }

// C8
:ng
g (single id) ids
//│ res: 'a -> 'a

// C9
map poly (single id)
//│ res: List[(int, bool,)]
//│    = Cons { head: [ 1, true ], tail: Nil {} }

// C10
map head (single ids)
//│ res: List[forall 'a. 'a -> 'a]
//│    = Cons { head: [Function: id1], tail: Nil {} }


// ============ D. application functions ============

// D1
app poly id
//│ res: (int, bool,)
//│    = [ 1, true ]

// D2
revapp id poly
//│ res: (int, bool,)
//│    = [ 1, true ]

// D3
:ng
runST argST
//│ res: int

// D4
:ng
app runST argST
//│ res: int

// D5
:ng
revapp argST runST
//│ res: int


// ============ E. η-expansion ============

// E1
:ng
k h lst
//│ res: int -> 'a -> 'a

// E2
:ng
k (fun x -> h x) lst
//│ res: int -> 'a -> 'a

// E3
:ng
r (fun x -> fun y -> y)
//│ res: int


// ============ F. FreezeML Additions ============

// F5
auto id
//│ res: 'b -> 'b
//│    = [Function: id1]

// F6
cons (head ids) ids
//│ res: List[forall 'a. 'a -> 'a]
//│    = Cons {
//│        head: [Function: id1],
//│        tail: Cons { head: [Function: id1], tail: Nil {} }
//│      }

// F7
(head ids) 3
//│ res: 3
//│    = 3

// F8
choose (head ids)
//│ res: 'a -> (forall 'a0. 'a | 'a0 -> 'a0)
//│    = [Function (anonymous)]

// F9
let f = revapp id in f poly
//│ res: (int, bool,)
//│    = [ 1, true ]

// F10
choose id (fun x -> auto_ x)
//│ res: (forall 'a. 'a -> 'a & 'a0) -> ('a0 | 'b -> 'b)
//│    = [Function: id1]


// ============ G. SuperF Additions ============

// G1
def z f x = x
//│ z: anything -> 'a -> 'a
//│  = [Function: z3]

// G2
def s n f x = f (n f x)
//│ s: ('a -> 'b -> 'c) -> ('c -> 'd & 'a) -> 'b -> 'd
//│  = [Function: s3]

// G3
n3 = s (s (s z))
//│ n3: ('a -> 'b & 'c -> 'a & 'd -> 'c) -> 'd -> 'b
//│   = [Function (anonymous)]

// G1A
z: ChurchInt
//│ res: ChurchInt
//│    = [Function: z3]

// G2A
s: ChurchInt -> ChurchInt
//│ res: ChurchInt -> ChurchInt
//│    = [Function: s3]

// G3A
n3: ChurchInt
//│ res: ChurchInt
//│    = [Function (anonymous)]

// G4
fst (fst (fst (n3 (fun x -> (x, 0)) 1)))
//│ res: 1
//│    = 1

(succ (succ zero)) (succ (succ zero))
//│ res: ('M -> 'M) -> 'M -> 'M
//│    = [Function (anonymous)]

:e
(s (s z)) (s (s z))
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.1997: 	(s (s z)) (s (s z))
//│ ║          	^^^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 4. α5745_6081'''''›  <:  α5738_6102    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 4. α5745_6081'''''›  <:  α5738_6099''''
//│ res: (('a | 'b) -> 'b & 'c -> 'a) -> 'c -> 'b | error
//│   where
//│     'c :> 'a | 'b
//│    = [Function (anonymous)]

// G7
rec def to_ch n = if n == 0 then z else s (to_ch (n - 1))
//│ to_ch: int -> ('a -> 'b & 'a -> 'a) -> ('a & 'b) -> 'b
//│      = [Function: to_ch3]

// G7A
to_ch: int -> ChurchInt
//│ res: int -> ChurchInt
//│    = [Function: to_ch3]

// G8
rec def id1 x = if true then x else id1 id1 x
//│ id1: 'id1
//│   where
//│     'id1 :> forall 'a. ('b & 'a) -> 'a
//│     'a :> 'c
//│     'b :> 'id1
//│        <: 'c
//│     'c :> 'id1
//│        <: 'b -> 'c
//│    = [Function: id14]

:e
// G9
id1 id1
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.2033: 	id1 id1
//│ ║          	^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 0. id16321'#›  <:  α6329_6375    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 0. id16321'#›  <:  α6329'
//│ res: error
//│    = [Function: id14]

// Gn
:e
auto auto
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.2045: 	auto auto
//│ ║          	^^^^^^^^^
//│ ╟── type `‘a_6394` is not a function
//│ ║  l.164: 	def auto : (forall 'a. 'a -> 'a) -> (forall 'b. 'b -> 'b)
//│ ║         	                   ^^
//│ ╟── Note: constraint arises from function type:
//│ ║  l.164: 	def auto : (forall 'a. 'a -> 'a) -> (forall 'b. 'b -> 'b)
//│ ╙──       	                       ^^^^^^^^
//│ res: 'b -> 'b | error
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded

// Gn+1
:e
(fun x -> x x) (fun x -> x x)
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.2061: 	(fun x -> x x) (fun x -> x x)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 0. (α6405_6407' -> α6406_6408')›  <:  α6405_6414    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 0. (α6405_6407' -> α6406_6408')›  <:  α6405_6407'
//│ res: error
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded

:re
// Gn+2
(fun x -> x x) (fun x -> x x)!
//│ res: nothing
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded


