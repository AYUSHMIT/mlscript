:GeneralizeCurriedFunctions
:DistributeForalls
:NoRecursiveTypes
// :ArgGen // * This actually causes extrusions in pred, failing its type checking



type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ Defined type alias ChurchInt



def zero_ty: ChurchInt
//│ zero_ty: ChurchInt
//│        = <missing implementation>

def zero f x = x
//│ zero: anything -> 'a -> 'a
//│     = [Function: zero]

zero_ty = zero
//│ anything -> 'a -> 'a
//│   <:  zero_ty:
//│ ChurchInt
//│        = [Function: zero]


def succ_ty: ChurchInt -> ChurchInt
//│ succ_ty: ChurchInt -> ChurchInt
//│        = <missing implementation>

def succ n f x = f (n f x)
//│ succ: ('a -> 'b -> 'c) -> ('c -> 'd & 'a) -> 'b -> 'd
//│     = [Function: succ]

succ_ty = succ
//│ ('a -> 'b -> 'c) -> ('c -> 'd & 'a) -> 'b -> 'd
//│   <:  succ_ty:
//│ ChurchInt -> ChurchInt
//│        = [Function: succ]



def to_church_ty: int -> ChurchInt
//│ to_church_ty: int -> ChurchInt
//│             = <missing implementation>

rec def to_church n =
  if n == 0 then zero
  else succ (to_church (n - 1))
//│ to_church: int -> ('a -> 'b & 'a -> 'a) -> ('a & 'b) -> 'b
//│          = [Function: to_church]

to_church_ty = to_church
//│ int -> ('a -> 'b & 'a -> 'a) -> ('a & 'b) -> 'b
//│   <:  to_church_ty:
//│ int -> ChurchInt
//│             = [Function: to_church]



def add_ty: ChurchInt -> ChurchInt -> ChurchInt
//│ add_ty: ChurchInt -> ChurchInt -> ChurchInt
//│       = <missing implementation>

def add n m = n succ m
//│ add: ((forall 'a, 'b, 'c, 'd. ('a -> 'b -> 'c) -> ('c -> 'd & 'a) -> 'b -> 'd) -> 'e -> 'f) -> 'e -> 'f
//│    = [Function: add]

:e // * Since "sound extrusion"
add_ty = add
//│ ((forall 'a, 'b, 'c, 'd. ('c -> 'd -> 'a) -> ('a -> 'b & 'c) -> 'd -> 'b) -> 'e -> 'f) -> 'e -> 'f
//│   <:  add_ty:
//│ ChurchInt -> ChurchInt -> ChurchInt
//│ ╔══[ERROR] Cyclic-looking constraint while typing def definition; a type annotation may be required
//│ ║  l.71: 	add_ty = add
//│ ║        	^^^^^^^^^^^^
//│ ╙── Note: use flag `:ex` to see internal error info.
//│       = [Function: add]

def add (n: ChurchInt) m = n succ m
// def add (n: ChurchInt) m = n succ_ty m
//│ add: ChurchInt -> ('a -> 'b -> 'c & 'd) -> (('c -> 'e & 'c -> 'c & 'a) -> 'b -> 'e | 'd)
//│    = [Function: add1]

add_ty = add
//│ ChurchInt -> ('a -> 'b -> 'c & 'd) -> (('c -> 'e & 'c -> 'c & 'a) -> 'b -> 'e | 'd)
//│   <:  add_ty:
//│ ChurchInt -> ChurchInt -> ChurchInt
//│       = [Function: add1]


def mul_ty: ChurchInt -> ChurchInt -> ChurchInt
//│ mul_ty: ChurchInt -> ChurchInt -> ChurchInt
//│       = <missing implementation>

def mul n m = n (add m) zero
//│ mul: ((forall 'a, 'b, 'c, 'd, 'e. ('e -> 'c -> 'b & 'a) -> (('b -> 'd & 'b -> 'b & 'e) -> 'c -> 'd | 'a)) -> (forall 'f. anything -> 'f -> 'f) -> 'g) -> ChurchInt -> 'g
//│    = [Function: mul]

:e // fails since the fix to spurious-TV-cycles
mul_ty = mul
//│ ((forall 'a, 'b, 'c, 'd, 'e. ('b -> 'd -> 'a & 'e) -> (('a -> 'c & 'a -> 'a & 'b) -> 'd -> 'c | 'e)) -> (forall 'f. anything -> 'f -> 'f) -> 'g) -> ChurchInt -> 'g
//│   <:  mul_ty:
//│ ChurchInt -> ChurchInt -> ChurchInt
//│ ╔══[ERROR] Cyclic-looking constraint while typing def definition; a type annotation may be required
//│ ║  l.102: 	mul_ty = mul
//│ ║         	^^^^^^^^^^^^
//│ ╙── Note: use flag `:ex` to see internal error info.
//│       = [Function: mul]

def mul (n: ChurchInt) m = n (add m) zero
//│ mul: ChurchInt -> ChurchInt -> ('a -> 'b & 'a -> 'a) -> ('a & 'b) -> 'b
//│    = [Function: mul1]

mul_ty = mul
//│ ChurchInt -> ChurchInt -> ('a -> 'b & 'a -> 'a) -> ('a & 'b) -> 'b
//│   <:  mul_ty:
//│ ChurchInt -> ChurchInt -> ChurchInt
//│       = [Function: mul1]



def pow_ty: ChurchInt -> ChurchInt -> ChurchInt
//│ pow_ty: ChurchInt -> ChurchInt -> ChurchInt
//│       = <missing implementation>

:e
def pow (n: ChurchInt) (m: ChurchInt) = n (mul m) (succ zero)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.129: 	def pow (n: ChurchInt) (m: ChurchInt) = n (mul m) (succ zero)
//│ ║         	                                        ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.8: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║       	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.8: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║       	                        ^^
//│ ╟── from reference:
//│ ║  l.32: 	def succ n f x = f (n f x)
//│ ╙──      	                        ^
//│ pow: ChurchInt -> (forall 'a, 'b. ChurchInt -> (('a -> 'b & nothing -> 'b & 'a -> 'a) -> ('a & 'b) -> 'b | error))
//│    = [Function: pow]

def pow (n: ChurchInt) (m: ChurchInt) = n (mul_ty m) (succ_ty zero_ty)
//│ pow: ChurchInt -> ChurchInt -> ChurchInt
//│    = [Function: pow1]
pow_ty = pow
//│ ChurchInt -> ChurchInt -> ChurchInt
//│   <:  pow_ty:
//│ ChurchInt -> ChurchInt -> ChurchInt
//│       = [Function: pow1]

def pow (n: ChurchInt) m = n (mul m) (succ_ty zero)
//│ pow: ChurchInt -> (forall 'a, 'b. ChurchInt -> (('a -> 'b & 'a -> 'a) -> ('a & 'b) -> 'b | ChurchInt))
//│    = [Function: pow2]
pow_ty = pow
//│ ChurchInt -> (forall 'a, 'b. ChurchInt -> (('a -> 'b & 'a -> 'a) -> ('a & 'b) -> 'b | ChurchInt))
//│   <:  pow_ty:
//│ ChurchInt -> ChurchInt -> ChurchInt
//│       = [Function: pow2]



def unit = id
//│ unit: 'a -> 'a
//│     = [Function: unit]

type Unit_t = 'a -> 'a
unit : Unit_t
//│ Defined type alias Unit_t
//│ res: Unit_t
//│    = [Function: id]

def tru x _ = x unit
//│ tru: ((forall 'a. 'a -> 'a) -> 'b) -> anything -> 'b
//│    = [Function: tru]

def fls _ x = x unit
//│ fls: anything -> ((forall 'a. 'a -> 'a) -> 'b) -> 'b
//│    = [Function: fls]

type If_t = (Unit_t -> 'a) -> (Unit_t -> 'a) -> 'a
tru : If_t
fls : If_t
//│ Defined type alias If_t
//│ res: If_t
//│    = [Function: tru]
//│ res: If_t
//│    = [Function: fls]

def iszero n = n (fun _ -> fls) tru
//│ iszero: ((forall 'a. anything -> anything -> ((forall 'b. 'b -> 'b) -> 'a) -> 'a) -> (forall 'c. ((forall 'd. 'd -> 'd) -> 'c) -> anything -> 'c) -> 'e) -> 'e
//│       = [Function: iszero]

iszero : ChurchInt -> If_t
//│ res: ChurchInt -> If_t
//│    = [Function: iszero]

def pair x y f = f x y
//│ pair: 'a -> 'b -> ('a -> 'b -> 'c) -> 'c
//│     = [Function: pair]

def fst p = p (fun x -> fun _ -> x)
//│ fst: ((forall 'a. 'a -> anything -> 'a) -> 'b) -> 'b
//│    = [Function: fst]

def snd p = p (fun _ -> fun x -> x)
//│ snd: ((forall 'a. anything -> 'a -> 'a) -> 'b) -> 'b
//│    = [Function: snd]



def pred_ty: ChurchInt -> ChurchInt
//│ pred_ty: ChurchInt -> ChurchInt
//│        = <missing implementation>

def s p = pair (snd p) (succ (snd p))
//│ s: ((forall 'a. anything -> 'a -> 'a) -> 'b -> 'c -> 'd & (forall 'e. anything -> 'e -> 'e) -> 'f) -> ('f -> (forall 'g. ('d -> 'g & 'b) -> 'c -> 'g) -> 'h) -> 'h
//│  = [Function: s]

def z = pair zero zero
//│ z: ((forall 'a. anything -> 'a -> 'a) -> (forall 'b. anything -> 'b -> 'b) -> 'c) -> 'c
//│  = [Function: z]

def pred (n: ChurchInt) = fst (n s z)
//│ pred: ChurchInt -> ('a -> 'b & 'a -> 'a) -> ('a & 'b) -> 'b
//│     = [Function: pred]

pred_ty = pred
//│ ChurchInt -> ('a -> 'b & 'a -> 'a) -> ('a & 'b) -> 'b
//│   <:  pred_ty:
//│ ChurchInt -> ChurchInt
//│        = [Function: pred]



def pred n =
  let s p = pair (snd p) (succ (snd p)) in
  let z = pair zero zero in
  fst (n s z)
//│ pred: ((forall 'a, 'b, 'c, 'd, 'e. ((forall 'f. anything -> 'f -> 'f) -> 'd -> 'e -> 'b & (forall 'g. anything -> 'g -> 'g) -> 'c) -> ('c -> (forall 'h. ('b -> 'h & 'd) -> 'e -> 'h) -> 'a) -> 'a) -> (forall 'i. ((forall 'j. anything -> 'j -> 'j) -> (forall 'k. anything -> 'k -> 'k) -> 'i) -> 'i) -> (forall 'l. 'l -> anything -> 'l) -> 'm) -> 'm
//│     = [Function: pred1]
:e
pred_ty = pred
//│ ((forall 'a, 'b, 'c, 'd, 'e. ((forall 'f. anything -> 'f -> 'f) -> 'd -> 'b -> 'a & (forall 'g. anything -> 'g -> 'g) -> 'c) -> ('c -> (forall 'h. ('a -> 'h & 'd) -> 'b -> 'h) -> 'e) -> 'e) -> (forall 'i. ((forall 'j. anything -> 'j -> 'j) -> (forall 'k. anything -> 'k -> 'k) -> 'i) -> 'i) -> (forall 'l. 'l -> anything -> 'l) -> 'm) -> 'm
//│   <:  pred_ty:
//│ ChurchInt -> ChurchInt
//│ ╔══[ERROR] Cyclic-looking constraint while typing def definition; a type annotation may be required
//│ ║  l.245: 	pred_ty = pred
//│ ║         	^^^^^^^^^^^^^^
//│ ╙── Note: use flag `:ex` to see internal error info.
//│        = [Function: pred1]

// * Only difference: use `succ_ty`
def pred n =
  let s p = pair (snd p) (succ_ty (snd p)) in
  let z = pair zero zero in
  fst (n s z)
//│ pred: ((forall 'a, 'b. ((forall 'c. anything -> 'c -> 'c) -> ChurchInt & (forall 'd. anything -> 'd -> 'd) -> 'a) -> ('a -> ChurchInt -> 'b) -> 'b) -> (forall 'e. ((forall 'f. anything -> 'f -> 'f) -> (forall 'g. anything -> 'g -> 'g) -> 'e) -> 'e) -> (forall 'h. 'h -> anything -> 'h) -> 'i) -> 'i
//│     = [Function: pred2]
pred_ty = pred
//│ ((forall 'a, 'b. ((forall 'c. anything -> 'c -> 'c) -> ChurchInt & (forall 'd. anything -> 'd -> 'd) -> 'b) -> ('b -> ChurchInt -> 'a) -> 'a) -> (forall 'e. ((forall 'f. anything -> 'f -> 'f) -> (forall 'g. anything -> 'g -> 'g) -> 'e) -> 'e) -> (forall 'h. 'h -> anything -> 'h) -> 'i) -> 'i
//│   <:  pred_ty:
//│ ChurchInt -> ChurchInt
//│        = [Function: pred2]



def fact_ty: ChurchInt -> ChurchInt
//│ fact_ty: ChurchInt -> ChurchInt
//│        = <missing implementation>

rec def fact (n: ChurchInt) = (iszero n) (fun _ -> succ zero) (fun _ -> mul n (fact (pred n)))
//│ fact: ChurchInt -> ('a -> 'b & 'c -> 'b & 'c -> 'c) -> ('c & 'a) -> ('a | 'b)
//│     = [Function: fact]

fact_ty = fact
//│ ChurchInt -> ('a -> 'b & 'c -> 'b & 'c -> 'c) -> ('c & 'a) -> ('a | 'b)
//│   <:  fact_ty:
//│ ChurchInt -> ChurchInt
//│        = [Function: fact]

// * A dummy mistake:
:e
def fact (n: ChurchInt) = (iszero n) (fun _ -> succ zero) (fun _ -> mul n {})
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.286: 	def fact (n: ChurchInt) = (iszero n) (fun _ -> succ zero) (fun _ -> mul n {})
//│ ║         	                                                                    ^^^^^^^^
//│ ╟── record literal of type `anything` is not a function
//│ ║  l.286: 	def fact (n: ChurchInt) = (iszero n) (fun _ -> succ zero) (fun _ -> mul n {})
//│ ║         	                                                                          ^^
//│ ╟── Note: constraint arises from function type:
//│ ║  l.8: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║       	                            ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.112: 	def mul (n: ChurchInt) m = n (add m) zero
//│ ╙──       	                                  ^
//│ fact: ChurchInt -> (('a -> 'b & 'c -> 'b & 'c -> 'c) -> ('c & 'a) -> ('a | 'b) | error)
//│     = [Function: fact1]

// * We can drop all intermediate annotations if the recursive call is annotated:
def fact n = (iszero n) (fun _ -> succ zero) (fun _ -> mul n (fact_ty (pred n)))
//│ fact: (ChurchInt & (forall 'a, 'b. ((forall 'c. anything -> 'c -> 'c) -> ChurchInt & (forall 'd. anything -> 'd -> 'd) -> 'a) -> ('a -> ChurchInt -> 'b) -> 'b) -> (forall 'e. ((forall 'f. anything -> 'f -> 'f) -> (forall 'g. anything -> 'g -> 'g) -> 'e) -> 'e) -> (forall 'h. 'h -> anything -> 'h) -> ChurchInt & (forall 'i. anything -> anything -> ((forall 'j. 'j -> 'j) -> 'i) -> 'i) -> (forall 'k. ((forall 'l. 'l -> 'l) -> 'k) -> anything -> 'k) -> (forall 'm, 'n. anything -> ('m -> 'n) -> 'm -> 'n) -> (forall 'o, 'p. anything -> ('o -> 'p & 'o -> 'o) -> ('o & 'p) -> 'p) -> 'q) -> 'q
//│     = [Function: fact2]

fact_ty = fact
//│ (ChurchInt & (forall 'a, 'b. ((forall 'c. anything -> 'c -> 'c) -> ChurchInt & (forall 'd. anything -> 'd -> 'd) -> 'a) -> ('a -> ChurchInt -> 'b) -> 'b) -> (forall 'e. ((forall 'f. anything -> 'f -> 'f) -> (forall 'g. anything -> 'g -> 'g) -> 'e) -> 'e) -> (forall 'h. 'h -> anything -> 'h) -> ChurchInt & (forall 'i. anything -> anything -> ((forall 'j. 'j -> 'j) -> 'i) -> 'i) -> (forall 'k. ((forall 'l. 'l -> 'l) -> 'k) -> anything -> 'k) -> (forall 'm, 'n. anything -> ('m -> 'n) -> 'm -> 'n) -> (forall 'o, 'p. anything -> ('o -> 'p & 'o -> 'o) -> ('o & 'p) -> 'p) -> 'q) -> 'q
//│   <:  fact_ty:
//│ ChurchInt -> ChurchInt
//│        = [Function: fact2]


:e
fact (to_church 4) (fun x -> x + 1) 0
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.315: 	fact (to_church 4) (fun x -> x + 1) 0
//│ ║         	^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> ?b` does not match type `nothing`
//│ ║  l.200: 	def pair x y f = f x y
//│ ║         	             ^^^^^^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.8: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ╙──     	                        ^^
//│ res: error
//│    = 24

:e
fact_ty (to_church 4) (fun x -> x + 1) 0
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.329: 	fact_ty (to_church 4) (fun x -> x + 1) 0
//│ ║         	^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.8: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║       	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.8: 	type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ║       	                        ^^
//│ ╟── from application:
//│ ║  l.32: 	def succ n f x = f (n f x)
//│ ╙──      	                 ^^^^^^^^^
//│ res: error
//│    = 24

fact (to_church_ty 4) (fun x -> x + 1) 0
//│ res: int
//│    = 24


