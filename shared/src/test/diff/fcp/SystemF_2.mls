:NoRecursiveTypes
:GeneralizeCurriedFunctions
:NoConstrainedTypes
:DistributeForalls



I x = x
K x y = x
//│ I: 'a -> 'a
//│  = [Function: I]
//│ K: 'a -> anything -> 'a
//│  = [Function: K]

id x = x
iter2 f x = f(f x)
//│ id: 'a -> 'a
//│   = [Function: id]
//│ iter2: ('a -> 'b & 'c -> 'a) -> 'c -> 'b
//│      = [Function: iter2]

iter2 K
//│ res: 'a -> anything -> anything -> 'a
//│    = [Function (anonymous)]

iter2 iter2
//│ res: ('a -> 'b & ('c | 'b) -> 'a) -> 'c -> 'b
//│    = [Function (anonymous)]

id iter2 iter2
//│ res: ('a -> 'b & ('c | 'b) -> 'a) -> 'c -> 'b
//│    = [Function (anonymous)]

// * The following occurs-check failure is legit.
// * We have `K: 'A -> anything -> 'A` which flows into `'a -> 'b & ('c | 'b) -> 'a`
// *  which implies `anything -> 'A <: 'b <: 'A`, a nested cycle.
// * The cycle displayed below is a 1-unrolling of the one above.
:e
iter2 iter2 K
//│ ╔══[ERROR] Inferred recursive type: 'a
//│   where
//│     'a :> anything -> anything -> 'a
//│ ║  l.16: 	iter2 f x = f(f x)
//│ ╙──      	            ^^^^^^
//│ res: 'a -> 'b
//│   where
//│     'a :> 'b
//│     'b :> anything -> anything -> 'a
//│    = [Function (anonymous)]

:e
iter2 iter2 iter2
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.52: 	iter2 iter2 iter2
//│ ║        	^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 3. α37_302''''›  <:  α35_288    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 3. α37_290'''›  <:  α35_46''
//│ res: (('a | 'b) -> 'b & 'c -> ('a & 'c)) -> 'c -> 'b | error
//│   where
//│     'c :> 'b
//│    = [Function (anonymous)]

iter2 K iter2 iter2 iter2
//│ res: ('a -> 'b & 'c -> 'a) -> 'c -> 'b
//│    = [Function: iter2]



// (λzy. y(zI)(zK))(λx. xx).
foo = (fun z -> fun y -> y (z I) (z K))
//│ foo: ((forall 'a. 'a -> anything -> 'a) -> 'b & (forall 'c. 'c -> 'c) -> 'd) -> ('d -> 'b -> 'e) -> 'e
//│    = [Function: foo]

foo (fun x -> x x)
//│ res: ((forall 'a. 'a -> 'a) -> (anything -> (forall 'b. 'b -> anything -> 'b)) -> 'c) -> 'c
//│    = [Function (anonymous)]

n0_ s z = z
def n0: forall 'X. ('X -> 'X) -> 'X -> 'X
n0 = n0_
//│ n0_: anything -> 'a -> 'a
//│    = [Function: n0_]
//│ n0: ('X -> 'X) -> 'X -> 'X
//│   = <missing implementation>
//│ anything -> 'a -> 'a
//│   <:  n0:
//│ ('X -> 'X) -> 'X -> 'X
//│   = [Function: n0_]

succ_ n s z = s (n s z)
def succ: (forall 'X. ('X -> 'X) -> 'X -> 'X) -> (forall 'X. ('X -> 'X) -> 'X -> 'X)
succ = succ_
//│ succ_: ('a -> 'b -> 'c) -> ('c -> 'd & 'a) -> 'b -> 'd
//│      = [Function: succ_]
//│ succ: (forall 'X. ('X -> 'X) -> 'X -> 'X) -> (forall 'X0. ('X0 -> 'X0) -> 'X0 -> 'X0)
//│     = <missing implementation>
//│ ('a -> 'b -> 'c) -> ('c -> 'd & 'a) -> 'b -> 'd
//│   <:  succ:
//│ (forall 'X. ('X -> 'X) -> 'X -> 'X) -> (forall 'X0. ('X0 -> 'X0) -> 'X0 -> 'X0)
//│     = [Function: succ_]

c2 = succ (succ n0)
//│ c2: ('X -> 'X) -> 'X -> 'X
//│   = [Function (anonymous)]

:e
c2 c2 K
//│ ╔══[ERROR] Inferred recursive type: 'a
//│   where
//│     'a :> anything -> 'a
//│ ╙──
//│ res: ('X & 'a) -> ('X | anything -> 'a)
//│   where
//│     'X :> anything -> 'X
//│    = [Function (anonymous)]

c2_ = succ_ (succ_ n0)
//│ c2_: ('a -> 'b & 'X -> 'a & 'X -> 'X) -> 'X -> 'b
//│    = [Function (anonymous)]

:e // * Started failing after better distrib, not sure why...
c2_ c2_
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.123: 	c2_ c2_
//│ ║         	^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 4. α529_829'''''›  <:  'X500_818    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 4. α529_828''''›  <:  'X500_711'
//│ res: error
//│    = [Function (anonymous)]

:e
c2_ c2_!
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.134: 	c2_ c2_!
//│ ║         	^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 4. α529_922'''''›  <:  α522_923    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 4. α529_921''''›  <:  α522_920''''
//│ res: error
//│    = [Function (anonymous)]

:e // * Started failing after better distrib, not sure why...
c2_ c2_ K
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.145: 	c2_ c2_ K
//│ ║         	^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 4. α529_1013'''''›  <:  'X500_1002    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 4. α529_1012''''›  <:  'X500_711'
//│ res: error
//│    = [Function (anonymous)]

c2__ = succ_ (succ_ n0_)
//│ c2__: ('a -> 'b & 'c -> 'a) -> 'c -> 'b
//│     = [Function (anonymous)]

c2__ c2__
//│ res: ('a -> 'b & ('c | 'b) -> 'a) -> 'c -> 'b
//│    = [Function (anonymous)]

:e
c2__ c2__ K
//│ ╔══[ERROR] Inferred recursive type: 'a
//│   where
//│     'a :> anything -> anything -> (forall 'a. 'a)
//│ ║  l.91: 	succ_ n s z = s (n s z)
//│ ╙──      	              ^^^^^^^^^
//│ res: 'a -> 'b
//│   where
//│     'a :> 'b
//│     'b :> anything -> anything -> 'a
//│    = [Function (anonymous)]


// --------------
:RecursiveTypes

iter2 iter2 K
//│ res: 'a -> 'b
//│   where
//│     'a :> 'b
//│     'b :> anything -> anything -> 'a
//│    = [Function (anonymous)]

res id
//│ res: 'a
//│   where
//│     'a :> anything -> anything -> (forall 'b. 'b -> 'b | 'a)
//│    = [Function (anonymous)]

r1 = res id id id id id
//│ r1: 'a -> 'a | 'b
//│   where
//│     'b :> anything -> (forall 'c. 'c -> ('b | 'c))
//│   = [Function: id]

// * FIXME(oc) rebinding of 'e seems unhygienic...
r1 iter2 iter2 K
//│ res: ('a & 'b & 'c) -> (anything -> anything -> 'b | 'a | 'd) | 'e
//│   where
//│     'e :> anything -> anything -> (forall 'e, 'f. 'f -> 'f | 'e)
//│     'c :> 'd
//│     'd :> anything -> anything -> 'c
//│    = [Function (anonymous)]

r = r1 iter2 iter2
//│ r: nothing -> anything -> nothing | 'a
//│   where
//│     'a :> anything -> (forall 'b. 'b -> ('a | 'b))
//│  = [Function (anonymous)]

:e
r iter2
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.215: 	r iter2
//│ ║         	^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 3. α37_1707''''›  <:  α35_1689    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 3. α37_1698'''›  <:  α35_46''
//│ res: nothing -> 'a -> 'b | error | 'c
//│   where
//│     'c :> anything -> anything -> (forall 'c, 'd. 'd -> 'd | 'c)
//│    = [Function (anonymous)]

:NoRecursiveTypes
// --------------



// ==============

:ConstrainedTypes
:DontDistributeForalls

// ==============



id x = x
iter2 f x = f(f x)
//│ id: 'a -> 'a
//│   = [Function: id1]
//│ iter2: 'a -> (forall 'b, 'c, 'd. ('b -> 'd
//│   where
//│     'a <: 'b -> 'c & 'c -> 'd))
//│      = [Function: iter21]

iter2 iter2
//│ res: 'a -> 'b
//│   where
//│     forall 'c. 'c -> (forall 'd, 'e, 'f. ('e -> 'd
//│   where
//│     'c <: 'e -> 'f & 'f -> 'd)) <: 'a -> 'g & 'g -> 'b
//│    = [Function (anonymous)]

id iter2 iter2
//│ res: 'a -> 'b
//│   where
//│     forall 'c. 'c -> (forall 'd, 'e, 'f. ('d -> 'f
//│   where
//│     'c <: 'd -> 'e & 'e -> 'f)) <: 'a -> 'g & 'g -> 'b
//│    = [Function (anonymous)]


iter2 iter2 K
//│ res: 'a -> 'b
//│   where
//│     forall 'c, 'd, 'e. ('c -> 'e
//│   where
//│     forall 'f. 'f -> anything -> 'f <: 'c -> 'd & 'd -> 'e) <: 'a -> 'g & 'g -> 'b
//│    = [Function (anonymous)]



// (λzy. y(zI)(zK))(λx. xx).
foo = (fun z -> fun y -> y (z I) (z K))
//│ foo: 'a -> (forall 'b, 'c, 'd. (('d -> 'b -> 'c) -> 'c
//│   where
//│     'a <: (forall 'e. 'e -> 'e) -> 'd & (forall 'f. 'f -> anything -> 'f) -> 'b))
//│    = [Function: foo1]

foo (fun x -> x x)
//│ res: ('a -> 'b -> 'c) -> 'c
//│   where
//│     forall 'd, 'e. ('d -> 'e & 'd) -> 'e <: (forall 'f. 'f -> 'f) -> 'a & (forall 'g. 'g -> anything -> 'g) -> 'b
//│    = [Function (anonymous)]

n0_ s z = z
def n0: forall 'X. ('X -> 'X) -> 'X -> 'X
n0 = n0_
//│ n0_: anything -> (forall 'a. 'a -> 'a)
//│    = [Function: n0_1]
//│ n0: ('X -> 'X) -> 'X -> 'X
//│   = <missing implementation>
//│ anything -> (forall 'a. 'a -> 'a)
//│   <:  n0:
//│ ('X -> 'X) -> 'X -> 'X
//│   = [Function: n0_1]

succ_ n s z = s (n s z)
def succ: (forall 'X. ('X -> 'X) -> 'X -> 'X) -> (forall 'X. ('X -> 'X) -> 'X -> 'X)
//│ succ_: 'a -> (forall 'b. 'b -> (forall 'c, 'd, 'e. ('c -> 'e
//│   where
//│     'a <: 'b -> 'c -> 'd
//│     'b <: 'd -> 'e)))
//│      = [Function: succ_1]
//│ succ: (forall 'X. ('X -> 'X) -> 'X -> 'X) -> (forall 'X0. ('X0 -> 'X0) -> 'X0 -> 'X0)
//│     = <missing implementation>
:e // * Needs distrib
succ = succ_
//│ 'a -> (forall 'b. 'b -> (forall 'c, 'd, 'e. ('c -> 'e
//│   where
//│     'a <: 'b -> 'c -> 'd
//│     'b <: 'd -> 'e)))
//│   <:  succ:
//│ (forall 'X. ('X -> 'X) -> 'X -> 'X) -> (forall 'X0. ('X0 -> 'X0) -> 'X0 -> 'X0)
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.312: 	succ = succ_
//│ ║         	^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.303: 	def succ: (forall 'X. ('X -> 'X) -> 'X -> 'X) -> (forall 'X. ('X -> 'X) -> 'X -> 'X)
//│ ║         	                                                         ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.303: 	def succ: (forall 'X. ('X -> 'X) -> 'X -> 'X) -> (forall 'X. ('X -> 'X) -> 'X -> 'X)
//│ ║         	                                                         ^^
//│ ╟── from quantified type variable:
//│ ║  l.303: 	def succ: (forall 'X. ('X -> 'X) -> 'X -> 'X) -> (forall 'X. ('X -> 'X) -> 'X -> 'X)
//│ ╙──       	                  ^^
//│     = [Function: succ_1]

c2 = succ (succ n0)
//│ c2: ('X -> 'X) -> 'X -> 'X
//│   = [Function (anonymous)]

:e
c2 c2 K
//│ ╔══[ERROR] Inferred recursive type: 'a
//│   where
//│     'a :> anything -> 'a
//│ ╙──
//│ res: ('X & 'a) -> ('X | anything -> 'a)
//│   where
//│     'X :> anything -> 'X
//│    = [Function (anonymous)]

c2_ = succ_ (succ_ n0)
//│ c2_: 'a -> (forall 'b, 'c, 'd. ('b -> 'd
//│   where
//│     forall 'e. 'e -> (forall 'f, 'g, 'h. ('f -> 'h
//│   where
//│     'e <: 'g -> 'h
//│     forall 'X. ('X -> 'X) -> 'X -> 'X <: 'e -> 'f -> 'g)) <: 'a -> 'b -> 'c
//│     'a <: 'c -> 'd))
//│    = [Function (anonymous)]

c2_ c2_
//│ res: 'a -> 'b
//│   where
//│     forall 'c. 'c -> (forall 'd, 'e, 'f. ('e -> 'd
//│   where
//│     forall 'g. 'g -> (forall 'h, 'i, 'j. ('h -> 'j
//│   where
//│     forall 'X. ('X -> 'X) -> 'X -> 'X <: 'g -> 'h -> 'i
//│     'g <: 'i -> 'j)) <: 'c -> 'e -> 'f
//│     'c <: 'f -> 'd)) <: 'k -> 'b
//│     forall 'l. 'l -> (forall 'm, 'n, 'o. ('m -> 'o
//│   where
//│     forall 'X. ('X -> 'X) -> 'X -> 'X <: 'l -> 'm -> 'n
//│     'l <: 'n -> 'o)) <: (forall 'c. 'c -> (forall 'd, 'e, 'f. ('e -> 'd
//│   where
//│     forall 'g. 'g -> (forall 'h, 'i, 'j. ('h -> 'j
//│   where
//│     forall 'X. ('X -> 'X) -> 'X -> 'X <: 'g -> 'h -> 'i
//│     'g <: 'i -> 'j)) <: 'c -> 'e -> 'f
//│     'c <: 'f -> 'd))) -> 'a -> 'k
//│    = [Function (anonymous)]

:e
c2_ c2_ K
//│ ╔══[ERROR] Inferred recursive type: 'a
//│   where
//│     'a :> forall 'b, 'c, 'd, 'e. (('e & 'b) -> (anything -> 'e | 'd)
//│   where
//│     'a <: 'c -> 'd
//│     forall 'f. 'f -> (forall 'g, 'h, 'i. ('g -> 'i
//│   where
//│     forall 'X. ('X -> 'X) -> 'X -> 'X <: 'f -> 'g -> 'h
//│     'f <: 'h -> 'i)) <: 'a -> 'b -> 'c)
//│ ╙──
//│ res: 'a -> 'b
//│   where
//│     forall 'c, 'd, 'e. ('d -> 'c
//│   where
//│     forall 'f. 'f -> (forall 'g, 'h, 'i. ('g -> 'i
//│   where
//│     forall 'X. ('X -> 'X) -> 'X -> 'X <: 'f -> 'g -> 'h
//│     'f <: 'h -> 'i)) <: 'j -> 'd -> 'e
//│     'j <: 'e -> 'c) <: 'k -> 'b
//│     forall 'l. 'l -> (forall 'm, 'n, 'o. ('n -> 'm
//│   where
//│     'l <: 'o -> 'm
//│     forall 'X. ('X -> 'X) -> 'X -> 'X <: 'l -> 'n -> 'o)) <: (forall 'c, 'd, 'e. ('d -> 'c
//│   where
//│     forall 'f. 'f -> (forall 'g, 'h, 'i. ('g -> 'i
//│   where
//│     forall 'X. ('X -> 'X) -> 'X -> 'X <: 'f -> 'g -> 'h
//│     'f <: 'h -> 'i)) <: 'j -> 'd -> 'e
//│     'j <: 'e -> 'c)) -> 'a -> 'k
//│   where
//│     'j :> forall 'p, 'q, 'r, 's. (('s & 'p) -> (anything -> 's | 'r)
//│   where
//│     forall 't. 't -> (forall 'u, 'v, 'w. ('u -> 'w
//│   where
//│     't <: 'v -> 'w
//│     forall 'X. ('X -> 'X) -> 'X -> 'X <: 't -> 'u -> 'v)) <: 'j -> 'p -> 'q
//│     'j <: 'q -> 'r)
//│    = [Function (anonymous)]

c2__ = succ_ (succ_ n0_)
//│ c2__: 'a -> (forall 'b, 'c, 'd. ('b -> 'd
//│   where
//│     'a <: 'c -> 'd
//│     forall 'e. 'e -> (forall 'f, 'g, 'h. ('f -> 'h
//│   where
//│     anything -> (forall 'i. 'i -> 'i) <: 'e -> 'f -> 'g
//│     'e <: 'g -> 'h)) <: 'a -> 'b -> 'c))
//│     = [Function (anonymous)]

c2__ c2__
//│ res: 'a -> 'b
//│   where
//│     forall 'c. 'c -> (forall 'd, 'e, 'f. ('d -> 'f
//│   where
//│     'c <: 'e -> 'f
//│     anything -> (forall 'g. 'g -> 'g) <: 'c -> 'd -> 'e)) <: (forall 'h. 'h -> (forall 'i, 'j, 'k. ('k -> 'j
//│   where
//│     'h <: 'i -> 'j
//│     forall 'l. 'l -> (forall 'm, 'n, 'o. ('m -> 'o
//│   where
//│     'l <: 'n -> 'o
//│     anything -> (forall 'g. 'g -> 'g) <: 'l -> 'm -> 'n)) <: 'h -> 'k -> 'i))) -> 'a -> 'p
//│     forall 'h. 'h -> (forall 'i, 'j, 'k. ('k -> 'j
//│   where
//│     'h <: 'i -> 'j
//│     forall 'l. 'l -> (forall 'm, 'n, 'o. ('m -> 'o
//│   where
//│     'l <: 'n -> 'o
//│     anything -> (forall 'g. 'g -> 'g) <: 'l -> 'm -> 'n)) <: 'h -> 'k -> 'i)) <: 'p -> 'b
//│    = [Function (anonymous)]

c2__ c2__ K
//│ res: 'a -> 'b
//│   where
//│     forall 'c. 'c -> (forall 'd, 'e, 'f. ('d -> 'f
//│   where
//│     anything -> (forall 'g. 'g -> 'g) <: 'c -> 'd -> 'e
//│     'c <: 'e -> 'f)) <: (forall 'h, 'i, 'j. ('h -> 'j
//│   where
//│     forall 'k. 'k -> (forall 'l, 'm, 'n. ('n -> 'm
//│   where
//│     anything -> (forall 'g. 'g -> 'g) <: 'k -> 'n -> 'l
//│     'k <: 'l -> 'm)) <: (forall 'o. 'o -> anything -> 'o) -> 'h -> 'i
//│     forall 'o. 'o -> anything -> 'o <: 'i -> 'j)) -> 'a -> 'p
//│     forall 'h, 'i, 'j. ('h -> 'j
//│   where
//│     forall 'k. 'k -> (forall 'l, 'm, 'n. ('n -> 'm
//│   where
//│     anything -> (forall 'g. 'g -> 'g) <: 'k -> 'n -> 'l
//│     'k <: 'l -> 'm)) <: (forall 'o. 'o -> anything -> 'o) -> 'h -> 'i
//│     forall 'o. 'o -> anything -> 'o <: 'i -> 'j) <: 'p -> 'b
//│    = [Function (anonymous)]



