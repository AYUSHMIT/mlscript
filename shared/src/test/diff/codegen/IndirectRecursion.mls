

def z: (('a -> 'b) -> (('a -> 'b) & 'c)) -> 'c
//│ z: (('a -> 'b) -> ('a -> 'b & 'c)) -> 'c
//│  = <missing implementation>

:e
def z =
  (fun f -> (fun x -> f (fun v -> (x x) v)) (fun x -> f (fun v -> (x x) v)))
//│ (('a -> 'b) -> ('c -> 'd & 'a -> 'b) & ('c -> 'd) -> 'e) -> (error | 'e)
//│   <:  z:
//│ (('a -> 'b) -> ('a -> 'b & 'c)) -> 'c
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.9: 	  (fun f -> (fun x -> f (fun v -> (x x) v)) (fun x -> f (fun v -> (x x) v)))
//│ ║       	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 2. (α44_59''' -> α53_63''')›  <:  α44_76''    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 2. (α44_59''' -> α53_63''')›  <:  α44_59'''
//│  = [Function: z]

def z =
  (fun f -> (fun x -> f (fun v -> (x x) v)) (fun x -> f (fun v -> (x x) v))!)
//│ (('a -> 'b) -> ('c -> 'd & 'a -> 'b) & ('c -> 'd) -> 'e) -> 'e
//│   <:  z:
//│ (('a -> 'b) -> ('a -> 'b & 'c)) -> 'c
//│  = [Function: z1]


def pow1 = z (fun pow0 -> fun n -> fun x ->
    if n > 0 then pow0 (n - 1) x * x
    else 1
  )
//│ pow1: int -> int -> int
//│     = [Function: pow1]

pow1 3 4
//│ res: int
//│    = 64


:e
z (fun self -> 1)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.42: 	z (fun self -> 1)
//│ ║        	^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `1` is not a function
//│ ║  l.42: 	z (fun self -> 1)
//│ ║        	               ^
//│ ╟── Note: constraint arises from function type:
//│ ║  l.3: 	def z: (('a -> 'b) -> (('a -> 'b) & 'c)) -> 'c
//│ ║       	                       ^^^^^^^^^^
//│ ╟── from intersection type:
//│ ║  l.3: 	def z: (('a -> 'b) -> (('a -> 'b) & 'c)) -> 'c
//│ ╙──     	                      ^^^^^^^^^^^^^^^^^
//│ res: 1 | error
//│    = 1


zid = z (fun self -> id)
//│ zid: 'a -> 'a
//│    = [Function: id]

zid 1
//│ res: 1
//│    = 1


zargs = z (fun self -> fun x -> self)
//│ zargs: 'b
//│   where
//│     'b :> anything -> 'b
//│      = [Function (anonymous)]

zargs 1
//│ res: 'b
//│   where
//│     'b :> anything -> 'b
//│    = [Function (anonymous)]

zargs 1 2 3 4
//│ res: 'b
//│   where
//│     'b :> anything -> 'b
//│    = [Function (anonymous)]


loop = z (fun self -> self)
//│ loop: anything -> nothing
//│     = [Function (anonymous)]

:re
loop 1
//│ res: nothing
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded


def pow pow n x =
    if n > 0 then pow (n - 1) x * x
    else 1
//│ pow: (int -> 'a -> int) -> int -> (int & 'a) -> int
//│    = [Function: pow]

def pow = z pow
pow 3 4
//│ pow: int -> int -> int
//│    = [Function: pow2]
//│ res: int
//│    = 64


def oops = z (fun f -> f)
//│ oops: anything -> nothing
//│     = [Function: oops]

:re
oops 1
//│ res: nothing
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded



:NoRecursiveTypes

:e
def z =
  (fun f -> (fun x -> f (fun v -> (x x) v)) (fun x -> f (fun v -> (x x) v)))
//│ (('a -> 'b) -> ('c -> 'd & 'a -> 'b) & ('c -> 'd) -> 'e) -> (error | 'e)
//│   <:  z:
//│ (('a -> 'b) -> ('a -> 'b & 'c)) -> 'c
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.128: 	  (fun f -> (fun x -> f (fun v -> (x x) v)) (fun x -> f (fun v -> (x x) v)))
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 2. (α627_642''' -> α636_646''')›  <:  α627_659''    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 2. (α627_642''' -> α636_646''')›  <:  α627_642'''
//│  = [Function: z2]

:e
def z =
  (fun f -> (fun x -> f (fun v -> (x x) v)) (fun x -> f (fun v -> (x x) v))!)
//│ ╔══[ERROR] Inferred recursive type: 'a
//│   where
//│     'a :> 'a -> nothing
//│        <: 'a -> nothing -> anything
//│ ╙──
//│ (('a -> 'b) -> ('c -> 'd & 'a -> 'b) & ('c -> 'd) -> 'e) -> 'e
//│   <:  z:
//│ (('a -> 'b) -> ('a -> 'b & 'c)) -> 'c
//│  = [Function: z3]

:NoCycleCheck

// Exceeds recursion depth limit:
:e
def z =
  (fun f -> (fun x -> f (fun v -> (x x) v)) (fun x -> f (fun v -> (x x) v)))
//│ ((anything -> nothing) -> anything) -> error
//│   <:  z:
//│ (('a -> 'b) -> ('a -> 'b & 'c)) -> 'c
//│ ╔══[ERROR] Subtyping constraint of the form `forall ?a, ?b, ?c, ?d, ?e. ?b -> ?a <: (forall ?f, ?g, ?h, ?i, ?j. ?g -> ?f) -> ?k` exceeded recursion depth limit (250)
//│ ║  l.158: 	  (fun f -> (fun x -> f (fun v -> (x x) v)) (fun x -> f (fun v -> (x x) v)))
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── while constraining:  α956_1018''  <!<  α956_1023''
//│ ╟── while constraining:  (α956_1018'',)  <!<  (α956_1023'',)
//│ ╟── while constraining:  (α956_1023'' -> ‹∀ 3. α965_1022''''›)  <!<  ((α956_1018'',) -> α959_1019'')
//│ ╟── while constraining:  ‹∀ 2. (α956_971''' -> ‹∀ 3. α965_1022''''›)›  <!<  ((α956_1018'',) -> α959_1019'')
//│ ╟── while constraining:  ‹∀ 2. (α956_971''' -> α965_975''')›  <!<  ((α956_1018'',) -> α959_1019'')
//│ ╟── while constraining:  ‹∀ 2. (α956_971''' -> α965_975''')›  <!<  α956_1018''
//│ ╟── while constraining:  α956_1013''  <!<  α956_1018''
//│ ╟── while constraining:  (α956_1013'',)  <!<  (α956_1018'',)
//│ ╟── while constraining:  (α956_1018'' -> ‹∀ 3. α965_1017''''›)  <!<  ((α956_1013'',) -> α959_1014'')
//│ ╟── while constraining:  ‹∀ 2. (α956_971''' -> ‹∀ 3. α965_1017''''›)›  <!<  ((α956_1013'',) -> α959_1014'')
//│ ╟── while constraining:  ‹∀ 2. (α956_971''' -> α965_975''')›  <!<  ((α956_1013'',) -> α959_1014'')
//│ ╟── while constraining:  ‹∀ 2. (α956_971''' -> α965_975''')›  <!<  α956_1013''
//│ ╟── while constraining:  α956_1008''  <!<  α956_1013''
//│ ╟── while constraining:  (α956_1008'',)  <!<  (α956_1013'',)
//│ ╟── while constraining:  (α956_1013'' -> ‹∀ 3. α965_1012''''›)  <!<  ((α956_1008'',) -> α959_1009'')
//│ ╟── ......
//│ ╟── ......
//│ ╟── while constraining:  (α956_983'',)  <!<  (α956_988'',)
//│ ╟── while constraining:  (α956_988'' -> ‹∀ 3. α965_987''''›)  <!<  ((α956_983'',) -> α959_984'')
//│ ╟── while constraining:  ‹∀ 2. (α956_971''' -> ‹∀ 3. α965_987''''›)›  <!<  ((α956_983'',) -> α959_984'')
//│ ╟── while constraining:  ‹∀ 2. (α956_971''' -> α965_975''')›  <!<  ((α956_983'',) -> α959_984'')
//│ ╟── while constraining:  ‹∀ 2. (α956_971''' -> α965_975''')›  <!<  α956_983''
//│ ╟── while constraining:  α936_978''  <!<  α956_983''
//│ ╟── while constraining:  (α936_978'',)  <!<  (α956_983'',)
//│ ╟── while constraining:  (α956_983'' -> ‹∀ 3. α965_982''''›)  <!<  ((α936_978'',) -> α939_979'')
//│ ╟── while constraining:  ‹∀ 2. (α956_971''' -> ‹∀ 3. α965_982''''›)›  <!<  ((α936_978'',) -> α939_979'')
//│ ╟── while constraining:  ‹∀ 2. (α956_971''' -> α965_975''')›  <!<  ((α936_978'',) -> α939_979'')
//│ ╟── while constraining:  ‹∀ 2. (α956_971''' -> α965_975''')›  <!<  α936_978''
//│ ╟── while constraining:  (‹∀ 2. (α956_971''' -> α965_975''')›,)  <!<  (α936_978'',)
//│ ╟── while constraining:  (α936_978'' -> ‹∀ 3. α945_977''''›)  <!<  ((‹∀ 2. (α956_971''' -> α965_975''')›,) -> α976'')
//│ ╟── while constraining:  ‹∀ 2. (α936_951''' -> ‹∀ 3. α945_977''''›)›  <!<  ((‹∀ 2. (α956_971''' -> α965_975''')›,) -> α976'')
//│ ╙── while constraining:  ‹∀ 2. (α936_951''' -> α945_955''')›  <!<  ((‹∀ 2. (α956_971''' -> α965_975''')›,) -> α976'')
//│  = [Function: z4]

:e
def z =
  (fun f -> (fun x -> f (fun v -> (x x) v)) (fun x -> f (fun v -> (x x) v))!)
//│ ╔══[ERROR] Inferred recursive type: 'a
//│   where
//│     'a :> 'a -> nothing
//│        <: 'a -> nothing -> anything
//│ ╙──
//│ (('a -> 'b) -> ('c -> 'd & 'a -> 'b) & ('c -> 'd) -> 'e) -> 'e
//│   <:  z:
//│ (('a -> 'b) -> ('a -> 'b & 'c)) -> 'c
//│  = [Function: z5]

