:NewDefs
:NoJS

fun power(x) = case
  0 then `1.0
  n then x `*. power(x)(n - 1)
//│ fun power: forall 'a. Code[Num, 'a] -> (0 | Int & ~0) -> Code[Num, 'a]


:e
let p3 = y `=>
  discard(run(x `=> power(x `+ y)(3)))
  y
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.12: 	  discard(run(x `=> power(x `+ y)(3)))
//│ ║        	          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╙── expression of type `?y & ~??x` does not match type `nothing`
//│ let p3: Code[forall 'a. (Int & 'a) -> 'a, nothing]


:e
`let y = `42 in
  discard(run(x `=> power(x `+ y)(3)))
  y
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.23: 	  discard(run(x `=> power(x `+ y)(3)))
//│ ║        	          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╙── expression of type `?y & ~??x` does not match type `nothing`
//│ Code[42, nothing]


:e
`let y = `42 in
  discard(run(`let x = `0 in power(x `+ y)(3)))
  y
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.34: 	  discard(run(`let x = `0 in power(x `+ y)(3)))
//│ ║        	          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╙── expression of type `?y & ~??x` does not match type `nothing`
//│ Code[42, nothing]


fun bind(rhs, k: forall 'g : Code['a, 'g] -> Code['b, 'c | 'g]) =
  `let x = rhs in k(x)
//│ fun bind: forall 'a 'c 'b. (Code['a, 'c], k: forall 'g. Code['a, 'g] -> Code['b, 'g | 'c]) -> Code['b, 'c]


// fun body: forall 'g : (Code[Int, 'g], Code[Int, 'g]) -> Int -> Code[Int, 'g]
fun body(x, y) = case
  0 then x
  1 then y
  n then bind of x `+ y, z => body(y, z)(n - 1)
//│ fun body: forall 'a. (Code[Int, anything] & 'a, Code[Int, anything] & 'a) -> (0 | 1 | Int & ~0 & ~1) -> (Code[Int, anything] | 'a)


n => (x, y) `=> body(x, y)(n)
//│ (0 | 1 | Int & ~0 & ~1) -> Code[(Int, Int) -> Int, ??g & ~??y]

fun gib(n) = ((x, y) `=> body(x, y)(n))
//│ fun gib: (0 | 1 | Int & ~0 & ~1) -> Code[(Int, Int) -> Int, ??g & ~??y]


let g5 = gib(5)
//│ let g5: Code[(Int, Int) -> Int, ??g & ~??y]

:e
run(g5)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.67: 	run(g5)
//│ ║        	^^^^^^^
//│ ╙── expression of type `??g & ~??y` does not match type `nothing`
//│ error | (Int, Int) -> Int

x `=> x `+ (x `=> x)`(`42)
//│ Code[Int -> Int, nothing]

// * Note that `` `let ... `` requires an expression after the `in` keyword
// * so we need indentations here to use statements (e.g., `mut`).
fun foo =
  `let x = `1 in
    mut let v = x
    `let x = `true
    x
//│ fun foo: Code[true, nothing]


class Ref[A](init: A) { mut val value: A = init }
//│ class Ref[A](init: A) {
//│   val value: A
//│ }


fun foo =
  `let x = `1
  let v = Ref(x)
  `let x = `true
  (set v.value = x), x
//│ fun foo: Code[true, nothing]
