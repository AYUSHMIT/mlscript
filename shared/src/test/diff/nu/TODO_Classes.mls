:NewDefs





// *** Class instantiation *** //


class C
//│ class C {
//│   constructor()
//│ }

new C
//│ C
//│ res
//│     = C {}

// TODO Forbid?
new C()
//│ C
//│ res
//│     = C {}

:e
C()
//│ ╔══[ERROR] Construction of unparameterized class C should use the `new` keyword
//│ ║  l.27: 	C()
//│ ╙──      	^
//│ C
//│ res
//│ Runtime error:
//│   TypeError: Class constructor C cannot be invoked without 'new'


class D(x: Int)
//│ class D(x: Int)

:js
D(0)
//│ D
//│ // Prelude
//│ class TypingUnit5 {}
//│ const typing_unit5 = new TypingUnit5;
//│ // Query 1
//│ res = D(0);
//│ // End of generated code
//│ res
//│     = D {}

// TODO reject or accept?
:js
new D(0)
//│ D
//│ // Prelude
//│ class TypingUnit6 {}
//│ const typing_unit6 = new TypingUnit6;
//│ // Query 1
//│ res = new D.class(0);
//│ // End of generated code
//│ res
//│     = D {}



// *** Explicit unapply *** //


// function D ...
// D.class = class D { #x; static unapply(self) { return [self.#x] } }
// D.unapply = D.class.unapply


class D(x: Int)
//│ class D(x: Int)

D.unapply
//│ forall 'x. (D & {x: 'x}) -> ['x]
//│ res
//│     = [Function: unapply]

D.unapply(D(42))
//│ [Int]
//│ res
//│     = [ 42 ]

:e
D.unapply({ x: 42 })
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.89: 	D.unapply({ x: 42 })
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── record literal of type `{x: 42}` is not an instance of type `D`
//│ ║  l.89: 	D.unapply({ x: 42 })
//│ ╙──      	               ^^
//│ error | [42]
//│ res
//│ Runtime error:
//│   TypeError: Cannot read private member #x from an object whose class did not declare it

class DT[T](x: T)
DT.unapply
//│ class DT[T](x: T)
//│ forall 'x. (DT[anything] & {x: 'x}) -> ['x]
//│ res
//│     = [Function: unapply]

DT.unapply(DT(42))
//│ [42]
//│ res
//│     = [ 42 ]

:e
DT.unapply({ x: 42 })
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.114: 	DT.unapply({ x: 42 })
//│ ║         	^^^^^^^^^^^^^^^^^^^^^
//│ ╟── record literal of type `{x: 42}` is not an instance of type `DT`
//│ ║  l.114: 	DT.unapply({ x: 42 })
//│ ╙──       	                ^^
//│ error | [42]
//│ res
//│ Runtime error:
//│   TypeError: Cannot read private member #x from an object whose class did not declare it

// *** First-class classes *** //


class C
//│ class C {
//│   constructor()
//│ }

:e
fun foo(c) = new c
//│ ╔══[ERROR] Cannot use `new` on non-class variable of type ?a
//│ ║  l.135: 	fun foo(c) = new c
//│ ╙──       	             ^^^^^
//│ fun foo: anything -> error

:re
foo(() => 123)
//│ error
//│ res
//│ Runtime error:
//│   TypeError: c is not a constructor

:e
foo(C)
//│ ╔══[ERROR] Construction of unparameterized class C should use the `new` keyword
//│ ║  l.149: 	foo(C)
//│ ╙──       	    ^
//│ error
//│ res
//│     = C {}


:e
fun bar(c) = new c(123)
//│ ╔══[ERROR] Cannot use `new` on non-class variable of type ?a
//│ ║  l.159: 	fun bar(c) = new c(123)
//│ ╙──       	             ^^^^^^^^^^
//│ fun bar: anything -> error

:re
bar(D)
//│ error
//│ res
//│ Runtime error:
//│   TypeError: c is not a constructor

:e // TODO accept when we have first-class classes
bar(D.class)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.173: 	bar(D.class)
//│ ║         	    ^^^^^^^
//│ ╟── reference of type `(x: Int) -> D` does not have field 'class'
//│ ║  l.173: 	bar(D.class)
//│ ╙──       	    ^
//│ error
//│ res
//│     = D {}



// *** Refinements *** //


class C
//│ class C {
//│   constructor()
//│ }

:e // TODO
new C { val x = 1 }
//│ ╔══[ERROR] Currently unsupported `new` syntax
//│ ║  l.195: 	new C { val x = 1 }
//│ ╙──       	^^^^^^^^^^^^^^^^^^^
//│ error
//│ Code generation encountered an error:
//│   custom class body is not supported yet



// *** Path-dependent types *** //


class Cls[A] { fun x: A = x }
//│ class Cls[A] {
//│   constructor()
//│   fun x: A
//│ }

let c = new Cls
//│ let c: forall 'A. Cls['A]
//│ c
//│   = Cls {}

// FIXME
let y: c.A = c.x
//│ ╔══[ERROR] type identifier not found: c
//│ ║  l.220: 	let y: c.A = c.x
//│ ╙──       	       ^
//│ /!!!\ Uncaught error: scala.NotImplementedError: an implementation is missing



// *** GADTs *** //


class Cls[A] { fun x: A = x; fun g: A -> Int; fun g = g }
//│ class Cls[A] {
//│   constructor()
//│   fun g: A -> Int
//│   fun x: A
//│ }


:e // TODO
fun test(a: Object) = if a is
  Cls then a.x
  else error
//│ ╔══[ERROR] Type error in `case` expression
//│ ║  l.240: 	fun test(a: Object) = if a is
//│ ║         	                         ^^^^
//│ ║  l.241: 	  Cls then a.x
//│ ║         	^^^^^^^^^^^^^^
//│ ║  l.242: 	  else error
//│ ║         	^^^^^^^^^^^^
//│ ╟── type variable `A` leaks out of its scope
//│ ║  l.231: 	class Cls[A] { fun x: A = x; fun g: A -> Int; fun g = g }
//│ ╙──       	          ^
//│ fun test: (a: Object) -> (error | ??A)

:e // TODO
fun test(a: Object) = if a is
  Cls then a.g(a.x) // a.x : a.A ; a.g : a.A -> a.A
  else 0
//│ ╔══[ERROR] Type error in `case` expression
//│ ║  l.256: 	fun test(a: Object) = if a is
//│ ║         	                         ^^^^
//│ ║  l.257: 	  Cls then a.g(a.x) // a.x : a.A ; a.g : a.A -> a.A
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.258: 	  else 0
//│ ║         	^^^^^^^^
//│ ╟── type variable `A` leaks out of its scope
//│ ║  l.231: 	class Cls[A] { fun x: A = x; fun g: A -> Int; fun g = g }
//│ ╙──       	          ^
//│ fun test: (a: Object) -> Int


class Cls[out A] { fun x: A = x }
//│ class Cls[A] {
//│   constructor()
//│   fun x: A
//│ }

fun test(a: Object) = if a is
  Cls then a.x
  else error
//│ fun test: (a: Object) -> ??A

fun test(a: Object) = if a is
  Cls then a
  else error
//│ fun test: (a: Object) -> Cls[??A]

:re
test(0).x
//│ ??A
//│ res
//│ Runtime error:
//│   Error: an error was thrown


// class Expr[T] {
//   constructor
//     IntLit(n: Int) { T = Int }
//     BoolLit(b: Bool) { T = Bool }
// }
// 
// fun foo(x) = if x is
//    IntLit then x.n as x.T
//    BoolLit then x.b
// foo: (x: IntLit | BoolLit) -> x.T | Bool
// 
// fun foo(x) = if x is
//    IntLit then x.n as x.T
//    BoolLit then x.b as x.T
// foo: (x: IntLit | BoolLit) -> x.T
//   <: Expr['a] -> 'a
// 
// fun foo(x: Expr[T]): T = if x is
//    IntLit then x.n // in Scala, compiler sees x.n : Int = x.T <: T
//    BoolLit then x.b

abstract class Expr[A]: IntLit | BoolLit {}
class IntLit() extends Expr[Int]
class BoolLit() extends Expr[Bool]
//│ abstract class Expr[A]: BoolLit | IntLit
//│ class IntLit() extends Expr
//│ class BoolLit() extends Expr

fun test(f: ((IntLit | BoolLit) -> Int)) =
  f : Expr[anything] -> Int
//│ fun test: (f: (BoolLit | IntLit) -> Int) -> Expr[anything] -> Int

class OopsLit() extends Expr[Bool]
//│ class OopsLit() extends Expr

fun test(a) = if a is
  IntLit then 0
  OopsLit then 1
//│ fun test: (IntLit | OopsLit) -> (0 | 1)


