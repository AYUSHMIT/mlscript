:NewDefs

:NoJS // TODO enable JS



trait T1 { fun x: 0 | 1 }
trait T2 { fun x: 1 | 2 }
//│ trait T1 {
//│   fun x: 0 | 1
//│ }
//│ trait T2 {
//│   fun x: 1 | 2
//│ }

:e // TODO mk abstract
class C1 { fun x: 0 | 2 }
//│ ╔══[ERROR] Member x is declared but not defined
//│ ║  l.17: 	class C1 { fun x: 0 | 2 }
//│ ╙──      	               ^
//│ class C1 {
//│   fun x: 0 | 2
//│ }

:e
module M extends C1, T1 {
  fun x = 2
}
//│ ╔══[ERROR] Type mismatch in definition of method x:
//│ ║  l.27: 	  fun x = 2
//│ ║        	      ^^^^^
//│ ╟── integer literal of type `2` does not match type `0 | 1`
//│ ║  l.27: 	  fun x = 2
//│ ║        	          ^
//│ ╟── but it flows into definition of method x with expected type `0 | 1`
//│ ║  l.27: 	  fun x = 2
//│ ║        	      ^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.7: 	trait T1 { fun x: 0 | 1 }
//│ ║       	                  ^^^^^
//│ ╟── from signature of member x:
//│ ║  l.7: 	trait T1 { fun x: 0 | 1 }
//│ ╙──     	               ^^^^^^^^
//│ module M {
//│   fun x: 2
//│ }

:e // TODO mk abstract
class C2 extends C1, T1
//│ ╔══[ERROR] Type mismatch in signature of member x:
//│ ║  l.17: 	class C1 { fun x: 0 | 2 }
//│ ║        	               ^^^^^^^^
//│ ╟── type `2` does not match type `0 | 1`
//│ ║  l.17: 	class C1 { fun x: 0 | 2 }
//│ ║        	                      ^
//│ ╟── but it flows into union type with expected type `0 | 1`
//│ ║  l.17: 	class C1 { fun x: 0 | 2 }
//│ ║        	                  ^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.7: 	trait T1 { fun x: 0 | 1 }
//│ ║       	                  ^^^^^
//│ ╟── from signature of member x:
//│ ║  l.7: 	trait T1 { fun x: 0 | 1 }
//│ ╙──     	               ^^^^^^^^
//│ class C2 {
//│   fun x: 0 | 2
//│ }

// * TODO error?
module M extends C2 {
  fun x = 2
}
//│ module M {
//│   fun x: 2
//│ }

class C1 { fun x: 0 | 2 = 0 }
//│ class C1 {
//│   fun x: 0 | 2
//│ }



:e
module M extends C1, T1
//│ ╔══[ERROR] Type mismatch in definition of method x:
//│ ║  l.77: 	class C1 { fun x: 0 | 2 = 0 }
//│ ║        	               ^^^^^^^^^^^^
//│ ╟── type `2` does not match type `0 | 1`
//│ ║  l.77: 	class C1 { fun x: 0 | 2 = 0 }
//│ ║        	                      ^
//│ ╟── but it flows into union type with expected type `0 | 1`
//│ ║  l.77: 	class C1 { fun x: 0 | 2 = 0 }
//│ ║        	                  ^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.7: 	trait T1 { fun x: 0 | 1 }
//│ ║       	                  ^^^^^
//│ ╟── from signature of member x:
//│ ║  l.7: 	trait T1 { fun x: 0 | 1 }
//│ ╙──     	               ^^^^^^^^
//│ module M {
//│   fun x: 0 | 2
//│ }

:e
module M extends T1, C1
//│ ╔══[ERROR] Type mismatch in definition of method x:
//│ ║  l.77: 	class C1 { fun x: 0 | 2 = 0 }
//│ ║        	               ^^^^^^^^^^^^
//│ ╟── type `2` does not match type `0 | 1`
//│ ║  l.77: 	class C1 { fun x: 0 | 2 = 0 }
//│ ║        	                      ^
//│ ╟── but it flows into union type with expected type `0 | 1`
//│ ║  l.77: 	class C1 { fun x: 0 | 2 = 0 }
//│ ║        	                  ^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.7: 	trait T1 { fun x: 0 | 1 }
//│ ║       	                  ^^^^^
//│ ╟── from signature of member x:
//│ ║  l.7: 	trait T1 { fun x: 0 | 1 }
//│ ╙──     	               ^^^^^^^^
//│ module M {
//│   fun x: 0 | 2
//│ }

:e
module M extends T1, T2, C1 {
  fun x = this.x
}
//│ ╔══[ERROR] Indirectly-recursive member should have type annotation
//│ ║  l.128: 	  fun x = this.x
//│ ╙──       	              ^^
//│ module M {
//│   fun x: error
//│ }

:e
module M extends T1, T2, C1 {
  fun x: 0
  fun x = this.x
}
//│ ╔══[ERROR] Type mismatch in definition of method x:
//│ ║  l.140: 	  fun x = this.x
//│ ║         	      ^^^^^^^^^^
//│ ╟── type `0` does not match type `1 | 2`
//│ ║  l.139: 	  fun x: 0
//│ ║         	         ^
//│ ╟── but it flows into field selection with expected type `1 | 2`
//│ ║  l.140: 	  fun x = this.x
//│ ║         	          ^^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.8: 	trait T2 { fun x: 1 | 2 }
//│ ║       	                  ^^^^^
//│ ╟── from signature of member x:
//│ ║  l.8: 	trait T2 { fun x: 1 | 2 }
//│ ╙──     	               ^^^^^^^^
//│ module M {
//│   fun x: 0
//│ }

module M extends C1, T2 {
  fun x: 2
  fun x = this.x
}
//│ module M {
//│   fun x: 2
//│ }



:e
class C2 extends T1
//│ ╔══[ERROR] Member x is declared in parent trait but not implemented
//│ ║  l.172: 	class C2 extends T1
//│ ╙──       	^^^^^^^^^^^^^^^^^^^
//│ class C2

// TODO
// abstract class C2 extends T1

class C2 extends T1 { fun x = 1 }
//│ class C2 {
//│   fun x: 1
//│ }

:e
class C2 extends T1, T2 { fun x = 2 }
//│ ╔══[ERROR] Type mismatch in definition of method x:
//│ ║  l.187: 	class C2 extends T1, T2 { fun x = 2 }
//│ ║         	                              ^^^^^
//│ ╟── integer literal of type `2` does not match type `0 | 1`
//│ ║  l.187: 	class C2 extends T1, T2 { fun x = 2 }
//│ ║         	                                  ^
//│ ╟── but it flows into definition of method x with expected type `0 | 1`
//│ ║  l.187: 	class C2 extends T1, T2 { fun x = 2 }
//│ ║         	                              ^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.7: 	trait T1 { fun x: 0 | 1 }
//│ ║       	                  ^^^^^
//│ ╟── from signature of member x:
//│ ║  l.7: 	trait T1 { fun x: 0 | 1 }
//│ ╙──     	               ^^^^^^^^
//│ class C2 {
//│   fun x: 2
//│ }

class C2 extends T1, T2 { fun x = 1 }
//│ class C2 {
//│   fun x: 1
//│ }

:e
class C3 extends C2 { fun x = 111 }
//│ ╔══[ERROR] Type mismatch in definition of method x:
//│ ║  l.213: 	class C3 extends C2 { fun x = 111 }
//│ ║         	                          ^^^^^^^
//│ ╟── integer literal of type `111` does not match type `1`
//│ ║  l.213: 	class C3 extends C2 { fun x = 111 }
//│ ║         	                              ^^^
//│ ╟── but it flows into definition of method x with expected type `1`
//│ ║  l.213: 	class C3 extends C2 { fun x = 111 }
//│ ║         	                          ^^^^^^^
//│ ╟── Note: constraint arises from integer literal:
//│ ║  l.207: 	class C2 extends T1, T2 { fun x = 1 }
//│ ║         	                                  ^
//│ ╟── from definition of method x:
//│ ║  l.207: 	class C2 extends T1, T2 { fun x = 1 }
//│ ╙──       	                              ^^^^^
//│ class C3 {
//│   fun x: 111
//│ }

class C3 extends C2 { fun x = 1 }
//│ class C3 {
//│   fun x: 1
//│ }

class C2 extends C1, T1 { fun x = 0 }
//│ class C2 {
//│   fun x: 0
//│ }

class C2 extends T1, C1 { fun x = 0 }
//│ class C2 {
//│   fun x: 0
//│ }

:e
class C2 extends C1, T1 { fun x = 1 }
//│ ╔══[ERROR] Type mismatch in definition of method x:
//│ ║  l.249: 	class C2 extends C1, T1 { fun x = 1 }
//│ ║         	                              ^^^^^
//│ ╟── integer literal of type `1` does not match type `0 | 2`
//│ ║  l.249: 	class C2 extends C1, T1 { fun x = 1 }
//│ ║         	                                  ^
//│ ╟── but it flows into definition of method x with expected type `0 | 2`
//│ ║  l.249: 	class C2 extends C1, T1 { fun x = 1 }
//│ ║         	                              ^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.77: 	class C1 { fun x: 0 | 2 = 0 }
//│ ║        	                  ^^^^^
//│ ╟── from definition of method x:
//│ ║  l.77: 	class C1 { fun x: 0 | 2 = 0 }
//│ ╙──      	               ^^^^^^^^^^^^
//│ class C2 {
//│   fun x: 1
//│ }

:e
class C2 extends T1, C1 { fun x = 1 }
//│ ╔══[ERROR] Type mismatch in definition of method x:
//│ ║  l.270: 	class C2 extends T1, C1 { fun x = 1 }
//│ ║         	                              ^^^^^
//│ ╟── integer literal of type `1` does not match type `0 | 2`
//│ ║  l.270: 	class C2 extends T1, C1 { fun x = 1 }
//│ ║         	                                  ^
//│ ╟── but it flows into definition of method x with expected type `0 | 2`
//│ ║  l.270: 	class C2 extends T1, C1 { fun x = 1 }
//│ ║         	                              ^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.77: 	class C1 { fun x: 0 | 2 = 0 }
//│ ║        	                  ^^^^^
//│ ╟── from definition of method x:
//│ ║  l.77: 	class C1 { fun x: 0 | 2 = 0 }
//│ ╙──      	               ^^^^^^^^^^^^
//│ class C2 {
//│   fun x: 1
//│ }



:e // FIXME reject impl in interface
trait T2 { val r = 1(1) }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.293: 	trait T2 { val r = 1(1) }
//│ ║         	                   ^^^^
//│ ╟── integer literal of type `1` is not a function
//│ ║  l.293: 	trait T2 { val r = 1(1) }
//│ ╙──       	                   ^
//│ trait T2 {
//│   let r: error
//│ }

:e
class C2 extends T2
//│ ╔══[ERROR] Member r is declared in parent trait but not implemented
//│ ║  l.305: 	class C2 extends T2
//│ ╙──       	^^^^^^^^^^^^^^^^^^^
//│ class C2


:e
trait T2[A] {
  val r = C2().x
}
class C2 extends T2[int]
//│ ╔══[ERROR] Unhandled cyclic definition
//│ ║  l.313: 	trait T2[A] {
//│ ║         	^^^^^^^^^^^^^
//│ ║  l.314: 	  val r = C2().x
//│ ╙──       	^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `C2` does not contain member `x`
//│ ║  l.314: 	  val r = C2().x
//│ ╙──       	              ^^
//│ trait T2[A] {
//│   let r: error
//│ }
//│ class C2

:e // FIXME
C2() : T2['X]
//│ ╔══[ERROR] Type `C2` does not contain member `T2#A`
//│ ║  l.313: 	trait T2[A] {
//│ ╙──       	         ^
//│ T2['X]
//│   where
//│     'X :> error


