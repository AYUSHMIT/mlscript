:NewDefs


mixin Test[A] {
    fun bar: (A, A)
    fun bar = (this.a, this.a)
}
//│ mixin Test[A]() {
//│   this: {a: A}
//│   fun bar: (A, A,)
//│ }

class A(a: int) extends Test
//│ class A(a: int) {
//│   fun bar: (int, int,)
//│ }

mixin Test2[S, T] {
    fun x: (S, T)
    fun x = (this.s, this.t)
    fun fb: S => (S, S)
    fun fb(h: S) = (this.s, h)
}
//│ mixin Test2[S, T]() {
//│   this: {s: S, t: T}
//│   fun fb: S -> (S, S,)
//│   fun x: (S, T,)
//│ }

class A1[B](s: bool, t: B) extends Test2[bool, B]
//│ class A1[B](s: bool, t: B) {
//│   fun fb: bool -> (bool, bool,)
//│   fun x: (bool, B,)
//│ }

// TODO: Investigate type of fb
class A2[A](s: A, t: int) extends Test2
//│ class A2[A](s: A, t: int) {
//│   fun fb: 'S -> (A | 'S, A | 'S,)
//│   fun x: (A | 'S, int,)
//│ }

// TODO: Investigate type of fb
class A3(s: int, t: bool) extends Test2
//│ class A3(s: int, t: bool) {
//│   fun fb: 'S -> ('S | int, 'S | int,)
//│   fun x: ('S | int, bool,)
//│ }

class P(p: int) { 
    fun foo(x) = x + p 
}
//│ class P(p: int) {
//│   fun foo: int -> int
//│ }

:e // FIXME
class C1(a: int) extends P(a) { fun bar = this.foo(0) }
//│ ╔══[ERROR] Indirectly-recursive member should have type annotation
//│ ║  l.58: 	class C1(a: int) extends P(a) { fun bar = this.foo(0) }
//│ ╙──      	                                              ^^^^
//│ class C1(a: int) extends P {
//│   fun bar: error
//│   fun foo: int -> int
//│ }

:e // FIXME
class C2(a: int, b: int) extends P(a + b) {
    fun foo(x) = x * this.p + a * b
}
//│ ╔══[ERROR] Indirectly-recursive member should have type annotation
//│ ║  l.69: 	    fun foo(x) = x * this.p + a * b
//│ ╙──      	                         ^^
//│ class C2(a: int, b: int) extends P {
//│   fun foo: int -> int
//│ }

let c2 =  C2(1, 2)
//│ let c2: C2
//│ c2
//│    = C2 {}

c2.foo(2)
//│ int
//│ res
//│     = 8

c2.p
//│ int
//│ res
//│     = 3


class Test[A](x: A)
//│ class Test[A](x: A)

class A(a: int) extends Test(a)
//│ class A(a: int) extends Test

let a1 = A(1)
//│ let a1: A
//│ a1
//│    = A {}

a1: Test['x]
//│ Test['x]
//│   where
//│     'x :> int
//│ res
//│     = A {}

a1.x
//│ int
//│ res
//│     = 1


:NoJS // TODO

trait Foo[A] {
    fun foo[A](x: A): A
}
//│ trait Foo[A] {
//│   fun foo: forall 'A. (x: 'A,) -> 'A
//│ }

:e
class B extends Foo {
    fun foo(x) = x + 1
}
//│ ╔══[ERROR] Type mismatch in definition of method foo:
//│ ║  l.129: 	    fun foo(x) = x + 1
//│ ║         	        ^^^^^^^^^^^^^^
//│ ╟── type `A` is not an instance of type `int`
//│ ║  l.121: 	    fun foo[A](x: A): A
//│ ║         	            ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.129: 	    fun foo(x) = x + 1
//│ ╙──       	                 ^
//│ ╔══[ERROR] Type mismatch in definition of method foo:
//│ ║  l.129: 	    fun foo(x) = x + 1
//│ ║         	        ^^^^^^^^^^^^^^
//│ ╟── operator application of type `int` does not match type `A`
//│ ║  l.129: 	    fun foo(x) = x + 1
//│ ║         	                 ^^^^^
//│ ╟── Note: constraint arises from method type parameter:
//│ ║  l.121: 	    fun foo[A](x: A): A
//│ ╙──       	            ^
//│ class B extends Foo {
//│   fun foo: int -> int
//│ }
