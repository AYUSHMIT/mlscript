:NewParser
:NewDefs


// * Adapted example from Code reuse through polymorphic variants (FOSE 2000)


:js
module Nil
//│ module Nil()
//│ // Prelude
//│ let res;
//│ let typing_unit = {
//│   cache: {},
//│   get Nil() {
//│     if (this.cache.Nil === undefined) {
//│       class Nil {}
//│       this.cache.Nil = new Nil();
//│       this.cache.Nil["class"] = Nil;
//│     }
//│     return this.cache.Nil;
//│   }
//│ };
//│ globalThis.Nil = typing_unit.Nil;
//│ // End of generated code

class Cons<A>(head: A, tail: Cons<A> | Nil)
//│ class Cons[A](head: A, tail: Cons[A] | Nil)

let l = Cons(1, Nil)
//│ let l: Cons['A]
//│   where
//│     'A :> 1
//│ l
//│   = Cons { head: 1, tail: Nil { class: [class Nil] } }

class NotFound
class Success<A>(result: A)
//│ class NotFound()
//│ class Success[A](result: A)

let e = eq
//│ let e: anything -> anything -> bool
//│ e
//│   = [Function: eq]

let eq(l: string, r: string): bool = e(l)(r)
//│ let eq: (l: string, r: string,) -> bool
//│ eq
//│    = [Function: eq1]

fun list_assoc(s, l) =
  if l is
    Cons(h, t) then
      if eq(s, h._1) then Success(h._2)
      else list_assoc(s, t)
    Nil then NotFound()
//│ fun list_assoc: (string, Cons['A] | Nil,) -> (NotFound | Success['A0])
//│   where
//│     'A <: {_1: string, _2: 'A0}

// fun list_assoc(s: string, l: Cons<{ _1: string, _2: 'b }> | Nil): NotFound | Success['b]

:js
class Var(s: string)
//│ class Var(s: string)
//│ // Prelude
//│ let typing_unit7 = {
//│   cache: {},
//│   get Var() {
//│     if (this.cache.Var === undefined) {
//│       class Var {
//│         constructor(s) {
//│           this.s = s;
//│         }
//│       };
//│       this.cache.Var = ((s) => new Var(s));
//│       this.cache.Var["class"] = Var;
//│     }
//│     return this.cache.Var;
//│   }
//│ };
//│ globalThis.Var = typing_unit7.Var;
//│ // End of generated code

:js
mixin EvalVar {
  fun eval(sub, v) =
    if v is Var(s) then
      if list_assoc(s, sub) is
        NotFound then v
        Success(r) then r
}
//│ mixin EvalVar() {
//│   fun eval: (Cons['A] | Nil, Var,) -> (Var | 'result)
//│ }
//│ where
//│   'A <: {_1: string, _2: 'result}
//│ // Prelude
//│ let typing_unit8 = {
//│   cache: {},
//│   EvalVar(base) {
//│     if (base === undefined) {
//│       return (class EvalVar {
//│         constructor() {
//│         }
//│         eval(sub1, v) {
//│           return ((() => {
//│             let a;
//│             return (a = v, a instanceof Var["class"] ? ((s) => (() => {
//│               return (((tmp0) => {
//│                 let b;
//│                 return (b = tmp0, b instanceof NotFound["class"] ? v : b instanceof Success["class"] ? ((r) => r)(tmp0.result) : (() => {
//│                   throw new Error("non-exhaustive case expression");
//│                 })());
//│               })(list_assoc(s, sub1)));
//│             })())(v.s) : (() => {
//│               throw new Error("non-exhaustive case expression");
//│             })());
//│           })());
//│         }
//│       });
//│     } else {
//│       return (class EvalVar extends base {
//│         constructor(...rest) {
//│           super(...rest);
//│         }
//│         eval(sub1, v) {
//│           return ((() => {
//│             let a;
//│             return (a = v, a instanceof Var["class"] ? ((s) => (() => {
//│               return (((tmp0) => {
//│                 let b;
//│                 return (b = tmp0, b instanceof NotFound["class"] ? v : b instanceof Success["class"] ? ((r) => r)(tmp0.result) : (() => {
//│                   throw new Error("non-exhaustive case expression");
//│                 })());
//│               })(list_assoc(s, sub1)));
//│             })())(v.s) : (() => {
//│               throw new Error("non-exhaustive case expression");
//│             })());
//│           })());
//│         }
//│       });
//│     }
//│   }
//│ };
//│ globalThis.EvalVar = typing_unit8.EvalVar;
//│ // End of generated code

class Abs<A>(x: string, t: A)
class App<A>(s: A, t: A)
//│ class Abs[A](x: string, t: A)
//│ class App[A](s: A, t: A)

fun gensym(): string = "fun"
//│ fun gensym: () -> string

fun int_to_string(x: int): string = "0"
//│ fun int_to_string: (x: int,) -> string

:js
mixin EvalLambda {
  fun eval(sub, v) =
    if v is
      App(t1, t2) then
        let l1 = this.eval(sub, t1)
        let l2 = this.eval(sub, t2)
        if t1 is
          Abs(x, t) then this.eval(Cons((x, l2), Nil), t)
        else
          App(l1, l2)
      Abs(x, t) then
        let s = gensym()
        Abs(s, this.eval(Cons((x, Var(s)), sub), t))
    else
      super.eval(sub, v)
}
//│ mixin EvalLambda() {
//│   super: {eval: ('a, 'b,) -> 'c}
//│   this: {eval: (Cons[in 'A out (string, 'd,) | 'A], 't,) -> 'c & ('a, 't0,) -> ('d & 'e) & (Cons[in 'A0 out (string, Var,) | 'A0 | 'A1], 't1,) -> 'f}
//│   fun eval: ('a & (Cons['A2] | Nil), Abs['t1] | App['t0 & (Abs['t] | ~Abs)] | 'b & ~Abs & ~App,) -> (Abs['f] | App['d | 'e] | 'c)
//│ }
//│ where
//│   'A2 :> (string, Var,) | 'A0
//│       <: 'A1
//│ // Prelude
//│ let typing_unit12 = {
//│   cache: {},
//│   EvalLambda(base) {
//│     if (base === undefined) {
//│       return (class EvalLambda {
//│         constructor() {
//│         }
//│         eval(sub1, v) {
//│           const self = this;
//│           return ((() => {
//│             let a;
//│             return (a = v, a instanceof App["class"] ? ((t1) => ((t2) => (() => {
//│               let l1 = self.eval(sub1, t1);
//│               let l2 = self.eval(sub1, t2);
//│               return (t1 instanceof Abs["class"] ? ((x) => ((t) => self.eval(Cons([
//│                 x,
//│                 l2
//│               ], Nil), t))(t1.t))(t1.x) : (() => {
//│                 return App(l1, l2);
//│               })());
//│             })())(v.t))(v.s) : a instanceof Abs["class"] ? ((x) => ((t) => (() => {
//│               let s = gensym();
//│               return (Abs(s, self.eval(Cons([
//│                 x,
//│                 Var(s)
//│               ], sub1), t)));
//│             })())(v.t))(v.x) : (() => {
//│               return super.eval(sub1, v);
//│             })());
//│           })());
//│         }
//│       });
//│     } else {
//│       return (class EvalLambda extends base {
//│         constructor(...rest) {
//│           super(...rest);
//│         }
//│         eval(sub1, v) {
//│           const self = this;
//│           return ((() => {
//│             let a;
//│             return (a = v, a instanceof App["class"] ? ((t1) => ((t2) => (() => {
//│               let l1 = self.eval(sub1, t1);
//│               let l2 = self.eval(sub1, t2);
//│               return (t1 instanceof Abs["class"] ? ((x) => ((t) => self.eval(Cons([
//│                 x,
//│                 l2
//│               ], Nil), t))(t1.t))(t1.x) : (() => {
//│                 return App(l1, l2);
//│               })());
//│             })())(v.t))(v.s) : a instanceof Abs["class"] ? ((x) => ((t) => (() => {
//│               let s = gensym();
//│               return (Abs(s, self.eval(Cons([
//│                 x,
//│                 Var(s)
//│               ], sub1), t)));
//│             })())(v.t))(v.x) : (() => {
//│               return super.eval(sub1, v);
//│             })());
//│           })());
//│         }
//│       });
//│     }
//│   }
//│ };
//│ globalThis.EvalLambda = typing_unit12.EvalLambda;
//│ // End of generated code

:js
module Test1: EvalVar, EvalLambda
//│ module Test1() {
//│   fun eval: (Cons['A | 'A0] | Nil, 'a,) -> 'result
//│ }
//│ where
//│   'a <: Abs['a] | App['a & (Abs['a] | ~Abs)] | Var
//│   'A :> 'A0
//│      <: 'A0 & 'A1
//│   'A0 :> (string, 'result,)
//│       <: 'A1 & {_1: string, _2: 'result}
//│   'A1 <: 'A & 'A0
//│   'result :> Var | App['result] | Abs['result]
//│ // Prelude
//│ let typing_unit13 = {
//│   cache: {},
//│   get Test1() {
//│     if (this.cache.Test1 === undefined) {
//│       class Test1 extends EvalLambda(EvalVar()) {
//│         constructor(...rest) {
//│           super(...rest);
//│         }
//│       }
//│       this.cache.Test1 = new Test1();
//│       this.cache.Test1["class"] = Test1;
//│     }
//│     return this.cache.Test1;
//│   }
//│ };
//│ globalThis.Test1 = typing_unit13.Test1;
//│ // End of generated code

Test1.eval(Nil, Var("a"))
//│ 'a
//│   where
//│     'a :> App['a] | Abs['a] | Var
//│ res
//│     = Var { s: 'a' }

Test1.eval(Nil, Abs("b", Var("a")))
//│ 'a
//│   where
//│     'a :> App['a] | Abs['a] | Var
//│ res
//│     = Abs { x: 'fun', t: Var { s: 'a' } }

Test1.eval(Cons(("c", Var("d")), Nil), App(Abs("b", Var("b")), Var("c")))
//│ 'a
//│   where
//│     'a :> App['a] | Abs['a] | Var
//│ res
//│     = Var { s: 'b' }

Test1.eval(Cons(("c", Abs("d", Var("d"))), Nil), App(Abs("b", Var("b")), Var("c")))
//│ 'a
//│   where
//│     'a :> App['a] | Abs['a] | Abs[Var] | Var
//│ res
//│     = Var { s: 'b' }

class Num(n: int)
class Add<A>(l: A, r: A)
class Mul<A>(l: A, r: A)
//│ class Num(n: int)
//│ class Add[A](l: A, r: A)
//│ class Mul[A](l: A, r: A)

fun map_expr(f, v) =
  if v is
    Var then v
    Num then v
    Add(l, r) then Add(f(l), f(r))
    Mul(l, r) then Mul(f(l), f(r))
//│ fun map_expr: ('l -> 'A & 'l0 -> 'A0, Add['l] | Mul['l0] | Num | Var,) -> (Add['A] | Mul['A0] | Num | Var)

mixin EvalExpr {
  fun eval(sub, v) =
    fun eta(e) = this.eval(sub, e)
    let vv = map_expr(eta, v)
    if vv is
      Var then super.eval(sub, vv)
      Add(Num(l), Num(r)) then Num(l + r)
      Mul(Num(l), Num(r)) then Num(l * r)
    else v
}
//│ mixin EvalExpr() {
//│   super: {eval: ('a, Var,) -> 'b}
//│   this: {eval: ('a, 'c,) -> anything}
//│   fun eval: ('a, 'd & (Add['c] | Mul['c] | Num | Var),) -> (Num | 'd | 'b)
//│ }

module Test2: EvalVar, EvalExpr
//│ module Test2() {
//│   fun eval: (Cons['A] | Nil, 'a,) -> (Num | Var | 'result | 'a)
//│ }
//│ where
//│   'a <: Add['b] | Mul['b] | Num | Var
//│   'b <: 'a
//│   'A <: {_1: string, _2: 'result}

Test2.eval(Nil, Var("a"))
//│ Num | Var
//│ res
//│     = Var { s: 'a' }

Test2.eval(Cons(("c", Abs("d", Var("d"))), Nil), Var("a"))
//│ Abs[Var] | Num | Var
//│ res
//│     = Var { s: 'a' }

Test2.eval(Cons(("a", Num(1)), Nil), Var("a"))
//│ Num | Var
//│ res
//│     = Var { s: 'a' }

:e
Test2.eval(Cons(("c", Abs("d", Var("d"))), Nil), Abs("a", Var("a")))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.371: 	Test2.eval(Cons(("c", Abs("d", Var("d"))), Nil), Abs("a", Var("a")))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Abs[?A]` does not match type `Add[?A0] | Mul[?A1] | Num | Var`
//│ ║  l.371: 	Test2.eval(Cons(("c", Abs("d", Var("d"))), Nil), Abs("a", Var("a")))
//│ ║         	                                                 ^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.323: 	  if v is
//│ ║         	     ^
//│ ╟── from reference:
//│ ║  l.333: 	    let vv = map_expr(eta, v)
//│ ╙──       	                           ^
//│ Abs[Var] | Num | Var | error
//│ res
//│ Runtime error:
//│   Error: non-exhaustive case expression

Test2.eval(Cons(("a", Abs("d", Var("d"))), Nil), Add(Num(1), Var("a")))
//│ Abs[Var] | Add[Num | Var] | Num | Var
//│ res
//│     = Add { l: Num { n: 1 }, r: Var { s: 'a' } }

module Test3: EvalVar, EvalExpr, EvalLambda
//│ module Test3() {
//│   fun eval: (Cons['A | 'A0] | Nil, 'a,) -> 'result
//│ }
//│ where
//│   'A :> 'A0
//│      <: 'A0 & 'A1
//│   'A0 :> (string, 'result,)
//│       <: 'A1 & {_1: string, _2: 'result}
//│   'A1 <: 'A & 'A0
//│   'result :> App['result] | Abs['result] | Num | 'b | Var
//│   'b <: Add['c] | Mul['c] | Num | Var
//│   'c <: 'a
//│   'a <: Abs['a] | App['a & (Abs['a] | ~Abs)] | 'b & ~Abs & ~App

Test3.eval(Cons(("c", Abs("d", Var("d"))), Nil), Abs("a", Var("a")))
//│ 'a
//│   where
//│     'a :> App['a] | Abs['a] | Abs[Var] | Num | Var
//│ res
//│     = Abs { x: 'fun', t: Var { s: 'a' } }

Test3.eval(Cons(("c", Abs("d", Var("d"))), Nil), App(Abs("a", Var("a")), Add(Num(1), Var("c"))))
//│ 'a
//│   where
//│     'a :> App['a] | Abs['a] | Abs[Var] | Add[Num | Var] | Num | Var
//│ res
//│     = Var { s: 'a' }

:js
module Test3: EvalVar, EvalLambda, EvalExpr
//│ module Test3() {
//│   fun eval: (Cons['A | 'A0] | Nil, 'a,) -> ('a | 'result)
//│ }
//│ where
//│   'A :> 'A0
//│      <: 'A0 & 'A1
//│   'A0 :> (string, 'result,)
//│       <: 'A1 & {_1: string, _2: 'result}
//│   'A1 <: 'A & 'A0
//│   'result :> Abs['result] | App['result] | Num | 'a | Var
//│   'a <: Add['b] | Mul['b] | Num | Var
//│   'b <: 'a
//│ // Prelude
//│ let typing_unit30 = {
//│   cache: {},
//│   get Test31() {
//│     if (this.cache.Test31 === undefined) {
//│       class Test31 extends EvalExpr(EvalLambda(EvalVar())) {
//│         constructor(...rest) {
//│           super(...rest);
//│         }
//│       }
//│       this.cache.Test31 = new Test31();
//│       this.cache.Test31["class"] = Test31;
//│     }
//│     return this.cache.Test31;
//│   }
//│ };
//│ globalThis.Test31 = typing_unit30.Test31;
//│ // End of generated code

// Because EvalExpr does not dispatch lambdas to super and map_expr only
// handles exprs
:e
Test3.eval(Cons(("c", Abs("d", Var("d"))), Nil), Abs("a", Var("a")))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.459: 	Test3.eval(Cons(("c", Abs("d", Var("d"))), Nil), Abs("a", Var("a")))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Abs[?A]` does not match type `Add[?A0] | Mul[?A1] | Num | Var`
//│ ║  l.459: 	Test3.eval(Cons(("c", Abs("d", Var("d"))), Nil), Abs("a", Var("a")))
//│ ║         	                                                 ^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.323: 	  if v is
//│ ║         	     ^
//│ ╟── from reference:
//│ ║  l.333: 	    let vv = map_expr(eta, v)
//│ ╙──       	                           ^
//│ error | 'a
//│   where
//│     'a :> Abs['a] | App['a] | Var | Abs[Var] | Num
//│ res
//│ Runtime error:
//│   Error: non-exhaustive case expression
