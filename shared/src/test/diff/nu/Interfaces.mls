:NewDefs
:NoJS

trait Test { 
    fun foo: int
    fun bar: bool -> bool
}
//│ trait Test() {
//│   fun bar: bool -> bool
//│   fun foo: int
//│ }

trait Oth extends Test {
    fun cool : int -> bool
}
//│ trait Oth() {
//│   fun bar: bool -> bool
//│   fun cool: int -> bool
//│   fun foo: int
//│ }


class C extends Test {
    fun foo = 1
    fun bar(x) = x
}
//│ class C() {
//│   fun bar: bool -> bool
//│   fun foo: int
//│ }

class F extends Oth {
    fun cool(x) = x == 1
    fun foo = 2
    fun bar(x) = x
}
//│ class F() {
//│   fun bar: bool -> bool
//│   fun cool: int -> bool
//│   fun foo: int
//│ }

let c = C()
c.foo
c.bar(true)
//│ let c: C
//│ bool

// FIXME
let c1: Test = C()
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.50: 	let c1: Test = C()
//│ ║        	               ^^^
//│ ╟── application of type `C` is not an instance of type `Test`
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.50: 	let c1: Test = C()
//│ ╙──      	        ^^^^
//│ let c1: Test

:e
class E1 extends Test {
    fun foo = 2
}
//│ ╔══[ERROR] Member bar is declared in parent trait but not implemented
//│ ║  l.61: 	class E1 extends Test {
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.62: 	    fun foo = 2
//│ ║        	^^^^^^^^^^^^^^^
//│ ║  l.63: 	}
//│ ╙──      	^
//│ class E1() {
//│   fun bar: bool -> bool
//│   fun foo: int
//│ }

:e
trait TE1 extends C
//│ ╔══[ERROR] trait can only inherit traits
//│ ║  l.77: 	trait TE1 extends C
//│ ╙──      	                  ^
//│ trait TE1()

:e
class E2 extends Test {
    fun foo = true
    fun bar(x) = x
}
//│ ╔══[ERROR] Type mismatch in definition of method foo:
//│ ║  l.85: 	    fun foo = true
//│ ║        	        ^^^^^^^^^^
//│ ╟── reference of type `true` is not an instance of type `int`
//│ ║  l.85: 	    fun foo = true
//│ ║        	              ^^^^
//│ ╟── but it flows into definition of method foo with expected type `int`
//│ ║  l.85: 	    fun foo = true
//│ ║        	        ^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.5: 	    fun foo: int
//│ ║       	             ^^^
//│ ╟── from signature of member foo:
//│ ║  l.5: 	    fun foo: int
//│ ╙──     	        ^^^^^^^^
//│ class E2() {
//│   fun bar: bool -> bool
//│   fun foo: int
//│ }

// TODO
:e
class D extends Test[int], Test[bool]
//│ ╔══[ERROR] Unsupported parent specification
//│ ║  l.110: 	class D extends Test[int], Test[bool]
//│ ╙──       	                ^^^^^^^^^
//│ ╔══[ERROR] Unsupported parent specification
//│ ║  l.110: 	class D extends Test[int], Test[bool]
//│ ╙──       	                           ^^^^^^^^^^
//│ class D()



trait Base: A | B
class A
class B
//│ trait Base()
//│ class A()
//│ class B()


// FIXME
let b: Base = A()
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.130: 	let b: Base = A()
//│ ║         	              ^^^
//│ ╟── application of type `A` is not an instance of type `Base`
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.130: 	let b: Base = A()
//│ ╙──       	       ^^^^
//│ let b: Base

// FIXME
b: Base & (A | B)
//│ /!!!\ Uncaught error: java.lang.ClassCastException: class mlscript.NuTypeDefs$TypedNuTrt cannot be cast to class mlscript.NuTypeDefs$TypedNuCls (mlscript.NuTypeDefs$TypedNuTrt and mlscript.NuTypeDefs$TypedNuCls are in unnamed module of loader sbt.internal.LayeredClassLoader @6d580313)


// FIXME
trait Base: Foo | Bar
class Foo[A]
class Bar[B]
//│ trait Base()
//│ class Foo[A]()
//│ class Bar[B]()



