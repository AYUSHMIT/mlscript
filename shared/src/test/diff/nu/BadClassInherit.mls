:NewDefs


class C1(x: int)
//│ class C1(x: int)

:e
class C2(x: int) extends C1(y) {
  val y = x
}
//│ ╔══[ERROR] identifier not found: y
//│ ║  l.8: 	class C2(x: int) extends C1(y) {
//│ ╙──     	                            ^
//│ class C2(x: int) extends C1 {
//│   let y: int
//│ }

:e
class C2 extends C1(y) {
  val y: int
}
//│ ╔══[ERROR] identifier not found: y
//│ ║  l.19: 	class C2 extends C1(y) {
//│ ╙──      	                    ^
//│ class C2 extends C1 {
//│   let y: int
//│ }
//│ Code generation encountered an error:
//│   unresolved symbol y

:e
class C2 extends C1(this.y) {
  val y: int
}
//│ ╔══[ERROR] identifier not found: this
//│ ║  l.32: 	class C2 extends C1(this.y) {
//│ ╙──      	                    ^^^^
//│ class C2 extends C1 {
//│   let y: int
//│ }


class C1(x: C1)
//│ class C1(x: C1)

:e
class C2 extends C1(this)
//│ ╔══[ERROR] identifier not found: this
//│ ║  l.47: 	class C2 extends C1(this)
//│ ╙──      	                    ^^^^
//│ class C2 extends C1


class Foo { fun x: int = 1 }
mixin M { fun x = false }
//│ class Foo {
//│   fun x: int
//│ }
//│ mixin M() {
//│   fun x: false
//│ }

:e
class Bar extends Foo, M
//│ ╔══[ERROR] Type mismatch in definition of method x:
//│ ║  l.55: 	mixin M { fun x = false }
//│ ║        	              ^^^^^^^^^
//│ ╟── reference of type `false` is not an instance of type `int`
//│ ║  l.55: 	mixin M { fun x = false }
//│ ║        	                  ^^^^^
//│ ╟── but it flows into definition of method x with expected type `int`
//│ ║  l.55: 	mixin M { fun x = false }
//│ ║        	              ^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.54: 	class Foo { fun x: int = 1 }
//│ ║        	                   ^^^
//│ ╟── from definition of method x:
//│ ║  l.54: 	class Foo { fun x: int = 1 }
//│ ╙──      	                ^^^^^^^^^^
//│ class Bar extends Foo {
//│   fun x: false
//│ }


