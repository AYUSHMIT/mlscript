:NewDefs



module Oops {
  fun a : int
  fun a = 2
}
//│ module Oops {
//│   fun a: int
//│ }

:e
module Oops {
  fun a : int
}
//│ ╔══[ERROR] Member a is declared but not defined
//│ ║  l.15: 	  fun a : int
//│ ╙──      	      ^
//│ module Oops {
//│   fun a: int
//│ }

:e
module Oops {
  fun a : int
  fun a : string
  fun a = a
}
//│ ╔══[ERROR] A type signature for 'a' has already been given
//│ ║  l.27: 	  fun a : string
//│ ╙──      	      ^^^^^^^^^^
//│ module Oops {
//│   fun a: string
//│ }

:e
module Oops {
  fun a : int
  fun a = false
}
//│ ╔══[ERROR] Type mismatch in definition of method a:
//│ ║  l.40: 	  fun a = false
//│ ║        	      ^^^^^^^^^
//│ ╟── reference of type `false` is not an instance of type `int`
//│ ║  l.40: 	  fun a = false
//│ ║        	          ^^^^^
//│ ╟── but it flows into definition of method a with expected type `int`
//│ ║  l.40: 	  fun a = false
//│ ║        	      ^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.39: 	  fun a : int
//│ ║        	          ^^^
//│ ╟── from signature of member a:
//│ ║  l.39: 	  fun a : int
//│ ╙──      	      ^^^^^^^
//│ module Oops {
//│   fun a: int
//│ }

:e
module Oops {
  fun a = 1
  fun a = 2
}
//│ ╔══[ERROR] Refininition of a
//│ ║  l.64: 	  fun a = 2
//│ ╙──      	      ^^^^^
//│ module Oops {
//│   fun a: 2
//│ }



// * Without a type signature, the method's inferred type is not generalized
module A {
  fun i(x) = x
}
//│ module A {
//│   fun i: 'a -> 'a
//│ }

// * With a type signature, it is generalized and checked against the signature
module A {
  
  fun i: forall 'a; 'a -> 'a
  fun i(x) = x
  
  fun j: 'b -> 'b
  fun j(x) = x
  
}
//│ module A {
//│   fun i: forall 'a. 'a -> 'a
//│   fun j: forall 'b. 'b -> 'b
//│ }


:e
module A {
  fun i : 'a
  fun i(x) = x
}
//│ ╔══[ERROR] Type mismatch in definition of method i:
//│ ║  l.102: 	  fun i(x) = x
//│ ║         	      ^^^^^^^^
//│ ╟── function of type `?a -> ?a` does not match type `'a`
//│ ║  l.102: 	  fun i(x) = x
//│ ║         	       ^^^^^^^
//│ ╟── but it flows into definition of method i with expected type `'a`
//│ ║  l.102: 	  fun i(x) = x
//│ ║         	      ^^^^^^^^
//│ ╟── Note: constraint arises from type variable:
//│ ║  l.101: 	  fun i : 'a
//│ ║         	          ^^
//│ ╟── from signature of member i:
//│ ║  l.101: 	  fun i : 'a
//│ ╙──       	      ^^^^^^
//│ module A {
//│   fun i: nothing
//│ }



// FIXME currently type signatures are typed too early (not in the context where the other defns live)
// We need to move all the typing unit setup to lazy type info prelude
// :d
module M {
  class A
  fun a: A
  fun a = 1
}
//│ ╔══[ERROR] Type mismatch in definition of method a:
//│ ║  l.131: 	  fun a = 1
//│ ║         	      ^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `A`
//│ ║  l.131: 	  fun a = 1
//│ ║         	          ^
//│ ╟── but it flows into definition of method a with expected type `A`
//│ ║  l.131: 	  fun a = 1
//│ ║         	      ^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.130: 	  fun a: A
//│ ║         	         ^
//│ ╟── from signature of member a:
//│ ║  l.130: 	  fun a: A
//│ ╙──       	      ^^^^
//│ module M {
//│   class A
//│   fun a: A
//│ }

// FIXME similar
module M {
  class A
  fun a: this.A
  fun a = 1
}
//│ ╔══[ERROR] undeclared `this`
//│ ║  l.156: 	  fun a: this.A
//│ ╙──       	         ^^^^
//│ /!!!\ Uncaught error: java.lang.Exception: Internal Error: Program reached and unexpected state.

// FIXME similar
module M {
  class A
  fun a: M.A
  fun a = 1
}
//│ /!!!\ Uncaught error: scala.NotImplementedError: an implementation is missing


