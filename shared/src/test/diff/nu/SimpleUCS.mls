:NewParser

class Option
class Some(value): Option
class None: Option
//│ Defined class Option
//│ Defined class Some
//│ Defined class None
//│ Option: () -> Option
//│       = [Function: Option1]
//│ Some: 'value -> (Some with {value: 'value})
//│     = [Function: Some1]
//│ None: () -> None
//│     = [Function: None1]

class Either
class Left(leftValue): Either
class Right(rightValue): Either
//│ Defined class Either
//│ Defined class Left
//│ Defined class Right
//│ Either: () -> Either
//│       = [Function: Either1]
//│ Left: 'leftValue -> (Left with {leftValue: 'leftValue})
//│     = [Function: Left1]
//│ Right: 'rightValue -> (Right with {rightValue: 'rightValue})
//│      = [Function: Right1]

fun f(x, y) =
  if x is
    Left(xv) and y is Left(yv) then xv + yv
    Right(xv) and y is Right(yv) then xv * yv
    None() and y is None() then 0
//│ f: (Left & {leftValue: int} | None | Right & {rightValue: int}, nothing,) -> int
//│  = [Function: f]

fun boolToStr(x) =
  if x is
    true then "yah"
    false then "nah"
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.38: 	  if x is
//│ ║        	     ^^^^
//│ ║  l.39: 	    true then "yah"
//│ ║        	^^^^^^^^
//│ ╟── reference of type `true` is not an instance of type `number`
//│ ║  l.39: 	    true then "yah"
//│ ╙──      	    ^^^^
//│ boolToStr: number -> ("nah" | "yah")
//│          = [Function: boolToStr]

fun f(x, y) =
  if x is
    Left(xv) and y is Left(yv) then xv + yv
    None() then 0
//│ f: (Left & {leftValue: int} | None, Left & {leftValue: int},) -> int
//│  = [Function: f1]

fun f(x, y) =
  if x is
    Left(xv) and y is
      Left(yv) then xv + yv
      Right(yv) then xv * yv
    None() then 0
//│ f: (Left & {leftValue: int} | None, Left & {leftValue: int} | Right & {rightValue: int},) -> int
//│  = [Function: f2]

fun f(x) =
  if x is
    Some(v) and
      v < 0 then "negative"
      v > 0 then "positive"
      _     then "zero"
    None() then "nothing"
//│ /!!!\ Uncaught error: scala.NotImplementedError: an implementation is missing
//│ 	at: scala.Predef$.$qmark$qmark$qmark(Predef.scala:344)
//│ 	at: mlscript.MutCaseOf$IfThenElse.merge(helpers.scala:949)
//│ 	at: mlscript.MutCaseOf$Match.merge(helpers.scala:977)
//│ 	at: mlscript.MutCaseOf$.$anonfun$build$1(helpers.scala:1060)
//│ 	at: mlscript.MutCaseOf$.$anonfun$build$1$adapted(helpers.scala:1060)
//│ 	at: scala.collection.immutable.List.foreach(List.scala:333)
//│ 	at: mlscript.MutCaseOf$.build(helpers.scala:1060)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:727)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:30)
//│ 	at: mlscript.Typer.typeTerm(Typer.scala:744)

fun f(x, y) =
  if x is
    Some(x) and y is
      Some(y) then 0
//│ f: (Some, Some,) -> 0
//│  = [Function: f3]

class A(value)
class B(value)
//│ Defined class A
//│ Defined class B
//│ A: 'value -> (A with {value: 'value})
//│  = [Function: A1]
//│ B: 'value -> (B with {value: 'value})
//│  = [Function: B1]

fun f(x) =
  if x is
    A(a) and y <>
      u then 0
      v then 1
    A(a) and y is
      B(0) then 0
      B(1) then 1
//│ /!!!\ Uncaught error: scala.NotImplementedError: an implementation is missing
//│ 	at: scala.Predef$.$qmark$qmark$qmark(Predef.scala:344)
//│ 	at: mlscript.MutCaseOf$IfThenElse.merge(helpers.scala:956)
//│ 	at: mlscript.MutCaseOf$Match.merge(helpers.scala:977)
//│ 	at: mlscript.MutCaseOf$.$anonfun$build$1(helpers.scala:1060)
//│ 	at: mlscript.MutCaseOf$.$anonfun$build$1$adapted(helpers.scala:1060)
//│ 	at: scala.collection.immutable.List.foreach(List.scala:333)
//│ 	at: mlscript.MutCaseOf$.build(helpers.scala:1060)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:727)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:30)
//│ 	at: mlscript.Typer.typeTerm(Typer.scala:744)

fun f(x) =
  if x is
    A(_) then "A"
    B(_) then "B"
//│ f: (A | B) -> ("A" | "B")
//│  = [Function: f4]

fun f(x, y) =
  if x is
    Some(xv) and y is Some(yv) then xv + yv
    None() and y is None() then 0
//│ f: (None | Some & {value: int}, nothing,) -> int
//│  = [Function: f5]

fun f(x, y) =
  if x is
    Some(xv) and y is
      Some(yv) then xv + yv
      None() then xv * 2
    None() and y is
      Some(yv) then yv * 3
//│ f: (None | Some & {value: int}, Some & {value: int},) -> int
//│  = [Function: f6]

fun f(x, y) =
  if x is
    A and y is
      B then "bruh"
//│ f: (A, B,) -> "bruh"
//│  = [Function: f7]

fun f(x, y, z) =
  if x is
    A and z == 0 and y == 0 and y is
      B then "bruh"
//│ /!!!\ Uncaught error: java.lang.Exception: illegal pattern: and (and (A,) (== (z,) (0,),),) (== (y,) (0,),)
//│ 	at: mlscript.Typer.destructPattern(Typer.scala:1037)
//│ 	at: mlscript.Typer.desugarMatchBranch$1(Typer.scala:1084)
//│ 	at: mlscript.Typer.$anonfun$desugarIf$2(Typer.scala:1152)
//│ 	at: mlscript.Typer.$anonfun$desugarIf$2$adapted(Typer.scala:1152)
//│ 	at: scala.collection.immutable.List.foreach(List.scala:333)
//│ 	at: mlscript.Typer.desugarIfBody$1(Typer.scala:1152)
//│ 	at: mlscript.Typer.desugarIf(Typer.scala:1170)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:725)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:30)
//│ 	at: mlscript.Typer.typeTerm(Typer.scala:744)

fun f(x, y) =
  if x is
    Some(x) and y
      == 0 then "bruh"
      > 0 then "bruh"
//│ /!!!\ Uncaught error: scala.NotImplementedError: an implementation is missing
//│ 	at: scala.Predef$.$qmark$qmark$qmark(Predef.scala:344)
//│ 	at: mlscript.Typer.desugarIfBody$1(Typer.scala:1126)
//│ 	at: mlscript.Typer.desugarMatchBranch$1(Typer.scala:1085)
//│ 	at: mlscript.Typer.$anonfun$desugarIf$2(Typer.scala:1152)
//│ 	at: mlscript.Typer.$anonfun$desugarIf$2$adapted(Typer.scala:1152)
//│ 	at: scala.collection.immutable.List.foreach(List.scala:333)
//│ 	at: mlscript.Typer.desugarIfBody$1(Typer.scala:1152)
//│ 	at: mlscript.Typer.desugarIf(Typer.scala:1170)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:725)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:30)

fun isValid(x) = if x then false else true
//│ isValid: anything -> bool
//│        = [Function: isValid]

fun f(x, allowNone) =
  if x is
    Some(x) and isValid(x) then "good"
    None() and allowNone then "okay"
    else "bad"
//│ f: (anything, anything,) -> ("bad" | "good" | "okay")
//│  = [Function: f8]

fun f(x) =
  if x is
    None then "bruh"
    Some(x) then "roll"
    _ and x == 0 then 0
//│ ╔══[ERROR] missing a default branch
//│ ║  l.200: 	  if x is
//│ ║         	     ^^^^
//│ ║  l.201: 	    None then "bruh"
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.202: 	    Some(x) then "roll"
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.203: 	    _ and x == 0 then 0
//│ ╙──       	^^^^^^^^^^^^^^^^^^^^^^^
//│ f: anything -> error
//│ Code generation encountered an error:
//│   if expression has not been not desugared

class A()
class B()
//│ ╔══[ERROR] Type 'A' is already defined.
//│ ║  l.217: 	class A()
//│ ╙──       	      ^
//│ ╔══[ERROR] Type 'B' is already defined.
//│ ║  l.218: 	class B()
//│ ╙──       	      ^
//│ A: () -> A
//│  = [Function: A3]
//│ B: () -> B
//│  = [Function: B3]

fun f(x) =
  if x is
    A() and a then aa
    B() and b then bb
//│ /!!!\ Uncaught error: java.lang.Exception: A expects 1 but meet 0
//│ 	at: mlscript.Typer.destructPattern(Typer.scala:1015)
//│ 	at: mlscript.Typer.desugarMatchBranch$1(Typer.scala:1071)
//│ 	at: mlscript.Typer.$anonfun$desugarIf$2(Typer.scala:1152)
//│ 	at: mlscript.Typer.$anonfun$desugarIf$2$adapted(Typer.scala:1152)
//│ 	at: scala.collection.immutable.List.foreach(List.scala:333)
//│ 	at: mlscript.Typer.desugarIfBody$1(Typer.scala:1152)
//│ 	at: mlscript.Typer.desugarIf(Typer.scala:1170)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:725)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:30)
//│ 	at: mlscript.Typer.typeTerm(Typer.scala:744)

fun f(x) =
  if x is
    Some(xv) and y
      is Some(yv) then "bruh"
      is None() then "bruh"
    Some(xv) and b then xb + b
//│ /!!!\ Uncaught error: scala.NotImplementedError: an implementation is missing
//│ 	at: scala.Predef$.$qmark$qmark$qmark(Predef.scala:344)
//│ 	at: mlscript.Typer.desugarIfBody$1(Typer.scala:1126)
//│ 	at: mlscript.Typer.desugarMatchBranch$1(Typer.scala:1085)
//│ 	at: mlscript.Typer.$anonfun$desugarIf$2(Typer.scala:1152)
//│ 	at: mlscript.Typer.$anonfun$desugarIf$2$adapted(Typer.scala:1152)
//│ 	at: scala.collection.immutable.List.foreach(List.scala:333)
//│ 	at: mlscript.Typer.desugarIfBody$1(Typer.scala:1152)
//│ 	at: mlscript.Typer.desugarIf(Typer.scala:1170)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:725)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:30)

fun foo(x, y, z) = x + y + z
//│ foo: (int, int, int,) -> int
//│    = [Function: foo]

fun f(u, v, w) =
  if foo(u, v, w) is
    Some(x) and x is
      Left(_) then "left-defined"
      Right(_) then "right-defined"
    None then "undefined"
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.269: 	  if foo(u, v, w) is
//│ ║         	     ^^^^^^^^^^^^
//│ ╟── operator application of type `int` does not have field 'value'
//│ ║  l.264: 	fun foo(x, y, z) = x + y + z
//│ ║         	                   ^^^^^^^^^
//│ ╟── but it flows into application with expected type `{value: ?value}`
//│ ║  l.269: 	  if foo(u, v, w) is
//│ ╙──       	     ^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.269: 	  if foo(u, v, w) is
//│ ║         	     ^^^^^^^^^^^^
//│ ╟── operator application of type `int` does not have field 'value'
//│ ║  l.264: 	fun foo(x, y, z) = x + y + z
//│ ║         	                   ^^^^^^^^^
//│ ╟── but it flows into application with expected type `{value: ?value}`
//│ ║  l.269: 	  if foo(u, v, w) is
//│ ╙──       	     ^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.269: 	  if foo(u, v, w) is
//│ ║         	     ^^^^^^^^^^^^^^^
//│ ║  l.270: 	    Some(x) and x is
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.271: 	      Left(_) then "left-defined"
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.272: 	      Right(_) then "right-defined"
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.273: 	    None then "undefined"
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── operator application of type `int` does not match type `None | Some`
//│ ║  l.264: 	fun foo(x, y, z) = x + y + z
//│ ║         	                   ^^^^^^^^^
//│ ╟── but it flows into application with expected type `None | Some`
//│ ║  l.269: 	  if foo(u, v, w) is
//│ ╙──       	     ^^^^^^^^^^^^
//│ f: (int, int, int,) -> ("left-defined" | "right-defined" | "undefined")
//│  = [Function: f10]

class Var(name)
class ValBase
class IntVal(value): ValBase
class BoolVal(value): ValBase
class Lit(val)
//│ Defined class Var
//│ Defined class ValBase
//│ Defined class IntVal
//│ Defined class BoolVal
//│ Defined class Lit
//│ Var: 'name -> (Var with {name: 'name})
//│    = [Function: Var1]
//│ ValBase: () -> ValBase
//│        = [Function: ValBase1]
//│ IntVal: 'value -> (IntVal with {value: 'value})
//│       = [Function: IntVal1]
//│ BoolVal: 'value -> (BoolVal with {value: 'value})
//│        = [Function: BoolVal1]
//│ Lit: 'val -> (Lit with {val: 'val})
//│    = [Function: Lit1]

fun p(e, context) =
  if e is
    Var(x) and context.get(x) is
      Some(IntVal(v)) then Left(v)
      Some(BoolVal(v)) then Right(v)
    Lit(IntVal(v)) then Left(v)
    Lit(BoolVal(v)) then Right(v)
//│ p: (Lit & {val: (BoolVal with {value: 'rightValue}) | (IntVal with {value: 'leftValue})} | (Var with {name: 'name}), {get: 'name -> (Some & {value: (BoolVal with {value: 'rightValue}) | (IntVal with {value: 'leftValue})})},) -> ((Left with {leftValue: 'leftValue}) | (Right with {rightValue: 'rightValue}))
//│  = [Function: p]


fun f(x) =
  if x is
    0 ::
      Nil then "oh"
//│ /!!!\ Uncaught error: scala.NotImplementedError: an implementation is missing
//│ 	at: scala.Predef$.$qmark$qmark$qmark(Predef.scala:344)
//│ 	at: mlscript.Typer.desugarMatchBranch$1(Typer.scala:1116)
//│ 	at: mlscript.Typer.$anonfun$desugarIf$2(Typer.scala:1152)
//│ 	at: mlscript.Typer.$anonfun$desugarIf$2$adapted(Typer.scala:1152)
//│ 	at: scala.collection.immutable.List.foreach(List.scala:333)
//│ 	at: mlscript.Typer.desugarIfBody$1(Typer.scala:1152)
//│ 	at: mlscript.Typer.desugarIf(Typer.scala:1170)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:725)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:30)
//│ 	at: mlscript.Typer.typeTerm(Typer.scala:744)

fun f(x) =
  if x == 0 and x is
    A() then "A"
    B() then "B"
    else "bruh"
//│ /!!!\ Uncaught error: java.lang.Exception: A expects 1 but meet 0
//│ 	at: mlscript.Typer.destructPattern(Typer.scala:1015)
//│ 	at: mlscript.Typer.desugarMatchBranch$1(Typer.scala:1073)
//│ 	at: mlscript.Typer.$anonfun$desugarIf$2(Typer.scala:1152)
//│ 	at: mlscript.Typer.$anonfun$desugarIf$2$adapted(Typer.scala:1152)
//│ 	at: scala.collection.immutable.List.foreach(List.scala:333)
//│ 	at: mlscript.Typer.desugarIfBody$1(Typer.scala:1152)
//│ 	at: mlscript.Typer.desugarIf(Typer.scala:1170)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:725)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:30)
//│ 	at: mlscript.Typer.typeTerm(Typer.scala:744)

fun f(x, y) =
  if x == 0 and f(x) is
    Some(a) and f(y) is
      Some(b) then a + b
      None() then a + 1
    None() and f(y) is
      Some(b) then 2 + b
      None() then 1
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.377: 	fun f(x, y) =
//│ ║         	     ^^^^^^^^
//│ ║  l.378: 	  if x == 0 and f(x) is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.379: 	    Some(a) and f(y) is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.380: 	      Some(b) then a + b
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.381: 	      None() then a + 1
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.382: 	    None() and f(y) is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.383: 	      Some(b) then 2 + b
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.384: 	      None() then 1
//│ ║         	^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` does not match type `(?b, ?a,)`
//│ ║  l.382: 	    None() and f(y) is
//│ ║         	                ^^^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.377: 	fun f(x, y) =
//│ ╙──       	     ^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.377: 	fun f(x, y) =
//│ ║         	     ^^^^^^^^
//│ ║  l.378: 	  if x == 0 and f(x) is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.379: 	    Some(a) and f(y) is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.380: 	      Some(b) then a + b
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.381: 	      None() then a + 1
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.382: 	    None() and f(y) is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.383: 	      Some(b) then 2 + b
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.384: 	      None() then 1
//│ ║         	^^^^^^^^^^^^^^^^^^^
//│ ╟── operator application of type `int` does not have field 'value'
//│ ║  l.380: 	      Some(b) then a + b
//│ ║         	                   ^^^^^
//│ ╟── Note: constraint arises from field selection:
//│ ║  l.382: 	    None() and f(y) is
//│ ╙──       	               ^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.377: 	fun f(x, y) =
//│ ║         	     ^^^^^^^^
//│ ║  l.378: 	  if x == 0 and f(x) is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.379: 	    Some(a) and f(y) is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.380: 	      Some(b) then a + b
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.381: 	      None() then a + 1
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.382: 	    None() and f(y) is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.383: 	      Some(b) then 2 + b
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.384: 	      None() then 1
//│ ║         	^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `1` does not have field 'value'
//│ ║  l.384: 	      None() then 1
//│ ║         	                  ^
//│ ╟── Note: constraint arises from field selection:
//│ ║  l.382: 	    None() and f(y) is
//│ ╙──       	               ^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.377: 	fun f(x, y) =
//│ ║         	     ^^^^^^^^
//│ ║  l.378: 	  if x == 0 and f(x) is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.379: 	    Some(a) and f(y) is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.380: 	      Some(b) then a + b
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.381: 	      None() then a + 1
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.382: 	    None() and f(y) is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.383: 	      Some(b) then 2 + b
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.384: 	      None() then 1
//│ ║         	^^^^^^^^^^^^^^^^^^^
//│ ╟── operator application of type `int` does not match type `None | Some`
//│ ║  l.380: 	      Some(b) then a + b
//│ ║         	                   ^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.382: 	    None() and f(y) is
//│ ╙──       	               ^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.377: 	fun f(x, y) =
//│ ║         	     ^^^^^^^^
//│ ║  l.378: 	  if x == 0 and f(x) is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.379: 	    Some(a) and f(y) is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.380: 	      Some(b) then a + b
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.381: 	      None() then a + 1
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.382: 	    None() and f(y) is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.383: 	      Some(b) then 2 + b
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.384: 	      None() then 1
//│ ║         	^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `1` does not match type `None | Some`
//│ ║  l.384: 	      None() then 1
//│ ║         	                  ^
//│ ╟── Note: constraint arises from application:
//│ ║  l.382: 	    None() and f(y) is
//│ ╙──       	               ^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.377: 	fun f(x, y) =
//│ ║         	     ^^^^^^^^
//│ ║  l.378: 	  if x == 0 and f(x) is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.379: 	    Some(a) and f(y) is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.380: 	      Some(b) then a + b
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.381: 	      None() then a + 1
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.382: 	    None() and f(y) is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.383: 	      Some(b) then 2 + b
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.384: 	      None() then 1
//│ ║         	^^^^^^^^^^^^^^^^^^^
//│ ╟── operator application of type `int` does not have field 'value'
//│ ║  l.380: 	      Some(b) then a + b
//│ ║         	                   ^^^^^
//│ ╟── Note: constraint arises from field selection:
//│ ║  l.379: 	    Some(a) and f(y) is
//│ ╙──       	                ^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.377: 	fun f(x, y) =
//│ ║         	     ^^^^^^^^
//│ ║  l.378: 	  if x == 0 and f(x) is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.379: 	    Some(a) and f(y) is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.380: 	      Some(b) then a + b
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.381: 	      None() then a + 1
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.382: 	    None() and f(y) is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.383: 	      Some(b) then 2 + b
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.384: 	      None() then 1
//│ ║         	^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `1` does not have field 'value'
//│ ║  l.384: 	      None() then 1
//│ ║         	                  ^
//│ ╟── Note: constraint arises from field selection:
//│ ║  l.379: 	    Some(a) and f(y) is
//│ ╙──       	                ^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.377: 	fun f(x, y) =
//│ ║         	     ^^^^^^^^
//│ ║  l.378: 	  if x == 0 and f(x) is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.379: 	    Some(a) and f(y) is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.380: 	      Some(b) then a + b
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.381: 	      None() then a + 1
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.382: 	    None() and f(y) is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.383: 	      Some(b) then 2 + b
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.384: 	      None() then 1
//│ ║         	^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` does not match type `(?a, ?b,)`
//│ ║  l.378: 	  if x == 0 and f(x) is
//│ ║         	                 ^^^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.377: 	fun f(x, y) =
//│ ╙──       	     ^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.377: 	fun f(x, y) =
//│ ║         	     ^^^^^^^^
//│ ║  l.378: 	  if x == 0 and f(x) is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.379: 	    Some(a) and f(y) is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.380: 	      Some(b) then a + b
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.381: 	      None() then a + 1
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.382: 	    None() and f(y) is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.383: 	      Some(b) then 2 + b
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.384: 	      None() then 1
//│ ║         	^^^^^^^^^^^^^^^^^^^
//│ ╟── operator application of type `int` does not have field 'value'
//│ ║  l.380: 	      Some(b) then a + b
//│ ║         	                   ^^^^^
//│ ╟── Note: constraint arises from field selection:
//│ ║  l.378: 	  if x == 0 and f(x) is
//│ ╙──       	                ^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.377: 	fun f(x, y) =
//│ ║         	     ^^^^^^^^
//│ ║  l.378: 	  if x == 0 and f(x) is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.379: 	    Some(a) and f(y) is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.380: 	      Some(b) then a + b
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.381: 	      None() then a + 1
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.382: 	    None() and f(y) is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.383: 	      Some(b) then 2 + b
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.384: 	      None() then 1
//│ ║         	^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `1` does not have field 'value'
//│ ║  l.384: 	      None() then 1
//│ ║         	                  ^
//│ ╟── Note: constraint arises from field selection:
//│ ║  l.378: 	  if x == 0 and f(x) is
//│ ╙──       	                ^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.377: 	fun f(x, y) =
//│ ║         	     ^^^^^^^^
//│ ║  l.378: 	  if x == 0 and f(x) is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.379: 	    Some(a) and f(y) is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.380: 	      Some(b) then a + b
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.381: 	      None() then a + 1
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.382: 	    None() and f(y) is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.383: 	      Some(b) then 2 + b
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.384: 	      None() then 1
//│ ║         	^^^^^^^^^^^^^^^^^^^
//│ ╟── operator application of type `int` does not have field 'value'
//│ ║  l.380: 	      Some(b) then a + b
//│ ║         	                   ^^^^^
//│ ╟── Note: constraint arises from field selection:
//│ ║  l.378: 	  if x == 0 and f(x) is
//│ ╙──       	                ^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.377: 	fun f(x, y) =
//│ ║         	     ^^^^^^^^
//│ ║  l.378: 	  if x == 0 and f(x) is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.379: 	    Some(a) and f(y) is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.380: 	      Some(b) then a + b
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.381: 	      None() then a + 1
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.382: 	    None() and f(y) is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.383: 	      Some(b) then 2 + b
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.384: 	      None() then 1
//│ ║         	^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `1` does not have field 'value'
//│ ║  l.384: 	      None() then 1
//│ ║         	                  ^
//│ ╟── Note: constraint arises from field selection:
//│ ║  l.378: 	  if x == 0 and f(x) is
//│ ╙──       	                ^^^^
//│ f: (anything, anything,) -> int
//│  = [Function: f11]
