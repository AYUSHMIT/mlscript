:NewDefs
:NoJS

trait Showable {
    fun toString: string
}
//│ trait Showable() {
//│   fun toString: string
//│ }

:e
trait What0 extends woooo
//│ ╔══[ERROR] Could not find definition `woooo`
//│ ║  l.12: 	trait What0 extends woooo
//│ ╙──      	                    ^^^^^
//│ trait What0()

class Point(x: int, y: int) extends Showable {
    fun mlen = x + y
    fun toString = "I'm a point"
}
//│ class Point(x: int, y: int) {
//│   fun mlen: int
//│   fun toString: "I'm a point"
//│ }

class What1(toString: string) extends Showable
//│ class What1(toString: string)

:e
trait NoShow extends What1("hi")
//│ ╔══[ERROR] trait arguments not yet supported
//│ ║  l.31: 	trait NoShow extends What1("hi")
//│ ╙──      	                     ^^^^^^^^^^^
//│ ╔══[ERROR] trait can only inherit traits
//│ ║  l.31: 	trait NoShow extends What1("hi")
//│ ╙──      	                     ^^^^^^^^^^^
//│ trait NoShow()

:e
class ErrC1 extends Showable
class ErrC2 extends Showable {
    fun toString = 114
}
//│ ╔══[ERROR] Member toString is declared in parent trait but not implemented
//│ ║  l.41: 	class ErrC1 extends Showable
//│ ╙──      	^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in definition of method toString:
//│ ║  l.43: 	    fun toString = 114
//│ ║        	        ^^^^^^^^^^^^^^
//│ ╟── integer literal of type `114` is not an instance of type `string`
//│ ║  l.43: 	    fun toString = 114
//│ ║        	                   ^^^
//│ ╟── but it flows into definition of method toString with expected type `string`
//│ ║  l.43: 	    fun toString = 114
//│ ║        	        ^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.5: 	    fun toString: string
//│ ║       	                  ^^^^^^
//│ ╟── from signature of member toString:
//│ ║  l.5: 	    fun toString: string
//│ ╙──     	        ^^^^^^^^^^^^^^^^
//│ class ErrC1()
//│ class ErrC2() {
//│   fun toString: 114
//│ }

trait Stadt {
    let name: string
}
//│ trait Stadt() {
//│   let name: string
//│ }

trait RefinedStadt extends Stadt {
    let size: int
    fun foo: bool -> int
}
//│ trait RefinedStadt() {
//│   fun foo: bool -> int
//│   let name: string
//│   let size: int
//│ }

trait SizedStadt extends RefinedStadt {
    let size: 1 | 2 | 3
    fun bar: int -> int
}
//│ trait SizedStadt() {
//│   fun bar: int -> int
//│   fun foo: bool -> int
//│   let name: string
//│   let size: 1 | 2 | 3
//│ }

class Goodstatt(size: 1 | 2) extends RefinedStadt {
    let name = "good"
    fun bar(x) = x
    fun foo(t) = if t && true then this.size else 0
}
//│ class Goodstatt(size: 1 | 2) {
//│   fun bar: forall 'a. 'a -> 'a
//│   fun foo: bool -> (0 | 1 | 2)
//│   let name: "good"
//│ }

:e
class Errcity(size: int) extends SizedStadt {
    fun bar = "hahaha"
}
//│ ╔══[ERROR] Type mismatch in definition of method bar:
//│ ║  l.109: 	    fun bar = "hahaha"
//│ ║         	        ^^^^^^^^^^^^^^
//│ ╟── string literal of type `"hahaha"` is not a function
//│ ║  l.109: 	    fun bar = "hahaha"
//│ ║         	              ^^^^^^^^
//│ ╟── but it flows into definition of method bar with expected type `int -> int`
//│ ║  l.109: 	    fun bar = "hahaha"
//│ ║         	        ^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from function type:
//│ ║  l.87: 	    fun bar: int -> int
//│ ║        	             ^^^^^^^^^^
//│ ╟── from signature of member bar:
//│ ║  l.87: 	    fun bar: int -> int
//│ ╙──      	        ^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Member foo is declared in parent trait but not implemented
//│ ║  l.108: 	class Errcity(size: int) extends SizedStadt {
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.109: 	    fun bar = "hahaha"
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.110: 	}
//│ ╙──       	^
//│ ╔══[ERROR] Member name is declared in parent trait but not implemented
//│ ║  l.108: 	class Errcity(size: int) extends SizedStadt {
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.109: 	    fun bar = "hahaha"
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.110: 	}
//│ ╙──       	^
//│ ╔══[ERROR] Type mismatch in type reference:
//│ ║  l.108: 	class Errcity(size: int) extends SizedStadt {
//│ ║         	                    ^^^
//│ ╟── type `int` does not match type `1 | 2 | 3`
//│ ╟── Note: constraint arises from union type:
//│ ║  l.86: 	    let size: 1 | 2 | 3
//│ ╙──      	              ^^^^^^^^^
//│ class Errcity(size: int) {
//│   fun bar: "hahaha"
//│ }

module Omg extends Stadt {
    fun name = "omg!!!"
    fun cool(x) = x + x
}
//│ module Omg() {
//│   fun cool: int -> int
//│   fun name: "omg!!!"
//│ }

mixin More {
    fun more(x) = x == 1
    fun size = 1
    fun bar(x) = x
}
//│ mixin More() {
//│   fun bar: forall 'a. 'a -> 'a
//│   fun more: number -> bool
//│   fun size: 1
//│ }

mixin Fooo {
    fun foo(x) = 0
}
//│ mixin Fooo() {
//│   fun foo: anything -> 0
//│ }

// FIXME
class Dirtberg extends More, SizedStadt, Fooo {
    let name = "dirt"
    fun size = 4
}
//│ class Dirtberg() {
//│   fun bar: int -> int
//│   fun foo: anything -> 0
//│   fun more: number -> bool
//│   let name: "dirt"
//│   fun size: 4
//│ }

class Iceburg(name: string) extends RefinedStadt, More, Fooo
//│ class Iceburg(name: string) {
//│   fun bar: 'a -> 'a
//│   fun foo: anything -> 0
//│   fun more: number -> bool
//│   fun size: 1
//│ }
