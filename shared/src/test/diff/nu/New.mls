:NewParser


class Foo(x)
//│ Defined class Foo
//│ Foo: 'x -> (Foo & {x: 'x})
//│    = [Function: Foo1]

let f = Foo(1)
//│ f: Foo & {x: 1}
//│  = Foo { x: 1 }

let f = new Foo(1)
//│ f: Foo & {x: 1}
//│  = Foo { x: 1 }

if f is Foo then 1 else 0
//│ res: 0 | 1
//│    = 1

if f is Foo(a) then a else 0
//│ ╔══[ERROR] Type mismatch in reference:
//│ ║  l.21: 	if f is Foo(a) then a else 0
//│ ║        	   ^
//│ ╟── class pattern of type `Foo` does not have field 'x'
//│ ║  l.21: 	if f is Foo(a) then a else 0
//│ ║        	        ^^^
//│ ╟── but it flows into reference with expected type `{x: ?x}`
//│ ║  l.21: 	if f is Foo(a) then a else 0
//│ ╙──      	   ^
//│ res: 0 | error
//│    = 1

// case f of
//   { Foo ->
//     let a = f.x
//     a
//   | _ -> 0
//   }

// Foo(A) =:= Foo & { x: A }


fun test(x) = if x is Foo(a) then a
//│ ╔══[ERROR] Type mismatch in reference:
//│ ║  l.44: 	fun test(x) = if x is Foo(a) then a
//│ ║        	                 ^
//│ ╟── class pattern of type `Foo` does not have field 'x'
//│ ║  l.44: 	fun test(x) = if x is Foo(a) then a
//│ ║        	                      ^^^
//│ ╟── but it flows into reference with expected type `{x: ?x}`
//│ ║  l.44: 	fun test(x) = if x is Foo(a) then a
//│ ╙──      	                 ^
//│ test: Foo -> error
//│     = [Function: test]

test(f)
//│ res: error
//│    = 1

class Point(x, y)
//│ Defined class Point
//│ Point: ('x, 'y,) -> (Point & {x: 'x, y: 'y})
//│      = [Function: Point1]

let origin = new Point(0, 0)
//│ origin: Point & {x: 0, y: 0}
//│       = Point { x: 0, y: 0 }
