:NewDefs



// TODO use available type signatures!
class Foo1(x: int) {
  fun test = Foo1(1).x
}
//│ ╔══[ERROR] unsupported indirectly recursive member access
//│ ║  l.7: 	  fun test = Foo1(1).x
//│ ╙──     	                    ^^
//│ class Foo1(x: int) {
//│   fun test: error
//│ }

// TODO
class Foo2[A](x: A) {
  fun test = Foo2(1).x
}
//│ ╔══[ERROR] unsupported indirectly recursive member access
//│ ║  l.18: 	  fun test = Foo2(1).x
//│ ╙──      	                    ^^
//│ class Foo2[A](x: A) {
//│   fun test: error
//│ }


class Foo3[A](x: A) {
  fun test = Foo3(1)
  fun foo = Foo3
}
//│ class Foo3[A](x: A) {
//│   fun foo: (x: A,) -> Foo3[A]
//│   fun test: Foo3[1]
//│ }

Foo3
//│ forall 'A. (x: 'A,) -> Foo3['A]
//│ res
//│     = [Function (anonymous)] { class: [class Foo3] }

Foo3(1)
//│ Foo3[1]
//│ res
//│     = Foo3 {}

Foo3(1).x
//│ 1
//│ res
//│     = 1

Foo3(1).foo
//│ forall 'A. (x: 'A,) -> Foo3['A]
//│ res
//│     = [Function (anonymous)] { class: [class Foo3] }

:e
class Foo4 {
  fun test = [Foo4.test]
}
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.59: 	  fun test = [Foo4.test]
//│ ║        	              ^^^^^^^^^
//│ ╟── reference of type `() -> #Foo4` does not have field 'test'
//│ ║  l.59: 	  fun test = [Foo4.test]
//│ ╙──      	              ^^^^
//│ class Foo4() {
//│   fun test: (error,)
//│ }

:e
class Foo5(x: int) {
  fun test = [Foo5(5).test]
}
//│ ╔══[ERROR] unsupported indirectly recursive member access
//│ ║  l.73: 	  fun test = [Foo5(5).test]
//│ ╙──      	                     ^^^^^
//│ class Foo5(x: int) {
//│   fun test: (error,)
//│ }

:e
class Foo6[A](x: A) {
  fun test1 = [Foo6(x).test]
  fun test2 = [Foo6(123).test]
  fun test3 = [Foo6([x]).test]
}
//│ ╔══[ERROR] unsupported indirectly recursive member access
//│ ║  l.84: 	  fun test1 = [Foo6(x).test]
//│ ╙──      	                      ^^^^^
//│ ╔══[ERROR] unsupported indirectly recursive member access
//│ ║  l.85: 	  fun test2 = [Foo6(123).test]
//│ ╙──      	                        ^^^^^
//│ ╔══[ERROR] unsupported indirectly recursive member access
//│ ║  l.86: 	  fun test3 = [Foo6([x]).test]
//│ ╙──      	                        ^^^^^
//│ class Foo6[A](x: A) {
//│   fun test1: (error,)
//│   fun test2: (error,)
//│   fun test3: (error,)
//│ }

module N
//│ module N()

:e
class Foo7[A](head: A, tail: Foo7[A] | N) {
  fun test1 = if tail is
    N then head
    _ then tail.test1
}
//│ ╔══[ERROR] unsupported indirectly recursive member access
//│ ║  l.110: 	    _ then tail.test1
//│ ╙──       	               ^^^^^^
//│ class Foo7[A](head: A, tail: Foo7[A] | N) {
//│   fun test1: A | error
//│ }

// TODO support
class Foo7_A[A](head: A, tail: Foo7_A[A] | N) {
  test1: A
  fun test1 = if tail is
    N then head
    _ then tail.test1
}
//│ ╔══[ERROR] unsupported indirectly recursive member access
//│ ║  l.124: 	    _ then tail.test1
//│ ╙──       	               ^^^^^^
//│ class Foo7_A[A](head: A, tail: Foo7_A[A] | N) {
//│   fun test1: A | error
//│ }

class Foo7_A2[A](head: A, tail: Foo7_A[A] | N) {
  fun test1: A = if tail is
    N then head
    _ then tail.test1
}
//│ class Foo7_A2[A](head: A, tail: Foo7_A[A] | N) {
//│   fun test1: A
//│ }

:e
class Foo8[A](x: A) {
  fun test1[B](y: B): A =
    let tmp = Foo8(y).test1(x)
    x
}
//│ ╔══[ERROR] unsupported indirectly recursive member access
//│ ║  l.145: 	    let tmp = Foo8(y).test1(x)
//│ ╙──       	                     ^^^^^^
//│ class Foo8[A](x: A) {
//│   fun test1: (y: anything,) -> A
//│ }


