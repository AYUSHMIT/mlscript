:NewDefs

:d
mixin Foo {
  fun f(x) = x(f)
}
//│ 0. Typing TypingUnit(List(NuTypeDef(Mxn,TypeName(Foo),List(),None,None,None,List(),None,None,TypingUnit(List(NuFunDef(None,Var(f),None,List(),Left(Lam(Tup(List((None,Fld(_,Var(x))))),App(Var(x),Tup(List((None,Fld(_,Var(f))))))))))))))
//│ | 0. Created lazy type info for NuTypeDef(Mxn,TypeName(Foo),List(),None,None,None,List(),None,None,TypingUnit(List(NuFunDef(None,Var(f),None,List(),Left(Lam(Tup(List((None,Fld(_,Var(x))))),App(Var(x),Tup(List((None,Fld(_,Var(f))))))))))))
//│ | Completing mixin Foo {fun f = (x,) => x(f,)}
//│ | | Type params 
//│ | | Params 
//│ | | 1. Typing TypingUnit(List(NuFunDef(None,Var(f),None,List(),Left(Lam(Tup(List((None,Fld(_,Var(x))))),App(Var(x),Tup(List((None,Fld(_,Var(f)))))))))))
//│ | | | 1. Created lazy type info for NuFunDef(None,Var(f),None,List(),Left(Lam(Tup(List((None,Fld(_,Var(x))))),App(Var(x),Tup(List((None,Fld(_,Var(f)))))))))
//│ | | | Completing fun f = (x,) => x(f,)
//│ | | | | Type params 
//│ | | | | Params 
//│ | | | | Type f polymorphically? true && (1 === 0 || false || false
//│ | | | | 1. Typing term Lam(Tup(List((None,Fld(_,Var(x))))),App(Var(x),Tup(List((None,Fld(_,Var(f)))))))
//│ | | | | | 1. Typing pattern Tup(List((None,Fld(_,Var(x)))))
//│ | | | | | | 1. Typing pattern Var(x)
//│ | | | | | | 1. : x31'
//│ | | | | | 1. : (x31',)
//│ | | | | | 1. Typing term App(Var(x),Tup(List((None,Fld(_,Var(f))))))
//│ | | | | | | 1. Typing term Var(x)
//│ | | | | | | 1. : x31'
//│ | | | | | | 1. Typing term Var(f)
//│ | | | | | | | Already computing! Using TV: f32'
//│ | | | | | | 1. : f32'
//│ | | | | | | CONSTRAIN x31' <! (f32' -> α33')
//│ | | | | | |   where 
//│ | | | | | | 1. C x31' <! (f32' -> α33')    (0)
//│ | | | | | | | NEW x31' UB (1)
//│ | | | | | 1. : α33'
//│ | | | | 1. : (x31' -> α33')
//│ | | | | CONSTRAIN (x31' -> α33') <! f32'
//│ | | | |   where 
//│ 		x31' <: (f32' -> α33')
//│ | | | | 2. C (x31' -> α33') <! f32'    (0)
//│ | | | | | NEW f32' LB (1)
//│ | | | Completed TypedNuFun(1,NuFunDef(None,Var(f),None,List(),Left(Lam(Tup(List((None,Fld(_,Var(x))))),App(Var(x),Tup(List((None,Fld(_,Var(f))))))))),(x31' -> α33')) where 
//│ 		x31' <: (f32' -> α33')
//│ 		f32' :> (x31' -> α33')
//│ | | | Typing unit statements
//│ | | | : None
//│ | | Checking overriding for TypedNuFun(1,NuFunDef(None,Var(f),None,List(),Left(Lam(Tup(List((None,Fld(_,Var(x))))),App(Var(x),Tup(List((None,Fld(_,Var(f))))))))),(x31' -> α33')) against None...
//│ | Completed TypedNuMxn(0, TypeName(Foo),
//│ 	this: this29',
//│ 	super: super30',
//│ 	tparams: List(),
//│ 	params: List(),
//│ 	members: 
//│ 	(f,TypedNuFun(1,NuFunDef(None,Var(f),None,List(),Left(Lam(Tup(List((None,Fld(_,Var(x))))),App(Var(x),Tup(List((None,Fld(_,Var(f))))))))),(x31' -> α33')))
//│ ) where 
//│ 		x31' <: (f32' -> α33')
//│ 		f32' :> (x31' -> α33')
//│ | Typing unit statements
//│ | : None
//│ ======== TYPED ========
//│ mixin Foo
//│   this: this29' 
//│   super: super30' 
//│ mixin Foo() {
//│   fun f: 'x -> 'a
//│ }
//│ where
//│   'x <: ('x -> 'a) -> 'a

mixin Foo {
  fun f(x) = g(f), x
  fun g(y) = y(g)
}
//│ mixin Foo() {
//│   fun f: ('a & 'b) -> ('c -> 'b | 'a)
//│   fun g: 'c -> 'b
//│ }
//│ where
//│   'b :> 'c -> 'b
//│   'c <: ('c -> 'b) -> 'b

mixin Foo {
  fun f(x) = g(x), x
  fun g(y) = f(y)
}
//│ mixin Foo() {
//│   fun f: 'a -> 'a
//│   fun g: 'a -> 'a
//│ }

module Foo {
  fun f(x) = g(x), x
  fun g(y) = f(y)
}
//│ module Foo {
//│   fun f: forall 'a. 'a -> 'a
//│   fun g: forall 'a. 'a -> 'a
//│ }
