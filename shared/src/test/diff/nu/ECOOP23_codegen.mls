:NewParser
:NewDefs

:js
class Add<E>(lhs: E, rhs: E)
class Lit(n: int)
//│ class Add[E](lhs: E, rhs: E)
//│ class Lit(n: int)
//│ // Prelude
//│ let res;
//│ let __mls_modules__ = { cache: {} };
//│ Object.defineProperty(__mls_modules__, "Add", {
//│   get: function () {
//│     if (this.cache.Add === undefined) {
//│       class Add {
//│         constructor(lhs, rhs) {
//│           this.lhs = lhs;
//│           this.rhs = rhs;
//│         }
//│       };
//│       this.cache.Add = ((lhs, rhs) => new Add(lhs, rhs));
//│       this.cache.Add["class"] = Add;
//│     }
//│     return this.cache.Add;
//│   }
//│ });
//│ Object.defineProperty(__mls_modules__, "Lit", {
//│   get: function () {
//│     if (this.cache.Lit === undefined) {
//│       class Lit {
//│         constructor(n) {
//│           this.n = n;
//│         }
//│       };
//│       this.cache.Lit = ((n) => new Lit(n));
//│       this.cache.Lit["class"] = Lit;
//│     }
//│     return this.cache.Lit;
//│   }
//│ });
//│ // End of generated code

:js
mixin EvalBase {
  fun eval(e) =
    if e is
      Lit(n) then n: int
      Add(l, r) then this.eval(l) + this.eval(r)
}
//│ mixin EvalBase() {
//│   this: {eval: 'lhs -> int}
//│   fun eval: (Add['lhs] | Lit) -> int
//│ }
//│ // Query 1
//│ globalThis.EvalBase = function EvalBase(base) {
//│   return (class EvalBase extends base {
//│     constructor(...rest) {
//│       super(...rest);
//│     }
//│     eval(e) {
//│       const self = this;
//│       return ((() => {
//│         let a;
//│         return (a = e, a instanceof __mls_modules__.Lit ? ((n) => n)(e.n) : a instanceof __mls_modules__.Add ? ((l) => ((r) => self.eval(l) + self.eval(r))(e.rhs))(e.lhs) : (() => {
//│           throw new Error("non-exhaustive case expression");
//│         })());
//│       })());
//│     }
//│   });
//│ };
//│ // End of generated code

:js
class Neg<A>(expr: A)
//│ class Neg[A](expr: A)
//│ // Prelude
//│ Object.defineProperty(__mls_modules__, "Neg", {
//│   get: function () {
//│     if (this.cache.Neg === undefined) {
//│       class Neg {
//│         constructor(expr) {
//│           this.expr = expr;
//│         }
//│       };
//│       this.cache.Neg = ((expr) => new Neg(expr));
//│       this.cache.Neg["class"] = Neg;
//│     }
//│     return this.cache.Neg;
//│   }
//│ });
//│ // End of generated code

:js
mixin EvalNeg {
  fun eval(e) =
    if e is Neg(d) then 0 - this.eval(d)
    else super.eval(e)
}
//│ mixin EvalNeg() {
//│   super: {eval: 'a -> 'b}
//│   this: {eval: 'expr -> int}
//│   fun eval: (Neg['expr] | 'a & ~Neg) -> (int | 'b)
//│ }
//│ // Query 1
//│ globalThis.EvalNeg = function EvalNeg(base) {
//│   return (class EvalNeg extends base {
//│     constructor(...rest) {
//│       super(...rest);
//│     }
//│     eval(e) {
//│       const self = this;
//│       return ((() => {
//│         return e instanceof __mls_modules__.Neg ? ((d) => 0 - self.eval(d))(e.expr) : super.eval(e);
//│       })());
//│     }
//│   });
//│ };
//│ // End of generated code

:js
mixin EvalNegNeg {
  fun eval(e) =
    if e is Neg(Neg(d)) then this.eval(d)
    else super.eval(e)
}
//│ mixin EvalNegNeg() {
//│   super: {eval: (Neg['A] | 'a) -> 'b}
//│   this: {eval: 'expr -> 'b}
//│   fun eval: (Neg['A & (~Neg | Neg['expr])] | 'a & ~Neg) -> 'b
//│ }
//│ // Query 1
//│ globalThis.EvalNegNeg = function EvalNegNeg(base) {
//│   return (class EvalNegNeg extends base {
//│     constructor(...rest) {
//│       super(...rest);
//│     }
//│     eval(e) {
//│       const self = this;
//│       return ((() => {
//│         return e instanceof __mls_modules__.Neg ? ((tmp0) => tmp0 instanceof __mls_modules__.Neg ? ((d) => self.eval(d))(tmp0.expr) : super.eval(e))(e.expr) : super.eval(e);
//│       })());
//│     }
//│   });
//│ };
//│ // End of generated code

:js
module TestLang: EvalBase, EvalNeg, EvalNegNeg
//│ module TestLang() {
//│   fun eval: 'a -> int
//│ }
//│ where
//│   'a <: Add['a] | Lit | Neg['A & (~Neg | Neg['a])]
//│   'A <: 'a
//│ // Query 1
//│ globalThis.TestLang1 = function TestLang1() {
//│   return (new class TestLang extends EvalNegNeg(EvalNeg(EvalBase())) {
//│     constructor(...rest) {
//│       super(...rest);
//│     }
//│   });
//│ };
//│ // End of generated code

:js
fun mk(n) = if n is
  0 then Lit(0)
  1 then Neg(mk(n))
  _ then Add(mk(n), mk(n))
TestLang.eval(mk(0))
//│ fun mk: number -> (Lit | 'a)
//│ int
//│ where
//│   'a :> Neg[Lit | 'a] | Add[Lit | 'a]
//│ // Query 1
//│ globalThis.mk = function mk(n) {
//│   return n == 0 === true ? new __mls_modules__.Lit(0) : n == 1 === true ? new __mls_modules__.Neg(mk(n)) : new __mls_modules__.Add(mk(n), mk(n));
//│ };
//│ // Query 2
//│ res = TestLang1().eval(mk(0));
//│ // End of generated code

