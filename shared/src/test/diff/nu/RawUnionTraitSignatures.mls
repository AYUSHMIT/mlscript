:NewDefs
:NoJS // TODO


trait Foo[A] { fun x: A }
//│ trait Foo[A]() {
//│   fun x: A
//│ }


trait Base1: Foo
//│ trait Base1(): #Foo

(b: Base1) => b.x
//│ (b: Base1,) -> ??A

(b: Base1) => b : Foo
//│ (b: Base1,) -> #Foo

:e
(b: Base1) => b : Foo['X]
//│ ╔══[ERROR] Type error in type ascription
//│ ║  l.21: 	(b: Base1) => b : Foo['X]
//│ ║        	              ^
//│ ╟── type variable `A` leaks out of its scope
//│ ║  l.21: 	(b: Base1) => b : Foo['X]
//│ ║        	                      ^^
//│ ╟── back into type variable `A`
//│ ║  l.5: 	trait Foo[A] { fun x: A }
//│ ╙──     	          ^
//│ (b: Base1,) -> Foo['X]
//│   where
//│     'X :> ??A
//│        <: ??A0

:e
1 : Foo[int]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.37: 	1 : Foo[int]
//│ ║        	^
//│ ╟── integer literal of type `1` is not an instance of type `Foo`
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.37: 	1 : Foo[int]
//│ ╙──      	    ^^^^^^^^
//│ Foo[int]


trait Base1: Foo { val x: int }
//│ trait Base1(): #Foo {
//│   let x: int
//│ }

(b: Base1) => b.x
//│ (b: Base1,) -> (int & ??A)


trait Base1: Foo[1 | 2] { val x: 0 | 1 }
//│ trait Base1(): Foo[1 | 2] {
//│   let x: 0 | 1
//│ }

(b: Base1) => b.x
//│ (b: Base1,) -> 1


trait Base2: Foo['FigureItOut]
//│ trait Base2(): Foo[in ??FigureItOut out ??FigureItOut0]

(b: Base2) => b.x
//│ (b: Base2,) -> ??FigureItOut

(b: Base1) => b : Foo
//│ (b: Base1,) -> #Foo

// :e
(b: Base2) => b : Foo['X]
//│ (b: Base2,) -> Foo['X]
//│   where
//│     'X :> ??FigureItOut
//│        <: ??FigureItOut0


// TODO reject
class Impl extends Base2
//│ class Impl()

(x: Impl) => x : Base2
//│ (x: Impl,) -> Base2

:e
class Impl extends Base2, Foo
//│ ╔══[ERROR] Member x is declared in parent trait but not implemented
//│ ║  l.91: 	class Impl extends Base2, Foo
//│ ╙──      	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ class Impl()

class Impl extends Base2, Foo {
  fun x = 1
}
//│ class Impl() {
//│   fun x: 1
//│ }

Impl().x
//│ 1

Impl() : Base2
//│ Base2

(Impl() : Base2).x
//│ ??FigureItOut

class Impl2 extends Base2, Foo[int] {
  fun x = 1
}
//│ class Impl2() {
//│   fun x: 1
//│ }

(Impl2() : Base2).x
//│ ??FigureItOut



trait Test1[A] { fun x: A }
trait Test2[A]: Test1[(A, A)]
//│ trait Test1[A]() {
//│   fun x: A
//│ }
//│ trait Test2[A](): Test1[(A, A,)]

(t: Test2[int]) => t.x
//│ (t: Test2[int],) -> (int, int,)



