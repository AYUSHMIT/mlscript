:NewParser
:NewDefs
:NoJS


// :d
mixin BaseTest {
  fun test = super.base
}
//│ mixin BaseTest
//│   this: this23' 
//│   super: super24' 
//│   |		super24' <: {base: base27_28'}
//│   fun test: ‹∀ 1. test26''#› where 
//│   |		test26''# := base27''
//│   |		base27'' :> base27_28' <: test26''#
//│   [pretty-printed] test: nothing

mixin BaseInc {
  fun test = super.base + 1
}
//│ mixin BaseInc
//│   this: this33' 
//│   super: super34' 
//│   |		super34' <: {base: base37_38'}
//│   |		base37_38' <: int<number>
//│   fun test: ‹∀ 1. test36''#› where 
//│   |		test36''# := α40''
//│   |		α40'' :> int<number> <: test36''#
//│   [pretty-printed] test: int

// :d
class Base1(base: int): BaseTest
//│ class Base1

Base1(1).test
//│ Typed: int


class Base1(base): BaseTest
//│ class Base1

Base1
//│ Typed: (base: anything,) -> Base1

// TODO
Base1(1).test
//│ Typed: nothing


:e
class Base1(x): BaseTest
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.52: 	class Base1(x): BaseTest
//│ ║        	      ^^^^^^^^^^^^^^^^^^
//│ ╟── type `{x: ?x}` does not have field 'base'
//│ ║  l.52: 	class Base1(x): BaseTest
//│ ║        	           ^^^
//│ ╟── Note: constraint arises from field selection:
//│ ║  l.8: 	  fun test = super.base
//│ ║       	             ^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.8: 	  fun test = super.base
//│ ╙──     	             ^^^^^
//│ class Base1

Base1
//│ Typed: (x: anything,) -> Base1


// :ns
mixin Foo {
  fun test(x) = [super.base + x, x, super.misc]
}
//│ mixin Foo
//│   this: this110' 
//│   super: super111' 
//│   |		super111' <: {misc: misc119_120'} & {base: base115_116'}
//│   |		base115_116' <: int<number>
//│   fun test: ‹∀ 1. test113''#› where 
//│   |		test113''# := (α114'' -> (α118'', α114'', misc119'',))
//│   |		α114'' <: int<number>
//│   |		α118'' :> int<number>
//│   |		misc119'' :> misc119_120'
//│   [pretty-printed] test: (int & 'a) -> (int, 'a, nothing,)



mixin WrapBase {
  // fun wrap(x) = x
  // fun wrap(x) = x : int
  fun wrap(x : int) = x : int
}
//│ mixin WrapBase
//│   this: this129' 
//│   super: super130' 
//│   fun wrap: ‹∀ 1. wrap132''#› where 
//│   |		wrap132''# := (Int -> Int)
//│   [pretty-printed] wrap: int -> int

// :d
mixin Wrap {
  fun wrap(x) = [super.wrap(x)]
}
//│ mixin Wrap
//│   this: this135' 
//│   super: super136' 
//│   |		super136' <: {wrap: wrap140_141'}
//│   |		wrap140_141' <: ((α139_143',) -> α142_144')
//│   fun wrap: ‹∀ 1. wrap138''#› where 
//│   |		wrap138''# := (α139'' -> (α142'',))
//│   |		α139'' <: α139_143'
//│   |		α142'' :> α142_144'
//│   [pretty-printed] wrap: anything -> (nothing,)



// :d
module WrapBase1: WrapBase, Wrap
//│ class WrapBase1


WrapBase1
//│ Typed: WrapBase1

// :d
WrapBase1.wrap
//│ Typed: int -> (int,)

// :d
// WrapBase1.wrap

WrapBase1.wrap(1)
//│ Typed: (int,)

:e
WrapBase1.wrap("ok")
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.137: 	WrapBase1.wrap("ok")
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"ok"` is not an instance of type `int`
//│ ║  l.137: 	WrapBase1.wrap("ok")
//│ ║         	               ^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.92: 	  fun wrap(x : int) = x : int
//│ ║        	               ^^^
//│ ╟── from reference:
//│ ║  l.103: 	  fun wrap(x) = [super.wrap(x)]
//│ ╙──       	                            ^
//│ Typed: (int,) | error


module WrapBase2: WrapBase, Wrap, Wrap, Wrap
//│ class WrapBase2

let w = WrapBase2.wrap
//│ fun w: ‹∀ 0. w241'#› where 
//│ |		w241'# := wrap242'
//│ |		wrap242' :> ‹∀ 1. wrap138_243''#› <: w241'#
//│ |		wrap138_243''# := (α139_244'' -> (α142_250'',))
//│ |		α139_244'' <: α139_245'
//│ |		α139_245' <: α139_246'
//│ |		α139_246' <: α139_247'
//│ |		α139_247' <: α139_248'
//│ |		α139_248' <: α139_249'
//│ |		α139_249' <: Int
//│ |		α142_250'' :> α142_251'
//│ |		α142_251' :> ‹∀ 2. (α142_252''',)›
//│ |		α142_252''' :> α142_253'
//│ |		α142_253' :> ‹∀ 2. (α142_254''',)›
//│ |		α142_254''' :> α142_255'
//│ |		α142_255' :> Int
//│ [pretty-printed] w: int -> (((int,),),)

let wd = w(1)
//│ fun wd: ‹∀ 0. wd272'#› where 
//│ |		α142_251' :> ‹∀ 2. (α142_252''',)›
//│ |		α142_252''' :> α142_253'
//│ |		α142_253' :> ‹∀ 2. (α142_254''',)›
//│ |		α142_254''' :> α142_255'
//│ |		α142_255' :> Int
//│ |		wd272'# := α273'
//│ |		α273' :> ‹∀ 2. (α142_274''',)› <: wd272'#
//│ |		α142_274''' :> α142_251'
//│ [pretty-printed] wd: (((int,),),)

wd._1._1._1 + 1
//│ Typed: int


