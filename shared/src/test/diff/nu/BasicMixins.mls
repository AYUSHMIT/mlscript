:NewParser
:NewDefs
:NoJS


// :d
mixin BaseTest {
  fun test = super.base
}
//│ mixin BaseTest() {
//│   super: {base: 'base}
//│   fun test: 'base
//│ }

mixin BaseInc {
  fun test = super.base + 1
  fun test2 = this.base
}
//│ mixin BaseInc() {
//│   super: {base: int}
//│   this: {base: 'base}
//│   fun test: int
//│   fun test2: 'base
//│ }

// :d
class Base1(base: int) extends BaseTest, BaseInc {
  fun test3 = [base, this.base]
}
//│ class Base1(base: int) {
//│   fun test: int
//│   fun test2: int
//│   fun test3: (int, int,)
//│ }

Base1(1).test
//│ int

Base1(1).test2
//│ int

Base1(1).test3
//│ (int, int,)


// TODO
class Base1(base) extends BaseTest
//│ ╔══[ERROR] Class parameters currently need type annotations
//│ ║  l.47: 	class Base1(base) extends BaseTest
//│ ╙──      	            ^^^^
//│ class Base1(base: error) {
//│   fun test: error
//│ }

Base1
//│ (base: error,) -> Base1

// TODO
Base1(1).test
//│ error


:e
class Base1(x) extends BaseTest
//│ ╔══[ERROR] Class parameters currently need type annotations
//│ ║  l.64: 	class Base1(x) extends BaseTest
//│ ╙──      	            ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.64: 	class Base1(x) extends BaseTest
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `{x: error}` does not have field 'base'
//│ ║  l.64: 	class Base1(x) extends BaseTest
//│ ║        	           ^^^
//│ ╟── Note: constraint arises from field selection:
//│ ║  l.8: 	  fun test = super.base
//│ ║       	             ^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.8: 	  fun test = super.base
//│ ╙──     	             ^^^^^
//│ class Base1(x: error) {
//│   fun test: nothing
//│ }

:e
class Base1(x): BaseTest
//│ ╔══[ERROR] Class parameters currently need type annotations
//│ ║  l.85: 	class Base1(x): BaseTest
//│ ╙──      	            ^
//│ ╔══[ERROR] mixins cannot be used as types
//│ ║  l.85: 	class Base1(x): BaseTest
//│ ╙──      	                ^^^^^^^^
//│ ╔══[ERROR] type signatures not yet supported for classes
//│ ║  l.85: 	class Base1(x): BaseTest
//│ ╙──      	                ^^^^^^^^
//│ class Base1(x: error)

Base1
//│ (x: error,) -> Base1


// :ns
mixin Foo {
  fun test(x) = [super.base + x, x, super.misc]
}
//│ mixin Foo() {
//│   super: {base: int, misc: 'misc}
//│   fun test: (int & 'a) -> (int, 'a, 'misc,)
//│ }

module Base1(base: int, misc: string) extends Foo
//│ module Base1(base: int, misc: string) {
//│   fun test: (int & 'a) -> (int, 'a, string,)
//│ }

Base1.test
//│ (int & 'a) -> (int, 'a, string,)


mixin WrapBase {
  // fun wrap(x) = x
  // fun wrap(x) = x : int
  fun wrapA(x: int) = x : int
  fun wrap(x) = x
}
//│ mixin WrapBase() {
//│   fun wrap: 'a -> 'a
//│   fun wrapA: (x: int,) -> int
//│ }

// :d
mixin Wrap {
  fun wrapA(x) = [super.wrapA(x)]
  fun wrap(x) = [super.wrap(x)]
}
//│ mixin Wrap() {
//│   super: {wrap: 'a -> 'b, wrapA: 'c -> 'd}
//│   fun wrap: 'a -> ('b,)
//│   fun wrapA: 'c -> ('d,)
//│ }



// :d
module WrapBase1 extends WrapBase, Wrap
//│ module WrapBase1() {
//│   fun wrap: 'a -> ('a,)
//│   fun wrapA: int -> (int,)
//│ }


WrapBase1
//│ WrapBase1

// :d
WrapBase1.wrapA
//│ int -> (int,)

WrapBase1.wrap
//│ 'a -> ('a,)

// :d
// WrapBase1.wrap


WrapBase1.wrap(1)
//│ (1,)

WrapBase1.wrap("ok")
//│ ("ok",)


WrapBase1.wrapA(1)
//│ (int,)

:e
WrapBase1.wrapA("ok")
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.176: 	WrapBase1.wrapA("ok")
//│ ║         	^^^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"ok"` is not an instance of type `int`
//│ ║  l.176: 	WrapBase1.wrapA("ok")
//│ ║         	                ^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.122: 	  fun wrapA(x: int) = x : int
//│ ║         	               ^^^
//│ ╟── from reference:
//│ ║  l.132: 	  fun wrapA(x) = [super.wrapA(x)]
//│ ╙──       	                              ^
//│ (int,) | error



module WrapBase2 extends WrapBase, Wrap, Wrap, Wrap
//│ module WrapBase2() {
//│   fun wrap: 'a -> ((('a,),),)
//│   fun wrapA: int -> (((int,),),)
//│ }

let w = WrapBase2.wrap
//│ let w: 'a -> ((('a,),),)

let wd = w(1)
//│ let wd: (((1,),),)

wd._1._1._1 + 1
//│ int


