:NewParser
:NewDefs
:NoJS


// :d
mixin BaseTest {
  fun test = super.base
}
//│ mixin BaseTest
//│   this: this23' 
//│   super: super24' 
//│   |		super24' <: {base: base27_28'}
//│   fun test: ‹∀ 1. test26''#› where 
//│   |		test26''# := base27''
//│   |		base27'' :> base27_28' <: test26''#
//│   [pretty-printed] test: nothing

mixin BaseInc {
  fun test = super.base + 1
  fun test2 = this.base
}
//│ mixin BaseInc
//│   this: this33' 
//│   |		this33' <: {base: base43_44'}
//│   super: super34' 
//│   |		super34' <: {base: base38_39'}
//│   |		base38_39' <: int<number>
//│   fun test: ‹∀ 1. test37''#› where 
//│   |		test37''# := α41''
//│   |		α41'' :> int<number> <: test37''#
//│   [pretty-printed] test: int
//│   fun test2: ‹∀ 1. test242''#› where 
//│   |		test242''# := base43''
//│   |		base43'' :> base43_44' <: test242''#
//│   [pretty-printed] test2: nothing

// :d
class Base1(base: int): BaseTest, BaseInc {
  fun test3 = [base, this.base]
}
//│ class Base1
//│   fun test3: ‹∀ 1. test368''#› where 
//│   |		test368''# := (Int, base69'',)
//│   |		base69'' :> base69_70'
//│   |		base69_70' :> Int
//│   [pretty-printed] test3: (int, int,)

Base1(1).test
//│ Typed: int

Base1(1).test2
//│ Typed: int

Base1(1).test3
//│ Typed: (int, int,)


class Base1(base): BaseTest
//│ class Base1

Base1
//│ Typed: (base: anything,) -> Base1

// TODO
Base1(1).test
//│ Typed: nothing


:e
class Base1(x): BaseTest
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.71: 	class Base1(x): BaseTest
//│ ║        	      ^^^^^^^^^^^^^^^^^^
//│ ╟── type `{x: ?x}` does not have field 'base'
//│ ║  l.71: 	class Base1(x): BaseTest
//│ ║        	           ^^^
//│ ╟── Note: constraint arises from field selection:
//│ ║  l.8: 	  fun test = super.base
//│ ║       	             ^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.8: 	  fun test = super.base
//│ ╙──     	             ^^^^^
//│ class Base1

Base1
//│ Typed: (x: anything,) -> Base1


// :ns
mixin Foo {
  fun test(x) = [super.base + x, x, super.misc]
}
//│ mixin Foo
//│   this: this186' 
//│   super: super187' 
//│   |		super187' <: {misc: misc195_196'} & {base: base191_192'}
//│   |		base191_192' <: int<number>
//│   fun test: ‹∀ 1. test189''#› where 
//│   |		test189''# := (α190'' -> (α194'', α190'', misc195'',))
//│   |		α190'' <: int<number>
//│   |		α194'' :> int<number>
//│   |		misc195'' :> misc195_196'
//│   [pretty-printed] test: (int & 'a) -> (int, 'a, nothing,)

module Base1(base: int, misc: string): Foo
//│ class Base1

Base1.test
//│ Typed: (int & 'a) -> (int, 'a, string,)


mixin WrapBase {
  // fun wrap(x) = x
  // fun wrap(x) = x : int
  fun wrapA(x : int) = x : int
  fun wrap(x) = x
}
//│ mixin WrapBase
//│   this: this231' 
//│   super: super232' 
//│   fun wrapA: ‹∀ 1. wrapA235''#› where 
//│   |		wrapA235''# := (Int -> Int)
//│   [pretty-printed] wrapA: int -> int
//│   fun wrap: ‹∀ 1. wrap236''#› where 
//│   |		wrap236''# := (α237'' -> α237'')
//│   [pretty-printed] wrap: 'a -> 'a

// :d
mixin Wrap {
  fun wrapA(x) = [super.wrapA(x)]
  fun wrap(x) = [super.wrap(x)]
}
//│ mixin Wrap
//│   this: this244' 
//│   super: super245' 
//│   |		super245' <: {wrap: wrap257_258'} & {wrapA: wrapA250_251'}
//│   |		wrapA250_251' <: ((α249_253',) -> α252_254')
//│   |		wrap257_258' <: ((α256_260',) -> α259_261')
//│   fun wrapA: ‹∀ 1. wrapA248''#› where 
//│   |		wrapA248''# := (α249'' -> (α252'',))
//│   |		α249'' <: α249_253'
//│   |		α252'' :> α252_254'
//│   [pretty-printed] wrapA: anything -> (nothing,)
//│   fun wrap: ‹∀ 1. wrap255''#› where 
//│   |		wrap255''# := (α256'' -> (α259'',))
//│   |		α256'' <: α256_260'
//│   |		α259'' :> α259_261'
//│   [pretty-printed] wrap: anything -> (nothing,)



// :d
module WrapBase1: WrapBase, Wrap
//│ class WrapBase1


WrapBase1
//│ Typed: WrapBase1

// :d
WrapBase1.wrapA
//│ Typed: int -> (int,)

WrapBase1.wrap
//│ Typed: 'a -> ('a,)

// :d
// WrapBase1.wrap


WrapBase1.wrap(1)
//│ Typed: (1,)

WrapBase1.wrap("ok")
//│ Typed: ("ok",)


WrapBase1.wrapA(1)
//│ Typed: (int,)

:e
WrapBase1.wrapA("ok")
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.183: 	WrapBase1.wrapA("ok")
//│ ║         	^^^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"ok"` is not an instance of type `int`
//│ ║  l.183: 	WrapBase1.wrapA("ok")
//│ ║         	                ^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.116: 	  fun wrapA(x : int) = x : int
//│ ║         	                ^^^
//│ ╟── from reference:
//│ ║  l.131: 	  fun wrapA(x) = [super.wrapA(x)]
//│ ╙──       	                              ^
//│ Typed: (int,) | error



module WrapBase2: WrapBase, Wrap, Wrap, Wrap
//│ class WrapBase2

let w = WrapBase2.wrap
//│ fun w: ‹∀ 0. w476'#› where 
//│ |		w476'# := wrap477'
//│ |		wrap477' :> ‹∀ 1. wrap255_491''#› <: w476'#
//│ |		wrap255_491''# := (α256_492'' -> (α259_500'',))
//│ |		α256_492'' <: α256_493'
//│ |		α256_493' <: α256_494'
//│ |		α256_494' <: α256_495'
//│ |		α256_495' <: α256_496'
//│ |		α256_496' <: α256_497'
//│ |		α256_497' <: α237_498'
//│ |		α237_498' <: α259_499'
//│ |		α259_500'' :> α259_501'
//│ |		α259_501' :> ‹∀ 2. (α259_502''',)›
//│ |		α259_502''' :> α259_503'
//│ |		α259_503' :> ‹∀ 2. (α259_504''',)›
//│ |		α259_504''' :> α259_499'
//│ [pretty-printed] w: 'a -> ((('a,),),)

let wd = w(1)
//│ fun wd: ‹∀ 0. wd524'#› where 
//│ |		α259_499' :> 1<int,number>
//│ |		α259_501' :> ‹∀ 2. (α259_502''',)›
//│ |		α259_502''' :> α259_503'
//│ |		α259_503' :> ‹∀ 2. (α259_504''',)›
//│ |		α259_504''' :> α259_499'
//│ |		wd524'# := α525'
//│ |		α525' :> ‹∀ 2. (α259_526''',)› <: wd524'#
//│ |		α259_526''' :> α259_501'
//│ [pretty-printed] wd: (((1,),),)

wd._1._1._1 + 1
//│ Typed: int


