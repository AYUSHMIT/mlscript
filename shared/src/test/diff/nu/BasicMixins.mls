:NewParser
:NewDefs
:NoJS


// :d
mixin BaseTest {
  fun test = super.base
}
//│ mixin BaseTest
//│   this: this23' 
//│   super: super24' 
//│   |		super24' <: {base: base27_28'}
//│   fun test: ‹∀ 1. test26''#› where 
//│   |		test26''# := base27''
//│   |		base27'' :> base27_28' <: test26''#
//│   [pretty-printed] test: nothing

mixin BaseInc {
  fun test = super.base + 1
  fun test2 = this.base
}
//│ mixin BaseInc
//│   this: this33' 
//│   |		this33' <: {base: base43_44'}
//│   super: super34' 
//│   |		super34' <: {base: base38_39'}
//│   |		base38_39' <: int<number>
//│   fun test: ‹∀ 1. test37''#› where 
//│   |		test37''# := α41''
//│   |		α41'' :> int<number> <: test37''#
//│   [pretty-printed] test: int
//│   fun test2: ‹∀ 1. test242''#› where 
//│   |		test242''# := base43''
//│   |		base43'' :> base43_44' <: test242''#
//│   [pretty-printed] test2: nothing

// :d
class Base1(base: int): BaseTest, BaseInc {
  fun test3 = [base, this.base]
}
//│ class Base1
//│   fun test3: ‹∀ 1. test368''#› where 
//│   |		test368''# := (Int, base69'',)
//│   |		base69'' :> base69_70'
//│   |		base69_70' :> Int
//│   [pretty-printed] test3: (int, int,)

Base1(1).test
//│ Typed: int

Base1(1).test2
//│ Typed: int

Base1(1).test3
//│ Typed: (int, int,)


class Base1(base): BaseTest
//│ class Base1

Base1
//│ Typed: (base: anything,) -> Base1

// TODO
Base1(1).test
//│ Typed: nothing


:e
class Base1(x): BaseTest
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.71: 	class Base1(x): BaseTest
//│ ║        	      ^^^^^^^^^^^^^^^^^^
//│ ╟── type `{x: ?x}` does not have field 'base'
//│ ║  l.71: 	class Base1(x): BaseTest
//│ ║        	           ^^^
//│ ╟── Note: constraint arises from field selection:
//│ ║  l.8: 	  fun test = super.base
//│ ║       	             ^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.8: 	  fun test = super.base
//│ ╙──     	             ^^^^^
//│ class Base1

Base1
//│ Typed: (x: anything,) -> Base1


// :ns
mixin Foo {
  fun test(x) = [super.base + x, x, super.misc]
}
//│ mixin Foo
//│   this: this191' 
//│   super: super192' 
//│   |		super192' <: {misc: misc200_201'} & {base: base196_197'}
//│   |		base196_197' <: int<number>
//│   fun test: ‹∀ 1. test194''#› where 
//│   |		test194''# := (α195'' -> (α199'', α195'', misc200'',))
//│   |		α195'' <: int<number>
//│   |		α199'' :> int<number>
//│   |		misc200'' :> misc200_201'
//│   [pretty-printed] test: (int & 'a) -> (int, 'a, nothing,)

module Base1(base: int, misc: string): Foo
//│ class Base1

Base1.test
//│ Typed: (int & 'a) -> (int, 'a, string,)


mixin WrapBase {
  // fun wrap(x) = x
  // fun wrap(x) = x : int
  fun wrapA(x : int) = x : int
  fun wrap(x) = x
}
//│ mixin WrapBase
//│   this: this236' 
//│   super: super237' 
//│   fun wrapA: ‹∀ 1. wrapA240''#› where 
//│   |		wrapA240''# := (Int -> Int)
//│   [pretty-printed] wrapA: int -> int
//│   fun wrap: ‹∀ 1. wrap241''#› where 
//│   |		wrap241''# := (α242'' -> α242'')
//│   [pretty-printed] wrap: 'a -> 'a

// :d
mixin Wrap {
  fun wrapA(x) = [super.wrapA(x)]
  fun wrap(x) = [super.wrap(x)]
}
//│ mixin Wrap
//│   this: this249' 
//│   super: super250' 
//│   |		super250' <: {wrap: wrap262_263'} & {wrapA: wrapA255_256'}
//│   |		wrapA255_256' <: ((α254_258',) -> α257_259')
//│   |		wrap262_263' <: ((α261_265',) -> α264_266')
//│   fun wrapA: ‹∀ 1. wrapA253''#› where 
//│   |		wrapA253''# := (α254'' -> (α257'',))
//│   |		α254'' <: α254_258'
//│   |		α257'' :> α257_259'
//│   [pretty-printed] wrapA: anything -> (nothing,)
//│   fun wrap: ‹∀ 1. wrap260''#› where 
//│   |		wrap260''# := (α261'' -> (α264'',))
//│   |		α261'' <: α261_265'
//│   |		α264'' :> α264_266'
//│   [pretty-printed] wrap: anything -> (nothing,)



// :d
module WrapBase1: WrapBase, Wrap
//│ class WrapBase1


WrapBase1
//│ Typed: WrapBase1

// :d
WrapBase1.wrapA
//│ Typed: int -> (int,)

WrapBase1.wrap
//│ Typed: 'a -> ('a,)

// :d
// WrapBase1.wrap


WrapBase1.wrap(1)
//│ Typed: (1,)

WrapBase1.wrap("ok")
//│ Typed: ("ok",)


WrapBase1.wrapA(1)
//│ Typed: (int,)

:e
WrapBase1.wrapA("ok")
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.183: 	WrapBase1.wrapA("ok")
//│ ║         	^^^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"ok"` is not an instance of type `int`
//│ ║  l.183: 	WrapBase1.wrapA("ok")
//│ ║         	                ^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.116: 	  fun wrapA(x : int) = x : int
//│ ║         	                ^^^
//│ ╟── from reference:
//│ ║  l.131: 	  fun wrapA(x) = [super.wrapA(x)]
//│ ╙──       	                              ^
//│ Typed: (int,) | error



module WrapBase2: WrapBase, Wrap, Wrap, Wrap
//│ class WrapBase2

let w = WrapBase2.wrap
//│ fun w: ‹∀ 0. w481'#› where 
//│ |		w481'# := wrap482'
//│ |		wrap482' :> ‹∀ 1. wrap260_496''#› <: w481'#
//│ |		wrap260_496''# := (α261_497'' -> (α264_505'',))
//│ |		α261_497'' <: α261_498'
//│ |		α261_498' <: α261_499'
//│ |		α261_499' <: α261_500'
//│ |		α261_500' <: α261_501'
//│ |		α261_501' <: α261_502'
//│ |		α261_502' <: α242_503'
//│ |		α242_503' <: α264_504'
//│ |		α264_505'' :> α264_506'
//│ |		α264_506' :> ‹∀ 2. (α264_507''',)›
//│ |		α264_507''' :> α264_508'
//│ |		α264_508' :> ‹∀ 2. (α264_509''',)›
//│ |		α264_509''' :> α264_504'
//│ [pretty-printed] w: 'a -> ((('a,),),)

let wd = w(1)
//│ fun wd: ‹∀ 0. wd529'#› where 
//│ |		α264_504' :> 1<int,number>
//│ |		α264_506' :> ‹∀ 2. (α264_507''',)›
//│ |		α264_507''' :> α264_508'
//│ |		α264_508' :> ‹∀ 2. (α264_509''',)›
//│ |		α264_509''' :> α264_504'
//│ |		wd529'# := α530'
//│ |		α530' :> ‹∀ 2. (α264_531''',)› <: wd529'#
//│ |		α264_531''' :> α264_506'
//│ [pretty-printed] wd: (((1,),),)

wd._1._1._1 + 1
//│ Typed: int


