:NewParser
:NewDefs
:NoJS


// :d
mixin BaseTest {
  fun test = super.base
}
//│ mixin BaseTest
//│   this: this23' 
//│   super: super24' 
//│   |		super24' <: {base: base27_28'}
//│   fun test: ‹∀ 1. test26''#› where 
//│   |		test26''# := base27''
//│   |		base27'' :> base27_28' <: test26''#
//│   [pretty-printed] test: nothing

mixin BaseInc {
  fun test = super.base + 1
}
//│ mixin BaseInc
//│   this: this33' 
//│   super: super34' 
//│   |		super34' <: {base: base37_38'}
//│   |		base37_38' <: int<number>
//│   fun test: ‹∀ 1. test36''#› where 
//│   |		test36''# := α40''
//│   |		α40'' :> int<number> <: test36''#
//│   [pretty-printed] test: int

// :d
class Base1(base: int): BaseTest
//│ class Base1

Base1(1).test
//│ Typed: int


class Base1(base): BaseTest
//│ class Base1

Base1
//│ Typed: (base: anything,) -> Base1

// TODO
Base1(1).test
//│ Typed: nothing


:e
class Base1(x): BaseTest
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.52: 	class Base1(x): BaseTest
//│ ║        	      ^^^^^^^^^^^^^^^^^^
//│ ╟── type `{x: ?x}` does not have field 'base'
//│ ║  l.52: 	class Base1(x): BaseTest
//│ ║        	           ^^^
//│ ╟── Note: constraint arises from field selection:
//│ ║  l.8: 	  fun test = super.base
//│ ║       	             ^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.8: 	  fun test = super.base
//│ ╙──     	             ^^^^^
//│ class Base1

Base1
//│ Typed: (x: anything,) -> Base1


// :ns
mixin Foo {
  fun test(x) = [super.base + x, x, super.misc]
}
//│ mixin Foo
//│   this: this110' 
//│   super: super111' 
//│   |		super111' <: {misc: misc119_120'} & {base: base115_116'}
//│   |		base115_116' <: int<number>
//│   fun test: ‹∀ 1. test113''#› where 
//│   |		test113''# := (α114'' -> (α118'', α114'', misc119'',))
//│   |		α114'' <: int<number>
//│   |		α118'' :> int<number>
//│   |		misc119'' :> misc119_120'
//│   [pretty-printed] test: (int & 'a) -> (int, 'a, nothing,)



mixin WrapBase {
  // fun wrap(x) = x
  // fun wrap(x) = x : int
  fun wrapA(x : int) = x : int
  fun wrap(x) = x
}
//│ mixin WrapBase
//│   this: this129' 
//│   super: super130' 
//│   fun wrapA: ‹∀ 1. wrapA133''#› where 
//│   |		wrapA133''# := (Int -> Int)
//│   [pretty-printed] wrapA: int -> int
//│   fun wrap: ‹∀ 1. wrap134''#› where 
//│   |		wrap134''# := (α135'' -> α135'')
//│   [pretty-printed] wrap: 'a -> 'a

// :d
mixin Wrap {
  fun wrapA(x) = [super.wrapA(x)]
  fun wrap(x) = [super.wrap(x)]
}
//│ mixin Wrap
//│   this: this142' 
//│   super: super143' 
//│   |		super143' <: {wrap: wrap155_156'} & {wrapA: wrapA148_149'}
//│   |		wrapA148_149' <: ((α147_151',) -> α150_152')
//│   |		wrap155_156' <: ((α154_158',) -> α157_159')
//│   fun wrapA: ‹∀ 1. wrapA146''#› where 
//│   |		wrapA146''# := (α147'' -> (α150'',))
//│   |		α147'' <: α147_151'
//│   |		α150'' :> α150_152'
//│   [pretty-printed] wrapA: anything -> (nothing,)
//│   fun wrap: ‹∀ 1. wrap153''#› where 
//│   |		wrap153''# := (α154'' -> (α157'',))
//│   |		α154'' <: α154_158'
//│   |		α157'' :> α157_159'
//│   [pretty-printed] wrap: anything -> (nothing,)



// :d
module WrapBase1: WrapBase, Wrap
//│ class WrapBase1


WrapBase1
//│ Typed: WrapBase1

// :d
WrapBase1.wrapA
//│ Typed: int -> (int,)

WrapBase1.wrap
//│ Typed: 'a -> ('a,)

// :d
// WrapBase1.wrap


WrapBase1.wrap(1)
//│ Typed: (1,)

WrapBase1.wrap("ok")
//│ Typed: ("ok",)


WrapBase1.wrapA(1)
//│ Typed: (int,)

:e
WrapBase1.wrapA("ok")
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.159: 	WrapBase1.wrapA("ok")
//│ ║         	^^^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"ok"` is not an instance of type `int`
//│ ║  l.159: 	WrapBase1.wrapA("ok")
//│ ║         	                ^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.92: 	  fun wrapA(x : int) = x : int
//│ ║        	                ^^^
//│ ╟── from reference:
//│ ║  l.107: 	  fun wrapA(x) = [super.wrapA(x)]
//│ ╙──       	                              ^
//│ Typed: (int,) | error



module WrapBase2: WrapBase, Wrap, Wrap, Wrap
//│ class WrapBase2

let w = WrapBase2.wrap
//│ fun w: ‹∀ 0. w374'#› where 
//│ |		w374'# := wrap375'
//│ |		wrap375' :> ‹∀ 1. wrap153_389''#› <: w374'#
//│ |		wrap153_389''# := (α154_390'' -> (α157_398'',))
//│ |		α154_390'' <: α154_391'
//│ |		α154_391' <: α154_392'
//│ |		α154_392' <: α154_393'
//│ |		α154_393' <: α154_394'
//│ |		α154_394' <: α154_395'
//│ |		α154_395' <: α135_396'
//│ |		α135_396' <: α157_397'
//│ |		α157_398'' :> α157_399'
//│ |		α157_399' :> ‹∀ 2. (α157_400''',)›
//│ |		α157_400''' :> α157_401'
//│ |		α157_401' :> ‹∀ 2. (α157_402''',)›
//│ |		α157_402''' :> α157_397'
//│ [pretty-printed] w: 'a -> ((('a,),),)

let wd = w(1)
//│ fun wd: ‹∀ 0. wd422'#› where 
//│ |		α157_397' :> 1<int,number>
//│ |		α157_399' :> ‹∀ 2. (α157_400''',)›
//│ |		α157_400''' :> α157_401'
//│ |		α157_401' :> ‹∀ 2. (α157_402''',)›
//│ |		α157_402''' :> α157_397'
//│ |		wd422'# := α423'
//│ |		α423' :> ‹∀ 2. (α157_424''',)› <: wd422'#
//│ |		α157_424''' :> α157_399'
//│ [pretty-printed] wd: (((1,),),)

wd._1._1._1 + 1
//│ Typed: int


