:NewParser
:NewDefs
:NoJS


// :d
mixin BaseTest {
  fun test = super.base
}
//│ mixin BaseTest
//│   this: this23' 
//│   super: super24' 
//│   |		super24' <: {base: base26_27'}
//│   fun test: base26'' where 
//│   |		test25'' :> base26_27'
//│   |		base26'' :> base26_27' <: test25''
//│   [pretty-printed] test: nothing

mixin BaseInc {
  fun test = super.base + 1
  fun test2 = this.base
}
//│ mixin BaseInc
//│   this: this31' 
//│   |		this31' <: {base: base39_40'}
//│   super: super32' 
//│   |		super32' <: {base: base35_36'}
//│   |		base35_36' <: int<number>
//│   fun test: α38'' where 
//│   |		test33'' :> int<number>
//│   |		α38'' :> int<number> <: test33''
//│   [pretty-printed] test: int
//│   fun test2: base39'' where 
//│   |		test234'' :> base39_40'
//│   |		base39'' :> base39_40' <: test234''
//│   [pretty-printed] test2: nothing

// :d
class Base1(base: int): BaseTest, BaseInc {
  fun test3 = [base, this.base]
}
//│ class Base1
//│   fun test3: (Int, base64'',) where 
//│   |		base64'' :> base64_65'
//│   |		base64_65' :> Int
//│   [pretty-printed] test3: (int, int,)

Base1(1).test
//│ Typed: int

Base1(1).test2
//│ Typed: int

Base1(1).test3
//│ Typed: (int, int,)


class Base1(base): BaseTest
//│ class Base1

Base1
//│ Typed: (base: anything,) -> Base1

// TODO
Base1(1).test
//│ Typed: nothing


:e
class Base1(x): BaseTest
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.70: 	class Base1(x): BaseTest
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `{x: ?x}` does not have field 'base'
//│ ║  l.70: 	class Base1(x): BaseTest
//│ ║        	           ^^^
//│ ╟── Note: constraint arises from field selection:
//│ ║  l.8: 	  fun test = super.base
//│ ║       	             ^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.8: 	  fun test = super.base
//│ ╙──     	             ^^^^^
//│ class Base1

Base1
//│ Typed: (x: anything,) -> Base1


// :ns
mixin Foo {
  fun test(x) = [super.base + x, x, super.misc]
}
//│ mixin Foo
//│   this: this183' 
//│   super: super184' 
//│   |		super184' <: {misc: misc191_192'} & {base: base187_188'}
//│   |		base187_188' <: int<number>
//│   fun test: (α186'' -> (α190'', α186'', misc191'',)) where 
//│   |		α186'' <: int<number>
//│   |		α190'' :> int<number>
//│   |		misc191'' :> misc191_192'
//│   [pretty-printed] test: (int & 'a) -> (int, 'a, nothing,)

module Base1(base: int, misc: string): Foo
//│ class Base1

Base1.test
//│ Typed: (int & 'a) -> (int, 'a, string,)


mixin WrapBase {
  // fun wrap(x) = x
  // fun wrap(x) = x : int
  fun wrapA(x: int) = x : int
  fun wrap(x) = x
}
//│ mixin WrapBase
//│   this: this223' 
//│   super: super224' 
//│   fun wrapA: ((x: Int,) -> Int) where 
//│   [pretty-printed] wrapA: (x: int,) -> int
//│   fun wrap: (α227'' -> α227'') where 
//│   [pretty-printed] wrap: 'a -> 'a

// :d
mixin Wrap {
  fun wrapA(x) = [super.wrapA(x)]
  fun wrap(x) = [super.wrap(x)]
}
//│ mixin Wrap
//│   this: this232' 
//│   super: super233' 
//│   |		super233' <: {wrap: wrap243_244'} & {wrapA: wrapA237_238'}
//│   |		wrapA237_238' <: ((α236_240',) -> α239_241')
//│   |		wrap243_244' <: ((α242_246',) -> α245_247')
//│   fun wrapA: (α236'' -> (α239'',)) where 
//│   |		α236'' <: α236_240'
//│   |		α239'' :> α239_241'
//│   [pretty-printed] wrapA: anything -> (nothing,)
//│   fun wrap: (α242'' -> (α245'',)) where 
//│   |		α242'' <: α242_246'
//│   |		α245'' :> α245_247'
//│   [pretty-printed] wrap: anything -> (nothing,)



// :d
module WrapBase1: WrapBase, Wrap
//│ class WrapBase1


WrapBase1
//│ Typed: WrapBase1

// :d
WrapBase1.wrapA
//│ Typed: int -> (int,)

WrapBase1.wrap
//│ Typed: 'a -> ('a,)

// :d
// WrapBase1.wrap


WrapBase1.wrap(1)
//│ Typed: (1,)

WrapBase1.wrap("ok")
//│ Typed: ("ok",)


WrapBase1.wrapA(1)
//│ Typed: (int,)

:e
WrapBase1.wrapA("ok")
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.177: 	WrapBase1.wrapA("ok")
//│ ║         	^^^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"ok"` is not an instance of type `int`
//│ ║  l.177: 	WrapBase1.wrapA("ok")
//│ ║         	                ^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.114: 	  fun wrapA(x: int) = x : int
//│ ║         	               ^^^
//│ ╟── from reference:
//│ ║  l.127: 	  fun wrapA(x) = [super.wrapA(x)]
//│ ╙──       	                              ^
//│ Typed: (int,) | error



module WrapBase2: WrapBase, Wrap, Wrap, Wrap
//│ class WrapBase2

let w = WrapBase2.wrap
//│ let w: wrap418 where 
//│ |		wrap418 :> (α242_431 -> (α245_439,))
//│ |		α242_431 <: α242_432
//│ |		α242_432 <: α242_433
//│ |		α242_433 <: α242_434
//│ |		α242_434 <: α242_435
//│ |		α242_435 <: α242_436
//│ |		α242_436 <: α227_437
//│ |		α227_437 <: α245_438
//│ |		α245_439 :> α245_440
//│ |		α245_440 :> (α245_441,)
//│ |		α245_441 :> α245_442
//│ |		α245_442 :> (α245_443,)
//│ |		α245_443 :> α245_438
//│ [pretty-printed] w: 'a -> ((('a,),),)

let wd = w(1)
//│ let wd: α461 where 
//│ |		α245_438 :> 1<int,number>
//│ |		α245_439 :> α245_440
//│ |		α245_440 :> (α245_441,)
//│ |		α245_441 :> α245_442
//│ |		α245_442 :> (α245_443,)
//│ |		α245_443 :> α245_438
//│ |		α461 :> (α245_439,)
//│ [pretty-printed] wd: (((1,),),)

wd._1._1._1 + 1
//│ Typed: int


