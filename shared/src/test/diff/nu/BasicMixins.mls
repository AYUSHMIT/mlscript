:NewParser
:NewDefs
:NoJS


// :d
mixin BaseTest {
  fun test = super.base
}
//│ mixin BaseTest
//│   this: this23' 
//│   super: super24' 
//│   |		super24' <: {base: base27_28'}
//│   fun test: ‹∀ 1. test26''#› where 
//│   |		test26''# := base27''
//│   |		base27'' :> base27_28' <: test26''#
//│   [pretty-printed] test: nothing

mixin BaseInc {
  fun test = super.base + 1
}
//│ mixin BaseInc
//│   this: this33' 
//│   super: super34' 
//│   |		super34' <: {base: base37_38'}
//│   |		base37_38' <: int<number>
//│   fun test: ‹∀ 1. test36''#› where 
//│   |		test36''# := α40''
//│   |		α40'' :> int<number> <: test36''#
//│   [pretty-printed] test: int

:d
class Base1(base: int): BaseTest
//│ 0. Typing TypingUnit(List(class Base1(base: int,): BaseTest {}))
//│ Completing class Base1(base: int,): BaseTest {}
//│ | Typing type int
//│ | | vars=Map() newDefsInfo=Map()
//│ | | 1. type int
//│ | | => Int
//│ | => Int ——— 
//│ | List()
//│ | base: int,
//│ | List(BaseTest)
//│ | Inheriting from BaseTest
//│ | | CONSTRAIN {base: Int} <! super24'
//│ | |   where 
//│ 		super24' <: {base: base27_28'}
//│ | | 1. C {base: Int} <! super24'    (0)
//│ | | | NEW super24' LB (0)
//│ | | | 1. C {base: Int} <! {base: base27_28'}    (2)
//│ | | | | 1. C {base: Int} <! {base: base27_28'}    (2)
//│ | | | | | 1. C {base: Int} <! {base: base27_28'}    (2)
//│ | | | | | | 1. C {base: Int} <! {base: base27_28'}    (2)
//│ | | | | | | | 1. C {base: Int} <! {base: base27_28'}    (2)
//│ | | | | | | | | 1. C Int <! base27_28'    (2)
//│ | | | | | | | | | NEW base27_28' LB (0)
//│ | | CONSTRAIN this45' <! this23'
//│ | |   where 
//│ | | 1. C this45' <! this23'    (0)
//│ | | | NEW this45' UB (1)
//│ | CONSTRAIN {base: Int, test: ‹∀ 1. test26''#›} <! this45'
//│ |   where 
//│ 		test26''# := base27''
//│ 		base27'' :> base27_28' <: test26''#
//│ 		base27_28' :> Int
//│ 		this45' <: this23'
//│ | 1. C {base: Int, test: ‹∀ 1. test26''#›} <! this45'    (0)
//│ | | NEW this45' LB (1)
//│ | | 1. C {base: Int, test: ‹∀ 1. test26''#›} <! this23'    (2)
//│ | | | NEW this23' LB (1)
//│ | 1. Typing TypingUnit(List())
//│ | UNSTASHING... (out)
//│ CONSTRAIN Base1<> <! this44'
//│   where 
//│ 0. C Base1<> <! this44'    (0)
//│ | NEW this44' LB (0)
//│ class Base1


class Base1(base): BaseTest
//│ class Base1

:e
class Base1(x): BaseTest
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.84: 	class Base1(x): BaseTest
//│ ║        	      ^^^^^^^^^^^^^^^^^^
//│ ╟── type `{x: ?x}` does not have field 'base'
//│ ║  l.84: 	class Base1(x): BaseTest
//│ ║        	           ^^^
//│ ╟── Note: constraint arises from field selection:
//│ ║  l.8: 	  fun test = super.base
//│ ║       	             ^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.8: 	  fun test = super.base
//│ ╙──     	             ^^^^^
//│ class Base1

Base1
//│ Typed: (x: anything,) -> Base1


// :ns
mixin Foo {
  fun test(x) = [super.base + x, x, super.misc]
}
//│ mixin Foo
//│   this: this60' 
//│   super: super61' 
//│   |		super61' <: {misc: misc69_70'} & {base: base65_66'}
//│   |		base65_66' <: int<number>
//│   fun test: ‹∀ 1. test63''#› where 
//│   |		test63''# := (α64'' -> (α68'', α64'', misc69'',))
//│   |		α64'' <: int<number>
//│   |		α68'' :> int<number>
//│   |		misc69'' :> misc69_70'
//│   [pretty-printed] test: (int & 'a) -> (int, 'a, nothing,)


mixin WrapBase {
  fun wrap(x) = x
}
mixin Wrap {
  fun wrap(x) = [super.wrap(x)]
}
//│ mixin WrapBase
//│   this: this80' 
//│   super: super81' 
//│   fun wrap: ‹∀ 1. wrap83''#› where 
//│   |		wrap83''# := (α84'' -> α84'')
//│   [pretty-printed] wrap: 'a -> 'a
//│ mixin Wrap
//│   this: this85' 
//│   super: super86' 
//│   |		super86' <: {wrap: wrap90_91'}
//│   |		wrap90_91' <: ((α89_93',) -> α92_94')
//│   fun wrap: ‹∀ 1. wrap88''#› where 
//│   |		wrap88''# := (α89'' -> (α92'',))
//│   |		α89'' <: α89_93'
//│   |		α92'' :> α92_94'
//│   [pretty-printed] wrap: anything -> (nothing,)



module WrapBase1: WrapBase, Wrap
//│ class WrapBase1


WrapBase1
//│ Typed: WrapBase1

WrapBase1.wrap
//│ Typed: 'a -> ('a,)

WrapBase1.wrap(1)
//│ Typed: (1,)

// FIXME
WrapBase1.wrap("ok")
//│ Typed: ("ok" | 1,)


module WrapBase2: WrapBase, Wrap, Wrap
//│ class WrapBase2

// FIXME
WrapBase2.wrap
//│ Typed: 'a -> ("ok" | 1 | 'a,)


