:NewParser
:NewDefs
:NoJS



// * I don't think it's a good idea to generate `this` refinements for classes,
// * as this could easily lead to typos and delayed error reporting.
// * Instead, we should require explicit `this` annotations by users when needed.


:e
class Foo { fun test = this.x }
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.13: 	class Foo { fun test = this.x }
//│ ║        	                       ^^^^^^
//│ ╟── reference of type `Foo` does not have field 'x'
//│ ║  l.13: 	class Foo { fun test = this.x }
//│ ╙──      	                       ^^^^
//│ class Foo() {
//│   fun test: error
//│ }


:e
class Foo(n: int) { fun test = this.x }
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.26: 	class Foo(n: int) { fun test = this.x }
//│ ║        	                               ^^^^^^
//│ ╟── reference of type `Foo & {n: int}` does not have field 'x'
//│ ║  l.26: 	class Foo(n: int) { fun test = this.x }
//│ ╙──      	                               ^^^^
//│ class Foo(n: int) {
//│   fun test: error
//│ }


:e
class Foo<A>(n: A) { fun test = this.x }
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.39: 	class Foo<A>(n: A) { fun test = this.x }
//│ ║        	                                ^^^^^^
//│ ╟── reference of type `Foo & {Foo#A = ?A, n: A}` does not have field 'x'
//│ ║  l.39: 	class Foo<A>(n: A) { fun test = this.x }
//│ ╙──      	                                ^^^^
//│ class Foo[A](n: A) {
//│   fun test: error
//│ }



// TODO support: (treat `this` annot not like a term ascription)
class Foo {
  this: { x: 'a }
  // fun test = this.x
}
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.54: 	  this: { x: 'a }
//│ ║        	  ^^^^
//│ ╟── reference of type `Foo` does not have field 'x'
//│ ╟── Note: constraint arises from record type:
//│ ║  l.54: 	  this: { x: 'a }
//│ ╙──      	        ^^^^^^^^^
//│ class Foo()


// TODO
// * All on one line:
class Test { this: { x: int}; fun test = this.x }
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.69: 	class Test { this: { x: int}; fun test = this.x }
//│ ║        	             ^^^^
//│ ╟── reference of type `Test` does not have field 'x'
//│ ╟── Note: constraint arises from record type:
//│ ║  l.69: 	class Test { this: { x: int}; fun test = this.x }
//│ ╙──      	                   ^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.69: 	class Test { this: { x: int}; fun test = this.x }
//│ ║        	                                         ^^^^^^
//│ ╟── reference of type `Test` does not have field 'x'
//│ ║  l.69: 	class Test { this: { x: int}; fun test = this.x }
//│ ╙──      	                                         ^^^^
//│ class Test() {
//│   fun test: error
//│ }


