:NewParser
:NewDefs
:NoJS


class Some<A>(value: A) {
  fun get = value
  fun toArray = [value]
  // fun mapBad(f) = Some(f(value)) // TODO
  // fun map(f : A => 'b) = Some(f(value)) // TODO
}
//│ class Some
//│   fun get: ‹∀ 1. get28''#› where 
//│   |		get28''# := ‘A23'
//│   [pretty-printed] get: A
//│   fun toArray: ‹∀ 1. toArray29''#› where 
//│   |		toArray29''# := (‘A23',)
//│   [pretty-printed] toArray: (A,)


let s = Some(1)
//│ fun s: ‹∀ 0. s33'#› where 
//│ |		s33'# := α39'
//│ |		α39' :> (Some<> & {Some#A: mut A23_40'..A23_40'}) <: s33'#
//│ |		A23_40' :> 1<int,number>
//│ [pretty-printed] s: Some & {Some#A = 'A}
//│ |  where
//│ |    'A :> 1


s.value
//│ Typed: 1

s.get
//│ Typed: 1

s.toArray
//│ Typed: (1,)


// TODO

// s.mapBad

// s.mapBad(succ)


// s.map

// s.map(succ)



module None {
  fun get = error
  fun toArray = []
  // fun mapBad(f) = None // TODO
}
//│ class None
//│   fun get: ‹∀ 1. get93''#› where 
//│   |		get93''# := ⊥
//│   [pretty-printed] get: nothing
//│   fun toArray: ‹∀ 1. toArray94''#› where 
//│   |		toArray94''# := ()
//│   [pretty-printed] toArray: ()


None.toArray
//│ Typed: ()


// TODO
type Option<A> = Some<A> | None
//│ /!!!\ Uncaught error: scala.NotImplementedError: an implementation is missing



let opt = if true then Some(123) else None
//│ fun opt: ‹∀ 0. opt104'#› where 
//│ |		opt104'# := (α111' | None<>)
//│ |		α111' :> (Some<> & {Some#A: mut A23_112'..A23_112'})
//│ |		A23_112' :> 123<int,number>
//│ [pretty-printed] opt: None | Some & {Some#A = 'A}
//│ |  where
//│ |    'A :> 123

opt.toArray
//│ Typed: Array[123]


// TODO

// opt.mapBad(succ)

// opt.map(succ)



if opt is Some then opt.value else 0
//│ Typed: 0 | 123

if opt is Some(v) then v else 0
//│ Typed: 0 | 123


fun map(x, f) = if x is
  None then None
  Some(v) then Some(f(v))
//│ fun map: ‹∀ 0. map165'#› where 
//│ |		map165'# := ((α166', α167',) -> (None<> | α178'))
//│ |		α166' <: ((None<> & α168') | ((Some<> & α169') & ~(None<>)))
//│ |		α167' <: ((‹∀ 1. value170''›,) -> α177')
//│ |		α169' <: {value: value170_171'}
//│ |		value170'' :> value170_171'
//│ |		α177' <: A23_179'
//│ |		α178' :> (Some<> & {Some#A: mut A23_179'..A23_179'})
//│ [pretty-printed] map: (None | Some & {value: 'value}, 'value -> 'A,) -> (None | Some & {Some#A = 'A})

let mo = map(opt, succ)
//│ fun mo: ‹∀ 0. mo195'#› where 
//│ |		α178' :> (Some<> & {Some#A: mut A23_179'..A23_179'})
//│ |		A23_179' :> int<number>
//│ |		mo195'# := α196'
//│ |		α196' :> (None<> | α178') <: mo195'#
//│ [pretty-printed] mo: None | Some & {Some#A = 'A}
//│ |  where
//│ |    'A :> int

mo.toArray
//│ Typed: Array[int]



class Test(n) {
  fun foo = n + 1
}
//│ class Test
//│   fun foo: ‹∀ 1. foo234''#› where 
//│   |		foo234''# := α236''
//│   |		α236'' :> int<number> <: foo234''#
//│   [pretty-printed] foo: int

Test(1)
//│ Typed: Test

:e
Test(true)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.147: 	Test(true)
//│ ║         	^^^^^^^^^^
//│ ╟── reference of type `true` is not an instance of type `int`
//│ ║  l.147: 	Test(true)
//│ ║         	     ^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.135: 	  fun foo = n + 1
//│ ║         	            ^
//│ ╟── from reference:
//│ ║  l.134: 	class Test(n) {
//│ ╙──       	           ^
//│ Typed: Test | error


:e
class Test<A>(n: A) {
  fun foo = n + 1
}
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.165: 	  fun foo = n + 1
//│ ║         	            ^^^
//│ ╟── reference of type `A` is not an instance of type `int`
//│ ║  l.165: 	  fun foo = n + 1
//│ ║         	            ^
//│ ╟── Note: type parameter A is defined at:
//│ ║  l.164: 	class Test<A>(n: A) {
//│ ╙──       	           ^
//│ class Test
//│   fun foo: ‹∀ 1. foo254''#› where 
//│   |		foo254''# := α256''
//│   |		α256'' :> error<> | int<number> <: foo254''#
//│   [pretty-printed] foo: error | int

Test(1)
//│ Typed: Test & {Test#A = 'A}
//│   where
//│     'A :> 1

Test(true)
//│ Typed: Test & {Test#A = 'A}
//│   where
//│     'A :> true


class Test<A>(n: A) {
  fun foo: A = n
}
//│ class Test
//│   fun foo: ‹∀ 1. foo280''#› where 
//│   |		foo280''# := ‘A276'
//│   [pretty-printed] foo: A

Test(1)
//│ Typed: Test & {Test#A = 'A}
//│   where
//│     'A :> 1

Test(1).foo
//│ Typed: 1

Test("ok").foo
//│ Typed: "ok"


:e
class Test<A> {
  // fun foo(x: A) = x // FIXME
  fun foo1(x : A) = x
  fun foo2(x : A) = x + 1
}
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.217: 	  fun foo2(x : A) = x + 1
//│ ║         	                    ^^^
//│ ╟── reference of type `A` is not an instance of type `int`
//│ ║  l.217: 	  fun foo2(x : A) = x + 1
//│ ║         	                    ^
//│ ╟── Note: type parameter A is defined at:
//│ ║  l.214: 	class Test<A> {
//│ ╙──       	           ^
//│ class Test
//│   fun foo1: ‹∀ 1. foo1323''#› where 
//│   |		foo1323''# := (‘A318' -> ‘A318')
//│   [pretty-printed] foo1: A -> A
//│   fun foo2: ‹∀ 1. foo2324''#› where 
//│   |		foo2324''# := (‘A318' -> α326'')
//│   |		α326'' :> error<> | int<number>
//│   [pretty-printed] foo2: A -> (error | int)

Test().foo1
//│ Typed: 'A -> 'A

Test().foo1(1)
//│ Typed: 1

x => Test().foo1(x)
//│ Typed: 'a -> 'a

let t = Test()
//│ fun t: ‹∀ 0. t393'#› where 
//│ |		t393'# := α400'
//│ |		α400' :> ‹∀ 0. (Test<> & {Test#A: mut A318_396'..A318_396'})› <: t393'#
//│ [pretty-printed] t: Test & {Test#A = 'A}

t.foo1
//│ Typed: 'A -> 'A

[t.foo1(0), t.foo1(true)]
//│ Typed: (0, true,)

t.foo1(0)
//│ Typed: 0

t
//│ Typed: Test & {Test#A = 'A}


// FIXME
fun foo(x : Test<int>) = x.foo1
//│ /!!!\ Uncaught error: java.util.NoSuchElementException: key not found: Test


Test().foo2
//│ Typed: anything -> (error | int)


