:NewParser
:NewDefs
:NoJS


class Some<A>(value: A) {
  fun get = value
  fun toArray = [value]
  // fun mapBad(f) = Some(f(value)) // TODO
  // fun map(f : A => 'b) = Some(f(value)) // TODO
}
//│ 
//│ class Some[A](value: A) {
//│ this: 'this
//│ fun get: A
//│ fun toArray: (A,)
//│ }
//│   where
//│     'this :> Some[?]


let s = Some(1)
//│ 
//│ let s: Some['A]
//│   where
//│     'A :> 1


s.value
//│ 
//│ 1
//│ Typed: 1

s.get
//│ 
//│ 1
//│ Typed: 1

s.toArray
//│ 
//│ (1,)
//│ Typed: (1,)


// TODO

// s.mapBad

// s.mapBad(succ)


// s.map

// s.map(succ)



module None {
  fun get = error
  fun toArray = []
  // fun mapBad(f) = None // TODO
}
//│ 
//│ namespace None() {
//│ this: 'this
//│ fun get: nothing
//│ fun toArray: ()
//│ }
//│   where
//│     'this :> None


None.toArray
//│ 
//│ ()
//│ Typed: ()


// TODO
type Option<A> = Some<A> | None
//│ /!!!\ Uncaught error: scala.NotImplementedError: an implementation is missing



let opt = if true then Some(123) else None
//│ 
//│ let opt: None | Some['A]
//│   where
//│     'A :> 123

opt.toArray
//│ 
//│ Array[123]
//│ Typed: Array[123]


// TODO

// opt.mapBad(succ)

// opt.map(succ)



if opt is Some then opt.value else 0
//│ 
//│ 0 | 123
//│ Typed: 0 | 123

if opt is Some(v) then v else 0
//│ 
//│ 0 | 123
//│ Typed: 0 | 123


fun map(x, f) = if x is
  None then None
  Some(v) then Some(f(v))
//│ 
//│ fun map: (None | Some['A], 'A -> 'A0,) -> (None | Some['A0])

let mo = map(opt, succ)
//│ 
//│ let mo: None | Some['A]
//│   where
//│     'A :> int

mo.toArray
//│ 
//│ Array[int]
//│ Typed: Array[int]



class Test(n) {
  fun foo = n + 1
}
//│ 
//│ class Test(n: nothing) {
//│ this: 'this
//│ fun foo: int
//│ }
//│   where
//│     'this :> Test

Test(1)
//│ 
//│ Test
//│ Typed: Test

:e
Test(true)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.152: 	Test(true)
//│ ║         	^^^^^^^^^^
//│ ╟── reference of type `true` is not an instance of type `int`
//│ ║  l.152: 	Test(true)
//│ ║         	     ^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.136: 	  fun foo = n + 1
//│ ║         	            ^
//│ ╟── from reference:
//│ ║  l.135: 	class Test(n) {
//│ ╙──       	           ^
//│ 
//│ Test | error
//│ Typed: Test | error


:e
class Test<A>(n: A) {
  fun foo = n + 1
}
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.172: 	  fun foo = n + 1
//│ ║         	            ^^^
//│ ╟── reference of type `A` is not an instance of type `int`
//│ ║  l.172: 	  fun foo = n + 1
//│ ║         	            ^
//│ ╟── Note: type parameter A is defined at:
//│ ║  l.171: 	class Test<A>(n: A) {
//│ ╙──       	           ^
//│ 
//│ class Test[A](n: A) {
//│ this: 'this
//│ fun foo: error | int
//│ }
//│   where
//│     'this :> Test[?]

Test(1)
//│ 
//│ Test['A]
//│   where
//│     'A :> 1
//│ Typed: Test['A]
//│   where
//│     'A :> 1

Test(true)
//│ 
//│ Test['A]
//│   where
//│     'A :> true
//│ Typed: Test['A]
//│   where
//│     'A :> true


class Test<A>(n: A) {
  fun foo: A = n
  fun foo1(x: A) = x
  fun id(x) = x
}
//│ 
//│ class Test[A](n: A) {
//│ this: 'this
//│ fun foo: A
//│ fun foo1: (x: A,) -> A
//│ fun id: 'a -> 'a
//│ }
//│   where
//│     'this :> Test[?]

Test(1)
//│ 
//│ Test['A]
//│   where
//│     'A :> 1
//│ Typed: Test['A]
//│   where
//│     'A :> 1

Test(1).foo
//│ 
//│ 1
//│ Typed: 1

Test("ok").foo
//│ 
//│ "ok"
//│ Typed: "ok"

let t = Test(1)
//│ 
//│ let t: Test['A]
//│   where
//│     'A :> 1

t.foo1(true)
//│ 
//│ 1 | true
//│ Typed: 1 | true

t : Test<'a>
//│ 
//│ Test['a]
//│   where
//│     'a :> 1 | true
//│ Typed: Test['a]
//│   where
//│     'a :> 1 | true

t.id
//│ 
//│ 'a -> 'a
//│ Typed: 'a -> 'a

[t.id(1), t.id(true)]
//│ 
//│ (1, true,)
//│ Typed: (1, true,)


:e
class Test<A> {
  fun foo1(x: A) = x
  fun foo2(x: A) = x + 1
}
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.278: 	  fun foo2(x: A) = x + 1
//│ ║         	                   ^^^
//│ ╟── reference of type `A` is not an instance of type `int`
//│ ║  l.278: 	  fun foo2(x: A) = x + 1
//│ ║         	                   ^
//│ ╟── Note: type parameter A is defined at:
//│ ║  l.276: 	class Test<A> {
//│ ╙──       	           ^
//│ 
//│ class Test[A]() {
//│ this: 'this
//│ fun foo1: (x: A,) -> A
//│ fun foo2: (x: A,) -> (error | int)
//│ }
//│   where
//│     'this :> Test[?]

Test().foo1
//│ 
//│ (x: 'A,) -> 'A
//│ Typed: (x: 'A,) -> 'A

Test().foo1(1)
//│ 
//│ 1
//│ Typed: 1

x => Test().foo1(x)
//│ 
//│ 'a -> 'a
//│ Typed: 'a -> 'a

// :d
let t = Test()
//│ 
//│ let t: forall 'A. Test['A]

t.foo1
//│ 
//│ (x: 'A,) -> 'A
//│ Typed: (x: 'A,) -> 'A

[t.foo1(0), t.foo1(true)]
//│ 
//│ (0, true,)
//│ Typed: (0, true,)

t.foo1(0)
//│ 
//│ 0
//│ Typed: 0

t
//│ 
//│ forall 'A. Test['A]
//│ Typed: Test['A]


fun foo(x: Test<int>) = x.foo1
//│ 
//│ fun foo: (x: Test[int],) -> (x: int,) -> int

foo(t)
//│ 
//│ (x: int,) -> int
//│ Typed: (x: int,) -> int

foo(t)(1)
//│ 
//│ int
//│ Typed: int


Test().foo2
//│ 
//│ (x: anything,) -> (error | int)
//│ Typed: (x: anything,) -> (error | int)


