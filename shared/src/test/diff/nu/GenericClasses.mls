:NewParser
:NewDefs
:NoJS


class Some<A>(value: A) {
  fun get = value
  fun toArray = [value]
  // fun mapBad(f) = Some(f(value)) // TODO
  // fun map(f : A => 'b) = Some(f(value)) // TODO
}
//│ class Some
//│   fun get: ‘A23' where 
//│   [pretty-printed] get: A
//│   fun toArray: (‘A23',) where 
//│   [pretty-printed] toArray: (A,)


let s = Some(1)
//│ let s: α32 where 
//│ |		α32 :> (Some<> & {Some#A: mut A23_33..A23_33})
//│ |		A23_33 :> 1<int,number>
//│ [pretty-printed] s: 'a
//│ |  where
//│ |    'a :> Some & {Some#A = 'A}
//│ |    'A :> 1


s.value
//│ Typed: 1

s.get
//│ Typed: 1

s.toArray
//│ Typed: (1,)


// TODO

// s.mapBad

// s.mapBad(succ)


// s.map

// s.map(succ)



module None {
  fun get = error
  fun toArray = []
  // fun mapBad(f) = None // TODO
}
//│ class None
//│   fun get: ⊥ where 
//│   [pretty-printed] get: nothing
//│   fun toArray: () where 
//│   [pretty-printed] toArray: ()


None.toArray
//│ Typed: ()


// TODO
type Option<A> = Some<A> | None
//│ /!!!\ Uncaught error: scala.NotImplementedError: an implementation is missing



let opt = if true then Some(123) else None
//│ let opt: (α68 | None<>) where 
//│ |		α68 :> (Some<> & {Some#A: mut A23_69..A23_69})
//│ |		A23_69 :> 123<int,number>
//│ [pretty-printed] opt: 'a | None
//│ |  where
//│ |    'a :> Some & {Some#A = 'A}
//│ |    'A :> 123

opt.toArray
//│ Typed: Array[123]


// TODO

// opt.mapBad(succ)

// opt.map(succ)



if opt is Some then opt.value else 0
//│ Typed: 0 | 123

if opt is Some(v) then v else 0
//│ Typed: 0 | 123


fun map(x, f) = if x is
  None then None
  Some(v) then Some(f(v))
//│ fun map: ((α98', α99',) -> (None<> | α108')) where 
//│ |		α98' <: ((None<> & α100') | ((Some<> & α101') & ~(None<>)))
//│ |		α99' <: ((‹∀ 1. value102''›,) -> α107')
//│ |		α101' <: {value: value102_103'}
//│ |		value102'' :> value102_103'
//│ |		α107' <: A23_109'
//│ |		α108' :> (Some<> & {Some#A: mut A23_109'..A23_109'})
//│ [pretty-printed] map: ('a, 'b,) -> (None | 'c)
//│ |  where
//│ |    'c :> Some & {Some#A = 'A}
//│ |    'b <: (forall 'value. 'value) -> 'd
//│ |    'd <: 'A
//│ |    'value :> 'value0
//│ |    'a <: None & 'e | Some & 'f & ~None
//│ |    'f <: {value: 'value0}

let mo = map(opt, succ)
//│ let mo: α111 where 
//│ |		α111 :> (None<> | α108_119)
//│ |		α108_119 :> (Some<> & {Some#A: mut A23_120..A23_121})
//│ |		A23_121 :> A23_120 | int<number>
//│ [pretty-printed] mo: 'a
//│ |  where
//│ |    'a :> None | 'b
//│ |    'b :> Some & {Some#A :> 'A <: 'A0}
//│ |    'A0 :> 'A | int

mo.toArray
//│ Typed: Array[int]



class Test(n) {
  fun foo = n + 1
}
//│ class Test
//│   fun foo: α138'' where 
//│   |		foo136'' :> int<number>
//│   |		α138'' :> int<number> <: foo136''
//│   [pretty-printed] foo: 'a
//│   |  where
//│   |    'a :> int
//│   |       <: 'foo
//│   |    'foo :> int

Test(1)
//│ Typed: Test

:e
Test(true)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.154: 	Test(true)
//│ ║         	^^^^^^^^^^
//│ ╟── reference of type `true` is not an instance of type `int`
//│ ║  l.154: 	Test(true)
//│ ║         	     ^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.138: 	  fun foo = n + 1
//│ ║         	            ^
//│ ╟── from reference:
//│ ║  l.137: 	class Test(n) {
//│ ╙──       	           ^
//│ Typed: Test | error


:e
class Test<A>(n: A) {
  fun foo = n + 1
}
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.172: 	  fun foo = n + 1
//│ ║         	            ^^^
//│ ╟── reference of type `A` is not an instance of type `int`
//│ ║  l.172: 	  fun foo = n + 1
//│ ║         	            ^
//│ ╟── Note: type parameter A is defined at:
//│ ║  l.171: 	class Test<A>(n: A) {
//│ ╙──       	           ^
//│ class Test
//│   fun foo: α159'' where 
//│   |		foo157'' :> int<number> | error<>
//│   |		α159'' :> error<> | int<number> <: foo157''
//│   [pretty-printed] foo: 'a
//│   |  where
//│   |    'a :> error | int
//│   |       <: 'foo
//│   |    'foo :> int | error

Test(1)
//│ Typed: Test & {Test#A = 'A}
//│   where
//│     'A :> 1

Test(true)
//│ Typed: Test & {Test#A = 'A}
//│   where
//│     'A :> true


class Test<A>(n: A) {
  fun foo: A = n
  fun foo1(x: A) = x
  fun id(x) = x
}
//│ class Test
//│   fun foo: ‘A181' where 
//│   [pretty-printed] foo: A
//│   fun foo1: ((x: ‘A181',) -> ‘A181') where 
//│   [pretty-printed] foo1: (x: A,) -> A
//│   fun id: (α187'' -> α187'') where 
//│   [pretty-printed] id: 'a -> 'a

Test(1)
//│ Typed: Test & {Test#A = 'A}
//│   where
//│     'A :> 1

Test(1).foo
//│ Typed: 1

Test("ok").foo
//│ Typed: "ok"

let t = Test(1)
//│ let t: α233 where 
//│ |		α233 :> (Test<> & {Test#A: mut A181_234..A181_234})
//│ |		A181_234 :> 1<int,number>
//│ [pretty-printed] t: 'a
//│ |  where
//│ |    'a :> Test & {Test#A = 'A}
//│ |    'A :> 1

t.foo1(true)
//│ Typed: 1 | true

t : Test<'a>
//│ Typed: Test['a]
//│   where
//│     'a :> 1 | true

t.id
//│ Typed: 'a -> 'a

[t.id(1), t.id(true)]
//│ Typed: (1, true,)


:e
class Test<A> {
  fun foo1(x: A) = x
  fun foo2(x: A) = x + 1
}
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.255: 	  fun foo2(x: A) = x + 1
//│ ║         	                   ^^^
//│ ╟── reference of type `A` is not an instance of type `int`
//│ ║  l.255: 	  fun foo2(x: A) = x + 1
//│ ║         	                   ^
//│ ╟── Note: type parameter A is defined at:
//│ ║  l.253: 	class Test<A> {
//│ ╙──       	           ^
//│ class Test
//│   fun foo1: ((x: ‘A281',) -> ‘A281') where 
//│   [pretty-printed] foo1: (x: A,) -> A
//│   fun foo2: ((x: ‘A281',) -> α287'') where 
//│   |		α287'' :> error<> | int<number>
//│   [pretty-printed] foo2: (x: A,) -> 'a
//│   |  where
//│   |    'a :> error | int

Test().foo1
//│ Typed: (x: 'A,) -> 'A

Test().foo1(1)
//│ Typed: 1

x => Test().foo1(x)
//│ Typed: 'a -> 'a

// :d
let t = Test()
//│ let t: α340 where 
//│ |		α340 :> ‹∀ 0. (Test<> & {Test#A: mut A281_337'..A281_337'})›
//│ [pretty-printed] t: 'a
//│ |  where
//│ |    'a :> forall 'A. Test & {Test#A = 'A}

t.foo1
//│ Typed: (x: 'A,) -> 'A

[t.foo1(0), t.foo1(true)]
//│ Typed: (0, true,)

t.foo1(0)
//│ Typed: 0

t
//│ Typed: Test & {Test#A = 'A}


fun foo(x: Test<int>) = x.foo1
//│ fun foo: ((x: Test[Int],) -> foo1381') where 
//│ |		foo1381' :> ((x: A382#,) -> A382#)
//│ |		A382# := int<number>..int<number>
//│ [pretty-printed] foo: (x: Test[int],) -> 'foo1
//│ |  where
//│ |    'foo1 :> (x: 'A,) -> 'A
//│ |    'A := int

foo(t)
//│ Typed: (x: int,) -> int

foo(t)(1)
//│ Typed: int


Test().foo2
//│ Typed: (x: anything,) -> (error | int)


