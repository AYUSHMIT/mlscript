:NewParser
:NewDefs
:NoJS // TODO


class C<A>
//│ class C[A]()

fun f(x) = if x is C then x
//│ fun f: C['A] -> C['A]

// * TODO parse class tags?
// f(C : #C)


// :d
class C<A>(a: A)
//│ class C[A](a: A)

fun f(x) = if x is C(a) then a
//│ fun f: C['a] -> 'a

let c = C(1)
//│ let c: C[1]

f(c)
//│ 1


class Some<A>(value: A) {
  fun get = value
  fun toArray = [value]
  fun map(f) = Some(f(value))
  fun map_A(f : A => 'b) = Some(f(value))
}
//│ class Some[A](value: A) {
//│   fun get: A
//│   fun map: (A -> 'A) -> Some['A]
//│   fun map_A: (A -> 'A0) -> Some['A0]
//│   fun toArray: (A,)
//│ }


let s = Some(1)
//│ let s: Some[1]


s.value
//│ 1

s.get
//│ 1

s.toArray
//│ (1,)


s.map
//│ (1 -> 'A) -> Some['A]

s.map(succ)
//│ Some[int]


s.map_A
//│ (1 -> 'A) -> Some['A]

s.map_A(succ)
//│ Some[int]



module None {
  fun get = error
  fun toArray = []
  fun map(f) = None
  fun map_A(f: nothing -> anything) = None
}
//│ module None() {
//│   fun get: nothing
//│   fun map: anything -> None
//│   fun map_A: (f: nothing -> anything,) -> None
//│   fun toArray: ()
//│ }


None.toArray
//│ ()


type Option<A> = Some<A> | None
//│ type Option[A] = None | Some[A]



let opt = if true then Some(123) else None
//│ let opt: None | Some[123]

opt.toArray
//│ Array[123]


opt.map(succ)
//│ None | Some[int]

opt.map_A(succ)
//│ None | Some[int]

opt.map(x => x > 0)
//│ None | Some[bool]



if opt is Some then opt.value else 0
//│ 0 | 123

if opt is Some(v) then v else 0
//│ 0 | 123


fun map(x, f) = if x is
  None then None
  Some(v) then Some(f(v))
//│ fun map: (None | Some['value], 'value -> 'A,) -> (None | Some['A])

let mo = map(opt, succ)
//│ let mo: None | Some[int]

mo.toArray
//│ Array[int]



// TODO
class Test(n) {
  fun foo = n + 1
  fun bar = n
}
//│ ╔══[ERROR] Class parameters currently need type annotations
//│ ║  l.135: 	class Test(n) {
//│ ╙──       	           ^
//│ class Test(n: error) {
//│   fun bar: error
//│   fun foo: int
//│ }

Test(1)
//│ Test

// :e
Test(true)
//│ Test


:e
class Test<A>(n: A) {
  fun foo = n + 1
}
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.157: 	  fun foo = n + 1
//│ ║         	            ^^^
//│ ╟── reference of type `A` is not an instance of type `int`
//│ ║  l.157: 	  fun foo = n + 1
//│ ║         	            ^
//│ ╟── Note: type parameter A is defined at:
//│ ║  l.156: 	class Test<A>(n: A) {
//│ ╙──       	           ^
//│ class Test[A](n: A) {
//│   fun foo: error | int
//│ }

Test(1)
//│ Test[1]

Test(true)
//│ Test[true]


class Test<A>(n: A) {
  fun foo: A = n
  fun foo1(x: A) = x
  fun id(x) = x
}
//│ class Test[A](n: A) {
//│   fun foo: A
//│   fun foo1: (x: A,) -> A
//│   fun id: 'a -> 'a
//│ }

Test(1)
//│ Test[1]

Test(1).foo
//│ 1

Test("ok").foo
//│ "ok"

let t = Test(1)
//│ let t: Test[1]

t.foo1(true)
//│ 1 | true

t : Test<'a>
//│ Test['a]
//│   where
//│     'a :> 1 | true

t.id
//│ 'a -> 'a

[t.id(1), t.id(true)]
//│ (1, true,)


:e
class TestBad<A> {
  fun foo1(x: A) = x
  fun foo2(x: A) = x + 1
}
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.220: 	  fun foo2(x: A) = x + 1
//│ ║         	                   ^^^
//│ ╟── reference of type `A` is not an instance of type `int`
//│ ║  l.220: 	  fun foo2(x: A) = x + 1
//│ ║         	                   ^
//│ ╟── Note: type parameter A is defined at:
//│ ║  l.218: 	class TestBad<A> {
//│ ╙──       	              ^
//│ class TestBad[A]() {
//│   fun foo1: (x: A,) -> A
//│   fun foo2: (x: A,) -> (error | int)
//│ }

TestBad().foo1
//│ (x: 'A,) -> 'A

TestBad().foo1(1)
//│ 1

x => TestBad().foo1(x)
//│ 'a -> 'a

// :d
let t = TestBad()
//│ let t: forall 'A. TestBad['A]

t.foo1
//│ (x: 'A,) -> 'A

[t.foo1(0), t.foo1(true)]
//│ (0, true,)

t.foo1(0)
//│ 0

t
//│ forall 'A. TestBad['A]


fun foo(x: TestBad<int>) = x.foo1
//│ fun foo: (x: TestBad[int],) -> (x: int,) -> int

foo(t)
//│ (x: int,) -> int

foo(t)(1)
//│ int


TestBad().foo2
//│ (x: anything,) -> (error | int)



class Weird(x: C<'a>)
//│ class Weird(x: C['a])

let w = Weird(c)
//│ let w: Weird

w.x
//│ C['a]

// FIXME
not(w.x.a)
//│ bool


