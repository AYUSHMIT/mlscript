:NewParser
:NewDefs
:NoJS


class Some<A>(value: A) {
  fun get = value
  fun toArray = [value]
  // fun mapBad(f) = Some(f(value)) // TODO
  // fun map(f : A => 'b) = Some(f(value)) // TODO
}
//│ class Some
//│   fun get: ‘A23' where 
//│   [pretty-printed] get: A
//│   fun toArray: (‘A23',) where 
//│   [pretty-printed] toArray: (A,)


let s = Some(1)
//│ let s: α32 where 
//│ |		α32 :> (Some<> & {Some#A: mut A23_33..A23_33})
//│ |		A23_33 :> 1<int,number>
//│ [pretty-printed] s: Some & {Some#A = 'A}
//│ |  where
//│ |    'A :> 1


s.value
//│ Typed: 1

s.get
//│ Typed: 1

s.toArray
//│ Typed: (1,)


// TODO

// s.mapBad

// s.mapBad(succ)


// s.map

// s.map(succ)



module None {
  fun get = error
  fun toArray = []
  // fun mapBad(f) = None // TODO
}
//│ class None
//│   fun get: ⊥ where 
//│   [pretty-printed] get: nothing
//│   fun toArray: () where 
//│   [pretty-printed] toArray: ()


None.toArray
//│ Typed: ()


// TODO
type Option<A> = Some<A> | None
//│ /!!!\ Uncaught error: scala.NotImplementedError: an implementation is missing



let opt = if true then Some(123) else None
//│ let opt: (α72 | None<>) where 
//│ |		α72 :> (Some<> & {Some#A: mut A23_73..A23_73})
//│ |		A23_73 :> 123<int,number>
//│ [pretty-printed] opt: None | Some & {Some#A = 'A}
//│ |  where
//│ |    'A :> 123

opt.toArray
//│ Typed: Array[123]


// TODO

// opt.mapBad(succ)

// opt.map(succ)



if opt is Some then opt.value else 0
//│ Typed: 0 | 123

if opt is Some(v) then v else 0
//│ Typed: 0 | 123


fun map(x, f) = if x is
  None then None
  Some(v) then Some(f(v))
//│ fun map: ((α106', α107',) -> (None<> | α116')) where 
//│ |		α106' <: ((None<> & α108') | ((Some<> & α109') & ~(None<>)))
//│ |		α107' <: ((‹∀ 1. value110''›,) -> α115')
//│ |		α109' <: {value: value110_111'}
//│ |		value110'' :> value110_111'
//│ |		α115' <: A23_117'
//│ |		α116' :> (Some<> & {Some#A: mut A23_117'..A23_117'})
//│ [pretty-printed] map: (None | Some & {value: 'value}, 'value -> 'A,) -> (None | Some & {Some#A = 'A})

let mo = map(opt, succ)
//│ let mo: α132 where 
//│ |		α132 :> (None<> | α116_140)
//│ |		α116_140 :> (Some<> & {Some#A: mut A23_141..A23_142})
//│ |		A23_142 :> A23_141 | int<number>
//│ [pretty-printed] mo: None | Some & {Some#A :> 'A <: 'A | int}

mo.toArray
//│ Typed: Array[int]



class Test(n) {
  fun foo = n + 1
}
//│ class Test
//│   fun foo: α165'' where 
//│   |		foo163'' :> int<number>
//│   |		α165'' :> int<number> <: foo163''
//│   [pretty-printed] foo: int

Test(1)
//│ Typed: Test

:e
Test(true)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.137: 	Test(true)
//│ ║         	^^^^^^^^^^
//│ ╟── reference of type `true` is not an instance of type `int`
//│ ║  l.137: 	Test(true)
//│ ║         	     ^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.125: 	  fun foo = n + 1
//│ ║         	            ^
//│ ╟── from reference:
//│ ║  l.124: 	class Test(n) {
//│ ╙──       	           ^
//│ Typed: Test | error


:e
class Test<A>(n: A) {
  fun foo = n + 1
}
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.155: 	  fun foo = n + 1
//│ ║         	            ^^^
//│ ╟── reference of type `A` is not an instance of type `int`
//│ ║  l.155: 	  fun foo = n + 1
//│ ║         	            ^
//│ ╟── Note: type parameter A is defined at:
//│ ║  l.154: 	class Test<A>(n: A) {
//│ ╙──       	           ^
//│ class Test
//│   fun foo: α187'' where 
//│   |		foo185'' :> int<number> | error<>
//│   |		α187'' :> error<> | int<number> <: foo185''
//│   [pretty-printed] foo: error | int

Test(1)
//│ Typed: Test & {Test#A = 'A}
//│   where
//│     'A :> 1

Test(true)
//│ Typed: Test & {Test#A = 'A}
//│   where
//│     'A :> true


class Test<A>(n: A) {
  fun foo: A = n
  fun foo1(x : A) = x
  fun id(x) = x
}
//│ class Test
//│   fun foo: ‘A210' where 
//│   [pretty-printed] foo: A
//│   fun foo1: (‘A210' -> ‘A210') where 
//│   [pretty-printed] foo1: A -> A
//│   fun id: (α216'' -> α216'') where 
//│   [pretty-printed] id: 'a -> 'a

Test(1)
//│ Typed: Test & {Test#A = 'A}
//│   where
//│     'A :> 1

Test(1).foo
//│ Typed: 1

Test("ok").foo
//│ Typed: "ok"

let t = Test(1)
//│ let t: α265 where 
//│ |		α265 :> (Test<> & {Test#A: mut A210_266..A210_266})
//│ |		A210_266 :> 1<int,number>
//│ [pretty-printed] t: Test & {Test#A = 'A}
//│ |  where
//│ |    'A :> 1

t.foo1(true)
//│ Typed: 1 | true

t : Test<'a>
//│ Typed: Test['a]
//│   where
//│     'a :> 1 | true

t.id
//│ Typed: 'a -> 'a

[t.id(1), t.id(true)]
//│ Typed: (1, true,)


:e
class Test<A> {
  // fun foo(x: A) = x // FIXME
  fun foo1(x : A) = x
  fun foo2(x : A) = x + 1
}
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.234: 	  fun foo2(x : A) = x + 1
//│ ║         	                    ^^^
//│ ╟── reference of type `A` is not an instance of type `int`
//│ ║  l.234: 	  fun foo2(x : A) = x + 1
//│ ║         	                    ^
//│ ╟── Note: type parameter A is defined at:
//│ ║  l.231: 	class Test<A> {
//│ ╙──       	           ^
//│ class Test
//│   fun foo1: (‘A317' -> ‘A317') where 
//│   [pretty-printed] foo1: A -> A
//│   fun foo2: (‘A317' -> α323'') where 
//│   |		α323'' :> error<> | int<number>
//│   [pretty-printed] foo2: A -> (error | int)

Test().foo1
//│ Typed: 'A -> 'A

Test().foo1(1)
//│ Typed: 1

x => Test().foo1(x)
//│ Typed: 'a -> 'a

// :d
let t = Test()
//│ let t: α377 where 
//│ |		α377 :> ‹∀ 0. (Test<> & {Test#A: mut A317_374'..A317_374'})›
//│ [pretty-printed] t: Test & {Test#A = 'A}

t.foo1
//│ Typed: 'A -> 'A

[t.foo1(0), t.foo1(true)]
//│ Typed: (0, true,)

t.foo1(0)
//│ Typed: 0

t
//│ Typed: Test & {Test#A = 'A}


// FIXME
fun foo(x : Test<int>) = x.foo1
//│ /!!!\ Uncaught error: java.util.NoSuchElementException: key not found: Test


Test().foo2
//│ Typed: anything -> (error | int)


