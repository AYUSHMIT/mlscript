:NewParser
:NewDefs
:NoJS


class Some<A>(value: A) {
  fun get = value
  fun toArray = [value]
  // fun mapBad(f) = Some(f(value)) // TODO
  // fun map(f : A => 'b) = Some(f(value)) // TODO
}
//│ class Some
//│   fun get: ‹∀ 1. get28''#› where 
//│   |		get28''# := ‘A23'
//│   [pretty-printed] get: A
//│   fun toArray: ‹∀ 1. toArray29''#› where 
//│   |		toArray29''# := (‘A23',)
//│   [pretty-printed] toArray: (A,)


let s = Some(1)
//│ let s: α38 where 
//│ |		α38 :> (Some<> & {Some#A: mut A23_39..A23_39})
//│ |		A23_39 :> 1<int,number>
//│ [pretty-printed] s: Some & {Some#A = 'A}
//│ |  where
//│ |    'A :> 1


s.value
//│ Typed: 1

s.get
//│ Typed: 1

s.toArray
//│ Typed: (1,)


// TODO

// s.mapBad

// s.mapBad(succ)


// s.map

// s.map(succ)



module None {
  fun get = error
  fun toArray = []
  // fun mapBad(f) = None // TODO
}
//│ class None
//│   fun get: ‹∀ 1. get78''#› where 
//│   |		get78''# := ⊥
//│   [pretty-printed] get: nothing
//│   fun toArray: ‹∀ 1. toArray79''#› where 
//│   |		toArray79''# := ()
//│   [pretty-printed] toArray: ()


None.toArray
//│ Typed: ()


// TODO
type Option<A> = Some<A> | None
//│ /!!!\ Uncaught error: scala.NotImplementedError: an implementation is missing



let opt = if true then Some(123) else None
//│ let opt: (α95 | None<>) where 
//│ |		α95 :> (Some<> & {Some#A: mut A23_96..A23_96})
//│ |		A23_96 :> 123<int,number>
//│ [pretty-printed] opt: None | Some & {Some#A = 'A}
//│ |  where
//│ |    'A :> 123

opt.toArray
//│ Typed: Array[123]


// TODO

// opt.mapBad(succ)

// opt.map(succ)



if opt is Some then opt.value else 0
//│ Typed: 0 | 123

if opt is Some(v) then v else 0
//│ Typed: 0 | 123


fun map(x, f) = if x is
  None then None
  Some(v) then Some(f(v))
//│ fun map: ‹∀ 0. map137'#› where 
//│ |		map137'# := ((α138', α139',) -> (None<> | α150'))
//│ |		α138' <: ((None<> & α140') | ((Some<> & α141') & ~(None<>)))
//│ |		α139' <: ((‹∀ 1. value142''›,) -> α149')
//│ |		α141' <: {value: value142_143'}
//│ |		value142'' :> value142_143'
//│ |		α149' <: A23_151'
//│ |		α150' :> (Some<> & {Some#A: mut A23_151'..A23_151'})
//│ [pretty-printed] map: (None | Some & {value: 'value}, 'value -> 'A,) -> (None | Some & {Some#A = 'A})

let mo = map(opt, succ)
//│ let mo: α167 where 
//│ |		α167 :> (None<> | α150_177)
//│ |		α150_177 :> (Some<> & {Some#A: mut A23_178..A23_179})
//│ |		A23_179 :> A23_178 | int<number>
//│ [pretty-printed] mo: None | Some & {Some#A :> 'A <: 'A | int}

mo.toArray
//│ Typed: Array[int]



class Test(n) {
  fun foo = n + 1
}
//│ class Test
//│   fun foo: ‹∀ 1. foo205''#› where 
//│   |		foo205''# := α207''
//│   |		α207'' :> int<number> <: foo205''#
//│   [pretty-printed] foo: int

Test(1)
//│ Typed: Test

:e
Test(true)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.142: 	Test(true)
//│ ║         	^^^^^^^^^^
//│ ╟── reference of type `true` is not an instance of type `int`
//│ ║  l.142: 	Test(true)
//│ ║         	     ^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.130: 	  fun foo = n + 1
//│ ║         	            ^
//│ ╟── from reference:
//│ ║  l.129: 	class Test(n) {
//│ ╙──       	           ^
//│ Typed: Test | error


:e
class Test<A>(n: A) {
  fun foo = n + 1
}
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.160: 	  fun foo = n + 1
//│ ║         	            ^^^
//│ ╟── reference of type `A` is not an instance of type `int`
//│ ║  l.160: 	  fun foo = n + 1
//│ ║         	            ^
//│ ╟── Note: type parameter A is defined at:
//│ ║  l.159: 	class Test<A>(n: A) {
//│ ╙──       	           ^
//│ class Test
//│   fun foo: ‹∀ 1. foo225''#› where 
//│   |		foo225''# := α227''
//│   |		α227'' :> error<> | int<number> <: foo225''#
//│   [pretty-printed] foo: error | int

Test(1)
//│ Typed: Test & {Test#A = 'A}
//│   where
//│     'A :> 1

Test(true)
//│ Typed: Test & {Test#A = 'A}
//│   where
//│     'A :> true


class Test<A>(n: A) {
  fun foo: A = n
  fun foo1(x : A) = x
}
//│ class Test
//│   fun foo: ‹∀ 1. foo252''#› where 
//│   |		foo252''# := ‘A247'
//│   [pretty-printed] foo: A
//│   fun foo1: ‹∀ 1. foo1253''#› where 
//│   |		foo1253''# := (‘A247' -> ‘A247')
//│   [pretty-printed] foo1: A -> A

Test(1)
//│ Typed: Test & {Test#A = 'A}
//│   where
//│     'A :> 1

Test(1).foo
//│ Typed: 1

Test("ok").foo
//│ Typed: "ok"

let t = Test(1)
//│ let t: α307 where 
//│ |		α307 :> (Test<> & {Test#A: mut A247_308..A247_308})
//│ |		A247_308 :> 1<int,number>
//│ [pretty-printed] t: Test & {Test#A = 'A}
//│ |  where
//│ |    'A :> 1

t.foo1(true)
//│ Typed: 1 | true

t : Test<'a>
//│ Typed: Test['a]
//│   where
//│     'a :> 1 | true


:e
class Test<A> {
  // fun foo(x: A) = x // FIXME
  fun foo1(x : A) = x
  fun foo2(x : A) = x + 1
}
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.232: 	  fun foo2(x : A) = x + 1
//│ ║         	                    ^^^
//│ ╟── reference of type `A` is not an instance of type `int`
//│ ║  l.232: 	  fun foo2(x : A) = x + 1
//│ ║         	                    ^
//│ ╟── Note: type parameter A is defined at:
//│ ║  l.229: 	class Test<A> {
//│ ╙──       	           ^
//│ class Test
//│   fun foo1: ‹∀ 1. foo1339''#› where 
//│   |		foo1339''# := (‘A334' -> ‘A334')
//│   [pretty-printed] foo1: A -> A
//│   fun foo2: ‹∀ 1. foo2340''#› where 
//│   |		foo2340''# := (‘A334' -> α342'')
//│   |		α342'' :> error<> | int<number>
//│   [pretty-printed] foo2: A -> (error | int)

Test().foo1
//│ Typed: 'A -> 'A

Test().foo1(1)
//│ Typed: 1

x => Test().foo1(x)
//│ Typed: 'a -> 'a

// :d
let t = Test()
//│ let t: α415 where 
//│ |		α415 :> ‹∀ 0. (Test<> & {Test#A: mut A334_411'..A334_411'})›
//│ [pretty-printed] t: Test & {Test#A = 'A}

t.foo1
//│ Typed: 'A -> 'A

[t.foo1(0), t.foo1(true)]
//│ Typed: (0, true,)

t.foo1(0)
//│ Typed: 0

t
//│ Typed: Test & {Test#A = 'A}


// FIXME
fun foo(x : Test<int>) = x.foo1
//│ /!!!\ Uncaught error: java.util.NoSuchElementException: key not found: Test


Test().foo2
//│ Typed: anything -> (error | int)


