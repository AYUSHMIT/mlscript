:NewParser
:NewDefs
:NoJS


class Some<A>(value: A) {
  fun get = value
  fun toArray = [value]
  // fun mapBad(f) = Some(f(value)) // TODO
  // fun map(f : A => 'b) = Some(f(value)) // TODO
}
//│ 
//│ class Some[A](value: A) {
//│ this: 'this
//│ fun get: A
//│ fun toArray: (A,)
//│ }


let s = Some(1)
//│ 
//│ let s: 'a


s.value
//│ 
//│ 'value
//│ Typed: 1

s.get
//│ 
//│ 'get
//│ Typed: 1

s.toArray
//│ 
//│ 'toArray
//│ Typed: (1,)


// TODO

// s.mapBad

// s.mapBad(succ)


// s.map

// s.map(succ)



module None {
  fun get = error
  fun toArray = []
  // fun mapBad(f) = None // TODO
}
//│ 
//│ namespace None() {
//│ this: 'this
//│ fun get: nothing
//│ fun toArray: ()
//│ }


None.toArray
//│ 
//│ 'toArray
//│ Typed: ()


// TODO
type Option<A> = Some<A> | None
//│ /!!!\ Uncaught error: scala.NotImplementedError: an implementation is missing



let opt = if true then Some(123) else None
//│ 
//│ let opt: 'a | None

opt.toArray
//│ 
//│ 'toArray
//│ Typed: Array[123]


// TODO

// opt.mapBad(succ)

// opt.map(succ)



if opt is Some then opt.value else 0
//│ 
//│ 'value | 0
//│ Typed: 0 | 123

if opt is Some(v) then v else 0
//│ 
//│ (forall 'value. 'value) | 0
//│ Typed: 0 | 123


fun map(x, f) = if x is
  None then None
  Some(v) then Some(f(v))
//│ 
//│ fun map: ('a, 'b,) -> (None | 'c)

let mo = map(opt, succ)
//│ 
//│ let mo: 'a

mo.toArray
//│ 
//│ 'toArray
//│ Typed: Array[int]



class Test(n) {
  fun foo = n + 1
}
//│ 
//│ class Test(n: 'n) {
//│ this: 'this
//│ fun foo: 'a
//│ }

Test(1)
//│ 
//│ 'a
//│ Typed: Test

:e
Test(true)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.140: 	Test(true)
//│ ║         	^^^^^^^^^^
//│ ╟── reference of type `true` is not an instance of type `int`
//│ ║  l.140: 	Test(true)
//│ ║         	     ^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.126: 	  fun foo = n + 1
//│ ║         	            ^
//│ ╟── from reference:
//│ ║  l.125: 	class Test(n) {
//│ ╙──       	           ^
//│ 
//│ 'a
//│ Typed: Test | error


:e
class Test<A>(n: A) {
  fun foo = n + 1
}
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.160: 	  fun foo = n + 1
//│ ║         	            ^^^
//│ ╟── reference of type `A` is not an instance of type `int`
//│ ║  l.160: 	  fun foo = n + 1
//│ ║         	            ^
//│ ╟── Note: type parameter A is defined at:
//│ ║  l.159: 	class Test<A>(n: A) {
//│ ╙──       	           ^
//│ 
//│ class Test[A](n: A) {
//│ this: 'this
//│ fun foo: 'a
//│ }

Test(1)
//│ 
//│ 'a
//│ Typed: Test & {Test#A = 'A}
//│   where
//│     'A :> 1

Test(true)
//│ 
//│ 'a
//│ Typed: Test & {Test#A = 'A}
//│   where
//│     'A :> true


class Test<A>(n: A) {
  fun foo: A = n
  fun foo1(x: A) = x
  fun id(x) = x
}
//│ 
//│ class Test[A](n: A) {
//│ this: 'this
//│ fun foo: A
//│ fun foo1: (x: A,) -> A
//│ fun id: 'a -> 'a
//│ }

Test(1)
//│ 
//│ 'a
//│ Typed: Test & {Test#A = 'A}
//│   where
//│     'A :> 1

Test(1).foo
//│ 
//│ 'foo
//│ Typed: 1

Test("ok").foo
//│ 
//│ 'foo
//│ Typed: "ok"

let t = Test(1)
//│ 
//│ let t: 'a

t.foo1(true)
//│ 
//│ 'a
//│ Typed: 1 | true

t : Test<'a>
//│ 
//│ Test['a]
//│ Typed: Test['a]
//│   where
//│     'a :> 1 | true

t.id
//│ 
//│ 'id
//│ Typed: 'a -> 'a

[t.id(1), t.id(true)]
//│ 
//│ ('a, 'b,)
//│ Typed: (1, true,)


:e
class Test<A> {
  fun foo1(x: A) = x
  fun foo2(x: A) = x + 1
}
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.252: 	  fun foo2(x: A) = x + 1
//│ ║         	                   ^^^
//│ ╟── reference of type `A` is not an instance of type `int`
//│ ║  l.252: 	  fun foo2(x: A) = x + 1
//│ ║         	                   ^
//│ ╟── Note: type parameter A is defined at:
//│ ║  l.250: 	class Test<A> {
//│ ╙──       	           ^
//│ 
//│ class Test[A]() {
//│ this: 'this
//│ fun foo1: (x: A,) -> A
//│ fun foo2: (x: A,) -> 'a
//│ }

Test().foo1
//│ 
//│ 'foo1
//│ Typed: (x: 'A,) -> 'A

Test().foo1(1)
//│ 
//│ 'a
//│ Typed: 1

x => Test().foo1(x)
//│ 
//│ 'a -> 'b
//│ Typed: 'a -> 'a

// :d
let t = Test()
//│ 
//│ let t: 'a

t.foo1
//│ 
//│ 'foo1
//│ Typed: (x: 'A,) -> 'A

[t.foo1(0), t.foo1(true)]
//│ 
//│ ('a, 'b,)
//│ Typed: (0, true,)

t.foo1(0)
//│ 
//│ 'a
//│ Typed: 0

t
//│ 
//│ 'a
//│ Typed: Test & {Test#A = 'A}


fun foo(x: Test<int>) = x.foo1
//│ 
//│ fun foo: (x: Test[int],) -> 'foo1

foo(t)
//│ 
//│ 'a
//│ Typed: (x: int,) -> int

foo(t)(1)
//│ 
//│ 'a
//│ Typed: int


Test().foo2
//│ 
//│ 'foo2
//│ Typed: (x: anything,) -> (error | int)


