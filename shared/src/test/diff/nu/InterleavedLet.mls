:NewParser

fun f(x) =
  if x ==
    let v = 0
    v then v
    else 0
//│ f: number -> 0
//│  = [Function: f]

class Option
class Some(value): Option
class None: Option
class Either
class Left(leftValue): Either
class Right(rightValue): Either
//│ Defined class Option
//│ Defined class Some
//│ Defined class None
//│ Defined class Either
//│ Defined class Left
//│ Defined class Right
//│ Option: () -> Option
//│       = [Function: Option1]
//│ Some: 'value -> (Some with {value: 'value})
//│     = [Function: Some1]
//│ None: () -> None
//│     = [Function: None1]
//│ Either: () -> Either
//│       = [Function: Either1]
//│ Left: 'leftValue -> (Left with {leftValue: 'leftValue})
//│     = [Function: Left1]
//│ Right: 'rightValue -> (Right with {rightValue: 'rightValue})
//│      = [Function: Right1]

fun q(x) =
  if
    x is Some and x is Some and x is Some then 0
//│ q: Some -> 0
//│  = [Function: q]

// FIXME
:w
fun p(x, y) =
  if
    x is Some and y is None then 0
    y is Some and x is Some then 1
    x is Some and y is Some then 0
//│ ╔══[WARNING] duplicated branch
//│ ╙──
//│ p: (Some, None | Some,) -> (0 | 1)
//│  = [Function: p]

fun h(x, y) =
  if x is
    None then y
    let y_square = y * y
    Some(z) then z + y_square
//│ h: (None | Some & {value: int}, int,) -> int
//│  = [Function: h]

h(Some(5), 6)
//│ res: int
//│    = undefined

fun h(x, y) =
  if x is
    None then y
    let y_square = y * y
    Some(y_square) then 0
//│ h: (None | Some, int & 'a,) -> (0 | 'a)
//│  = [Function: h1]

fun f(a, y) =
  if a is
    Some(v) and v is
      Left(x) then x
      let y = v + 1
      Right(x) then x + y
    else 0
//│ f: (Some & {value: int} | ~Some, anything,) -> int
//│  = [Function: f1]

:pe
fun q(a) =
  if a is
    Left(x) then x
    let y = a + 1
    then y
//│ ╔══[PARSE ERROR] Expected an expression; found a 'then'/'else' clause instead
//│ ║  l.88: 	    let y = a + 1
//│ ║        	            ^^^^^
//│ ║  l.89: 	    then y
//│ ╙──      	^^^^^^^^^^
//│ q: (Left with {leftValue: 'leftValue}) -> 'leftValue
//│  = [Function: q1]

class A()
class B()
//│ Defined class A
//│ Defined class B
//│ A: () -> A
//│  = [Function: A1]
//│ B: () -> B
//│  = [Function: B1]

fun w() =
  if
    A then "A"
    let y = 0
    B then "B"
    else "?"
//│ w: () -> ("?" | "A" | "B")
//│  = [Function: w]

w()
//│ res: "?" | "A" | "B"
//│    = undefined

fun i(x) =
  if x is
    A() then "A"
    let y = 0
    B() then "B"
//│ i: (A | B) -> ("A" | "B")
//│  = [Function: i]

fun inc(x) = x + 1
//│ inc: int -> int
//│    = [Function: inc]

fun qq(x, z) =
  if x ==
    let y = inc(z)
    y * y then 0
    else 0
//│ qq: (number, int,) -> 0
//│   = [Function: qq]

fun bruh(x) =
  if
    x == 0 then 0
    let y = 1
    else y
//│ bruh: number -> (0 | 1)
//│     = [Function: bruh]

fun f1(x) = x + 1
fun f2(x, y) = x + y
//│ f1: int -> int
//│   = [Function: f11]
//│ f2: (int, int,) -> int
//│   = [Function: f2]

fun ff(x) =
  if
    x == 0 then 0
    let y = f1(x)
    let z = f2(x, y)
    z == 1 then 1
    z == 2 then 2
    else 0
//│ ff: int -> (0 | 1 | 2)
//│   = [Function: ff]

fun ip(y) =
  if q(y) and
    let z = inc(y)
    y == z * z then "bruh"
  else "rocks"
//│ ip: nothing -> ("bruh" | "rocks")
//│   = [Function: ip]

fun tr(x) =
  if x is
    Some(v) then v
    let tmp = 1
    None then tmp
//│ tr: (None | (Some with {value: 'value})) -> (1 | 'value)
//│   = [Function: tr]

class Pair(fst, snd)
class List
class Nil: List
class Cons(head, tail): List
//│ Defined class Pair
//│ Defined class List
//│ Defined class Nil
//│ Defined class Cons
//│ Pair: ('fst, 'snd,) -> (Pair with {fst: 'fst, snd: 'snd})
//│     = [Function: Pair1]
//│ List: () -> List
//│     = [Function: List1]
//│ Nil: () -> Nil
//│    = [Function: Nil1]
//│ Cons: ('head, 'tail,) -> (Cons with {head: 'head, tail: 'tail})
//│     = [Function: Cons1]

// FIXME: Take a look...
fun mapPartition(f, xs) =
  if xs is
    Nil then Nil
    Cons(x, xs) and f(x) is
      let res = mapPartition(f, xs)
      let l = res.fst
      let r = res.snd
      Left(v)  then Pair(Cons(v, l), r)
      Right(v) then Pair(l, Cons(v, r))
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.200: 	fun mapPartition(f, xs) =
//│ ║         	                ^^^^^^^^^
//│ ║  l.201: 	  if xs is
//│ ║         	^^^^^^^^^^
//│ ║  l.202: 	    Nil then Nil
//│ ║         	^^^^^^^^^^^^^^^^^
//│ ║  l.203: 	    Cons(x, xs) and f(x) is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.204: 	      let res = mapPartition(f, xs)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.205: 	      let l = res.fst
//│ ║         	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.206: 	      let r = res.snd
//│ ║         	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.207: 	      Left(v)  then Pair(Cons(v, l), r)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.208: 	      Right(v) then Pair(l, Cons(v, r))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `() -> ?a` does not have field 'snd'
//│ ║  l.184: 	class Nil: List
//│ ║         	      ^^^
//│ ╟── but it flows into reference with expected type `{snd: ?snd}`
//│ ║  l.202: 	    Nil then Nil
//│ ║         	             ^^^
//│ ╟── Note: constraint arises from field selection:
//│ ║  l.206: 	      let r = res.snd
//│ ║         	              ^^^^^^^
//│ ╟── from application:
//│ ║  l.204: 	      let res = mapPartition(f, xs)
//│ ╙──       	                ^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.200: 	fun mapPartition(f, xs) =
//│ ║         	                ^^^^^^^^^
//│ ║  l.201: 	  if xs is
//│ ║         	^^^^^^^^^^
//│ ║  l.202: 	    Nil then Nil
//│ ║         	^^^^^^^^^^^^^^^^^
//│ ║  l.203: 	    Cons(x, xs) and f(x) is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.204: 	      let res = mapPartition(f, xs)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.205: 	      let l = res.fst
//│ ║         	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.206: 	      let r = res.snd
//│ ║         	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.207: 	      Left(v)  then Pair(Cons(v, l), r)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.208: 	      Right(v) then Pair(l, Cons(v, r))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `() -> ?a` does not have field 'fst'
//│ ║  l.184: 	class Nil: List
//│ ║         	      ^^^
//│ ╟── but it flows into reference with expected type `{fst: ?fst}`
//│ ║  l.202: 	    Nil then Nil
//│ ║         	             ^^^
//│ ╟── Note: constraint arises from field selection:
//│ ║  l.205: 	      let l = res.fst
//│ ║         	              ^^^^^^^
//│ ╟── from application:
//│ ║  l.204: 	      let res = mapPartition(f, xs)
//│ ╙──       	                ^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.200: 	fun mapPartition(f, xs) =
//│ ║         	                ^^^^^^^^^
//│ ║  l.201: 	  if xs is
//│ ║         	^^^^^^^^^^
//│ ║  l.202: 	    Nil then Nil
//│ ║         	^^^^^^^^^^^^^^^^^
//│ ║  l.203: 	    Cons(x, xs) and f(x) is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.204: 	      let res = mapPartition(f, xs)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.205: 	      let l = res.fst
//│ ║         	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.206: 	      let r = res.snd
//│ ║         	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.207: 	      Left(v)  then Pair(Cons(v, l), r)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.208: 	      Right(v) then Pair(l, Cons(v, r))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `() -> ?a` does not have field 'snd'
//│ ║  l.184: 	class Nil: List
//│ ║         	      ^^^
//│ ╟── but it flows into reference with expected type `{snd: ?snd}`
//│ ║  l.202: 	    Nil then Nil
//│ ║         	             ^^^
//│ ╟── Note: constraint arises from field selection:
//│ ║  l.206: 	      let r = res.snd
//│ ║         	              ^^^^^^^
//│ ╟── from application:
//│ ║  l.204: 	      let res = mapPartition(f, xs)
//│ ╙──       	                ^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.200: 	fun mapPartition(f, xs) =
//│ ║         	                ^^^^^^^^^
//│ ║  l.201: 	  if xs is
//│ ║         	^^^^^^^^^^
//│ ║  l.202: 	    Nil then Nil
//│ ║         	^^^^^^^^^^^^^^^^^
//│ ║  l.203: 	    Cons(x, xs) and f(x) is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.204: 	      let res = mapPartition(f, xs)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.205: 	      let l = res.fst
//│ ║         	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.206: 	      let r = res.snd
//│ ║         	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.207: 	      Left(v)  then Pair(Cons(v, l), r)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.208: 	      Right(v) then Pair(l, Cons(v, r))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `() -> ?a` does not have field 'fst'
//│ ║  l.184: 	class Nil: List
//│ ║         	      ^^^
//│ ╟── but it flows into reference with expected type `{fst: ?fst}`
//│ ║  l.202: 	    Nil then Nil
//│ ║         	             ^^^
//│ ╟── Note: constraint arises from field selection:
//│ ║  l.205: 	      let l = res.fst
//│ ║         	              ^^^^^^^
//│ ╟── from application:
//│ ║  l.204: 	      let res = mapPartition(f, xs)
//│ ╙──       	                ^^^^^^^^^^^^^^^^^^^
//│ mapPartition: ('head -> ((Left with {leftValue: 'head0}) | (Right with {rightValue: 'head1})), 'a,) -> (() -> Nil | (Pair with {fst: 'fst, snd: 'snd}))
//│   where
//│     'snd :> Cons with {head: 'head1, tail: 'snd}
//│     'fst :> Cons with {head: 'head0, tail: 'fst}
//│     'a <: (Cons with {head: 'head, tail: 'a}) | Nil
//│             = [Function: mapPartition]

fun mn(a) =
  if a is
    Some(x) and x is
      Left(a)  then "left-defined"
      let y = x + 1
      Right(b) then "right-defined"
    None       then "undefined"
//│ mn: (None | Some & {value: nothing}) -> ("left-defined" | "right-defined" | "undefined")
//│   = [Function: mn]
