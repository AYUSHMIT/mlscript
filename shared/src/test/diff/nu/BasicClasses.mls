:NewParser
:NewDefs
:NoJS


class A(n: int)
//│ class A(n: int) {
//│   this: 'this_A
//│ }
//│ where
//│   'this_A :> A & {n: int}

A
//│ (n: int,) -> A

let a = A(42)
//│ let a: A


fun f(x: A) = x.n
//│ fun f: (x: A,) -> int

fun f(x: A) = if x is A then x.n
//│ fun f: (x: A,) -> int

fun f(x: A | 'b) = if x is A then x.n else 0
//│ fun f: (x: (anything,),) -> int


fun f(x) = x.n
//│ fun f: {n: 'n} -> 'n

f(a)
//│ int

fun f(x) = if x is A then x.n
//│ fun f: A -> int

f(a)
//│ int

fun f(x) = if x is A then x.n else 0
//│ fun f: anything -> int

f(a)
//│ int



class C {
  fun id(x) = x
  fun const(x) = id
}
//│ class C() {
//│   this: 'this_C
//│   fun const: anything -> 'a -> 'a
//│   fun id: 'a -> 'a
//│ }
//│ where
//│   'this_C :> C


class Base0(n) {
  fun me = this
  fun my = this.n
  fun mine = my
  fun oops = this.my
}
//│ class Base0(n: nothing) {
//│   this: 'this_Base0
//│   fun me: 'this_Base0
//│   fun mine: 'n
//│   fun my: 'n
//│   fun oops: 'my
//│ }
//│ where
//│   'this_Base0 :> Base0 & {n: nothing}
//│               <: {my: 'my, n: 'n}

// :d
// Base0
// Base0

let b1 = Base0(42)
//│ let b1: Base0

// :d
let n1 = b1.n
//│ let n1: nothing

// TODO
n1 + 1
//│ int


let b2 = Base0("hi")
let n2 = b2.n
//│ let b2: Base0
//│ let n2: nothing



class Base1(base: int) {
  fun getBase1 = base
  fun getBase2 = this.base
  fun foo(x) = this.base + x
}
//│ class Base1(base: int) {
//│   this: 'this_Base1
//│   fun foo: int -> int
//│   fun getBase1: int
//│   fun getBase2: int
//│ }
//│ where
//│   'this_Base1 :> Base1 & {base: int}
//│               <: {base: int}

class Base1(base: int) {
  fun getBase1 = base
  fun me = this
  fun foo(x) = base + x
}
//│ class Base1(base: int) {
//│   this: 'this_Base1
//│   fun foo: int -> int
//│   fun getBase1: int
//│   fun me: 'this_Base1
//│ }
//│ where
//│   'this_Base1 :> Base1 & {base: int}

Base1
//│ (base: int,) -> Base1

let b = Base1(1)
//│ let b: Base1

b.base
//│ int

b.getBase1
//│ int

// :d
b.me
//│ Base1 & {base: int}

:e
b.getBaseTypo
//│ ╔══[ERROR] class `Base1` does not contain member `getBaseTypo`
//│ ║  l.149: 	b.getBaseTypo
//│ ╙──       	 ^^^^^^^^^^^^
//│ error


b : Base1
//│ Base1


:e // TODO
class Rec(n) {
  fun go = Rec(n + 1)
}
//│ ╔══[ERROR] Cyclic definition
//│ ║  l.161: 	class Rec(n) {
//│ ║         	^^^^^^^^^^^^^^
//│ ║  l.162: 	  fun go = Rec(n + 1)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.163: 	}
//│ ╙──       	^
//│ class Rec(n: nothing) {
//│   this: 'this_Rec
//│   fun go: error
//│ }
//│ where
//│   'this_Rec :> Rec & {n: nothing}




// TODO treat `a: int` as a signature
class Annots(base: 0 | 1) {
  a: int
  fun a = base
}
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.183: 	  a: int
//│ ║         	  ^
//│ ╟── type `(0 | 1,)` is not an instance of type `int`
//│ ║  l.182: 	class Annots(base: 0 | 1) {
//│ ║         	                   ^
//│ ╟── but it flows into reference with expected type `int`
//│ ║  l.183: 	  a: int
//│ ║         	  ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.183: 	  a: int
//│ ╙──       	     ^^^
//│ class Annots(base: (0 | 1,)) {
//│   this: 'this_Annots
//│   fun a: (0 | 1,)
//│ }
//│ where
//│   'this_Annots :> Annots & {base: (0 | 1,)}




