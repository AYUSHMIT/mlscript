:NewParser
:NewDefs
:NoJS



class Base0(n) {
  fun me = this
  fun my = this.n
  fun mine = my
  fun oops = this.my
}
//│ class Base0
//│   fun me: ‹∀ 1. me30''#› where 
//│   |		this24' :> Base0<> <: {my: my36_37'} & {n: n32_33'}
//│   |		me30''# := this24'
//│   |		my31''# := n32''
//│   |		n32'' :> n32_33' <: mine34''# & my31''#
//│   |		mine34''# := my31''#
//│   |		my36_37' :> ‹∀ 1. my31''#›
//│   [pretty-printed] me: Base0
//│   fun my: ‹∀ 1. my31''#› where 
//│   |		my31''# := n32''
//│   |		n32'' :> n32_33' <: mine34''# & my31''#
//│   |		mine34''# := my31''#
//│   [pretty-printed] my: nothing
//│   fun mine: ‹∀ 1. mine34''#› where 
//│   |		my31''# := n32''
//│   |		n32'' :> n32_33' <: mine34''# & my31''#
//│   |		mine34''# := my31''#
//│   [pretty-printed] mine: nothing
//│   fun oops: ‹∀ 1. oops35''#› where 
//│   |		my31''# := n32''
//│   |		n32'' :> n32_33' <: mine34''# & my31''#
//│   |		mine34''# := my31''#
//│   |		oops35''# := my36''
//│   |		my36'' :> my36_37' <: oops35''#
//│   |		my36_37' :> ‹∀ 1. my31''#›
//│   [pretty-printed] oops: nothing

// :d
// Base0
// Base0

let b1 = Base0(42)
//│ fun b1: ‹∀ 0. b162'#› where 
//│ |		b162'# := α113'
//│ |		α113' :> Base0<> <: b162'#
//│ [pretty-printed] b1: Base0

:d
let n1 = b1.n
//│ 0. Typing TypingUnit(List(let n1 = (b1).n))
//│ Completing let n1 = (b1).n
//│ | 1. Typing term (b1).n
//│ | | 1. Typing term b1
//│ | | 1. : b162'#
//│ | | CONSTRAIN b162'# <! {n: n118'}
//│ | |   where 
//│ 		b162'# := α113'
//│ 		α113' :> Base0<> <: b162'#
//│ | | 1. C b162'# <! {n: n118'}    (0)
//│ | | | 1. C α113' <! {n: n118'}    (2)
//│ | | | | NEW α113' UB (1)
//│ | | | | 1. C Base0<> <! {n: n118'}    (4)
//│ | | | | | 1. C Base0<> <! {n: n118'}    (4)
//│ | | | | | | TypedNuCls(0,class Base0(n,) {fun me = this; fun my = (this).n; fun mine = my; fun oops = (this).my},TypedTypingUnit(List(me ~> TypedNuFun(1,fun me = this,‹∀ 1. me30''#›), my ~> TypedNuFun(1,fun my = (this).n,‹∀ 1. my31''#›), mine ~> TypedNuFun(1,fun mine = my,‹∀ 1. mine34''#›), oops ~> TypedNuFun(1,fun oops = (this).my,‹∀ 1. oops35''#›)),None),List((n,n23')),HashMap(n -> NuParam(n,n23'), mine -> TypedNuFun(1,fun mine = my,‹∀ 1. mine34''#›), oops -> TypedNuFun(1,fun oops = (this).my,‹∀ 1. oops35''#›), my -> TypedNuFun(1,fun my = (this).n,‹∀ 1. my31''#›), me -> TypedNuFun(1,fun me = this,‹∀ 1. me30''#›)))
//│ | | | | | | (>>,0,1)
//│ | | | | | | 2. FRESHEN ‹∀ 1. me30''#› || 1 .. 1024  1 true
//│ | | | | | | => ‹∀ 1. me30''#›
//│ | | | | | | 2. FRESHEN ‹∀ 1. my31''#› || 1 .. 1024  1 true
//│ | | | | | | => ‹∀ 1. my31''#›
//│ | | | | | | 2. FRESHEN ‹∀ 1. mine34''#› || 1 .. 1024  1 true
//│ | | | | | | => ‹∀ 1. mine34''#›
//│ | | | | | | 2. FRESHEN ‹∀ 1. oops35''#› || 1 .. 1024  1 true
//│ | | | | | | => ‹∀ 1. oops35''#›
//│ | | | | | | 1. FRESHEN n23' || 1 .. 1024  1 true
//│ | | | | | | => n23'
//│ | | | | | | 1. FRESHEN n23' || 1 .. 1024  1 true
//│ | | | | | | => n23'
//│ | | | | | | 2. FRESHEN ‹∀ 1. mine34''#› || 1 .. 1024  1 true
//│ | | | | | | => ‹∀ 1. mine34''#›
//│ | | | | | | 2. FRESHEN ‹∀ 1. oops35''#› || 1 .. 1024  1 true
//│ | | | | | | => ‹∀ 1. oops35''#›
//│ | | | | | | 2. FRESHEN ‹∀ 1. my31''#› || 1 .. 1024  1 true
//│ | | | | | | => ‹∀ 1. my31''#›
//│ | | | | | | 2. FRESHEN ‹∀ 1. me30''#› || 1 .. 1024  1 true
//│ | | | | | | => ‹∀ 1. me30''#›
//│ | | | | | | TypedNuCls(0,class Base0(n,) {fun me = this; fun my = (this).n; fun mine = my; fun oops = (this).my},TypedTypingUnit(List(me ~> TypedNuFun(1,fun me = this,‹∀ 1. me30''#›), my ~> TypedNuFun(1,fun my = (this).n,‹∀ 1. my31''#›), mine ~> TypedNuFun(1,fun mine = my,‹∀ 1. mine34''#›), oops ~> TypedNuFun(1,fun oops = (this).my,‹∀ 1. oops35''#›)),None),List((n,n23')),HashMap(n -> NuParam(n,n23'), mine -> TypedNuFun(1,fun mine = my,‹∀ 1. mine34''#›), oops -> TypedNuFun(1,fun oops = (this).my,‹∀ 1. oops35''#›), my -> TypedNuFun(1,fun my = (this).n,‹∀ 1. my31''#›), me -> TypedNuFun(1,fun me = this,‹∀ 1. me30''#›)))
//│ | | | | | | (n,HashMap(n -> NuParam(n,n23'), mine -> TypedNuFun(1,fun mine = my,‹∀ 1. mine34''#›), oops -> TypedNuFun(1,fun oops = (this).my,‹∀ 1. oops35''#›), my -> TypedNuFun(1,fun my = (this).n,‹∀ 1. my31''#›), me -> TypedNuFun(1,fun me = this,‹∀ 1. me30''#›)))
//│ | | | | | | 1. C n23' <! n118'    (3)
//│ | | | | | | | NEW n23' UB (1)
//│ | 1. : n118'
//│ | CONSTRAIN n118' <! n1117'
//│ |   where 
//│ | 1. C n118' <! n1117'    (0)
//│ | | NEW n118' UB (1)
//│ | UNSTASHING... (out)
//│ ⬤ Typed as: ‹∀ 0. n1117'#›
//│  where: 
//│ 		n1117'# := n118'
//│ 		n118' <: n1117'#
//│ fun n1: ‹∀ 0. n1117'#› where 
//│ |		n1117'# := n118'
//│ |		n118' <: n1117'#
//│ [pretty-printed] n1: nothing

// TODO
n1 + 1
//│ Typed: int


let b2 = Base0("hi")
let n2 = b2.n
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.113: 	let b2 = Base0("hi")
//│ ║         	         ^^^^^^^^^^^
//│ ╟── string literal of type `"hi"` is not an instance of type `int`
//│ ║  l.113: 	let b2 = Base0("hi")
//│ ║         	               ^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.109: 	n1 + 1
//│ ║         	^^
//│ ╟── from reference:
//│ ║  l.7: 	class Base0(n) {
//│ ╙──     	            ^
//│ fun b2: ‹∀ 0. b2130'#› where 
//│ |		b2130'# := α183'
//│ |		α183' :> Base0<> | error<> <: {n: n185'} & b2130'#
//│ |		n2184'# := n185'
//│ |		n185' :> error<> <: n2184'#
//│ [pretty-printed] b2: Base0 | error
//│ fun n2: ‹∀ 0. n2184'#› where 
//│ |		n2184'# := n185'
//│ |		n185' :> error<> <: n2184'#
//│ [pretty-printed] n2: error



class Base1(base: int) {
  fun getBase1 = base
  fun getBase2 = this.base
  fun foo(x) = this.base + x
}
//│ class Base1
//│   fun getBase1: ‹∀ 1. getBase1200''#› where 
//│   |		getBase1200''# := Int
//│   [pretty-printed] getBase1: int
//│   fun getBase2: ‹∀ 1. getBase2201''#› where 
//│   |		getBase2201''# := base202''
//│   |		base202'' :> base202_203' <: getBase2201''#
//│   |		base202_203' :> Int
//│   [pretty-printed] getBase2: int
//│   fun foo: ‹∀ 1. foo204''#› where 
//│   |		foo204''# := (α205'' -> α209'')
//│   |		α205'' <: int<number>
//│   |		α209'' :> int<number>
//│   [pretty-printed] foo: int -> int

class Base1(base: int) {
  fun getBase1 = base
  fun me = this
  fun foo(x) = base + x
}
//│ class Base1
//│   fun getBase1: ‹∀ 1. getBase1229''#› where 
//│   |		getBase1229''# := Int
//│   [pretty-printed] getBase1: int
//│   fun me: ‹∀ 1. me230''#› where 
//│   |		this224' :> Base1<>
//│   |		me230''# := this224'
//│   [pretty-printed] me: Base1
//│   fun foo: ‹∀ 1. foo231''#› where 
//│   |		foo231''# := (α232'' -> α234'')
//│   |		α232'' <: int<number>
//│   |		α234'' :> int<number>
//│   [pretty-printed] foo: int -> int

Base1
//│ Typed: (base: int,) -> Base1

let b = Base1(1)
//│ fun b: ‹∀ 0. b250'#› where 
//│ |		b250'# := α259'
//│ |		α259' :> Base1<> <: b250'#
//│ [pretty-printed] b: Base1

b.base
//│ Typed: int

b.getBase1
//│ Typed: int

b.me
//│ Typed: Base1

:e
b.getBaseTypo
//│ ╔══[ERROR] class `Base1` does not contain member `getBaseTypo`
//│ ║  l.198: 	b.getBaseTypo
//│ ╙──       	 ^^^^^^^^^^^^
//│ Typed: error


b : Base1
//│ Typed: Base1



// TODO treat `a: int` as a signature
class Annots(base: 0 | 1) {
  a: int
  fun a = base
}
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.212: 	  a: int
//│ ║         	  ^
//│ ╟── type `(0 | 1,)` is not an instance of type `int`
//│ ║  l.211: 	class Annots(base: 0 | 1) {
//│ ║         	                   ^
//│ ╟── but it flows into reference with expected type `int`
//│ ║  l.212: 	  a: int
//│ ║         	  ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.212: 	  a: int
//│ ╙──       	     ^^^
//│ class Annots
//│   fun a: ‹∀ 1. a292''#› where 
//│   |		a292''# := ((0<int,number> | 1<int,number>),)
//│   [pretty-printed] a: (0 | 1,)


