:NewParser
:NewDefs
:NoJS



class Base0(n) {
  fun me = this
  fun my = this.n
  fun mine = my
  fun oops = this.my
}
//│ class Base0
//│   fun me: ‹∀ 1. me30''#› where 
//│   |		this24' :> Base0<> <: {my: my36_37'} & {n: n32_33'}
//│   |		me30''# := this24'
//│   |		n32_33' :> n23_65
//│   |		my36_37' :> ‹∀ 1. my31_44''#›
//│   |		my31_44''# := n32_45''
//│   |		n32_45'' :> n32_42 <: mine34_46''# & my31_44''#
//│   |		mine34_46''# := my31_44''#
//│   [pretty-printed] me: Base0
//│   fun my: ‹∀ 1. my31''#› where 
//│   |		my31''# := n32''
//│   |		n32'' :> n32_33' <: mine34''# & my31''#
//│   |		n32_33' :> n23_65
//│   |		mine34''# := my31''#
//│   [pretty-printed] my: nothing
//│   fun mine: ‹∀ 1. mine34''#› where 
//│   |		my31''# := n32''
//│   |		n32'' :> n32_33' <: mine34''# & my31''#
//│   |		n32_33' :> n23_65
//│   |		mine34''# := my31''#
//│   [pretty-printed] mine: nothing
//│   fun oops: ‹∀ 1. oops35''#› where 
//│   |		oops35''# := my36''
//│   |		my36'' :> my36_37' <: oops35''#
//│   |		my36_37' :> ‹∀ 1. my31_44''#›
//│   |		my31_44''# := n32_45''
//│   |		n32_45'' :> n32_42 <: mine34_46''# & my31_44''#
//│   |		mine34_46''# := my31_44''#
//│   [pretty-printed] oops: nothing

// :d
// Base0
// Base0

let b1 = Base0(42)
//│ fun b1: ‹∀ 0. b184'#› where 
//│ |		b184'# := α99'
//│ |		α99' :> Base0<> <: b184'#
//│ [pretty-printed] b1: Base0

// :d
let n1 = b1.n
//│ fun n1: ‹∀ 0. n1104'#› where 
//│ |		n1104'# := n105'
//│ |		n105' <: n1104'#
//│ [pretty-printed] n1: nothing

// TODO
n1 + 1
//│ Typed: int


let b2 = Base0("hi")
let n2 = b2.n
//│ fun b2: ‹∀ 0. b2127'#› where 
//│ |		b2127'# := α142'
//│ |		α142' :> Base0<> <: {n: n145'} & b2127'#
//│ |		n2144'# := n145'
//│ |		n145' <: n2144'#
//│ [pretty-printed] b2: Base0
//│ fun n2: ‹∀ 0. n2144'#› where 
//│ |		n2144'# := n145'
//│ |		n145' <: n2144'#
//│ [pretty-printed] n2: nothing



class Base1(base: int) {
  fun getBase1 = base
  fun getBase2 = this.base
  fun foo(x) = this.base + x
}
//│ class Base1
//│   fun getBase1: ‹∀ 1. getBase1170''#› where 
//│   |		getBase1170''# := Int
//│   [pretty-printed] getBase1: int
//│   fun getBase2: ‹∀ 1. getBase2171''#› where 
//│   |		getBase2171''# := base172''
//│   |		base172'' :> base172_173' <: getBase2171''#
//│   |		base172_173' :> Int
//│   [pretty-printed] getBase2: int
//│   fun foo: ‹∀ 1. foo174''#› where 
//│   |		foo174''# := (α175'' -> α179'')
//│   |		α175'' <: int<number>
//│   |		α179'' :> int<number>
//│   [pretty-printed] foo: int -> int

class Base1(base: int) {
  fun getBase1 = base
  fun me = this
  fun foo(x) = base + x
}
//│ class Base1
//│   fun getBase1: ‹∀ 1. getBase1205''#› where 
//│   |		getBase1205''# := Int
//│   [pretty-printed] getBase1: int
//│   fun me: ‹∀ 1. me206''#› where 
//│   |		this200' :> Base1<>
//│   |		me206''# := this200'
//│   [pretty-printed] me: Base1
//│   fun foo: ‹∀ 1. foo207''#› where 
//│   |		foo207''# := (α208'' -> α210'')
//│   |		α208'' <: int<number>
//│   |		α210'' :> int<number>
//│   [pretty-printed] foo: int -> int

Base1
//│ Typed: (base: int,) -> Base1

let b = Base1(1)
//│ fun b: ‹∀ 0. b223'#› where 
//│ |		b223'# := α229'
//│ |		α229' :> Base1<> <: b223'#
//│ [pretty-printed] b: Base1

b.base
//│ Typed: int

b.getBase1
//│ Typed: int

// :d
b.me
//│ Typed: Base1

:e
b.getBaseTypo
//│ ╔══[ERROR] class `Base1` does not contain member `getBaseTypo`
//│ ║  l.140: 	b.getBaseTypo
//│ ╙──       	 ^^^^^^^^^^^^
//│ Typed: error


b : Base1
//│ Typed: Base1


:e // TODO
class Rec(n) {
  fun go = Rec(n + 1)
}
//│ ╔══[ERROR] Cyclic definition
//│ ║  l.152: 	class Rec(n) {
//│ ║         	      ^^^^^^^^
//│ ║  l.153: 	  fun go = Rec(n + 1)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.154: 	}
//│ ╙──       	^
//│ class Rec
//│   fun go: ‹∀ 1. go268''#› where 
//│   |		go268''# := α271''
//│   |		α271'' :> error<> <: go268''#
//│   [pretty-printed] go: error




// TODO treat `a: int` as a signature
class Annots(base: 0 | 1) {
  a: int
  fun a = base
}
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.173: 	  a: int
//│ ║         	  ^
//│ ╟── type `(0 | 1,)` is not an instance of type `int`
//│ ║  l.172: 	class Annots(base: 0 | 1) {
//│ ║         	                   ^
//│ ╟── but it flows into reference with expected type `int`
//│ ║  l.173: 	  a: int
//│ ║         	  ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.173: 	  a: int
//│ ╙──       	     ^^^
//│ class Annots
//│   fun a: ‹∀ 1. a278''#› where 
//│   |		a278''# := ((0<int,number> | 1<int,number>),)
//│   [pretty-printed] a: (0 | 1,)


