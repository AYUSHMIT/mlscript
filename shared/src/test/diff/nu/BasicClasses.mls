:NewParser
:NewDefs
:NoJS



class Base0(n) {
  fun me = this
  fun my = this.n
  fun mine = my
  fun oops = this.my
}
//│ class Base0
//│   fun me: this24' where 
//│   |		this24' :> Base0<> <: {my: my32_33'} & {n: n30_31'}
//│   |		n30_31' :> n23_59
//│   |		my32_33' :> n30_39
//│   |		n30_39 :> n30_37 <: mine28_40 & my27_41
//│   |		mine28_40 :> n30_37
//│   |		my27_41 :> n30_37
//│   [pretty-printed] me: Base0
//│   fun my: n30'' where 
//│   |		my27'' :> n30_31'
//│   |		mine28'' :> n30_31'
//│   |		n30'' :> n30_31' <: mine28'' & my27''
//│   |		n30_31' :> n23_59
//│   [pretty-printed] my: nothing
//│   fun mine: n30'' where 
//│   |		my27'' :> n30_31'
//│   |		mine28'' :> n30_31'
//│   |		n30'' :> n30_31' <: mine28'' & my27''
//│   |		n30_31' :> n23_59
//│   [pretty-printed] mine: nothing
//│   fun oops: my32'' where 
//│   |		oops29'' :> my32_33'
//│   |		my32'' :> my32_33' <: oops29''
//│   |		my32_33' :> n30_39
//│   |		n30_39 :> n30_37 <: mine28_40 & my27_41
//│   |		mine28_40 :> n30_37
//│   |		my27_41 :> n30_37
//│   [pretty-printed] oops: nothing

// :d
// Base0
// Base0

let b1 = Base0(42)
//│ let b1: α85 where 
//│ |		α85 :> Base0<>
//│ [pretty-printed] b1: Base0

// :d
let n1 = b1.n
//│ let n1: n89 where 
//│ [pretty-printed] n1: nothing

// TODO
n1 + 1
//│ Typed: int


let b2 = Base0("hi")
let n2 = b2.n
//│ let b2: α122 where 
//│ |		α122 :> Base0<> <: {n: n124}
//│ [pretty-printed] b2: Base0
//│ let n2: n124 where 
//│ [pretty-printed] n2: nothing



class Base1(base: int) {
  fun getBase1 = base
  fun getBase2 = this.base
  fun foo(x) = this.base + x
}
//│ class Base1
//│   fun getBase1: Int where 
//│   [pretty-printed] getBase1: int
//│   fun getBase2: base146'' where 
//│   |		getBase2144'' :> base146_147'
//│   |		base146'' :> base146_147' <: getBase2144''
//│   |		base146_147' :> Int
//│   [pretty-printed] getBase2: int
//│   fun foo: (α148'' -> α152'') where 
//│   |		α148'' <: int<number>
//│   |		α152'' :> int<number>
//│   [pretty-printed] foo: int -> int

class Base1(base: int) {
  fun getBase1 = base
  fun me = this
  fun foo(x) = base + x
}
//│ class Base1
//│   fun getBase1: Int where 
//│   [pretty-printed] getBase1: int
//│   fun me: this174' where 
//│   |		this174' :> Base1<>
//│   [pretty-printed] me: Base1
//│   fun foo: (α179'' -> α181'') where 
//│   |		α179'' <: int<number>
//│   |		α181'' :> int<number>
//│   [pretty-printed] foo: int -> int

Base1
//│ Typed: (base: int,) -> Base1

let b = Base1(1)
//│ let b: α198 where 
//│ |		α198 :> Base1<>
//│ [pretty-printed] b: Base1

b.base
//│ Typed: int

b.getBase1
//│ Typed: int

// :d
b.me
//│ Typed: Base1

:e
b.getBaseTypo
//│ ╔══[ERROR] class `Base1` does not contain member `getBaseTypo`
//│ ║  l.125: 	b.getBaseTypo
//│ ╙──       	 ^^^^^^^^^^^^
//│ Typed: error


b : Base1
//│ Typed: Base1


:e // TODO
class Rec(n) {
  fun go = Rec(n + 1)
}
//│ ╔══[ERROR] Cyclic definition
//│ ║  l.137: 	class Rec(n) {
//│ ║         	^^^^^^^^^^^^^^
//│ ║  l.138: 	  fun go = Rec(n + 1)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.139: 	}
//│ ╙──       	^
//│ class Rec
//│   fun go: α239'' where 
//│   |		go236'' :> error<>
//│   |		α239'' :> error<> <: go236''
//│   [pretty-printed] go: error




// TODO treat `a: int` as a signature
class Annots(base: 0 | 1) {
  a: int
  fun a = base
}
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.158: 	  a: int
//│ ║         	  ^
//│ ╟── type `(0 | 1,)` is not an instance of type `int`
//│ ║  l.157: 	class Annots(base: 0 | 1) {
//│ ║         	                   ^
//│ ╟── but it flows into reference with expected type `int`
//│ ║  l.158: 	  a: int
//│ ║         	  ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.158: 	  a: int
//│ ╙──       	     ^^^
//│ class Annots
//│   fun a: ((0<int,number> | 1<int,number>),) where 
//│   [pretty-printed] a: (0 | 1,)


