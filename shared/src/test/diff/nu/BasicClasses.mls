:NewParser
:NewDefs
:NoJS



class C {
  fun id(x) = x
  fun const(x) = id
}


class Base0(n) {
  fun me = this
  fun my = this.n
  fun mine = my
  fun oops = this.my
}
//│ /!!!\ Uncaught error: scala.NotImplementedError: an implementation is missing
//│ 	at: scala.Predef$.$qmark$qmark$qmark(Predef.scala:344)
//│ 	at: mlscript.NuTypeDefs$TypedNuTypeDef.freshenAbove(NuTypeDefs.scala:119)
//│ 	at: mlscript.ConstraintSolver.lookupNuTypeDef$1(ConstraintSolver.scala:486)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrainImpl$94(ConstraintSolver.scala:667)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrainImpl$94$adapted(ConstraintSolver.scala:666)
//│ 	at: scala.collection.immutable.List.foreach(List.scala:333)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrainImpl$93(ConstraintSolver.scala:666)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrainImpl$93$adapted(ConstraintSolver.scala:654)
//│ 	at: mlscript.utils.package$GenHelper$.$bar$greater$extension(package.scala:111)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrainImpl$89(ConstraintSolver.scala:654)

// :d
// Base0
// Base0

let b1 = Base0(42)
//│ ╔══[ERROR] identifier not found: Base0
//│ ║  l.35: 	let b1 = Base0(42)
//│ ╙──      	         ^^^^^

// :d
let n1 = b1.n
//│ ╔══[ERROR] identifier not found: b1
//│ ║  l.41: 	let n1 = b1.n
//│ ╙──      	         ^^

// TODO
n1 + 1
//│ ╔══[ERROR] identifier not found: n1
//│ ║  l.47: 	n1 + 1
//│ ╙──      	^^


let b2 = Base0("hi")
let n2 = b2.n
//│ ╔══[ERROR] identifier not found: Base0
//│ ║  l.53: 	let b2 = Base0("hi")
//│ ╙──      	         ^^^^^



class Base1(base: int) {
  fun getBase1 = base
  fun getBase2 = this.base
  fun foo(x) = this.base + x
}
//│ /!!!\ Uncaught error: scala.NotImplementedError: an implementation is missing
//│ 	at: scala.Predef$.$qmark$qmark$qmark(Predef.scala:344)
//│ 	at: mlscript.NuTypeDefs$TypedNuTypeDef.freshenAbove(NuTypeDefs.scala:119)
//│ 	at: mlscript.ConstraintSolver.lookupNuTypeDef$1(ConstraintSolver.scala:486)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrainImpl$94(ConstraintSolver.scala:667)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrainImpl$94$adapted(ConstraintSolver.scala:666)
//│ 	at: scala.collection.immutable.List.foreach(List.scala:333)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrainImpl$93(ConstraintSolver.scala:666)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrainImpl$93$adapted(ConstraintSolver.scala:654)
//│ 	at: mlscript.utils.package$GenHelper$.$bar$greater$extension(package.scala:111)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrainImpl$89(ConstraintSolver.scala:654)

class Base1(base: int) {
  fun getBase1 = base
  fun me = this
  fun foo(x) = base + x
}

Base1
//│ ╔══[ERROR] identifier not found: Base1
//│ ║  l.84: 	Base1
//│ ╙──      	^^^^^

let b = Base1(1)
//│ ╔══[ERROR] identifier not found: Base1
//│ ║  l.89: 	let b = Base1(1)
//│ ╙──      	        ^^^^^

b.base
//│ ╔══[ERROR] identifier not found: b
//│ ║  l.94: 	b.base
//│ ╙──      	^

b.getBase1
//│ ╔══[ERROR] identifier not found: b
//│ ║  l.99: 	b.getBase1
//│ ╙──      	^

// :d
b.me
//│ ╔══[ERROR] identifier not found: b
//│ ║  l.105: 	b.me
//│ ╙──       	^

:e
b.getBaseTypo
//│ ╔══[ERROR] identifier not found: b
//│ ║  l.111: 	b.getBaseTypo
//│ ╙──       	^


b : Base1
//│ ╔══[ERROR] identifier not found: b
//│ ║  l.117: 	b : Base1
//│ ╙──       	^
//│ ╔══[ERROR] type identifier not found: Base1
//│ ║  l.117: 	b : Base1
//│ ╙──       	    ^^^^^


:e // TODO
class Rec(n) {
  fun go = Rec(n + 1)
}
//│ ╔══[ERROR] Cyclic definition
//│ ║  l.127: 	class Rec(n) {
//│ ║         	^^^^^^^^^^^^^^
//│ ║  l.128: 	  fun go = Rec(n + 1)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.129: 	}
//│ ╙──       	^




// TODO treat `a: int` as a signature
class Annots(base: 0 | 1) {
  a: int
  fun a = base
}
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.143: 	  a: int
//│ ║         	  ^
//│ ╟── type `(0 | 1,)` is not an instance of type `int`
//│ ║  l.142: 	class Annots(base: 0 | 1) {
//│ ║         	                   ^
//│ ╟── but it flows into reference with expected type `int`
//│ ║  l.143: 	  a: int
//│ ║         	  ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.143: 	  a: int
//│ ╙──       	     ^^^



