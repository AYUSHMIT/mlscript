:NewParser
:NewDefs
:NoJS


class A(n: int)
//│ 
//│ class A(n: int) {
//│ this: 'this
//│ }
//│   where
//│     'this :> A

let a = A(42)
//│ 
//│ let a: 'a
//│   where
//│     'a :> A


fun f(x: A) = x.n
//│ 
//│ fun f: (x: A,) -> 'n
//│   where
//│     'n :> int

fun f(x: A) = if x is A then x.n
//│ 
//│ fun f: (x: A,) -> 'n
//│   where
//│     'n :> int

// FIXedME no bounds on 'n...
fun f(x: A | 'b) = if x is A then x.n else 0
//│ 
//│ fun f: (x: (A | 'b,),) -> ('n | 0)
//│   where
//│     'n :> int


fun f(x) = x.n
//│ 
//│ fun f: 'a -> 'n
//│   where
//│     'a <: {n: 'n}

f(a)
//│ 
//│ 'a
//│   where
//│     'a :> int
//│ Typed: int

fun f(x) = if x is A then x.n
//│ 
//│ fun f: 'a -> 'n
//│   where
//│     'n :> int
//│     'a <: A

f(a)
//│ 
//│ 'a
//│   where
//│     'a :> forall 'n. 'n
//│     'n :> int
//│ Typed: int

fun f(x) = if x is A then x.n else 0
//│ 
//│ fun f: 'a -> ('n | 0)
//│   where
//│     'n :> int
//│     'a <: A | 'b & ~A

f(a)
//│ 
//│ 'a
//│   where
//│     'a :> forall 'n. 'n | 0
//│     'n :> int
//│ Typed: int



class C {
  fun id(x) = x
  fun const(x) = id
}
//│ 
//│ class C() {
//│ this: 'this
//│ fun const: 'a -> 'b -> 'b
//│ fun id: 'b -> 'b
//│ }
//│   where
//│     'this :> C


class Base0(n) {
  fun me = this
  fun my = this.n
  fun mine = my
  fun oops = this.my
}
//│ 
//│ class Base0(n: 'n) {
//│ this: 'this
//│ fun me: 'this
//│ fun mine: 'n0
//│ fun my: 'n0
//│ fun oops: 'my
//│ }
//│   where
//│     'my :> 'my0
//│         <: 'oops
//│     'oops :> 'my0
//│     'n0 :> 'n1
//│         <: 'mine & 'my1
//│     'my1 :> 'n1
//│     'mine :> 'n1
//│     'this :> Base0
//│           <: {my: 'my0} & {n: 'n1}
//│     'n1 :> 'n2
//│     'my0 :> 'n3
//│     'n3 :> 'n4
//│         <: 'mine0 & 'my2
//│     'my2 :> 'n4
//│     'mine0 :> 'n4

// :d
// Base0
// Base0

let b1 = Base0(42)
//│ 
//│ let b1: 'a
//│   where
//│     'a :> Base0

// :d
let n1 = b1.n
//│ 
//│ let n1: 'n

// TODO
n1 + 1
//│ 
//│ 'a
//│   where
//│     'a :> int
//│ Typed: int


let b2 = Base0("hi")
let n2 = b2.n
//│ 
//│ let b2: 'a
//│ let n2: 'n
//│   where
//│     'a :> Base0
//│        <: {n: 'n}



class Base1(base: int) {
  fun getBase1 = base
  fun getBase2 = this.base
  fun foo(x) = this.base + x
}
//│ 
//│ class Base1(base: int) {
//│ this: 'this
//│ fun foo: 'a -> 'b
//│ fun getBase1: int
//│ fun getBase2: 'base
//│ }
//│   where
//│     'base :> 'base0
//│           <: 'getBase2
//│     'getBase2 :> 'base0
//│     'b :> int
//│     'a <: int
//│     'this :> Base1
//│           <: {base: 'base1} & {base: 'base0}
//│     'base0 :> int
//│     'base1 := int

class Base1(base: int) {
  fun getBase1 = base
  fun me = this
  fun foo(x) = base + x
}
//│ 
//│ class Base1(base: int) {
//│ this: 'this
//│ fun foo: 'a -> 'b
//│ fun getBase1: int
//│ fun me: 'this
//│ }
//│   where
//│     'b :> int
//│     'a <: int
//│     'this :> Base1

Base1
//│ 
//│ (base: int,) -> Base1
//│ Typed: (base: int,) -> Base1

let b = Base1(1)
//│ 
//│ let b: 'a
//│   where
//│     'a :> Base1

b.base
//│ 
//│ 'base
//│   where
//│     'base :> int
//│ Typed: int

b.getBase1
//│ 
//│ 'getBase1
//│   where
//│     'getBase1 :> int
//│ Typed: int

// :d
b.me
//│ 
//│ 'me
//│   where
//│     'me :> Base1
//│ Typed: Base1

:e
b.getBaseTypo
//│ ╔══[ERROR] class `Base1` does not contain member `getBaseTypo`
//│ ║  l.240: 	b.getBaseTypo
//│ ╙──       	 ^^^^^^^^^^^^
//│ 
//│ 'getBaseTypo
//│   where
//│     'getBaseTypo :> error
//│ Typed: error


b : Base1
//│ 
//│ Base1
//│ Typed: Base1


:e // TODO
class Rec(n) {
  fun go = Rec(n + 1)
}
//│ ╔══[ERROR] Cyclic definition
//│ ║  l.258: 	class Rec(n) {
//│ ║         	^^^^^^^^^^^^^^
//│ ║  l.259: 	  fun go = Rec(n + 1)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.260: 	}
//│ ╙──       	^
//│ 
//│ class Rec(n: 'n) {
//│ this: 'this
//│ fun go: 'a
//│ }
//│   where
//│     'a :> error
//│        <: 'go
//│     'go :> error
//│     'this :> Rec
//│     'n <: int




// TODO treat `a: int` as a signature
class Annots(base: 0 | 1) {
  a: int
  fun a = base
}
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.285: 	  a: int
//│ ║         	  ^
//│ ╟── type `(0 | 1,)` is not an instance of type `int`
//│ ║  l.284: 	class Annots(base: 0 | 1) {
//│ ║         	                   ^
//│ ╟── but it flows into reference with expected type `int`
//│ ║  l.285: 	  a: int
//│ ║         	  ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.285: 	  a: int
//│ ╙──       	     ^^^
//│ 
//│ class Annots(base: (0 | 1,)) {
//│ this: 'this
//│ fun a: (0 | 1,)
//│ }
//│   where
//│     'this :> Annots



