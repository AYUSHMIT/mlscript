:NewDefs
:NoJS


run
//│ forall 'a. Code['a, nothing] -> 'a

:e
code"x => ${run(code"x")}"
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.9: 	code"x => ${run(code"x")}"
//│ ║       	            ^^^^^^^^^^^^
//│ ╙── expression of type `?a` does not match type `nothing`
//│ Code[forall 'a. Code['a, anything] -> 'a, nothing]


// * FIXME type is wrong: it's not true that this accepts code with any context dependency and returns code with no context dependency
fun test(cde) =
  code"x => x + ${cde}"
//│ fun test: Code[Int, anything] -> Code[Int -> Int, nothing]

// :e // FIXME this should not type check
code"y => ${ run(test(code"y")); code"0" }"
//│ Code[Int -> 0, nothing]


fun test(cde, f) =
  code"x => x + ${f(cde)}"
//│ fun test: forall 'a. ('a, 'a -> Code[Int, anything]) -> Code[Int -> Int, nothing]

run(test(code"1", id))
//│ Int -> Int


fun test(cde: Code[Int, 'a], f: forall 'c: Code[Int, 'c] -> Code[Int, 'c]) =
  code"x => x + ${f(cde)}"
//│ fun test: (cde: Code[Int, anything], f: forall 'c. Code[Int, 'c] -> Code[Int, 'c]) -> Code[Int -> Int, nothing]

run(test(code"1", id))
//│ Int -> Int

// :e // FIXME this should not type check!
code"x => ${ run(test(code"x", id)); code"x" }"
//│ Code[forall 'a. (Int & 'a) -> 'a, nothing]

// :e // FIXME this should not type check!
code"x => ${ let c = code"x" in run(test(c, id)); c }"
//│ Code[forall 'a. (Int & 'a) -> 'a, nothing]


fun test(f) =
  code"x => x + ${f(code"x + 1")}"
//│ fun test: (Code[Int, ??_] -> Code[Int, anything]) -> Code[Int -> Int, nothing]


let myrun = c => run(c)
//│ let myrun: forall 'a. Code['a, nothing] -> 'a

:e
code"x => ${ test(myrun) }"
//│ ╔══[ERROR] Type error in application
//│ ║  l.60: 	code"x => ${ test(myrun) }"
//│ ║        	             ^^^^^^^^^^^
//│ ╟── type variable `?a` leaks out of its scope
//│ ╟── into type `nothing`
//│ ╟── adding a type annotation to any of the following terms may help resolve the problem
//│ ╟── • this reference:
//│ ║  l.52: 	  code"x => x + ${f(code"x + 1")}"
//│ ╙──      	                  ^
//│ Code[anything -> Int -> Int, nothing]

:e
code"x => ${ test(c => run(c); code"0") }"
//│ ╔══[ERROR] Type error in application
//│ ║  l.73: 	code"x => ${ test(c => run(c); code"0") }"
//│ ║        	             ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type variable `?a` leaks out of its scope
//│ ╟── into type `nothing`
//│ ╟── adding a type annotation to any of the following terms may help resolve the problem
//│ ╟── • this reference:
//│ ║  l.52: 	  code"x => x + ${f(code"x + 1")}"
//│ ╙──      	                  ^
//│ Code[anything -> Int -> Int, nothing]


:e
code"x => ${ test(c => run(c); code"x") }"
//│ ╔══[ERROR] Type error in application
//│ ║  l.87: 	code"x => ${ test(c => run(c); code"x") }"
//│ ║        	             ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type variable `?a` leaks out of its scope
//│ ╟── into type `nothing`
//│ ╟── adding a type annotation to any of the following terms may help resolve the problem
//│ ╟── • this reference:
//│ ║  l.52: 	  code"x => x + ${f(code"x + 1")}"
//│ ╙──      	                  ^
//│ Code[anything -> Int -> Int, nothing]


:e
fun test2(a) = code"x => ${ test(c => run(c); a) }"
//│ ╔══[ERROR] Type error in application
//│ ║  l.101: 	fun test2(a) = code"x => ${ test(c => run(c); a) }"
//│ ║         	                            ^^^^^^^^^^^^^^^^^^^^
//│ ╟── type variable `?a` leaks out of its scope
//│ ╟── into type `nothing`
//│ ╟── adding a type annotation to any of the following terms may help resolve the problem
//│ ╟── • this reference:
//│ ║  l.52: 	  code"x => x + ${f(code"x + 1")}"
//│ ╙──      	                  ^
//│ fun test2: Code[Int, anything] -> Code[anything -> Int -> Int, nothing]


