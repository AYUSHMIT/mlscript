:PreTyper

// This test file is to track possible name collision during specialization.

fun (~~>) check(x, y) = if x === y then "passed" else error
class Pair[out A, out B](val first: A, val second: B)
//│ fun (~~>) check: forall 'a. (Eql['a], 'a) -> "passed"
//│ class Pair[A, B](first: A, second: B)

fun p1(x) = x < 0
fun p2(x) = x > 0
fun p3(x) = x == 0
//│ fun p1: Num -> Bool
//│ fun p2: Num -> Bool
//│ fun p3: Num -> Bool

fun example1(p) =
  if p is
    Pair(x, y) and p1(x) and p1(y) then "both negative"
    Pair(a, b) and p2(a) and p2(b) then "both positive"
    else "nah"
//│ fun example1: (Object & ~#Pair | Pair[Num, Num]) -> ("both negative" | "both positive" | "nah")

// FIXME: The error should be handled gracefully.
fun example2(p) =
  if p is
    Pair(x, y) and p1(x) and p1(y) then "both negative"
    Pair(a, b) and p2(a) and p2(b) then x + y
    else "nah"
//│ /!!!\ Uncaught error: java.lang.Exception: Variable x not found in scope

// Next, let's check the name collision between a class and its super class.

class Base(x: Int)
class Derived(y: Int) extends Base(y + 1)
//│ class Base(x: Int)
//│ class Derived(y: Int) extends Base

fun example3(t) =
  if t is
    Base(x) and p1(x) then x
    Derived(y) then y
    else 42
//│ fun example3: Base -> Int

fun example4(t, x) =
  if t is
    Base(x) and p1(x) then x
    Derived(y) then y + x
    //                  ^
    // Note that this branch will be absorbed by the previous one. As the
    // previous branch shadows the variable `x`, a correct implementation
    // should restore the original value of `x` in this branch.
    else 42
//│ fun example4: (Base, Int) -> Int

example4(Base(-1), 0) ~~> -1
example4(Base(1), 2) ~~> 42
//│ "passed"
//│ res
//│     = 'passed'
//│ res
//│     = 'passed'

example4(Derived(1), 4) ~~> 5
//│ "passed"
//│ res
//│     = 'passed'
