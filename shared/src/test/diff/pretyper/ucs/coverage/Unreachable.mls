:PreTyper

class Some[T](value: T)
module None
type Option[T] = Some[T] | None
class Pair[A, B](x: A, y: B)
//│ class Some[T](value: T)
//│ module None
//│ type Option[T] = None | Some[T]
//│ class Pair[A, B](x: A, y: B)

fun f(x) = if x is Some(xv) and xv === 1 then true else false
//│ fun f: (Object & ~#Some | Some[Eql[1]]) -> Bool

f(Some(1))
f(Some(2))
f(None)
//│ Bool
//│ res
//│     = true
//│ res
//│     = false
//│ res
//│     = false

fun reachable_1(x) =
  if x is
    _ and f(x) then "cos"
    Some(xv) then "sin"
    None then "tan"
//│ fun reachable_1: (None | Some[Eql[1]] | Some[anything] & ~#Some) -> ("cos" | "sin" | "tan")

reachable_1(Some(1))
reachable_1(Some(2))
reachable_1(None)
//│ "cos" | "sin" | "tan"
//│ res
//│     = 'cos'
//│ res
//│     = 'sin'
//│ res
//│     = 'tan'

:dpt
fun unreachable_1(x) =
  if x is
    _ and
      f(x) then "tmux"
      else "screen"
    Some(xv) then "sin"
    None then "tan"
//│ process <== <root>: {fun unreachable_1}
//│ | visitTypingUnit <== <root>: {fun unreachable_1}
//│ | | 1. scope = {unreachable_1}
//│ | | 2. scope = {unreachable_1}
//│ | | visitFunction <== unreachable_1
//│ | | | visitTerm <== Lam(_, _)
//│ | | | | visitTerm <== Blk(_)
//│ | | | | | visitTerm <== If(_)
//│ | | | | | | visitIf
//│ | | | | | | | STEP 0
//│ | | | | | | | Transformed UCS term:
//│ | | | | | | | if x is
//│ | | | | | | |   _ and f(x,) then "tmux"
//│ | | | | | | |   else "screen"
//│ | | | | | | |   Some(xv) then "sin"
//│ | | | | | | |   None then "tan"
//│ | | | | | | | STEP 1
//│ | | | | | | | Desugared UCS term:
//│ | | | | | | | if
//│ | | | | | | |   x is _
//│ | | | | | | |     let scrut0 = f(x,)
//│ | | | | | | |     scrut0 is true then "tmux"
//│ | | | | | | |     else "screen"
//│ | | | | | | |   x is Some(xv) then "sin"
//│ | | | | | | |   x is None then "tan"
//│ | | | | | | | visitSplit <== [unreachable_1, x]
//│ | | | | | | | | found branch: x is _
//│ | | | | | | | | visitTerm <== Var("x")
//│ | | | | | | | | | visitVar(name = "x")
//│ | | | | | | | | | | resolveVar(name = "x")
//│ | | | | | | | | visitTerm ==> Var("x")
//│ | | | | | | | | visitPattern <== _
//│ | | | | | | | | visitPattern ==> [_]
//│ | | | | | | | | visitSplit <== [unreachable_1, x, _]
//│ | | | | | | | | | found let binding: "scrut0"
//│ | | | | | | | | | visitSplit <== [unreachable_1, x, _, scrut0]
//│ | | | | | | | | | | found branch: scrut0 is true
//│ | | | | | | | | | | visitTerm <== Var("scrut0")
//│ | | | | | | | | | | | visitVar(name = "scrut0")
//│ | | | | | | | | | | | | resolveVar(name = "scrut0")
//│ | | | | | | | | | | visitTerm ==> Var("scrut0")
//│ | | | | | | | | | | visitPattern <== true
//│ | | | | | | | | | | visitPattern ==> []
//│ | | | | | | | | | | visitSplit <== [unreachable_1, x, _, scrut0]
//│ | | | | | | | | | | | visitTerm <== "tmux"
//│ | | | | | | | | | | | visitTerm ==> "tmux"
//│ | | | | | | | | | | visitSplit <== [unreachable_1, x, _, scrut0]
//│ | | | | | | | | | | | visitTerm <== "screen"
//│ | | | | | | | | | | | visitTerm ==> "screen"
//│ | | | | | | | | visitSplit <== [unreachable_1, x]
//│ | | | | | | | | | found branch: x is Some(xv)
//│ | | | | | | | | | visitTerm <== Var("x")
//│ | | | | | | | | | | visitVar(name = "x")
//│ | | | | | | | | | visitTerm ==> Var("x")
//│ | | | | | | | | | visitPattern <== Some(xv)
//│ | | | | | | | | | visitPattern ==> [xv]
//│ | | | | | | | | | visitSplit <== [unreachable_1, x, xv]
//│ | | | | | | | | | | visitTerm <== "sin"
//│ | | | | | | | | | | visitTerm ==> "sin"
//│ | | | | | | | | | visitSplit <== [unreachable_1, x]
//│ | | | | | | | | | | found branch: x is None
//│ | | | | | | | | | | visitTerm <== Var("x")
//│ | | | | | | | | | | | visitVar(name = "x")
//│ | | | | | | | | | | visitTerm ==> Var("x")
//│ | | | | | | | | | | visitPattern <== None
//│ | | | | | | | | | | visitPattern ==> []
//│ | | | | | | | | | | visitSplit <== [unreachable_1, x]
//│ | | | | | | | | | | | visitTerm <== "tan"
//│ | | | | | | | | | | | visitTerm ==> "tan"
//│ | | | | | | | | | | visitSplit <== [unreachable_1, x]
//│ | | | | | | | | | | | the end
//│ | | | | | | | STEP 2
//│ | | | | | | | normalizeToTerm
//│ | | | | | | | | alias x => _
//│ | | | | | | | | normalizeToTerm
//│ | | | | | | | | | normalizeToTerm
//│ | | | | | | | | | | match scrut0 with true
//│ | | | | | | | | | | S+ <== scrut0 is true
//│ | | | | | | | | | | | the end
//│ | | | | | | | | | | S+ ==> then "tmux"
//│ | | | | | | | | | | normalizeToTerm
//│ | | | | | | | | | | S- <== scrut0 is true
//│ | | | | | | | | | | | the end
//│ | | | | | | | | | | S- ==> then "screen"
//│ | | | | | | | | | | normalizeToCaseBranches
//│ | | | | | | | Normalized UCS term:
//│ | | | | | | | let _* = x
//│ | | | | | | | let scrut0* = f(x,)
//│ | | | | | | | scrut0 match
//│ | | | | | | |   case true => "tmux"
//│ | | | | | | |   case _ => "screen"
//│ | | | | | | | STEP 3
//│ | | | | | | | postProcess <== Let(_, _)
//│ | | | | | | | | postProcess <== Let(_, _)
//│ | | | | | | | | | postProcess <== CaseOf(_, _)
//│ | | | | | | | | | | found a BINARY case: scrut0 is true
//│ | | | | | | | | | | `scrut0`'s matched classes: [true]
//│ | | | | | | | | | | post-processing the first branch
//│ | | | | | | | | | | postProcess <== "tmux"
//│ | | | | | | | | | | | CANNOT post-process
//│ | | | | | | | | | | postProcess ==> 
//│ | | | | | | | | | | found 0 cases
//│ | | | | | | | | | postProcess ==> 
//│ | | | | | | | | postProcess ==> 
//│ | | | | | | | postProcess ==> 
//│ | | | | | | | Post-processed UCS term:
//│ | | | | | | | let _* = x
//│ | | | | | | | let scrut0* = f(x,)
//│ | | | | | | | scrut0 match
//│ | | | | | | |   case true => "tmux"
//│ | | | | | | |   case _ => "screen"
//│ | | | | | | | STEP 4
//│ | | | | | | | collected match registry: 
//│ | | | | | | | >>> scrut0 => [true]
//│ | | | | | | | checkCoverage <== Let(_, _), 0 pending, 1 working
//│ | | | | | | | | assumptions: empty
//│ | | | | | | | | checkCoverage <== Let(_, _), 0 pending, 1 working
//│ | | | | | | | | | assumptions: empty
//│ | | | | | | | | | checkCoverage <== CaseOf(_, _), 0 pending, 1 working
//│ | | | | | | | | | | assumptions: empty
//│ | | | | | | | | | | scrutinee: scrut0
//│ | | | | | | | | | | checkCoverage <== "tmux", 0 pending, 0 working
//│ | | | | | | | | | | | assumptions: scrut0 is true
//│ | | | | | | | | | | | STOP
//│ | | | | | | | | | | checkCoverage ==> 0
//│ | | | | | | | | | | wildcard case
//│ | | | | | | | | | | checkCoverage <== "screen", 0 pending, 1 working
//│ | | | | | | | | | | | assumptions: empty
//│ | | | | | | | | | | | STOP
//│ | | | | | | | | | | checkCoverage ==> 0
//│ | | | | | | | | | checkCoverage ==> 0
//│ | | | | | | | | checkCoverage ==> 0
//│ | | | | | | | checkCoverage ==> 0
//│ | | | | | | | Coverage checking result: 0 errors
//│ | | | | | | visitIf ==> ()
//│ | | | | | visitTerm ==> If(_)
//│ | | | | visitTerm ==> Blk(_)
//│ | | | visitTerm ==> Lam(_, _)
//│ | | visitFunction ==> unreachable_1
//│ | visitTypingUnit ==> unreachable_1
//│ process ==> unreachable_1
//│ fun unreachable_1: (Object & ~#Some | Some[Eql[1]]) -> ("screen" | "tmux")
