:PreTyper

class Some[T](value: T)
module None
type Option[T] = Some[T] | None
class Pair[A, B](x: A, y: B)
//│ class Some[T](value: T)
//│ module None
//│ type Option[T] = None | Some[T]
//│ class Pair[A, B](x: A, y: B)

fun f(x) = if x is Some(xv) and xv === 1 then true else false
//│ fun f: (Object & ~#Some | Some[Eql[1]]) -> Bool

f(Some(1))
f(Some(2))
f(None)
//│ Bool
//│ res
//│     = true
//│ res
//│     = false
//│ res
//│     = false

fun reachable_1(x) =
  if x is
    _ and f(x) then "cos"
    Some(xv) then "sin"
    None then "tan"
//│ fun reachable_1: (None | Some[Eql[1]] | Some[anything] & ~#Some) -> ("cos" | "sin" | "tan")

reachable_1(Some(1))
reachable_1(Some(2))
reachable_1(None)
//│ "cos" | "sin" | "tan"
//│ res
//│     = 'cos'
//│ res
//│     = 'sin'
//│ res
//│     = 'tan'

:dpt
fun unreachable_1(x) =
  if x is
    _ and
      f(x) then "tmux"
      else "screen"
    Some(xv) then "sin"
    None then "tan"
//│ process <== <root>: {fun unreachable_1}
//│ | traverseTypingUnit <== <root>: {fun unreachable_1}
//│ | | 1. scope = {unreachable_1}
//│ | | 2. scope = {unreachable_1}
//│ | | traverseFunction <== unreachable_1
//│ | | | traverseTerm <== Lam(_, _)
//│ | | | | traverseTerm <== Blk(_)
//│ | | | | | traverseTerm <== If(_)
//│ | | | | | | traverseIf
//│ | | | | | | | STEP 0
//│ | | | | | | | Transformed UCS term:
//│ | | | | | | | if x is
//│ | | | | | | |   _ and f(x,) then "tmux"
//│ | | | | | | |   else "screen"
//│ | | | | | | |   Some(xv) then "sin"
//│ | | | | | | |   None then "tan"
//│ | | | | | | | STEP 1
//│ | | | | | | | Desugared UCS term:
//│ | | | | | | | if
//│ | | | | | | |   x is _
//│ | | | | | | |     let scrut$0 = f(x,) : Bool
//│ | | | | | | |     scrut$0 is true then "tmux"
//│ | | | | | | |     else "screen"
//│ | | | | | | |   x is Some(xv) then "sin"
//│ | | | | | | |   x is None then "tan"
//│ | | | | | | | traverseSplit <== [unreachable_1, x]
//│ | | | | | | | | found branch: x is _
//│ | | | | | | | | traverseTerm <== Var("x")
//│ | | | | | | | | | traverseVar(name = "x")
//│ | | | | | | | | | | resolveVar(name = "x")
//│ | | | | | | | | traverseTerm ==> Var("x")
//│ | | | | | | | | traversePattern <== _
//│ | | | | | | | | traversePattern ==> [_]
//│ | | | | | | | | traverseSplit <== [unreachable_1, x, _]
//│ | | | | | | | | | found let binding: "scrut$0"
//│ | | | | | | | | | traverseSplit <== [unreachable_1, x, _, scrut$0]
//│ | | | | | | | | | | found branch: scrut$0 is true
//│ | | | | | | | | | | traverseTerm <== Var("scrut$0")
//│ | | | | | | | | | | | traverseVar(name = "scrut$0")
//│ | | | | | | | | | | | | resolveVar(name = "scrut$0")
//│ | | | | | | | | | | traverseTerm ==> Var("scrut$0")
//│ | | | | | | | | | | traversePattern <== true
//│ | | | | | | | | | | traversePattern ==> []
//│ | | | | | | | | | | traverseSplit <== [unreachable_1, x, _, scrut$0]
//│ | | | | | | | | | | | traverseTerm <== "tmux"
//│ | | | | | | | | | | | traverseTerm ==> "tmux"
//│ | | | | | | | | | | traverseSplit <== [unreachable_1, x, _, scrut$0]
//│ | | | | | | | | | | | traverseTerm <== "screen"
//│ | | | | | | | | | | | traverseTerm ==> "screen"
//│ | | | | | | | | traverseSplit <== [unreachable_1, x]
//│ | | | | | | | | | found branch: x is Some(xv)
//│ | | | | | | | | | traverseTerm <== Var("x")
//│ | | | | | | | | | | traverseVar(name = "x")
//│ | | | | | | | | | traverseTerm ==> Var("x")
//│ | | | | | | | | | traversePattern <== Some(xv)
//│ | | | | | | | | | traversePattern ==> [xv]
//│ | | | | | | | | | traverseSplit <== [unreachable_1, x, xv]
//│ | | | | | | | | | | traverseTerm <== "sin"
//│ | | | | | | | | | | traverseTerm ==> "sin"
//│ | | | | | | | | | traverseSplit <== [unreachable_1, x]
//│ | | | | | | | | | | found branch: x is None
//│ | | | | | | | | | | traverseTerm <== Var("x")
//│ | | | | | | | | | | | traverseVar(name = "x")
//│ | | | | | | | | | | traverseTerm ==> Var("x")
//│ | | | | | | | | | | traversePattern <== None
//│ | | | | | | | | | | traversePattern ==> []
//│ | | | | | | | | | | traverseSplit <== [unreachable_1, x]
//│ | | | | | | | | | | | traverseTerm <== "tan"
//│ | | | | | | | | | | | traverseTerm ==> "tan"
//│ | | | | | | | | | | traverseSplit <== [unreachable_1, x]
//│ | | | | | | | | | | | the end
//│ | | | | | | | STEP 2
//│ | | | | | | | normalizeToTerm
//│ | | | | | | | | alias x => _
//│ | | | | | | | | normalizeToTerm
//│ | | | | | | | | | normalizeToTerm
//│ | | | | | | | | | | match scrut$0 with true
//│ | | | | | | | | | | S+ <== scrut$0 is true
//│ | | | | | | | | | | | the end
//│ | | | | | | | | | | S+ ==> then "tmux"
//│ | | | | | | | | | | normalizeToTerm
//│ | | | | | | | | | | S- <== scrut$0 is true
//│ | | | | | | | | | | | the end
//│ | | | | | | | | | | S- ==> then "screen"
//│ | | | | | | | | | | normalizeToCaseBranches
//│ | | | | | | | Normalized UCS term:
//│ | | | | | | | let _* = x
//│ | | | | | | | let scrut$0* = f(x,) : Bool
//│ | | | | | | | scrut$0 match
//│ | | | | | | |   case true => "tmux"
//│ | | | | | | |   case _ => "screen"
//│ | | | | | | | STEP 3
//│ | | | | | | | postProcess <== Let(_, _)
//│ | | | | | | | | postProcess <== Let(_, _)
//│ | | | | | | | | | postProcess <== CaseOf(_, _)
//│ | | | | | | | | | | found a BINARY case: scrut$0 is true
//│ | | | | | | | | | | `scrut$0`'s matched classes: [true]
//│ | | | | | | | | | | post-processing the first branch
//│ | | | | | | | | | | postProcess <== "tmux"
//│ | | | | | | | | | | | CANNOT post-process
//│ | | | | | | | | | | postProcess ==> 
//│ | | | | | | | | | | found 0 cases
//│ | | | | | | | | | postProcess ==> 
//│ | | | | | | | | postProcess ==> 
//│ | | | | | | | postProcess ==> 
//│ | | | | | | | Post-processed UCS term:
//│ | | | | | | | let _* = x
//│ | | | | | | | let scrut$0* = f(x,) : Bool
//│ | | | | | | | scrut$0 match
//│ | | | | | | |   case true => "tmux"
//│ | | | | | | |   case _ => "screen"
//│ | | | | | | | STEP 4
//│ | | | | | | | collected match registry: 
//│ | | | | | | | >>> scrut$0 => [true]
//│ | | | | | | | checkCoverage <== Let(_, _), 0 pending, 1 working
//│ | | | | | | | | assumptions: empty
//│ | | | | | | | | checkCoverage <== Let(_, _), 0 pending, 1 working
//│ | | | | | | | | | assumptions: empty
//│ | | | | | | | | | checkCoverage <== CaseOf(_, _), 0 pending, 1 working
//│ | | | | | | | | | | assumptions: empty
//│ | | | | | | | | | | scrutinee: scrut$0
//│ | | | | | | | | | | checkCoverage <== "tmux", 0 pending, 0 working
//│ | | | | | | | | | | | assumptions: scrut$0 is true
//│ | | | | | | | | | | | STOP
//│ | | | | | | | | | | checkCoverage ==> 0
//│ | | | | | | | | | | wildcard case
//│ | | | | | | | | | | checkCoverage <== "screen", 0 pending, 1 working
//│ | | | | | | | | | | | assumptions: empty
//│ | | | | | | | | | | | STOP
//│ | | | | | | | | | | checkCoverage ==> 0
//│ | | | | | | | | | checkCoverage ==> 0
//│ | | | | | | | | checkCoverage ==> 0
//│ | | | | | | | checkCoverage ==> 0
//│ | | | | | | | Coverage checking result: 0 errors
//│ | | | | | | traverseIf ==> ()
//│ | | | | | traverseTerm ==> If(_)
//│ | | | | traverseTerm ==> Blk(_)
//│ | | | traverseTerm ==> Lam(_, _)
//│ | | traverseFunction ==> unreachable_1
//│ | traverseTypingUnit ==> unreachable_1
//│ process ==> unreachable_1
//│ fun unreachable_1: (Object & ~#Some | Some[Eql[1]]) -> ("screen" | "tmux")
