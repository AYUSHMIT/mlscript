:AllowParseErrors
:AllowTypeErrors // TODO rm


x => x
//│ |x| |=>| |x|
//│ Parsed: {=> x x}

(x) => x
//│ |(|x|)| |=>| |x|
//│ Parsed: {=> '(' x, ')' x}

fun f = 1
//│ |#fun| |f| |#=| |1|
//│ Parsed: {def f: 1}

fun f x = x
//│ |#fun| |f| |x| |#=| |x|
//│ Parsed: {def f: x, => x}

fun f = x => x
//│ |#fun| |f| |#=| |x| |=>| |x|
//│ Parsed: {def f: => x x}

// TODO
fun x => x
//│ |#fun| |x| |=>| |x|
//│ ╔══[ERROR] Unexpected operator in expression position
//│ ║  l.26: 	fun x => x
//│ ╙──      	      ^^
//│ ╔══[ERROR] Expected '=' keyword; found end of input instead
//│ ║  l.26: 	fun x => x
//│ ╙──      	          ^
//│ ╔══[ERROR] Unexpected end of input; an expression was expected here
//│ ║  l.26: 	fun x => x
//│ ╙──      	          ^
//│ Parsed: {def x: x, => undefined}

let f = x => x
//│ |#let| |f| |#=| |x| |=>| |x|
//│ Parsed: {let f = => x x in undefined}

// TODO
let f = fun x => x
//│ |#let| |f| |#=| |#fun| |x| |=>| |x|
//│ ╔══[ERROR] Unexpected 'fun' keyword in expression position
//│ ║  l.44: 	let f = fun x => x
//│ ╙──      	        ^^^
//│ Parsed: {let f = => x x in undefined}


fun f x = x
//│ |#fun| |f| |x| |#=| |x|
//│ Parsed: {def f: x, => x}

fun f(x) = x
//│ |#fun| |f|(|x|)| |#=| |x|
//│ Parsed: {def f: '(' x, ')', => x}

f(x) + x
//│ |f|(|x|)| |+| |x|
//│ Parsed: {+ (f (x,)) x}


(x, y) => x
//│ |(|x|,| |y|)| |=>| |x|
//│ Parsed: {=> '(' x, y, ')' x}


fun f(x) = x
//│ |#fun| |f|(|x|)| |#=| |x|
//│ Parsed: {def f: '(' x, ')', => x}

fun f(x, y) = x
//│ |#fun| |f|(|x|,| |y|)| |#=| |x|
//│ Parsed: {def f: '(' x, y, ')', => x}

fun f of x = x
//│ |#fun| |f| |#of| |x| |#=| |x|
//│ ╔══[ERROR] Unexpected 'of' keyword in expression position
//│ ║  l.78: 	fun f of x = x
//│ ╙──      	      ^^
//│ Parsed: {def f: x, => x}

// FIXME expr should return an option...
fun f of x, y = x
//│ |#fun| |f| |#of| |x|,| |y| |#=| |x|
//│ ╔══[ERROR] Unexpected 'of' keyword in expression position
//│ ║  l.86: 	fun f of x, y = x
//│ ╙──      	      ^^
//│ /!!!\ Uncaught error: java.lang.StackOverflowError

